var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// .svelte-kit/cloudflare/_worker.js
var __create = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = /* @__PURE__ */ __name((fn, res) => /* @__PURE__ */ __name(function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
}, "__init"), "__esm");
var __commonJS = /* @__PURE__ */ __name((cb, mod) => /* @__PURE__ */ __name(function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
}, "__require"), "__commonJS");
var __export = /* @__PURE__ */ __name((target, all) => {
  for (var name3 in all)
    __defProp2(target, name3, { get: all[name3], enumerable: true });
}, "__export");
var __copyProps = /* @__PURE__ */ __name((to, from, except2, desc2) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except2)
        __defProp2(to, key2, { get: () => from[key2], enumerable: !(desc2 = __getOwnPropDesc(from, key2)) || desc2.enumerable });
  }
  return to;
}, "__copyProps");
var __toESM = /* @__PURE__ */ __name((mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
  mod
)), "__toESM");
function run_all(arr) {
  for (var i2 = 0; i2 < arr.length; i2++) {
    arr[i2]();
  }
}
__name(run_all, "run_all");
function fallback(value, fallback2, lazy = false) {
  return value === void 0 ? lazy ? (
    /** @type {() => V} */
    fallback2()
  ) : (
    /** @type {V} */
    fallback2
  ) : value;
}
__name(fallback, "fallback");
function equals(value) {
  return value === this.v;
}
__name(equals, "equals");
function safe_not_equal(a2, b) {
  return a2 != a2 ? b == b : a2 !== b || a2 !== null && typeof a2 === "object" || typeof a2 === "function";
}
__name(safe_not_equal, "safe_not_equal");
function safe_equals(value) {
  return !safe_not_equal(value, this.v);
}
__name(safe_equals, "safe_equals");
function effect_update_depth_exceeded() {
  {
    throw new Error("effect_update_depth_exceeded");
  }
}
__name(effect_update_depth_exceeded, "effect_update_depth_exceeded");
function hydration_failed() {
  {
    throw new Error("hydration_failed");
  }
}
__name(hydration_failed, "hydration_failed");
function state_unsafe_local_read() {
  {
    throw new Error("state_unsafe_local_read");
  }
}
__name(state_unsafe_local_read, "state_unsafe_local_read");
function state_unsafe_mutation() {
  {
    throw new Error("state_unsafe_mutation");
  }
}
__name(state_unsafe_mutation, "state_unsafe_mutation");
function source(v2) {
  return {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: v2,
    reactions: null,
    equals,
    version: 0
  };
}
__name(source, "source");
function mutable_source(initial_value, immutable2 = false) {
  const s3 = source(initial_value);
  if (!immutable2) {
    s3.equals = safe_equals;
  }
  if (component_context !== null && component_context.l !== null) {
    (component_context.l.s ??= []).push(s3);
  }
  return s3;
}
__name(mutable_source, "mutable_source");
function set(source2, value) {
  if (active_reaction !== null && is_runes() && (active_reaction.f & (DERIVED | BLOCK_EFFECT)) !== 0 && // If the source was created locally within the current derived, then
  // we allow the mutation.
  (derived_sources === null || !derived_sources.includes(source2))) {
    state_unsafe_mutation();
  }
  return internal_set(source2, value);
}
__name(set, "set");
function internal_set(source2, value) {
  if (!source2.equals(value)) {
    source2.v = value;
    source2.version = increment_version();
    mark_reactions(source2, DIRTY);
    if (is_runes() && active_effect !== null && (active_effect.f & CLEAN) !== 0 && (active_effect.f & BRANCH_EFFECT) === 0) {
      if (new_deps !== null && new_deps.includes(source2)) {
        set_signal_status(active_effect, DIRTY);
        schedule_effect(active_effect);
      } else {
        if (untracked_writes === null) {
          set_untracked_writes([source2]);
        } else {
          untracked_writes.push(source2);
        }
      }
    }
  }
  return value;
}
__name(internal_set, "internal_set");
function mark_reactions(signal, status) {
  var reactions = signal.reactions;
  if (reactions === null)
    return;
  var runes = is_runes();
  var length = reactions.length;
  for (var i2 = 0; i2 < length; i2++) {
    var reaction = reactions[i2];
    var flags = reaction.f;
    if ((flags & DIRTY) !== 0)
      continue;
    if (!runes && reaction === active_effect)
      continue;
    set_signal_status(reaction, status);
    if ((flags & (CLEAN | UNOWNED)) !== 0) {
      if ((flags & DERIVED) !== 0) {
        mark_reactions(
          /** @type {Derived} */
          reaction,
          MAYBE_DIRTY
        );
      } else {
        schedule_effect(
          /** @type {Effect} */
          reaction
        );
      }
    }
  }
}
__name(mark_reactions, "mark_reactions");
function init_operations() {
  if ($window !== void 0) {
    return;
  }
  $window = window;
  var element_prototype = Element.prototype;
  var node_prototype = Node.prototype;
  first_child_getter = get_descriptor(node_prototype, "firstChild").get;
  next_sibling_getter = get_descriptor(node_prototype, "nextSibling").get;
  element_prototype.__click = void 0;
  element_prototype.__className = "";
  element_prototype.__attributes = null;
  element_prototype.__styles = null;
  element_prototype.__e = void 0;
  Text.prototype.__t = void 0;
}
__name(init_operations, "init_operations");
function create_text(value = "") {
  return document.createTextNode(value);
}
__name(create_text, "create_text");
function get_first_child(node) {
  return first_child_getter.call(node);
}
__name(get_first_child, "get_first_child");
function get_next_sibling(node) {
  return next_sibling_getter.call(node);
}
__name(get_next_sibling, "get_next_sibling");
function clear_text_content(node) {
  node.textContent = "";
}
__name(clear_text_content, "clear_text_content");
function destroy_derived_children(derived2) {
  var children = derived2.children;
  if (children !== null) {
    derived2.children = null;
    for (var i2 = 0; i2 < children.length; i2 += 1) {
      var child = children[i2];
      if ((child.f & DERIVED) !== 0) {
        destroy_derived(
          /** @type {Derived} */
          child
        );
      } else {
        destroy_effect(
          /** @type {Effect} */
          child
        );
      }
    }
  }
}
__name(destroy_derived_children, "destroy_derived_children");
function execute_derived(derived2) {
  var value;
  var prev_active_effect = active_effect;
  set_active_effect(derived2.parent);
  {
    try {
      destroy_derived_children(derived2);
      value = update_reaction(derived2);
    } finally {
      set_active_effect(prev_active_effect);
    }
  }
  return value;
}
__name(execute_derived, "execute_derived");
function update_derived(derived2) {
  var value = execute_derived(derived2);
  var status = (skip_reaction || (derived2.f & UNOWNED) !== 0) && derived2.deps !== null ? MAYBE_DIRTY : CLEAN;
  set_signal_status(derived2, status);
  if (!derived2.equals(value)) {
    derived2.v = value;
    derived2.version = increment_version();
  }
}
__name(update_derived, "update_derived");
function destroy_derived(signal) {
  destroy_derived_children(signal);
  remove_reactions(signal, 0);
  set_signal_status(signal, DESTROYED);
  signal.v = signal.children = signal.deps = signal.ctx = signal.reactions = null;
}
__name(destroy_derived, "destroy_derived");
function push_effect(effect22, parent_effect) {
  var parent_last = parent_effect.last;
  if (parent_last === null) {
    parent_effect.last = parent_effect.first = effect22;
  } else {
    parent_last.next = effect22;
    effect22.prev = parent_last;
    parent_effect.last = effect22;
  }
}
__name(push_effect, "push_effect");
function create_effect(type, fn, sync, push2 = true) {
  var is_root = (type & ROOT_EFFECT) !== 0;
  var parent_effect = active_effect;
  var effect22 = {
    ctx: component_context,
    deps: null,
    deriveds: null,
    nodes_start: null,
    nodes_end: null,
    f: type | DIRTY,
    first: null,
    fn,
    last: null,
    next: null,
    parent: is_root ? null : parent_effect,
    prev: null,
    teardown: null,
    transitions: null,
    version: 0
  };
  if (sync) {
    var previously_flushing_effect = is_flushing_effect;
    try {
      set_is_flushing_effect(true);
      update_effect(effect22);
      effect22.f |= EFFECT_RAN;
    } catch (e3) {
      destroy_effect(effect22);
      throw e3;
    } finally {
      set_is_flushing_effect(previously_flushing_effect);
    }
  } else if (fn !== null) {
    schedule_effect(effect22);
  }
  var inert = sync && effect22.deps === null && effect22.first === null && effect22.nodes_start === null && effect22.teardown === null && (effect22.f & EFFECT_HAS_DERIVED) === 0;
  if (!inert && !is_root && push2) {
    if (parent_effect !== null) {
      push_effect(effect22, parent_effect);
    }
    if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {
      var derived2 = (
        /** @type {Derived} */
        active_reaction
      );
      (derived2.children ??= []).push(effect22);
    }
  }
  return effect22;
}
__name(create_effect, "create_effect");
function effect_root(fn) {
  const effect22 = create_effect(ROOT_EFFECT, fn, true);
  return () => {
    destroy_effect(effect22);
  };
}
__name(effect_root, "effect_root");
function effect(fn) {
  return create_effect(EFFECT, fn, false);
}
__name(effect, "effect");
function branch(fn, push2 = true) {
  return create_effect(RENDER_EFFECT | BRANCH_EFFECT, fn, true, push2);
}
__name(branch, "branch");
function execute_effect_teardown(effect22) {
  var teardown = effect22.teardown;
  if (teardown !== null) {
    const previous_reaction = active_reaction;
    set_active_reaction(null);
    try {
      teardown.call(null);
    } finally {
      set_active_reaction(previous_reaction);
    }
  }
}
__name(execute_effect_teardown, "execute_effect_teardown");
function destroy_effect_deriveds(signal) {
  var deriveds = signal.deriveds;
  if (deriveds !== null) {
    signal.deriveds = null;
    for (var i2 = 0; i2 < deriveds.length; i2 += 1) {
      destroy_derived(deriveds[i2]);
    }
  }
}
__name(destroy_effect_deriveds, "destroy_effect_deriveds");
function destroy_effect_children(signal, remove_dom = false) {
  var effect22 = signal.first;
  signal.first = signal.last = null;
  while (effect22 !== null) {
    var next2 = effect22.next;
    destroy_effect(effect22, remove_dom);
    effect22 = next2;
  }
}
__name(destroy_effect_children, "destroy_effect_children");
function destroy_block_effect_children(signal) {
  var effect22 = signal.first;
  while (effect22 !== null) {
    var next2 = effect22.next;
    if ((effect22.f & BRANCH_EFFECT) === 0) {
      destroy_effect(effect22);
    }
    effect22 = next2;
  }
}
__name(destroy_block_effect_children, "destroy_block_effect_children");
function destroy_effect(effect22, remove_dom = true) {
  var removed = false;
  if ((remove_dom || (effect22.f & HEAD_EFFECT) !== 0) && effect22.nodes_start !== null) {
    var node = effect22.nodes_start;
    var end = effect22.nodes_end;
    while (node !== null) {
      var next2 = node === end ? null : (
        /** @type {TemplateNode} */
        /* @__PURE__ */ get_next_sibling(node)
      );
      node.remove();
      node = next2;
    }
    removed = true;
  }
  destroy_effect_deriveds(effect22);
  destroy_effect_children(effect22, remove_dom && !removed);
  remove_reactions(effect22, 0);
  set_signal_status(effect22, DESTROYED);
  var transitions = effect22.transitions;
  if (transitions !== null) {
    for (const transition of transitions) {
      transition.stop();
    }
  }
  execute_effect_teardown(effect22);
  var parent = effect22.parent;
  if (parent !== null && parent.first !== null) {
    unlink_effect(effect22);
  }
  effect22.next = effect22.prev = effect22.teardown = effect22.ctx = effect22.deps = effect22.parent = effect22.fn = effect22.nodes_start = effect22.nodes_end = null;
}
__name(destroy_effect, "destroy_effect");
function unlink_effect(effect22) {
  var parent = effect22.parent;
  var prev2 = effect22.prev;
  var next2 = effect22.next;
  if (prev2 !== null)
    prev2.next = next2;
  if (next2 !== null)
    next2.prev = prev2;
  if (parent !== null) {
    if (parent.first === effect22)
      parent.first = next2;
    if (parent.last === effect22)
      parent.last = prev2;
  }
}
__name(unlink_effect, "unlink_effect");
function flush_tasks() {
}
__name(flush_tasks, "flush_tasks");
function invalid_default_snippet() {
  {
    throw new Error("invalid_default_snippet");
  }
}
__name(invalid_default_snippet, "invalid_default_snippet");
function lifecycle_outside_component(name3) {
  {
    throw new Error("lifecycle_outside_component");
  }
}
__name(lifecycle_outside_component, "lifecycle_outside_component");
function set_is_flushing_effect(value) {
  is_flushing_effect = value;
}
__name(set_is_flushing_effect, "set_is_flushing_effect");
function set_active_reaction(reaction) {
  active_reaction = reaction;
}
__name(set_active_reaction, "set_active_reaction");
function set_active_effect(effect22) {
  active_effect = effect22;
}
__name(set_active_effect, "set_active_effect");
function set_untracked_writes(value) {
  untracked_writes = value;
}
__name(set_untracked_writes, "set_untracked_writes");
function increment_version() {
  return ++current_version;
}
__name(increment_version, "increment_version");
function is_runes() {
  return component_context !== null && component_context.l === null;
}
__name(is_runes, "is_runes");
function check_dirtiness(reaction) {
  var flags = reaction.f;
  if ((flags & DIRTY) !== 0) {
    return true;
  }
  if ((flags & MAYBE_DIRTY) !== 0) {
    var dependencies = reaction.deps;
    var is_unowned = (flags & UNOWNED) !== 0;
    if (dependencies !== null) {
      var i2;
      if ((flags & DISCONNECTED) !== 0) {
        for (i2 = 0; i2 < dependencies.length; i2++) {
          (dependencies[i2].reactions ??= []).push(reaction);
        }
        reaction.f ^= DISCONNECTED;
      }
      for (i2 = 0; i2 < dependencies.length; i2++) {
        var dependency = dependencies[i2];
        if (check_dirtiness(
          /** @type {Derived} */
          dependency
        )) {
          update_derived(
            /** @type {Derived} */
            dependency
          );
        }
        if (is_unowned && active_effect !== null && !skip_reaction && !dependency?.reactions?.includes(reaction)) {
          (dependency.reactions ??= []).push(reaction);
        }
        if (dependency.version > reaction.version) {
          return true;
        }
      }
    }
    if (!is_unowned) {
      set_signal_status(reaction, CLEAN);
    }
  }
  return false;
}
__name(check_dirtiness, "check_dirtiness");
function handle_error(error2, effect22, component_context2) {
  {
    throw error2;
  }
}
__name(handle_error, "handle_error");
function update_reaction(reaction) {
  var previous_deps = new_deps;
  var previous_skipped_deps = skipped_deps;
  var previous_untracked_writes = untracked_writes;
  var previous_reaction = active_reaction;
  var previous_skip_reaction = skip_reaction;
  var prev_derived_sources = derived_sources;
  var previous_component_context = component_context;
  var flags = reaction.f;
  new_deps = /** @type {null | Value[]} */
  null;
  skipped_deps = 0;
  untracked_writes = null;
  active_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;
  skip_reaction = !is_flushing_effect && (flags & UNOWNED) !== 0;
  derived_sources = null;
  component_context = reaction.ctx;
  try {
    var result = (
      /** @type {Function} */
      (0, reaction.fn)()
    );
    var deps = reaction.deps;
    if (new_deps !== null) {
      var i2;
      remove_reactions(reaction, skipped_deps);
      if (deps !== null && skipped_deps > 0) {
        deps.length = skipped_deps + new_deps.length;
        for (i2 = 0; i2 < new_deps.length; i2++) {
          deps[skipped_deps + i2] = new_deps[i2];
        }
      } else {
        reaction.deps = deps = new_deps;
      }
      if (!skip_reaction) {
        for (i2 = skipped_deps; i2 < deps.length; i2++) {
          (deps[i2].reactions ??= []).push(reaction);
        }
      }
    } else if (deps !== null && skipped_deps < deps.length) {
      remove_reactions(reaction, skipped_deps);
      deps.length = skipped_deps;
    }
    return result;
  } finally {
    new_deps = previous_deps;
    skipped_deps = previous_skipped_deps;
    untracked_writes = previous_untracked_writes;
    active_reaction = previous_reaction;
    skip_reaction = previous_skip_reaction;
    derived_sources = prev_derived_sources;
    component_context = previous_component_context;
  }
}
__name(update_reaction, "update_reaction");
function remove_reaction(signal, dependency) {
  let reactions = dependency.reactions;
  if (reactions !== null) {
    var index39 = reactions.indexOf(signal);
    if (index39 !== -1) {
      var new_length = reactions.length - 1;
      if (new_length === 0) {
        reactions = dependency.reactions = null;
      } else {
        reactions[index39] = reactions[new_length];
        reactions.pop();
      }
    }
  }
  if (reactions === null && (dependency.f & DERIVED) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (new_deps === null || !new_deps.includes(dependency))) {
    set_signal_status(dependency, MAYBE_DIRTY);
    if ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {
      dependency.f ^= DISCONNECTED;
    }
    remove_reactions(
      /** @type {Derived} **/
      dependency,
      0
    );
  }
}
__name(remove_reaction, "remove_reaction");
function remove_reactions(signal, start_index) {
  var dependencies = signal.deps;
  if (dependencies === null)
    return;
  for (var i2 = start_index; i2 < dependencies.length; i2++) {
    remove_reaction(signal, dependencies[i2]);
  }
}
__name(remove_reactions, "remove_reactions");
function update_effect(effect22) {
  var flags = effect22.f;
  if ((flags & DESTROYED) !== 0) {
    return;
  }
  set_signal_status(effect22, CLEAN);
  var previous_effect = active_effect;
  active_effect = effect22;
  try {
    destroy_effect_deriveds(effect22);
    if ((flags & BLOCK_EFFECT) !== 0) {
      destroy_block_effect_children(effect22);
    } else {
      destroy_effect_children(effect22);
    }
    execute_effect_teardown(effect22);
    var teardown = update_reaction(effect22);
    effect22.teardown = typeof teardown === "function" ? teardown : null;
    effect22.version = current_version;
    if (DEV)
      ;
  } catch (error2) {
    handle_error(
      /** @type {Error} */
      error2
    );
  } finally {
    active_effect = previous_effect;
  }
}
__name(update_effect, "update_effect");
function infinite_loop_guard() {
  if (flush_count > 1e3) {
    flush_count = 0;
    {
      effect_update_depth_exceeded();
    }
  }
  flush_count++;
}
__name(infinite_loop_guard, "infinite_loop_guard");
function flush_queued_root_effects(root_effects) {
  var length = root_effects.length;
  if (length === 0) {
    return;
  }
  infinite_loop_guard();
  var previously_flushing_effect = is_flushing_effect;
  is_flushing_effect = true;
  try {
    for (var i2 = 0; i2 < length; i2++) {
      var effect22 = root_effects[i2];
      if ((effect22.f & CLEAN) === 0) {
        effect22.f ^= CLEAN;
      }
      var collected_effects = [];
      process_effects(effect22, collected_effects);
      flush_queued_effects(collected_effects);
    }
  } finally {
    is_flushing_effect = previously_flushing_effect;
  }
}
__name(flush_queued_root_effects, "flush_queued_root_effects");
function flush_queued_effects(effects) {
  var length = effects.length;
  if (length === 0)
    return;
  for (var i2 = 0; i2 < length; i2++) {
    var effect22 = effects[i2];
    if ((effect22.f & (DESTROYED | INERT)) === 0 && check_dirtiness(effect22)) {
      update_effect(effect22);
      if (effect22.deps === null && effect22.first === null && effect22.nodes_start === null) {
        if (effect22.teardown === null) {
          unlink_effect(effect22);
        } else {
          effect22.fn = null;
        }
      }
    }
  }
}
__name(flush_queued_effects, "flush_queued_effects");
function process_deferred() {
  is_micro_task_queued = false;
  if (flush_count > 1001) {
    return;
  }
  const previous_queued_root_effects = queued_root_effects;
  queued_root_effects = [];
  flush_queued_root_effects(previous_queued_root_effects);
  if (!is_micro_task_queued) {
    flush_count = 0;
  }
}
__name(process_deferred, "process_deferred");
function schedule_effect(signal) {
  if (scheduler_mode === FLUSH_MICROTASK) {
    if (!is_micro_task_queued) {
      is_micro_task_queued = true;
      queueMicrotask(process_deferred);
    }
  }
  var effect22 = signal;
  while (effect22.parent !== null) {
    effect22 = effect22.parent;
    var flags = effect22.f;
    if ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
      if ((flags & CLEAN) === 0)
        return;
      effect22.f ^= CLEAN;
    }
  }
  queued_root_effects.push(effect22);
}
__name(schedule_effect, "schedule_effect");
function process_effects(effect22, collected_effects) {
  var current_effect = effect22.first;
  var effects = [];
  main_loop:
    while (current_effect !== null) {
      var flags = current_effect.f;
      var is_branch = (flags & BRANCH_EFFECT) !== 0;
      var is_skippable_branch = is_branch && (flags & CLEAN) !== 0;
      if (!is_skippable_branch && (flags & INERT) === 0) {
        if ((flags & RENDER_EFFECT) !== 0) {
          if (is_branch) {
            current_effect.f ^= CLEAN;
          } else if (check_dirtiness(current_effect)) {
            update_effect(current_effect);
          }
          var child = current_effect.first;
          if (child !== null) {
            current_effect = child;
            continue;
          }
        } else if ((flags & EFFECT) !== 0) {
          effects.push(current_effect);
        }
      }
      var sibling = current_effect.next;
      if (sibling === null) {
        let parent = current_effect.parent;
        while (parent !== null) {
          if (effect22 === parent) {
            break main_loop;
          }
          var parent_sibling = parent.next;
          if (parent_sibling !== null) {
            current_effect = parent_sibling;
            continue main_loop;
          }
          parent = parent.parent;
        }
      }
      current_effect = sibling;
    }
  for (var i2 = 0; i2 < effects.length; i2++) {
    child = effects[i2];
    collected_effects.push(child);
    process_effects(child, collected_effects);
  }
}
__name(process_effects, "process_effects");
function flush_sync(fn) {
  var previous_scheduler_mode = scheduler_mode;
  var previous_queued_root_effects = queued_root_effects;
  try {
    infinite_loop_guard();
    const root_effects = [];
    scheduler_mode = FLUSH_SYNC;
    queued_root_effects = root_effects;
    is_micro_task_queued = false;
    flush_queued_root_effects(previous_queued_root_effects);
    var result = fn?.();
    flush_tasks();
    if (queued_root_effects.length > 0 || root_effects.length > 0) {
      flush_sync();
    }
    flush_count = 0;
    if (DEV)
      ;
    return result;
  } finally {
    scheduler_mode = previous_scheduler_mode;
    queued_root_effects = previous_queued_root_effects;
  }
}
__name(flush_sync, "flush_sync");
function get(signal) {
  var flags = signal.f;
  var is_derived = (flags & DERIVED) !== 0;
  if (is_derived && (flags & DESTROYED) !== 0) {
    var value = execute_derived(
      /** @type {Derived} */
      signal
    );
    destroy_derived(
      /** @type {Derived} */
      signal
    );
    return value;
  }
  if (active_reaction !== null) {
    if (derived_sources !== null && derived_sources.includes(signal)) {
      state_unsafe_local_read();
    }
    var deps = active_reaction.deps;
    if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
      skipped_deps++;
    } else if (new_deps === null) {
      new_deps = [signal];
    } else {
      new_deps.push(signal);
    }
    if (untracked_writes !== null && active_effect !== null && (active_effect.f & CLEAN) !== 0 && (active_effect.f & BRANCH_EFFECT) === 0 && untracked_writes.includes(signal)) {
      set_signal_status(active_effect, DIRTY);
      schedule_effect(active_effect);
    }
  } else if (is_derived && /** @type {Derived} */
  signal.deps === null) {
    var derived2 = (
      /** @type {Derived} */
      signal
    );
    var parent = derived2.parent;
    if (parent !== null && !parent.deriveds?.includes(derived2)) {
      (parent.deriveds ??= []).push(derived2);
    }
  }
  if (is_derived) {
    derived2 = /** @type {Derived} */
    signal;
    if (check_dirtiness(derived2)) {
      update_derived(derived2);
    }
  }
  return signal.v;
}
__name(get, "get");
function untrack(fn) {
  const previous_reaction = active_reaction;
  try {
    active_reaction = null;
    return fn();
  } finally {
    active_reaction = previous_reaction;
  }
}
__name(untrack, "untrack");
function set_signal_status(signal, status) {
  signal.f = signal.f & STATUS_MASK | status;
}
__name(set_signal_status, "set_signal_status");
function push$1(props, runes = false, fn) {
  component_context = {
    p: component_context,
    c: null,
    e: null,
    m: false,
    s: props,
    x: null,
    l: null
  };
  if (!runes) {
    component_context.l = {
      s: null,
      u: null,
      r1: [],
      r2: source(false)
    };
  }
}
__name(push$1, "push$1");
function pop$1(component39) {
  const context_stack_item = component_context;
  if (context_stack_item !== null) {
    const component_effects = context_stack_item.e;
    if (component_effects !== null) {
      var previous_effect = active_effect;
      var previous_reaction = active_reaction;
      context_stack_item.e = null;
      try {
        for (var i2 = 0; i2 < component_effects.length; i2++) {
          var component_effect = component_effects[i2];
          set_active_effect(component_effect.effect);
          set_active_reaction(component_effect.reaction);
          effect(component_effect.fn);
        }
      } finally {
        set_active_effect(previous_effect);
        set_active_reaction(previous_reaction);
      }
    }
    component_context = context_stack_item.p;
    context_stack_item.m = true;
  }
  return (
    /** @type {T} */
    {}
  );
}
__name(pop$1, "pop$1");
function is_void(name3) {
  return VOID_ELEMENT_NAMES.includes(name3) || name3.toLowerCase() === "!doctype";
}
__name(is_void, "is_void");
function is_boolean_attribute(name3) {
  return DOM_BOOLEAN_ATTRIBUTES.includes(name3);
}
__name(is_boolean_attribute, "is_boolean_attribute");
function is_passive_event(name3) {
  return PASSIVE_EVENTS.includes(name3);
}
__name(is_passive_event, "is_passive_event");
function subscribe_to_store(store, run, invalidate) {
  if (store == null) {
    run(void 0);
    if (invalidate)
      invalidate(void 0);
    return noop;
  }
  const unsub = untrack(
    () => store.subscribe(
      run,
      // @ts-expect-error
      invalidate
    )
  );
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
__name(subscribe_to_store, "subscribe_to_store");
function escape_html(value, is_attr) {
  const str = String(value ?? "");
  const pattern2 = is_attr ? ATTR_REGEX : CONTENT_REGEX;
  pattern2.lastIndex = 0;
  let escaped2 = "";
  let last2 = 0;
  while (pattern2.test(str)) {
    const i2 = pattern2.lastIndex - 1;
    const ch = str[i2];
    escaped2 += str.substring(last2, i2) + (ch === "&" ? "&amp;" : ch === '"' ? "&quot;" : "&lt;");
    last2 = i2 + 1;
  }
  return escaped2 + str.substring(last2);
}
__name(escape_html, "escape_html");
function getContext(key2) {
  const context_map = get_or_init_context_map();
  const result = (
    /** @type {T} */
    context_map.get(key2)
  );
  return result;
}
__name(getContext, "getContext");
function setContext(key2, context) {
  get_or_init_context_map().set(key2, context);
  return context;
}
__name(setContext, "setContext");
function hasContext(key2) {
  return get_or_init_context_map().has(key2);
}
__name(hasContext, "hasContext");
function get_or_init_context_map(name3) {
  if (current_component === null) {
    lifecycle_outside_component();
  }
  return current_component.c ??= new Map(get_parent_context(current_component) || void 0);
}
__name(get_or_init_context_map, "get_or_init_context_map");
function push(fn) {
  current_component = { p: current_component, c: null, d: null };
}
__name(push, "push");
function pop() {
  var component39 = (
    /** @type {Component} */
    current_component
  );
  var ondestroy = component39.d;
  if (ondestroy) {
    on_destroy.push(...ondestroy);
  }
  current_component = component39.p;
}
__name(pop, "pop");
function get_parent_context(component_context2) {
  let parent = component_context2.p;
  while (parent !== null) {
    const context_map = parent.c;
    if (context_map !== null) {
      return context_map;
    }
    parent = parent.p;
  }
  return null;
}
__name(get_parent_context, "get_parent_context");
function copy_payload({ out, css, head: head2 }) {
  return {
    out,
    css: new Set(css),
    head: {
      title: head2.title,
      out: head2.out
    }
  };
}
__name(copy_payload, "copy_payload");
function assign_payload(p1, p2) {
  p1.out = p2.out;
  p1.head = p2.head;
}
__name(assign_payload, "assign_payload");
function element(payload, tag, attributes_fn = noop, children_fn = noop) {
  payload.out += "<!---->";
  if (tag) {
    payload.out += `<${tag} `;
    attributes_fn();
    payload.out += `>`;
    if (!is_void(tag)) {
      children_fn();
      if (!RAW_TEXT_ELEMENTS.includes(tag)) {
        payload.out += EMPTY_COMMENT;
      }
      payload.out += `</${tag}>`;
    }
  }
  payload.out += "<!---->";
}
__name(element, "element");
function render(component39, options2 = {}) {
  const payload = { out: "", css: /* @__PURE__ */ new Set(), head: { title: "", out: "" } };
  const prev_on_destroy = on_destroy;
  on_destroy = [];
  payload.out += BLOCK_OPEN;
  if (options2.context) {
    push();
    current_component.c = options2.context;
  }
  component39(payload, options2.props ?? {}, {}, {});
  if (options2.context) {
    pop();
  }
  payload.out += BLOCK_CLOSE;
  for (const cleanup of on_destroy)
    cleanup();
  on_destroy = prev_on_destroy;
  let head2 = payload.head.out + payload.head.title;
  for (const { hash: hash2, code } of payload.css) {
    head2 += `<style id="${hash2}">${code}</style>`;
  }
  return {
    head: head2,
    html: payload.out,
    body: payload.out
  };
}
__name(render, "render");
function head(payload, fn) {
  const head_payload = payload.head;
  head_payload.out += BLOCK_OPEN;
  fn(head_payload);
  head_payload.out += BLOCK_CLOSE;
}
__name(head, "head");
function attr(name3, value, is_boolean = false) {
  if (value == null || !value && is_boolean || value === "" && name3 === "class")
    return "";
  const normalized = name3 in replacements && replacements[name3].get(value) || value;
  const assignment = is_boolean ? "" : `="${escape_html(normalized, true)}"`;
  return ` ${name3}${assignment}`;
}
__name(attr, "attr");
function spread_attributes(attrs, classes, styles, flags = 0) {
  let attr_str = "";
  let name3;
  const is_html = (flags & ELEMENT_IS_NAMESPACED) === 0;
  const lowercase = (flags & ELEMENT_PRESERVE_ATTRIBUTE_CASE) === 0;
  for (name3 in attrs) {
    if (typeof attrs[name3] === "function")
      continue;
    if (name3[0] === "$" && name3[1] === "$")
      continue;
    if (INVALID_ATTR_NAME_CHAR_REGEX.test(name3))
      continue;
    if (lowercase) {
      name3 = name3.toLowerCase();
    }
    attr_str += attr(name3, attrs[name3], is_html && is_boolean_attribute(name3));
  }
  return attr_str;
}
__name(spread_attributes, "spread_attributes");
function spread_props(props) {
  const merged_props = {};
  let key2;
  for (let i2 = 0; i2 < props.length; i2++) {
    const obj = props[i2];
    for (key2 in obj) {
      const desc2 = Object.getOwnPropertyDescriptor(obj, key2);
      if (desc2) {
        Object.defineProperty(merged_props, key2, desc2);
      } else {
        merged_props[key2] = obj[key2];
      }
    }
  }
  return merged_props;
}
__name(spread_props, "spread_props");
function stringify(value) {
  return typeof value === "string" ? value : value == null ? "" : value + "";
}
__name(stringify, "stringify");
function store_get(store_values, store_name, store) {
  if (store_name in store_values && store_values[store_name][0] === store) {
    return store_values[store_name][2];
  }
  store_values[store_name]?.[1]();
  store_values[store_name] = [store, null, void 0];
  const unsub = subscribe_to_store(
    store,
    /** @param {any} v */
    (v2) => store_values[store_name][2] = v2
  );
  store_values[store_name][1] = unsub;
  return store_values[store_name][2];
}
__name(store_get, "store_get");
function store_set(store, value) {
  store.set(value);
  return value;
}
__name(store_set, "store_set");
function store_mutate(store_values, store_name, store, expression) {
  store_set(store, store_get(store_values, store_name, store));
  return expression;
}
__name(store_mutate, "store_mutate");
function unsubscribe_stores(store_values) {
  for (const store_name in store_values) {
    store_values[store_name][1]();
  }
}
__name(unsubscribe_stores, "unsubscribe_stores");
function slot(payload, $$props, name3, slot_props, fallback_fn) {
  var slot_fn = $$props.$$slots?.[name3];
  if (slot_fn === true) {
    slot_fn = $$props["children"];
  }
  if (slot_fn !== void 0) {
    slot_fn(payload, slot_props);
  } else {
    fallback_fn?.();
  }
}
__name(slot, "slot");
function rest_props(props, rest) {
  const rest_props2 = {};
  let key2;
  for (key2 in props) {
    if (!rest.includes(key2)) {
      rest_props2[key2] = props[key2];
    }
  }
  return rest_props2;
}
__name(rest_props, "rest_props");
function sanitize_props(props) {
  const { children, $$slots, ...sanitized } = props;
  return sanitized;
}
__name(sanitize_props, "sanitize_props");
function bind_props(props_parent, props_now) {
  for (const key2 in props_now) {
    const initial_value = props_parent[key2];
    const value = props_now[key2];
    if (initial_value === void 0 && value !== void 0 && Object.getOwnPropertyDescriptor(props_parent, key2)?.set) {
      props_parent[key2] = value;
    }
  }
}
__name(bind_props, "bind_props");
function ensure_array_like(array_like_or_iterator) {
  if (array_like_or_iterator) {
    return array_like_or_iterator.length !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
  }
  return [];
}
__name(ensure_array_like, "ensure_array_like");
var BROWSER;
var DEV;
var is_array;
var array_from;
var define_property;
var get_descriptor;
var noop;
var DERIVED;
var EFFECT;
var RENDER_EFFECT;
var BLOCK_EFFECT;
var BRANCH_EFFECT;
var ROOT_EFFECT;
var UNOWNED;
var DISCONNECTED;
var CLEAN;
var DIRTY;
var MAYBE_DIRTY;
var INERT;
var DESTROYED;
var EFFECT_RAN;
var HEAD_EFFECT;
var EFFECT_HAS_DERIVED;
var HYDRATION_START;
var HYDRATION_END;
var HYDRATION_ERROR;
var ELEMENT_IS_NAMESPACED;
var ELEMENT_PRESERVE_ATTRIBUTE_CASE;
var $window;
var first_child_getter;
var next_sibling_getter;
var FLUSH_MICROTASK;
var FLUSH_SYNC;
var scheduler_mode;
var is_micro_task_queued;
var is_flushing_effect;
var queued_root_effects;
var flush_count;
var active_reaction;
var active_effect;
var derived_sources;
var new_deps;
var skipped_deps;
var untracked_writes;
var current_version;
var skip_reaction;
var component_context;
var STATUS_MASK;
var VOID_ELEMENT_NAMES;
var DOM_BOOLEAN_ATTRIBUTES;
var PASSIVE_EVENTS;
var ATTR_REGEX;
var CONTENT_REGEX;
var current_component;
var BLOCK_OPEN;
var BLOCK_CLOSE;
var EMPTY_COMMENT;
var INVALID_ATTR_NAME_CHAR_REGEX;
var RAW_TEXT_ELEMENTS;
var on_destroy;
var replacements;
var init_index2 = __esm({
  ".svelte-kit/output/server/chunks/index2.js"() {
    BROWSER = false;
    DEV = false;
    is_array = Array.isArray;
    array_from = Array.from;
    define_property = Object.defineProperty;
    get_descriptor = Object.getOwnPropertyDescriptor;
    noop = /* @__PURE__ */ __name(() => {
    }, "noop");
    DERIVED = 1 << 1;
    EFFECT = 1 << 2;
    RENDER_EFFECT = 1 << 3;
    BLOCK_EFFECT = 1 << 4;
    BRANCH_EFFECT = 1 << 5;
    ROOT_EFFECT = 1 << 6;
    UNOWNED = 1 << 7;
    DISCONNECTED = 1 << 8;
    CLEAN = 1 << 9;
    DIRTY = 1 << 10;
    MAYBE_DIRTY = 1 << 11;
    INERT = 1 << 12;
    DESTROYED = 1 << 13;
    EFFECT_RAN = 1 << 14;
    HEAD_EFFECT = 1 << 18;
    EFFECT_HAS_DERIVED = 1 << 19;
    HYDRATION_START = "[";
    HYDRATION_END = "]";
    HYDRATION_ERROR = {};
    ELEMENT_IS_NAMESPACED = 1;
    ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;
    FLUSH_MICROTASK = 0;
    FLUSH_SYNC = 1;
    scheduler_mode = FLUSH_MICROTASK;
    is_micro_task_queued = false;
    is_flushing_effect = false;
    queued_root_effects = [];
    flush_count = 0;
    active_reaction = null;
    active_effect = null;
    derived_sources = null;
    new_deps = null;
    skipped_deps = 0;
    untracked_writes = null;
    current_version = 0;
    skip_reaction = false;
    component_context = null;
    STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);
    VOID_ELEMENT_NAMES = [
      "area",
      "base",
      "br",
      "col",
      "command",
      "embed",
      "hr",
      "img",
      "input",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ];
    DOM_BOOLEAN_ATTRIBUTES = [
      "allowfullscreen",
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "controls",
      "default",
      "disabled",
      "formnovalidate",
      "hidden",
      "indeterminate",
      "ismap",
      "loop",
      "multiple",
      "muted",
      "nomodule",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "seamless",
      "selected",
      "webkitdirectory"
    ];
    PASSIVE_EVENTS = ["touchstart", "touchmove"];
    ATTR_REGEX = /[&"<]/g;
    CONTENT_REGEX = /[&<]/g;
    current_component = null;
    BLOCK_OPEN = `<!--${HYDRATION_START}-->`;
    BLOCK_CLOSE = `<!--${HYDRATION_END}-->`;
    EMPTY_COMMENT = `<!---->`;
    INVALID_ATTR_NAME_CHAR_REGEX = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
    RAW_TEXT_ELEMENTS = ["textarea", "script", "style", "title"];
    on_destroy = [];
    replacements = {
      translate: /* @__PURE__ */ new Map([
        [true, "yes"],
        [false, "no"]
      ])
    };
  }
});
var building;
var prerendering;
var init_environment = __esm({
  ".svelte-kit/output/server/chunks/environment.js"() {
    building = false;
    prerendering = false;
  }
});
function is(value, type) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (value instanceof type) {
    return true;
  }
  if (!Object.prototype.hasOwnProperty.call(type, entityKind)) {
    throw new Error(
      `Class "${type.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`
    );
  }
  let cls = value.constructor;
  if (cls) {
    while (cls) {
      if (entityKind in cls && cls[entityKind] === type[entityKind]) {
        return true;
      }
      cls = Object.getPrototypeOf(cls);
    }
  }
  return false;
}
__name(is, "is");
var entityKind;
var hasOwnEntityKind;
var init_entity = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/entity.js"() {
    entityKind = Symbol.for("drizzle:entityKind");
    hasOwnEntityKind = Symbol.for("drizzle:hasOwnEntityKind");
  }
});
var Column;
var init_column = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/column.js"() {
    init_entity();
    Column = /* @__PURE__ */ __name(class {
      constructor(table, config) {
        this.table = table;
        this.config = config;
        this.name = config.name;
        this.keyAsName = config.keyAsName;
        this.notNull = config.notNull;
        this.default = config.default;
        this.defaultFn = config.defaultFn;
        this.onUpdateFn = config.onUpdateFn;
        this.hasDefault = config.hasDefault;
        this.primary = config.primaryKey;
        this.isUnique = config.isUnique;
        this.uniqueName = config.uniqueName;
        this.uniqueType = config.uniqueType;
        this.dataType = config.dataType;
        this.columnType = config.columnType;
        this.generated = config.generated;
        this.generatedIdentity = config.generatedIdentity;
      }
      static [entityKind] = "Column";
      name;
      keyAsName;
      primary;
      notNull;
      default;
      defaultFn;
      onUpdateFn;
      hasDefault;
      isUnique;
      uniqueName;
      uniqueType;
      dataType;
      columnType;
      enumValues = void 0;
      generated = void 0;
      generatedIdentity = void 0;
      config;
      mapFromDriverValue(value) {
        return value;
      }
      mapToDriverValue(value) {
        return value;
      }
      // ** @internal */
      shouldDisableInsert() {
        return this.config.generated !== void 0 && this.config.generated.type !== "byDefault";
      }
    }, "Column");
  }
});
var ColumnBuilder;
var init_column_builder = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/column-builder.js"() {
    init_entity();
    ColumnBuilder = /* @__PURE__ */ __name(class {
      static [entityKind] = "ColumnBuilder";
      config;
      constructor(name3, dataType, columnType) {
        this.config = {
          name: name3,
          keyAsName: name3 === "",
          notNull: false,
          default: void 0,
          hasDefault: false,
          primaryKey: false,
          isUnique: false,
          uniqueName: void 0,
          uniqueType: void 0,
          dataType,
          columnType,
          generated: void 0
        };
      }
      /**
       * Changes the data type of the column. Commonly used with `json` columns. Also, useful for branded types.
       *
       * @example
       * ```ts
       * const users = pgTable('users', {
       * 	id: integer('id').$type<UserId>().primaryKey(),
       * 	details: json('details').$type<UserDetails>().notNull(),
       * });
       * ```
       */
      $type() {
        return this;
      }
      /**
       * Adds a `not null` clause to the column definition.
       *
       * Affects the `select` model of the table - columns *without* `not null` will be nullable on select.
       */
      notNull() {
        this.config.notNull = true;
        return this;
      }
      /**
       * Adds a `default <value>` clause to the column definition.
       *
       * Affects the `insert` model of the table - columns *with* `default` are optional on insert.
       *
       * If you need to set a dynamic default value, use {@link $defaultFn} instead.
       */
      default(value) {
        this.config.default = value;
        this.config.hasDefault = true;
        return this;
      }
      /**
       * Adds a dynamic default value to the column.
       * The function will be called when the row is inserted, and the returned value will be used as the column value.
       *
       * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.
       */
      $defaultFn(fn) {
        this.config.defaultFn = fn;
        this.config.hasDefault = true;
        return this;
      }
      /**
       * Alias for {@link $defaultFn}.
       */
      $default = this.$defaultFn;
      /**
       * Adds a dynamic update value to the column.
       * The function will be called when the row is updated, and the returned value will be used as the column value if none is provided.
       * If no `default` (or `$defaultFn`) value is provided, the function will be called when the row is inserted as well, and the returned value will be used as the column value.
       *
       * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.
       */
      $onUpdateFn(fn) {
        this.config.onUpdateFn = fn;
        this.config.hasDefault = true;
        return this;
      }
      /**
       * Alias for {@link $onUpdateFn}.
       */
      $onUpdate = this.$onUpdateFn;
      /**
       * Adds a `primary key` clause to the column definition. This implicitly makes the column `not null`.
       *
       * In SQLite, `integer primary key` implicitly makes the column auto-incrementing.
       */
      primaryKey() {
        this.config.primaryKey = true;
        this.config.notNull = true;
        return this;
      }
      /** @internal Sets the name of the column to the key within the table definition if a name was not given. */
      setName(name3) {
        if (this.config.name !== "")
          return;
        this.config.name = name3;
      }
    }, "ColumnBuilder");
  }
});
var TableName;
var init_table_utils = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/table.utils.js"() {
    TableName = Symbol.for("drizzle:Name");
  }
});
var ForeignKeyBuilder;
var ForeignKey;
var init_foreign_keys = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/pg-core/foreign-keys.js"() {
    init_entity();
    init_table_utils();
    ForeignKeyBuilder = /* @__PURE__ */ __name(class {
      static [entityKind] = "PgForeignKeyBuilder";
      /** @internal */
      reference;
      /** @internal */
      _onUpdate = "no action";
      /** @internal */
      _onDelete = "no action";
      constructor(config, actions4) {
        this.reference = () => {
          const { name: name3, columns, foreignColumns } = config();
          return { name: name3, columns, foreignTable: foreignColumns[0].table, foreignColumns };
        };
        if (actions4) {
          this._onUpdate = actions4.onUpdate;
          this._onDelete = actions4.onDelete;
        }
      }
      onUpdate(action) {
        this._onUpdate = action === void 0 ? "no action" : action;
        return this;
      }
      onDelete(action) {
        this._onDelete = action === void 0 ? "no action" : action;
        return this;
      }
      /** @internal */
      build(table) {
        return new ForeignKey(table, this);
      }
    }, "ForeignKeyBuilder");
    ForeignKey = /* @__PURE__ */ __name(class {
      constructor(table, builder) {
        this.table = table;
        this.reference = builder.reference;
        this.onUpdate = builder._onUpdate;
        this.onDelete = builder._onDelete;
      }
      static [entityKind] = "PgForeignKey";
      reference;
      onUpdate;
      onDelete;
      getName() {
        const { name: name3, columns, foreignColumns } = this.reference();
        const columnNames = columns.map((column) => column.name);
        const foreignColumnNames = foreignColumns.map((column) => column.name);
        const chunks = [
          this.table[TableName],
          ...columnNames,
          foreignColumns[0].table[TableName],
          ...foreignColumnNames
        ];
        return name3 ?? `${chunks.join("_")}_fk`;
      }
    }, "ForeignKey");
  }
});
function iife(fn, ...args) {
  return fn(...args);
}
__name(iife, "iife");
var init_tracing_utils = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/tracing-utils.js"() {
  }
});
function uniqueKeyName(table, columns) {
  return `${table[TableName]}_${columns.join("_")}_unique`;
}
__name(uniqueKeyName, "uniqueKeyName");
var UniqueConstraintBuilder;
var UniqueOnConstraintBuilder;
var UniqueConstraint;
var init_unique_constraint = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/pg-core/unique-constraint.js"() {
    init_entity();
    init_table_utils();
    UniqueConstraintBuilder = /* @__PURE__ */ __name(class {
      constructor(columns, name3) {
        this.name = name3;
        this.columns = columns;
      }
      static [entityKind] = "PgUniqueConstraintBuilder";
      /** @internal */
      columns;
      /** @internal */
      nullsNotDistinctConfig = false;
      nullsNotDistinct() {
        this.nullsNotDistinctConfig = true;
        return this;
      }
      /** @internal */
      build(table) {
        return new UniqueConstraint(table, this.columns, this.nullsNotDistinctConfig, this.name);
      }
    }, "UniqueConstraintBuilder");
    UniqueOnConstraintBuilder = /* @__PURE__ */ __name(class {
      static [entityKind] = "PgUniqueOnConstraintBuilder";
      /** @internal */
      name;
      constructor(name3) {
        this.name = name3;
      }
      on(...columns) {
        return new UniqueConstraintBuilder(columns, this.name);
      }
    }, "UniqueOnConstraintBuilder");
    UniqueConstraint = /* @__PURE__ */ __name(class {
      constructor(table, columns, nullsNotDistinct, name3) {
        this.table = table;
        this.columns = columns;
        this.name = name3 ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));
        this.nullsNotDistinct = nullsNotDistinct;
      }
      static [entityKind] = "PgUniqueConstraint";
      columns;
      name;
      nullsNotDistinct = false;
      getName() {
        return this.name;
      }
    }, "UniqueConstraint");
  }
});
function parsePgArrayValue(arrayString, startFrom, inQuotes) {
  for (let i2 = startFrom; i2 < arrayString.length; i2++) {
    const char = arrayString[i2];
    if (char === "\\") {
      i2++;
      continue;
    }
    if (char === '"') {
      return [arrayString.slice(startFrom, i2).replace(/\\/g, ""), i2 + 1];
    }
    if (inQuotes) {
      continue;
    }
    if (char === "," || char === "}") {
      return [arrayString.slice(startFrom, i2).replace(/\\/g, ""), i2];
    }
  }
  return [arrayString.slice(startFrom).replace(/\\/g, ""), arrayString.length];
}
__name(parsePgArrayValue, "parsePgArrayValue");
function parsePgNestedArray(arrayString, startFrom = 0) {
  const result = [];
  let i2 = startFrom;
  let lastCharIsComma = false;
  while (i2 < arrayString.length) {
    const char = arrayString[i2];
    if (char === ",") {
      if (lastCharIsComma || i2 === startFrom) {
        result.push("");
      }
      lastCharIsComma = true;
      i2++;
      continue;
    }
    lastCharIsComma = false;
    if (char === "\\") {
      i2 += 2;
      continue;
    }
    if (char === '"') {
      const [value2, startFrom2] = parsePgArrayValue(arrayString, i2 + 1, true);
      result.push(value2);
      i2 = startFrom2;
      continue;
    }
    if (char === "}") {
      return [result, i2 + 1];
    }
    if (char === "{") {
      const [value2, startFrom2] = parsePgNestedArray(arrayString, i2 + 1);
      result.push(value2);
      i2 = startFrom2;
      continue;
    }
    const [value, newStartFrom] = parsePgArrayValue(arrayString, i2, false);
    result.push(value);
    i2 = newStartFrom;
  }
  return [result, i2];
}
__name(parsePgNestedArray, "parsePgNestedArray");
function parsePgArray(arrayString) {
  const [result] = parsePgNestedArray(arrayString, 1);
  return result;
}
__name(parsePgArray, "parsePgArray");
function makePgArray(array3) {
  return `{${array3.map((item) => {
    if (Array.isArray(item)) {
      return makePgArray(item);
    }
    if (typeof item === "string") {
      return `"${item.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
    }
    return `${item}`;
  }).join(",")}}`;
}
__name(makePgArray, "makePgArray");
var init_array = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/pg-core/utils/array.js"() {
  }
});
var PgColumnBuilder;
var PgColumn;
var ExtraConfigColumn;
var IndexedColumn;
var PgArrayBuilder;
var PgArray;
var init_common = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/pg-core/columns/common.js"() {
    init_column_builder();
    init_column();
    init_entity();
    init_foreign_keys();
    init_tracing_utils();
    init_unique_constraint();
    init_array();
    PgColumnBuilder = /* @__PURE__ */ __name(class extends ColumnBuilder {
      foreignKeyConfigs = [];
      static [entityKind] = "PgColumnBuilder";
      array(size2) {
        return new PgArrayBuilder(this.config.name, this, size2);
      }
      references(ref, actions4 = {}) {
        this.foreignKeyConfigs.push({ ref, actions: actions4 });
        return this;
      }
      unique(name3, config) {
        this.config.isUnique = true;
        this.config.uniqueName = name3;
        this.config.uniqueType = config?.nulls;
        return this;
      }
      generatedAlwaysAs(as) {
        this.config.generated = {
          as,
          type: "always",
          mode: "stored"
        };
        return this;
      }
      /** @internal */
      buildForeignKeys(column, table) {
        return this.foreignKeyConfigs.map(({ ref, actions: actions4 }) => {
          return iife(
            (ref2, actions22) => {
              const builder = new ForeignKeyBuilder(() => {
                const foreignColumn = ref2();
                return { columns: [column], foreignColumns: [foreignColumn] };
              });
              if (actions22.onUpdate) {
                builder.onUpdate(actions22.onUpdate);
              }
              if (actions22.onDelete) {
                builder.onDelete(actions22.onDelete);
              }
              return builder.build(table);
            },
            ref,
            actions4
          );
        });
      }
      /** @internal */
      buildExtraConfigColumn(table) {
        return new ExtraConfigColumn(table, this.config);
      }
    }, "PgColumnBuilder");
    PgColumn = /* @__PURE__ */ __name(class extends Column {
      constructor(table, config) {
        if (!config.uniqueName) {
          config.uniqueName = uniqueKeyName(table, [config.name]);
        }
        super(table, config);
        this.table = table;
      }
      static [entityKind] = "PgColumn";
    }, "PgColumn");
    ExtraConfigColumn = /* @__PURE__ */ __name(class extends PgColumn {
      static [entityKind] = "ExtraConfigColumn";
      getSQLType() {
        return this.getSQLType();
      }
      indexConfig = {
        order: this.config.order ?? "asc",
        nulls: this.config.nulls ?? "last",
        opClass: this.config.opClass
      };
      defaultConfig = {
        order: "asc",
        nulls: "last",
        opClass: void 0
      };
      asc() {
        this.indexConfig.order = "asc";
        return this;
      }
      desc() {
        this.indexConfig.order = "desc";
        return this;
      }
      nullsFirst() {
        this.indexConfig.nulls = "first";
        return this;
      }
      nullsLast() {
        this.indexConfig.nulls = "last";
        return this;
      }
      /**
       * ### PostgreSQL documentation quote
       *
       * > An operator class with optional parameters can be specified for each column of an index.
       * The operator class identifies the operators to be used by the index for that column.
       * For example, a B-tree index on four-byte integers would use the int4_ops class;
       * this operator class includes comparison functions for four-byte integers.
       * In practice the default operator class for the column's data type is usually sufficient.
       * The main point of having operator classes is that for some data types, there could be more than one meaningful ordering.
       * For example, we might want to sort a complex-number data type either by absolute value or by real part.
       * We could do this by defining two operator classes for the data type and then selecting the proper class when creating an index.
       * More information about operator classes check:
       *
       * ### Useful links
       * https://www.postgresql.org/docs/current/sql-createindex.html
       *
       * https://www.postgresql.org/docs/current/indexes-opclass.html
       *
       * https://www.postgresql.org/docs/current/xindex.html
       *
       * ### Additional types
       * If you have the `pg_vector` extension installed in your database, you can use the
       * `vector_l2_ops`, `vector_ip_ops`, `vector_cosine_ops`, `vector_l1_ops`, `bit_hamming_ops`, `bit_jaccard_ops`, `halfvec_l2_ops`, `sparsevec_l2_ops` options, which are predefined types.
       *
       * **You can always specify any string you want in the operator class, in case Drizzle doesn't have it natively in its types**
       *
       * @param opClass
       * @returns
       */
      op(opClass) {
        this.indexConfig.opClass = opClass;
        return this;
      }
    }, "ExtraConfigColumn");
    IndexedColumn = /* @__PURE__ */ __name(class {
      static [entityKind] = "IndexedColumn";
      constructor(name3, keyAsName, type, indexConfig) {
        this.name = name3;
        this.keyAsName = keyAsName;
        this.type = type;
        this.indexConfig = indexConfig;
      }
      name;
      keyAsName;
      type;
      indexConfig;
    }, "IndexedColumn");
    PgArrayBuilder = /* @__PURE__ */ __name(class extends PgColumnBuilder {
      static [entityKind] = "PgArrayBuilder";
      constructor(name3, baseBuilder, size2) {
        super(name3, "array", "PgArray");
        this.config.baseBuilder = baseBuilder;
        this.config.size = size2;
      }
      /** @internal */
      build(table) {
        const baseColumn = this.config.baseBuilder.build(table);
        return new PgArray(
          table,
          this.config,
          baseColumn
        );
      }
    }, "PgArrayBuilder");
    PgArray = /* @__PURE__ */ __name(class _PgArray extends PgColumn {
      constructor(table, config, baseColumn, range) {
        super(table, config);
        this.baseColumn = baseColumn;
        this.range = range;
        this.size = config.size;
      }
      size;
      static [entityKind] = "PgArray";
      getSQLType() {
        return `${this.baseColumn.getSQLType()}[${typeof this.size === "number" ? this.size : ""}]`;
      }
      mapFromDriverValue(value) {
        if (typeof value === "string") {
          value = parsePgArray(value);
        }
        return value.map((v2) => this.baseColumn.mapFromDriverValue(v2));
      }
      mapToDriverValue(value, isNestedArray = false) {
        const a2 = value.map(
          (v2) => v2 === null ? null : is(this.baseColumn, _PgArray) ? this.baseColumn.mapToDriverValue(v2, true) : this.baseColumn.mapToDriverValue(v2)
        );
        if (isNestedArray)
          return a2;
        return makePgArray(a2);
      }
    }, "_PgArray");
  }
});
function isPgEnum(obj) {
  return !!obj && typeof obj === "function" && isPgEnumSym in obj && obj[isPgEnumSym] === true;
}
__name(isPgEnum, "isPgEnum");
var isPgEnumSym;
var PgEnumColumnBuilder;
var PgEnumColumn;
var init_enum = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/pg-core/columns/enum.js"() {
    init_entity();
    init_common();
    isPgEnumSym = Symbol.for("drizzle:isPgEnum");
    PgEnumColumnBuilder = /* @__PURE__ */ __name(class extends PgColumnBuilder {
      static [entityKind] = "PgEnumColumnBuilder";
      constructor(name3, enumInstance) {
        super(name3, "string", "PgEnumColumn");
        this.config.enum = enumInstance;
      }
      /** @internal */
      build(table) {
        return new PgEnumColumn(
          table,
          this.config
        );
      }
    }, "PgEnumColumnBuilder");
    PgEnumColumn = /* @__PURE__ */ __name(class extends PgColumn {
      static [entityKind] = "PgEnumColumn";
      enum = this.config.enum;
      enumValues = this.config.enum.enumValues;
      constructor(table, config) {
        super(table, config);
        this.enum = config.enum;
      }
      getSQLType() {
        return this.enum.enumName;
      }
    }, "PgEnumColumn");
  }
});
var Subquery;
var WithSubquery;
var init_subquery = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/subquery.js"() {
    init_entity();
    Subquery = /* @__PURE__ */ __name(class {
      static [entityKind] = "Subquery";
      constructor(sql2, selection, alias, isWith = false) {
        this._ = {
          brand: "Subquery",
          sql: sql2,
          selectedFields: selection,
          alias,
          isWith
        };
      }
      // getSQL(): SQL<unknown> {
      // 	return new SQL([this]);
      // }
    }, "Subquery");
    WithSubquery = /* @__PURE__ */ __name(class extends Subquery {
      static [entityKind] = "WithSubquery";
    }, "WithSubquery");
  }
});
var version;
var init_version = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/version.js"() {
    version = "0.34.1";
  }
});
var otel;
var rawTracer;
var tracer;
var init_tracing = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/tracing.js"() {
    init_tracing_utils();
    init_version();
    tracer = {
      startActiveSpan(name3, fn) {
        if (!otel) {
          return fn();
        }
        if (!rawTracer) {
          rawTracer = otel.trace.getTracer("drizzle-orm", version);
        }
        return iife(
          (otel2, rawTracer2) => rawTracer2.startActiveSpan(
            name3,
            (span) => {
              try {
                return fn(span);
              } catch (e3) {
                span.setStatus({
                  code: otel2.SpanStatusCode.ERROR,
                  message: e3 instanceof Error ? e3.message : "Unknown error"
                  // eslint-disable-line no-instanceof/no-instanceof
                });
                throw e3;
              } finally {
                span.end();
              }
            }
          ),
          otel,
          rawTracer
        );
      }
    };
  }
});
var ViewBaseConfig;
var init_view_common = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/view-common.js"() {
    ViewBaseConfig = Symbol.for("drizzle:ViewBaseConfig");
  }
});
function getTableName(table) {
  return table[TableName];
}
__name(getTableName, "getTableName");
function getTableUniqueName(table) {
  return `${table[Schema] ?? "public"}.${table[TableName]}`;
}
__name(getTableUniqueName, "getTableUniqueName");
var Schema;
var Columns;
var ExtraConfigColumns;
var OriginalName;
var BaseName;
var IsAlias;
var ExtraConfigBuilder;
var IsDrizzleTable;
var Table;
var init_table = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/table.js"() {
    init_entity();
    init_table_utils();
    Schema = Symbol.for("drizzle:Schema");
    Columns = Symbol.for("drizzle:Columns");
    ExtraConfigColumns = Symbol.for("drizzle:ExtraConfigColumns");
    OriginalName = Symbol.for("drizzle:OriginalName");
    BaseName = Symbol.for("drizzle:BaseName");
    IsAlias = Symbol.for("drizzle:IsAlias");
    ExtraConfigBuilder = Symbol.for("drizzle:ExtraConfigBuilder");
    IsDrizzleTable = Symbol.for("drizzle:IsDrizzleTable");
    Table = /* @__PURE__ */ __name(class {
      static [entityKind] = "Table";
      /** @internal */
      static Symbol = {
        Name: TableName,
        Schema,
        OriginalName,
        Columns,
        ExtraConfigColumns,
        BaseName,
        IsAlias,
        ExtraConfigBuilder
      };
      /**
       * @internal
       * Can be changed if the table is aliased.
       */
      [TableName];
      /**
       * @internal
       * Used to store the original name of the table, before any aliasing.
       */
      [OriginalName];
      /** @internal */
      [Schema];
      /** @internal */
      [Columns];
      /** @internal */
      [ExtraConfigColumns];
      /**
       *  @internal
       * Used to store the table name before the transformation via the `tableCreator` functions.
       */
      [BaseName];
      /** @internal */
      [IsAlias] = false;
      /** @internal */
      [IsDrizzleTable] = true;
      /** @internal */
      [ExtraConfigBuilder] = void 0;
      constructor(name3, schema2, baseName) {
        this[TableName] = this[OriginalName] = name3;
        this[Schema] = schema2;
        this[BaseName] = baseName;
      }
    }, "Table");
  }
});
function isSQLWrapper(value) {
  return value !== null && value !== void 0 && typeof value.getSQL === "function";
}
__name(isSQLWrapper, "isSQLWrapper");
function mergeQueries(queries) {
  const result = { sql: "", params: [] };
  for (const query of queries) {
    result.sql += query.sql;
    result.params.push(...query.params);
    if (query.typings?.length) {
      if (!result.typings) {
        result.typings = [];
      }
      result.typings.push(...query.typings);
    }
  }
  return result;
}
__name(mergeQueries, "mergeQueries");
function isDriverValueEncoder(value) {
  return typeof value === "object" && value !== null && "mapToDriverValue" in value && typeof value.mapToDriverValue === "function";
}
__name(isDriverValueEncoder, "isDriverValueEncoder");
function sql(strings, ...params) {
  const queryChunks = [];
  if (params.length > 0 || strings.length > 0 && strings[0] !== "") {
    queryChunks.push(new StringChunk(strings[0]));
  }
  for (const [paramIndex, param2] of params.entries()) {
    queryChunks.push(param2, new StringChunk(strings[paramIndex + 1]));
  }
  return new SQL(queryChunks);
}
__name(sql, "sql");
function fillPlaceholders(params, values) {
  return params.map((p2) => {
    if (is(p2, Placeholder)) {
      if (!(p2.name in values)) {
        throw new Error(`No value for placeholder "${p2.name}" was provided`);
      }
      return values[p2.name];
    }
    if (is(p2, Param) && is(p2.value, Placeholder)) {
      if (!(p2.value.name in values)) {
        throw new Error(`No value for placeholder "${p2.value.name}" was provided`);
      }
      return p2.encoder.mapToDriverValue(values[p2.value.name]);
    }
    return p2;
  });
}
__name(fillPlaceholders, "fillPlaceholders");
var FakePrimitiveParam;
var StringChunk;
var SQL;
var Name;
var noopDecoder;
var noopEncoder;
var noopMapper;
var Param;
var Placeholder;
var View;
var init_sql = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sql/sql.js"() {
    init_entity();
    init_enum();
    init_subquery();
    init_tracing();
    init_view_common();
    init_column();
    init_table();
    FakePrimitiveParam = /* @__PURE__ */ __name(class {
      static [entityKind] = "FakePrimitiveParam";
    }, "FakePrimitiveParam");
    StringChunk = /* @__PURE__ */ __name(class {
      static [entityKind] = "StringChunk";
      value;
      constructor(value) {
        this.value = Array.isArray(value) ? value : [value];
      }
      getSQL() {
        return new SQL([this]);
      }
    }, "StringChunk");
    SQL = /* @__PURE__ */ __name(class _SQL {
      constructor(queryChunks) {
        this.queryChunks = queryChunks;
      }
      static [entityKind] = "SQL";
      /** @internal */
      decoder = noopDecoder;
      shouldInlineParams = false;
      append(query) {
        this.queryChunks.push(...query.queryChunks);
        return this;
      }
      toQuery(config) {
        return tracer.startActiveSpan("drizzle.buildSQL", (span) => {
          const query = this.buildQueryFromSourceParams(this.queryChunks, config);
          span?.setAttributes({
            "drizzle.query.text": query.sql,
            "drizzle.query.params": JSON.stringify(query.params)
          });
          return query;
        });
      }
      buildQueryFromSourceParams(chunks, _config) {
        const config = Object.assign({}, _config, {
          inlineParams: _config.inlineParams || this.shouldInlineParams,
          paramStartIndex: _config.paramStartIndex || { value: 0 }
        });
        const {
          casing,
          escapeName,
          escapeParam,
          prepareTyping,
          inlineParams,
          paramStartIndex
        } = config;
        return mergeQueries(chunks.map((chunk) => {
          if (is(chunk, StringChunk)) {
            return { sql: chunk.value.join(""), params: [] };
          }
          if (is(chunk, Name)) {
            return { sql: escapeName(chunk.value), params: [] };
          }
          if (chunk === void 0) {
            return { sql: "", params: [] };
          }
          if (Array.isArray(chunk)) {
            const result = [new StringChunk("(")];
            for (const [i2, p2] of chunk.entries()) {
              result.push(p2);
              if (i2 < chunk.length - 1) {
                result.push(new StringChunk(", "));
              }
            }
            result.push(new StringChunk(")"));
            return this.buildQueryFromSourceParams(result, config);
          }
          if (is(chunk, _SQL)) {
            return this.buildQueryFromSourceParams(chunk.queryChunks, {
              ...config,
              inlineParams: inlineParams || chunk.shouldInlineParams
            });
          }
          if (is(chunk, Table)) {
            const schemaName = chunk[Table.Symbol.Schema];
            const tableName = chunk[Table.Symbol.Name];
            return {
              sql: schemaName === void 0 ? escapeName(tableName) : escapeName(schemaName) + "." + escapeName(tableName),
              params: []
            };
          }
          if (is(chunk, Column)) {
            const columnName = casing.getColumnCasing(chunk);
            if (_config.invokeSource === "indexes") {
              return { sql: escapeName(columnName), params: [] };
            }
            return { sql: escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(columnName), params: [] };
          }
          if (is(chunk, View)) {
            const schemaName = chunk[ViewBaseConfig].schema;
            const viewName = chunk[ViewBaseConfig].name;
            return {
              sql: schemaName === void 0 ? escapeName(viewName) : escapeName(schemaName) + "." + escapeName(viewName),
              params: []
            };
          }
          if (is(chunk, Param)) {
            if (is(chunk.value, Placeholder)) {
              return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
            }
            const mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);
            if (is(mappedValue, _SQL)) {
              return this.buildQueryFromSourceParams([mappedValue], config);
            }
            if (inlineParams) {
              return { sql: this.mapInlineParam(mappedValue, config), params: [] };
            }
            let typings = ["none"];
            if (prepareTyping) {
              typings = [prepareTyping(chunk.encoder)];
            }
            return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
          }
          if (is(chunk, Placeholder)) {
            return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
          }
          if (is(chunk, _SQL.Aliased) && chunk.fieldAlias !== void 0) {
            return { sql: escapeName(chunk.fieldAlias), params: [] };
          }
          if (is(chunk, Subquery)) {
            if (chunk._.isWith) {
              return { sql: escapeName(chunk._.alias), params: [] };
            }
            return this.buildQueryFromSourceParams([
              new StringChunk("("),
              chunk._.sql,
              new StringChunk(") "),
              new Name(chunk._.alias)
            ], config);
          }
          if (isPgEnum(chunk)) {
            if (chunk.schema) {
              return { sql: escapeName(chunk.schema) + "." + escapeName(chunk.enumName), params: [] };
            }
            return { sql: escapeName(chunk.enumName), params: [] };
          }
          if (isSQLWrapper(chunk)) {
            if (chunk.shouldOmitSQLParens?.()) {
              return this.buildQueryFromSourceParams([chunk.getSQL()], config);
            }
            return this.buildQueryFromSourceParams([
              new StringChunk("("),
              chunk.getSQL(),
              new StringChunk(")")
            ], config);
          }
          if (inlineParams) {
            return { sql: this.mapInlineParam(chunk, config), params: [] };
          }
          return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
        }));
      }
      mapInlineParam(chunk, { escapeString }) {
        if (chunk === null) {
          return "null";
        }
        if (typeof chunk === "number" || typeof chunk === "boolean") {
          return chunk.toString();
        }
        if (typeof chunk === "string") {
          return escapeString(chunk);
        }
        if (typeof chunk === "object") {
          const mappedValueAsString = chunk.toString();
          if (mappedValueAsString === "[object Object]") {
            return escapeString(JSON.stringify(chunk));
          }
          return escapeString(mappedValueAsString);
        }
        throw new Error("Unexpected param value: " + chunk);
      }
      getSQL() {
        return this;
      }
      as(alias) {
        if (alias === void 0) {
          return this;
        }
        return new _SQL.Aliased(this, alias);
      }
      mapWith(decoder) {
        this.decoder = typeof decoder === "function" ? { mapFromDriverValue: decoder } : decoder;
        return this;
      }
      inlineParams() {
        this.shouldInlineParams = true;
        return this;
      }
      /**
       * This method is used to conditionally include a part of the query.
       *
       * @param condition - Condition to check
       * @returns itself if the condition is `true`, otherwise `undefined`
       */
      if(condition) {
        return condition ? this : void 0;
      }
    }, "_SQL");
    Name = /* @__PURE__ */ __name(class {
      constructor(value) {
        this.value = value;
      }
      static [entityKind] = "Name";
      brand;
      getSQL() {
        return new SQL([this]);
      }
    }, "Name");
    noopDecoder = {
      mapFromDriverValue: (value) => value
    };
    noopEncoder = {
      mapToDriverValue: (value) => value
    };
    noopMapper = {
      ...noopDecoder,
      ...noopEncoder
    };
    Param = /* @__PURE__ */ __name(class {
      /**
       * @param value - Parameter value
       * @param encoder - Encoder to convert the value to a driver parameter
       */
      constructor(value, encoder3 = noopEncoder) {
        this.value = value;
        this.encoder = encoder3;
      }
      static [entityKind] = "Param";
      brand;
      getSQL() {
        return new SQL([this]);
      }
    }, "Param");
    ((sql2) => {
      function empty() {
        return new SQL([]);
      }
      __name(empty, "empty");
      sql2.empty = empty;
      function fromList(list) {
        return new SQL(list);
      }
      __name(fromList, "fromList");
      sql2.fromList = fromList;
      function raw(str) {
        return new SQL([new StringChunk(str)]);
      }
      __name(raw, "raw");
      sql2.raw = raw;
      function join(chunks, separator) {
        const result = [];
        for (const [i2, chunk] of chunks.entries()) {
          if (i2 > 0 && separator !== void 0) {
            result.push(separator);
          }
          result.push(chunk);
        }
        return new SQL(result);
      }
      __name(join, "join");
      sql2.join = join;
      function identifier(value) {
        return new Name(value);
      }
      __name(identifier, "identifier");
      sql2.identifier = identifier;
      function placeholder2(name22) {
        return new Placeholder(name22);
      }
      __name(placeholder2, "placeholder2");
      sql2.placeholder = placeholder2;
      function param2(value, encoder3) {
        return new Param(value, encoder3);
      }
      __name(param2, "param2");
      sql2.param = param2;
    })(sql || (sql = {}));
    ((SQL2) => {
      class Aliased {
        constructor(sql2, fieldAlias) {
          this.sql = sql2;
          this.fieldAlias = fieldAlias;
        }
        static [entityKind] = "SQL.Aliased";
        /** @internal */
        isSelectionField = false;
        getSQL() {
          return this.sql;
        }
        /** @internal */
        clone() {
          return new Aliased(this.sql, this.fieldAlias);
        }
      }
      __name(Aliased, "Aliased");
      SQL2.Aliased = Aliased;
    })(SQL || (SQL = {}));
    Placeholder = /* @__PURE__ */ __name(class {
      constructor(name22) {
        this.name = name22;
      }
      static [entityKind] = "Placeholder";
      getSQL() {
        return new SQL([this]);
      }
    }, "Placeholder");
    View = /* @__PURE__ */ __name(class {
      static [entityKind] = "View";
      /** @internal */
      [ViewBaseConfig];
      constructor({ name: name22, schema: schema2, selectedFields, query }) {
        this[ViewBaseConfig] = {
          name: name22,
          originalName: name22,
          schema: schema2,
          selectedFields,
          query,
          isExisting: !query,
          isAlias: false
        };
      }
      getSQL() {
        return new SQL([this]);
      }
    }, "View");
    Column.prototype.getSQL = function() {
      return new SQL([this]);
    };
    Table.prototype.getSQL = function() {
      return new SQL([this]);
    };
    Subquery.prototype.getSQL = function() {
      return new SQL([this]);
    };
  }
});
function aliasedTable(table, tableAlias) {
  return new Proxy(table, new TableAliasProxyHandler(tableAlias, false));
}
__name(aliasedTable, "aliasedTable");
function aliasedTableColumn(column, tableAlias) {
  return new Proxy(
    column,
    new ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false)))
  );
}
__name(aliasedTableColumn, "aliasedTableColumn");
function mapColumnsInAliasedSQLToAlias(query, alias) {
  return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);
}
__name(mapColumnsInAliasedSQLToAlias, "mapColumnsInAliasedSQLToAlias");
function mapColumnsInSQLToAlias(query, alias) {
  return sql.join(query.queryChunks.map((c2) => {
    if (is(c2, Column)) {
      return aliasedTableColumn(c2, alias);
    }
    if (is(c2, SQL)) {
      return mapColumnsInSQLToAlias(c2, alias);
    }
    if (is(c2, SQL.Aliased)) {
      return mapColumnsInAliasedSQLToAlias(c2, alias);
    }
    return c2;
  }));
}
__name(mapColumnsInSQLToAlias, "mapColumnsInSQLToAlias");
var ColumnAliasProxyHandler;
var TableAliasProxyHandler;
var RelationTableAliasProxyHandler;
var init_alias = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/alias.js"() {
    init_column();
    init_entity();
    init_sql();
    init_table();
    init_view_common();
    ColumnAliasProxyHandler = /* @__PURE__ */ __name(class {
      constructor(table) {
        this.table = table;
      }
      static [entityKind] = "ColumnAliasProxyHandler";
      get(columnObj, prop) {
        if (prop === "table") {
          return this.table;
        }
        return columnObj[prop];
      }
    }, "ColumnAliasProxyHandler");
    TableAliasProxyHandler = /* @__PURE__ */ __name(class {
      constructor(alias, replaceOriginalName) {
        this.alias = alias;
        this.replaceOriginalName = replaceOriginalName;
      }
      static [entityKind] = "TableAliasProxyHandler";
      get(target, prop) {
        if (prop === Table.Symbol.IsAlias) {
          return true;
        }
        if (prop === Table.Symbol.Name) {
          return this.alias;
        }
        if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
          return this.alias;
        }
        if (prop === ViewBaseConfig) {
          return {
            ...target[ViewBaseConfig],
            name: this.alias,
            isAlias: true
          };
        }
        if (prop === Table.Symbol.Columns) {
          const columns = target[Table.Symbol.Columns];
          if (!columns) {
            return columns;
          }
          const proxiedColumns = {};
          Object.keys(columns).map((key2) => {
            proxiedColumns[key2] = new Proxy(
              columns[key2],
              new ColumnAliasProxyHandler(new Proxy(target, this))
            );
          });
          return proxiedColumns;
        }
        const value = target[prop];
        if (is(value, Column)) {
          return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(target, this)));
        }
        return value;
      }
    }, "TableAliasProxyHandler");
    RelationTableAliasProxyHandler = /* @__PURE__ */ __name(class {
      constructor(alias) {
        this.alias = alias;
      }
      static [entityKind] = "RelationTableAliasProxyHandler";
      get(target, prop) {
        if (prop === "sourceTable") {
          return aliasedTable(target.sourceTable, this.alias);
        }
        return target[prop];
      }
    }, "RelationTableAliasProxyHandler");
  }
});
var DrizzleError;
var TransactionRollbackError;
var init_errors = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/errors.js"() {
    init_entity();
    DrizzleError = /* @__PURE__ */ __name(class extends Error {
      static [entityKind] = "DrizzleError";
      constructor({ message, cause }) {
        super(message);
        this.name = "DrizzleError";
        this.cause = cause;
      }
    }, "DrizzleError");
    TransactionRollbackError = /* @__PURE__ */ __name(class extends DrizzleError {
      static [entityKind] = "TransactionRollbackError";
      constructor() {
        super({ message: "Rollback" });
      }
    }, "TransactionRollbackError");
  }
});
function bindIfParam(value, column) {
  if (isDriverValueEncoder(column) && !isSQLWrapper(value) && !is(value, Param) && !is(value, Placeholder) && !is(value, Column) && !is(value, Table) && !is(value, View)) {
    return new Param(value, column);
  }
  return value;
}
__name(bindIfParam, "bindIfParam");
function and(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter(
    (c2) => c2 !== void 0
  );
  if (conditions.length === 0) {
    return void 0;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" and ")),
    new StringChunk(")")
  ]);
}
__name(and, "and");
function or(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter(
    (c2) => c2 !== void 0
  );
  if (conditions.length === 0) {
    return void 0;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" or ")),
    new StringChunk(")")
  ]);
}
__name(or, "or");
function not(condition) {
  return sql`not ${condition}`;
}
__name(not, "not");
function inArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      return sql`false`;
    }
    return sql`${column} in ${values.map((v2) => bindIfParam(v2, column))}`;
  }
  return sql`${column} in ${bindIfParam(values, column)}`;
}
__name(inArray, "inArray");
function notInArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      return sql`true`;
    }
    return sql`${column} not in ${values.map((v2) => bindIfParam(v2, column))}`;
  }
  return sql`${column} not in ${bindIfParam(values, column)}`;
}
__name(notInArray, "notInArray");
function isNull(value) {
  return sql`${value} is null`;
}
__name(isNull, "isNull");
function isNotNull(value) {
  return sql`${value} is not null`;
}
__name(isNotNull, "isNotNull");
function exists(subquery) {
  return sql`exists ${subquery}`;
}
__name(exists, "exists");
function notExists(subquery) {
  return sql`not exists ${subquery}`;
}
__name(notExists, "notExists");
function between(column, min2, max2) {
  return sql`${column} between ${bindIfParam(min2, column)} and ${bindIfParam(
    max2,
    column
  )}`;
}
__name(between, "between");
function notBetween(column, min2, max2) {
  return sql`${column} not between ${bindIfParam(
    min2,
    column
  )} and ${bindIfParam(max2, column)}`;
}
__name(notBetween, "notBetween");
function like(column, value) {
  return sql`${column} like ${value}`;
}
__name(like, "like");
function notLike(column, value) {
  return sql`${column} not like ${value}`;
}
__name(notLike, "notLike");
function ilike(column, value) {
  return sql`${column} ilike ${value}`;
}
__name(ilike, "ilike");
function notIlike(column, value) {
  return sql`${column} not ilike ${value}`;
}
__name(notIlike, "notIlike");
var eq;
var ne;
var gt;
var gte;
var lt;
var lte;
var init_conditions = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sql/expressions/conditions.js"() {
    init_column();
    init_entity();
    init_table();
    init_sql();
    eq = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} = ${bindIfParam(right, left)}`;
    }, "eq");
    ne = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} <> ${bindIfParam(right, left)}`;
    }, "ne");
    gt = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} > ${bindIfParam(right, left)}`;
    }, "gt");
    gte = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} >= ${bindIfParam(right, left)}`;
    }, "gte");
    lt = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} < ${bindIfParam(right, left)}`;
    }, "lt");
    lte = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} <= ${bindIfParam(right, left)}`;
    }, "lte");
  }
});
function asc(column) {
  return sql`${column} asc`;
}
__name(asc, "asc");
function desc(column) {
  return sql`${column} desc`;
}
__name(desc, "desc");
var init_select = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sql/expressions/select.js"() {
    init_sql();
  }
});
var init_expressions = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sql/expressions/index.js"() {
    init_conditions();
    init_select();
  }
});
var init_expressions2 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/expressions.js"() {
    init_expressions();
  }
});
var ConsoleLogWriter;
var DefaultLogger;
var NoopLogger;
var init_logger = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/logger.js"() {
    init_entity();
    ConsoleLogWriter = /* @__PURE__ */ __name(class {
      static [entityKind] = "ConsoleLogWriter";
      write(message) {
        console.log(message);
      }
    }, "ConsoleLogWriter");
    DefaultLogger = /* @__PURE__ */ __name(class {
      static [entityKind] = "DefaultLogger";
      writer;
      constructor(config) {
        this.writer = config?.writer ?? new ConsoleLogWriter();
      }
      logQuery(query, params) {
        const stringifiedParams = params.map((p2) => {
          try {
            return JSON.stringify(p2);
          } catch {
            return String(p2);
          }
        });
        const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(", ")}]` : "";
        this.writer.write(`Query: ${query}${paramsStr}`);
      }
    }, "DefaultLogger");
    NoopLogger = /* @__PURE__ */ __name(class {
      static [entityKind] = "NoopLogger";
      logQuery() {
      }
    }, "NoopLogger");
  }
});
var init_operations2 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/operations.js"() {
  }
});
var QueryPromise;
var init_query_promise = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/query-promise.js"() {
    init_entity();
    QueryPromise = /* @__PURE__ */ __name(class {
      static [entityKind] = "QueryPromise";
      [Symbol.toStringTag] = "QueryPromise";
      catch(onRejected) {
        return this.then(void 0, onRejected);
      }
      finally(onFinally) {
        return this.then(
          (value) => {
            onFinally?.();
            return value;
          },
          (reason) => {
            onFinally?.();
            throw reason;
          }
        );
      }
      then(onFulfilled, onRejected) {
        return this.execute().then(onFulfilled, onRejected);
      }
    }, "QueryPromise");
  }
});
function mapResultRow(columns, row, joinsNotNullableMap) {
  const nullifyMap = {};
  const result = columns.reduce(
    (result2, { path, field }, columnIndex) => {
      let decoder;
      if (is(field, Column)) {
        decoder = field;
      } else if (is(field, SQL)) {
        decoder = field.decoder;
      } else {
        decoder = field.sql.decoder;
      }
      let node = result2;
      for (const [pathChunkIndex, pathChunk] of path.entries()) {
        if (pathChunkIndex < path.length - 1) {
          if (!(pathChunk in node)) {
            node[pathChunk] = {};
          }
          node = node[pathChunk];
        } else {
          const rawValue = row[columnIndex];
          const value = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);
          if (joinsNotNullableMap && is(field, Column) && path.length === 2) {
            const objectName = path[0];
            if (!(objectName in nullifyMap)) {
              nullifyMap[objectName] = value === null ? getTableName(field.table) : false;
            } else if (typeof nullifyMap[objectName] === "string" && nullifyMap[objectName] !== getTableName(field.table)) {
              nullifyMap[objectName] = false;
            }
          }
        }
      }
      return result2;
    },
    {}
  );
  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
    for (const [objectName, tableName] of Object.entries(nullifyMap)) {
      if (typeof tableName === "string" && !joinsNotNullableMap[tableName]) {
        result[objectName] = null;
      }
    }
  }
  return result;
}
__name(mapResultRow, "mapResultRow");
function orderSelectedFields(fields, pathPrefix) {
  return Object.entries(fields).reduce((result, [name3, field]) => {
    if (typeof name3 !== "string") {
      return result;
    }
    const newPath = pathPrefix ? [...pathPrefix, name3] : [name3];
    if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {
      result.push({ path: newPath, field });
    } else if (is(field, Table)) {
      result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
    } else {
      result.push(...orderSelectedFields(field, newPath));
    }
    return result;
  }, []);
}
__name(orderSelectedFields, "orderSelectedFields");
function haveSameKeys(left, right) {
  const leftKeys = Object.keys(left);
  const rightKeys = Object.keys(right);
  if (leftKeys.length !== rightKeys.length) {
    return false;
  }
  for (const [index39, key2] of leftKeys.entries()) {
    if (key2 !== rightKeys[index39]) {
      return false;
    }
  }
  return true;
}
__name(haveSameKeys, "haveSameKeys");
function mapUpdateSet(table, values) {
  const entries = Object.entries(values).filter(([, value]) => value !== void 0).map(([key2, value]) => {
    if (is(value, SQL)) {
      return [key2, value];
    } else {
      return [key2, new Param(value, table[Table.Symbol.Columns][key2])];
    }
  });
  if (entries.length === 0) {
    throw new Error("No values to set");
  }
  return Object.fromEntries(entries);
}
__name(mapUpdateSet, "mapUpdateSet");
function applyMixins(baseClass, extendedClasses) {
  for (const extendedClass of extendedClasses) {
    for (const name3 of Object.getOwnPropertyNames(extendedClass.prototype)) {
      if (name3 === "constructor")
        continue;
      Object.defineProperty(
        baseClass.prototype,
        name3,
        Object.getOwnPropertyDescriptor(extendedClass.prototype, name3) || /* @__PURE__ */ Object.create(null)
      );
    }
  }
}
__name(applyMixins, "applyMixins");
function getTableColumns(table) {
  return table[Table.Symbol.Columns];
}
__name(getTableColumns, "getTableColumns");
function getTableLikeName(table) {
  return is(table, Subquery) ? table._.alias : is(table, View) ? table[ViewBaseConfig].name : is(table, SQL) ? void 0 : table[Table.Symbol.IsAlias] ? table[Table.Symbol.Name] : table[Table.Symbol.BaseName];
}
__name(getTableLikeName, "getTableLikeName");
function getColumnNameAndConfig(a2, b) {
  return {
    name: typeof a2 === "string" && a2.length > 0 ? a2 : "",
    config: typeof a2 === "object" ? a2 : b
  };
}
__name(getColumnNameAndConfig, "getColumnNameAndConfig");
var init_utils = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/utils.js"() {
    init_column();
    init_entity();
    init_sql();
    init_subquery();
    init_table();
    init_view_common();
  }
});
var InlineForeignKeys;
var PgTable;
var init_table2 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/pg-core/table.js"() {
    init_entity();
    init_table();
    InlineForeignKeys = Symbol.for("drizzle:PgInlineForeignKeys");
    PgTable = /* @__PURE__ */ __name(class extends Table {
      static [entityKind] = "PgTable";
      /** @internal */
      static Symbol = Object.assign({}, Table.Symbol, {
        InlineForeignKeys
      });
      /**@internal */
      [InlineForeignKeys] = [];
      /** @internal */
      [Table.Symbol.ExtraConfigBuilder] = void 0;
    }, "PgTable");
  }
});
var PrimaryKeyBuilder;
var PrimaryKey;
var init_primary_keys = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/pg-core/primary-keys.js"() {
    init_entity();
    init_table2();
    PrimaryKeyBuilder = /* @__PURE__ */ __name(class {
      static [entityKind] = "PgPrimaryKeyBuilder";
      /** @internal */
      columns;
      /** @internal */
      name;
      constructor(columns, name3) {
        this.columns = columns;
        this.name = name3;
      }
      /** @internal */
      build(table) {
        return new PrimaryKey(table, this.columns, this.name);
      }
    }, "PrimaryKeyBuilder");
    PrimaryKey = /* @__PURE__ */ __name(class {
      constructor(table, columns, name3) {
        this.table = table;
        this.columns = columns;
        this.name = name3;
      }
      static [entityKind] = "PgPrimaryKey";
      columns;
      name;
      getName() {
        return this.name ?? `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
      }
    }, "PrimaryKey");
  }
});
function getOperators() {
  return {
    and,
    between,
    eq,
    exists,
    gt,
    gte,
    ilike,
    inArray,
    isNull,
    isNotNull,
    like,
    lt,
    lte,
    ne,
    not,
    notBetween,
    notExists,
    notLike,
    notIlike,
    notInArray,
    or,
    sql
  };
}
__name(getOperators, "getOperators");
function getOrderByOperators() {
  return {
    sql,
    asc,
    desc
  };
}
__name(getOrderByOperators, "getOrderByOperators");
function extractTablesRelationalConfig(schema2, configHelpers) {
  if (Object.keys(schema2).length === 1 && "default" in schema2 && !is(schema2["default"], Table)) {
    schema2 = schema2["default"];
  }
  const tableNamesMap = {};
  const relationsBuffer = {};
  const tablesConfig = {};
  for (const [key2, value] of Object.entries(schema2)) {
    if (is(value, Table)) {
      const dbName = getTableUniqueName(value);
      const bufferedRelations = relationsBuffer[dbName];
      tableNamesMap[dbName] = key2;
      tablesConfig[key2] = {
        tsName: key2,
        dbName: value[Table.Symbol.Name],
        schema: value[Table.Symbol.Schema],
        columns: value[Table.Symbol.Columns],
        relations: bufferedRelations?.relations ?? {},
        primaryKey: bufferedRelations?.primaryKey ?? []
      };
      for (const column of Object.values(
        value[Table.Symbol.Columns]
      )) {
        if (column.primary) {
          tablesConfig[key2].primaryKey.push(column);
        }
      }
      const extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.(value[Table.Symbol.ExtraConfigColumns]);
      if (extraConfig) {
        for (const configEntry of Object.values(extraConfig)) {
          if (is(configEntry, PrimaryKeyBuilder)) {
            tablesConfig[key2].primaryKey.push(...configEntry.columns);
          }
        }
      }
    } else if (is(value, Relations)) {
      const dbName = getTableUniqueName(value.table);
      const tableName = tableNamesMap[dbName];
      const relations2 = value.config(
        configHelpers(value.table)
      );
      let primaryKey2;
      for (const [relationName, relation] of Object.entries(relations2)) {
        if (tableName) {
          const tableConfig = tablesConfig[tableName];
          tableConfig.relations[relationName] = relation;
          if (primaryKey2) {
            tableConfig.primaryKey.push(...primaryKey2);
          }
        } else {
          if (!(dbName in relationsBuffer)) {
            relationsBuffer[dbName] = {
              relations: {},
              primaryKey: primaryKey2
            };
          }
          relationsBuffer[dbName].relations[relationName] = relation;
        }
      }
    }
  }
  return { tables: tablesConfig, tableNamesMap };
}
__name(extractTablesRelationalConfig, "extractTablesRelationalConfig");
function relations(table, relations2) {
  return new Relations(
    table,
    (helpers) => Object.fromEntries(
      Object.entries(relations2(helpers)).map(([key2, value]) => [
        key2,
        value.withFieldName(key2)
      ])
    )
  );
}
__name(relations, "relations");
function createOne(sourceTable) {
  return /* @__PURE__ */ __name(function one(table, config) {
    return new One(
      sourceTable,
      table,
      config,
      config?.fields.reduce((res, f) => res && f.notNull, true) ?? false
    );
  }, "one");
}
__name(createOne, "createOne");
function createMany(sourceTable) {
  return /* @__PURE__ */ __name(function many(referencedTable, config) {
    return new Many(sourceTable, referencedTable, config);
  }, "many");
}
__name(createMany, "createMany");
function normalizeRelation(schema2, tableNamesMap, relation) {
  if (is(relation, One) && relation.config) {
    return {
      fields: relation.config.fields,
      references: relation.config.references
    };
  }
  const referencedTableTsName = tableNamesMap[getTableUniqueName(relation.referencedTable)];
  if (!referencedTableTsName) {
    throw new Error(
      `Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`
    );
  }
  const referencedTableConfig = schema2[referencedTableTsName];
  if (!referencedTableConfig) {
    throw new Error(`Table "${referencedTableTsName}" not found in schema`);
  }
  const sourceTable = relation.sourceTable;
  const sourceTableTsName = tableNamesMap[getTableUniqueName(sourceTable)];
  if (!sourceTableTsName) {
    throw new Error(
      `Table "${sourceTable[Table.Symbol.Name]}" not found in schema`
    );
  }
  const reverseRelations = [];
  for (const referencedTableRelation of Object.values(
    referencedTableConfig.relations
  )) {
    if (relation.relationName && relation !== referencedTableRelation && referencedTableRelation.relationName === relation.relationName || !relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable) {
      reverseRelations.push(referencedTableRelation);
    }
  }
  if (reverseRelations.length > 1) {
    throw relation.relationName ? new Error(
      `There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`
    ) : new Error(
      `There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`
    );
  }
  if (reverseRelations[0] && is(reverseRelations[0], One) && reverseRelations[0].config) {
    return {
      fields: reverseRelations[0].config.references,
      references: reverseRelations[0].config.fields
    };
  }
  throw new Error(
    `There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`
  );
}
__name(normalizeRelation, "normalizeRelation");
function createTableRelationsHelpers(sourceTable) {
  return {
    one: createOne(sourceTable),
    many: createMany(sourceTable)
  };
}
__name(createTableRelationsHelpers, "createTableRelationsHelpers");
function mapRelationalRow(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value) => value) {
  const result = {};
  for (const [
    selectionItemIndex,
    selectionItem
  ] of buildQueryResultSelection.entries()) {
    if (selectionItem.isJson) {
      const relation = tableConfig.relations[selectionItem.tsKey];
      const rawSubRows = row[selectionItemIndex];
      const subRows = typeof rawSubRows === "string" ? JSON.parse(rawSubRows) : rawSubRows;
      result[selectionItem.tsKey] = is(relation, One) ? subRows && mapRelationalRow(
        tablesConfig,
        tablesConfig[selectionItem.relationTableTsKey],
        subRows,
        selectionItem.selection,
        mapColumnValue
      ) : subRows.map(
        (subRow) => mapRelationalRow(
          tablesConfig,
          tablesConfig[selectionItem.relationTableTsKey],
          subRow,
          selectionItem.selection,
          mapColumnValue
        )
      );
    } else {
      const value = mapColumnValue(row[selectionItemIndex]);
      const field = selectionItem.field;
      let decoder;
      if (is(field, Column)) {
        decoder = field;
      } else if (is(field, SQL)) {
        decoder = field.decoder;
      } else {
        decoder = field.sql.decoder;
      }
      result[selectionItem.tsKey] = value === null ? null : decoder.mapFromDriverValue(value);
    }
  }
  return result;
}
__name(mapRelationalRow, "mapRelationalRow");
var Relation;
var Relations;
var One;
var Many;
var init_relations = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/relations.js"() {
    init_table();
    init_column();
    init_entity();
    init_primary_keys();
    init_expressions();
    init_sql();
    Relation = /* @__PURE__ */ __name(class {
      constructor(sourceTable, referencedTable, relationName) {
        this.sourceTable = sourceTable;
        this.referencedTable = referencedTable;
        this.relationName = relationName;
        this.referencedTableName = referencedTable[Table.Symbol.Name];
      }
      static [entityKind] = "Relation";
      referencedTableName;
      fieldName;
    }, "Relation");
    Relations = /* @__PURE__ */ __name(class {
      constructor(table, config) {
        this.table = table;
        this.config = config;
      }
      static [entityKind] = "Relations";
    }, "Relations");
    One = /* @__PURE__ */ __name(class _One extends Relation {
      constructor(sourceTable, referencedTable, config, isNullable) {
        super(sourceTable, referencedTable, config?.relationName);
        this.config = config;
        this.isNullable = isNullable;
      }
      static [entityKind] = "One";
      withFieldName(fieldName) {
        const relation = new _One(
          this.sourceTable,
          this.referencedTable,
          this.config,
          this.isNullable
        );
        relation.fieldName = fieldName;
        return relation;
      }
    }, "_One");
    Many = /* @__PURE__ */ __name(class _Many extends Relation {
      constructor(sourceTable, referencedTable, config) {
        super(sourceTable, referencedTable, config?.relationName);
        this.config = config;
      }
      static [entityKind] = "Many";
      withFieldName(fieldName) {
        const relation = new _Many(
          this.sourceTable,
          this.referencedTable,
          this.config
        );
        relation.fieldName = fieldName;
        return relation;
      }
    }, "_Many");
  }
});
var init_aggregate = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sql/functions/aggregate.js"() {
  }
});
var init_vector = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sql/functions/vector.js"() {
  }
});
var init_functions = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sql/functions/index.js"() {
    init_aggregate();
    init_vector();
  }
});
var init_sql2 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sql/index.js"() {
    init_expressions();
    init_functions();
    init_sql();
  }
});
var init_drizzle_orm = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/index.js"() {
    init_alias();
    init_column_builder();
    init_column();
    init_entity();
    init_errors();
    init_expressions2();
    init_logger();
    init_operations2();
    init_query_promise();
    init_relations();
    init_sql2();
    init_subquery();
    init_table();
    init_utils();
    init_view_common();
  }
});
function encodeHexLowerCase(data) {
  let result = "";
  for (let i2 = 0; i2 < data.length; i2++) {
    result += alphabetLowerCase[data[i2] >> 4];
    result += alphabetLowerCase[data[i2] & 15];
  }
  return result;
}
__name(encodeHexLowerCase, "encodeHexLowerCase");
var alphabetLowerCase;
var init_hex = __esm({
  "node_modules/.pnpm/@oslojs+encoding@1.1.0/node_modules/@oslojs/encoding/dist/hex.js"() {
    alphabetLowerCase = "0123456789abcdef";
  }
});
function encodeBase32LowerCaseNoPadding(bytes) {
  return encodeBase32_internal(bytes, base32LowerCaseAlphabet, EncodingPadding.None);
}
__name(encodeBase32LowerCaseNoPadding, "encodeBase32LowerCaseNoPadding");
function encodeBase32_internal(bytes, alphabet, padding) {
  let result = "";
  for (let i2 = 0; i2 < bytes.byteLength; i2 += 5) {
    let buffer = 0n;
    let bufferBitSize = 0;
    for (let j2 = 0; j2 < 5 && i2 + j2 < bytes.byteLength; j2++) {
      buffer = buffer << 8n | BigInt(bytes[i2 + j2]);
      bufferBitSize += 8;
    }
    if (bufferBitSize % 5 !== 0) {
      buffer = buffer << BigInt(5 - bufferBitSize % 5);
      bufferBitSize += 5 - bufferBitSize % 5;
    }
    for (let j2 = 0; j2 < 8; j2++) {
      if (bufferBitSize >= 5) {
        result += alphabet[Number(buffer >> BigInt(bufferBitSize - 5) & 0x1fn)];
        bufferBitSize -= 5;
      } else if (bufferBitSize > 0) {
        result += alphabet[Number(buffer << BigInt(6 - bufferBitSize) & 0x3fn)];
        bufferBitSize = 0;
      } else if (padding === EncodingPadding.Include) {
        result += "=";
      }
    }
  }
  return result;
}
__name(encodeBase32_internal, "encodeBase32_internal");
var base32LowerCaseAlphabet;
var EncodingPadding;
var DecodingPadding;
var init_base32 = __esm({
  "node_modules/.pnpm/@oslojs+encoding@1.1.0/node_modules/@oslojs/encoding/dist/base32.js"() {
    base32LowerCaseAlphabet = "abcdefghijklmnopqrstuvwxyz234567";
    (function(EncodingPadding5) {
      EncodingPadding5[EncodingPadding5["Include"] = 0] = "Include";
      EncodingPadding5[EncodingPadding5["None"] = 1] = "None";
    })(EncodingPadding || (EncodingPadding = {}));
    (function(DecodingPadding5) {
      DecodingPadding5[DecodingPadding5["Required"] = 0] = "Required";
      DecodingPadding5[DecodingPadding5["Ignore"] = 1] = "Ignore";
    })(DecodingPadding || (DecodingPadding = {}));
  }
});
var EncodingPadding2;
var DecodingPadding2;
var init_base64 = __esm({
  "node_modules/.pnpm/@oslojs+encoding@1.1.0/node_modules/@oslojs/encoding/dist/base64.js"() {
    (function(EncodingPadding5) {
      EncodingPadding5[EncodingPadding5["Include"] = 0] = "Include";
      EncodingPadding5[EncodingPadding5["None"] = 1] = "None";
    })(EncodingPadding2 || (EncodingPadding2 = {}));
    (function(DecodingPadding5) {
      DecodingPadding5[DecodingPadding5["Required"] = 0] = "Required";
      DecodingPadding5[DecodingPadding5["Ignore"] = 1] = "Ignore";
    })(DecodingPadding2 || (DecodingPadding2 = {}));
  }
});
var init_dist = __esm({
  "node_modules/.pnpm/@oslojs+encoding@1.1.0/node_modules/@oslojs/encoding/dist/index.js"() {
    init_hex();
    init_base32();
    init_base64();
  }
});
var BigEndian;
var LittleEndian;
var bigEndian;
var littleEndian;
var init_uint = __esm({
  "node_modules/.pnpm/@oslojs+binary@1.0.0/node_modules/@oslojs/binary/dist/uint.js"() {
    BigEndian = /* @__PURE__ */ __name(class {
      uint8(data, offset2) {
        if (data.byteLength < offset2 + 1) {
          throw new TypeError("Insufficient bytes");
        }
        return data[offset2];
      }
      uint16(data, offset2) {
        if (data.byteLength < offset2 + 2) {
          throw new TypeError("Insufficient bytes");
        }
        return data[offset2] << 8 | data[offset2 + 1];
      }
      uint32(data, offset2) {
        if (data.byteLength < offset2 + 4) {
          throw new TypeError("Insufficient bytes");
        }
        let result = 0;
        for (let i2 = 0; i2 < 4; i2++) {
          result |= data[offset2 + i2] << 24 - i2 * 8;
        }
        return result;
      }
      uint64(data, offset2) {
        if (data.byteLength < offset2 + 8) {
          throw new TypeError("Insufficient bytes");
        }
        let result = 0n;
        for (let i2 = 0; i2 < 8; i2++) {
          result |= BigInt(data[offset2 + i2]) << BigInt(56 - i2 * 8);
        }
        return result;
      }
      putUint8(target, value, offset2) {
        if (target.length < offset2 + 1) {
          throw new TypeError("Not enough space");
        }
        if (value < 0 || value > 255) {
          throw new TypeError("Invalid uint8 value");
        }
        target[offset2] = value;
      }
      putUint16(target, value, offset2) {
        if (target.length < offset2 + 2) {
          throw new TypeError("Not enough space");
        }
        if (value < 0 || value > 65535) {
          throw new TypeError("Invalid uint16 value");
        }
        target[offset2] = value >> 8;
        target[offset2 + 1] = value & 255;
      }
      putUint32(target, value, offset2) {
        if (target.length < offset2 + 4) {
          throw new TypeError("Not enough space");
        }
        if (value < 0 || value > 4294967295) {
          throw new TypeError("Invalid uint32 value");
        }
        for (let i2 = 0; i2 < 4; i2++) {
          target[offset2 + i2] = value >> (3 - i2) * 8 & 255;
        }
      }
      putUint64(target, value, offset2) {
        if (target.length < offset2 + 8) {
          throw new TypeError("Not enough space");
        }
        if (value < 0 || value > 18446744073709551615n) {
          throw new TypeError("Invalid uint64 value");
        }
        for (let i2 = 0; i2 < 8; i2++) {
          target[offset2 + i2] = Number(value >> BigInt((7 - i2) * 8) & 0xffn);
        }
      }
    }, "BigEndian");
    LittleEndian = /* @__PURE__ */ __name(class {
      uint8(data, offset2) {
        if (data.byteLength < offset2 + 1) {
          throw new TypeError("Insufficient bytes");
        }
        return data[offset2];
      }
      uint16(data, offset2) {
        if (data.byteLength < offset2 + 2) {
          throw new TypeError("Insufficient bytes");
        }
        return data[offset2] | data[offset2 + 1] << 8;
      }
      uint32(data, offset2) {
        if (data.byteLength < offset2 + 4) {
          throw new TypeError("Insufficient bytes");
        }
        let result = 0;
        for (let i2 = 0; i2 < 4; i2++) {
          result |= data[offset2 + i2] << i2 * 8;
        }
        return result;
      }
      uint64(data, offset2) {
        if (data.byteLength < offset2 + 8) {
          throw new TypeError("Insufficient bytes");
        }
        let result = 0n;
        for (let i2 = 0; i2 < 8; i2++) {
          result |= BigInt(data[offset2 + i2]) << BigInt(i2 * 8);
        }
        return result;
      }
      putUint8(target, value, offset2) {
        if (target.length < 1 + offset2) {
          throw new TypeError("Insufficient space");
        }
        if (value < 0 || value > 255) {
          throw new TypeError("Invalid uint8 value");
        }
        target[offset2] = value;
      }
      putUint16(target, value, offset2) {
        if (target.length < 2 + offset2) {
          throw new TypeError("Insufficient space");
        }
        if (value < 0 || value > 65535) {
          throw new TypeError("Invalid uint16 value");
        }
        target[offset2 + 1] = value >> 8;
        target[offset2] = value & 255;
      }
      putUint32(target, value, offset2) {
        if (target.length < 4 + offset2) {
          throw new TypeError("Insufficient space");
        }
        if (value < 0 || value > 4294967295) {
          throw new TypeError("Invalid uint32 value");
        }
        for (let i2 = 0; i2 < 4; i2++) {
          target[offset2 + i2] = value >> i2 * 8 & 255;
        }
      }
      putUint64(target, value, offset2) {
        if (target.length < 8 + offset2) {
          throw new TypeError("Insufficient space");
        }
        if (value < 0 || value > 18446744073709551615n) {
          throw new TypeError("Invalid uint64 value");
        }
        for (let i2 = 0; i2 < 8; i2++) {
          target[offset2 + i2] = Number(value >> BigInt(i2 * 8) & 0xffn);
        }
      }
    }, "LittleEndian");
    bigEndian = new BigEndian();
    littleEndian = new LittleEndian();
  }
});
var init_bytes = __esm({
  "node_modules/.pnpm/@oslojs+binary@1.0.0/node_modules/@oslojs/binary/dist/bytes.js"() {
  }
});
function rotr32(x2, n2) {
  return (x2 << 32 - n2 | x2 >>> n2) >>> 0;
}
__name(rotr32, "rotr32");
var init_bits = __esm({
  "node_modules/.pnpm/@oslojs+binary@1.0.0/node_modules/@oslojs/binary/dist/bits.js"() {
  }
});
var init_big = __esm({
  "node_modules/.pnpm/@oslojs+binary@1.0.0/node_modules/@oslojs/binary/dist/big.js"() {
  }
});
var init_dist2 = __esm({
  "node_modules/.pnpm/@oslojs+binary@1.0.0/node_modules/@oslojs/binary/dist/index.js"() {
    init_uint();
    init_bytes();
    init_bits();
    init_big();
  }
});
var K;
var init_sha224 = __esm({
  "node_modules/.pnpm/@oslojs+crypto@1.0.1/node_modules/@oslojs/crypto/dist/sha2/sha224.js"() {
    init_dist2();
    init_dist2();
    K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
  }
});
function sha256(data) {
  const hash2 = new SHA256();
  hash2.update(data);
  return hash2.digest();
}
__name(sha256, "sha256");
var SHA256;
var K2;
var init_sha256 = __esm({
  "node_modules/.pnpm/@oslojs+crypto@1.0.1/node_modules/@oslojs/crypto/dist/sha2/sha256.js"() {
    init_dist2();
    init_dist2();
    SHA256 = /* @__PURE__ */ __name(class {
      blockSize = 64;
      size = 32;
      blocks = new Uint8Array(64);
      currentBlockSize = 0;
      H = new Uint32Array([
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ]);
      l = 0n;
      w = new Uint32Array(64);
      update(data) {
        this.l += BigInt(data.byteLength) * 8n;
        if (this.currentBlockSize + data.byteLength < 64) {
          this.blocks.set(data, this.currentBlockSize);
          this.currentBlockSize += data.byteLength;
          return;
        }
        let processed = 0;
        if (this.currentBlockSize > 0) {
          const next2 = data.slice(0, 64 - this.currentBlockSize);
          this.blocks.set(next2, this.currentBlockSize);
          this.process();
          processed += next2.byteLength;
          this.currentBlockSize = 0;
        }
        while (processed + 64 <= data.byteLength) {
          const next2 = data.slice(processed, processed + 64);
          this.blocks.set(next2);
          this.process();
          processed += 64;
        }
        if (data.byteLength - processed > 0) {
          const remaining = data.slice(processed);
          this.blocks.set(remaining);
          this.currentBlockSize = remaining.byteLength;
        }
      }
      digest() {
        this.blocks[this.currentBlockSize] = 128;
        this.currentBlockSize += 1;
        if (64 - this.currentBlockSize < 8) {
          this.blocks.fill(0, this.currentBlockSize);
          this.process();
          this.currentBlockSize = 0;
        }
        this.blocks.fill(0, this.currentBlockSize);
        bigEndian.putUint64(this.blocks, this.l, this.blockSize - 8);
        this.process();
        const result = new Uint8Array(32);
        for (let i2 = 0; i2 < 8; i2++) {
          bigEndian.putUint32(result, this.H[i2], i2 * 4);
        }
        return result;
      }
      process() {
        for (let t2 = 0; t2 < 16; t2++) {
          this.w[t2] = (this.blocks[t2 * 4] << 24 | this.blocks[t2 * 4 + 1] << 16 | this.blocks[t2 * 4 + 2] << 8 | this.blocks[t2 * 4 + 3]) >>> 0;
        }
        for (let t2 = 16; t2 < 64; t2++) {
          const sigma1 = (rotr32(this.w[t2 - 2], 17) ^ rotr32(this.w[t2 - 2], 19) ^ this.w[t2 - 2] >>> 10) >>> 0;
          const sigma0 = (rotr32(this.w[t2 - 15], 7) ^ rotr32(this.w[t2 - 15], 18) ^ this.w[t2 - 15] >>> 3) >>> 0;
          this.w[t2] = sigma1 + this.w[t2 - 7] + sigma0 + this.w[t2 - 16] | 0;
        }
        let a2 = this.H[0];
        let b = this.H[1];
        let c2 = this.H[2];
        let d = this.H[3];
        let e3 = this.H[4];
        let f = this.H[5];
        let g2 = this.H[6];
        let h = this.H[7];
        for (let t2 = 0; t2 < 64; t2++) {
          const sigma1 = (rotr32(e3, 6) ^ rotr32(e3, 11) ^ rotr32(e3, 25)) >>> 0;
          const ch = (e3 & f ^ ~e3 & g2) >>> 0;
          const t1 = h + sigma1 + ch + K2[t2] + this.w[t2] | 0;
          const sigma0 = (rotr32(a2, 2) ^ rotr32(a2, 13) ^ rotr32(a2, 22)) >>> 0;
          const maj = (a2 & b ^ a2 & c2 ^ b & c2) >>> 0;
          const t22 = sigma0 + maj | 0;
          h = g2;
          g2 = f;
          f = e3;
          e3 = d + t1 | 0;
          d = c2;
          c2 = b;
          b = a2;
          a2 = t1 + t22 | 0;
        }
        this.H[0] = a2 + this.H[0] | 0;
        this.H[1] = b + this.H[1] | 0;
        this.H[2] = c2 + this.H[2] | 0;
        this.H[3] = d + this.H[3] | 0;
        this.H[4] = e3 + this.H[4] | 0;
        this.H[5] = f + this.H[5] | 0;
        this.H[6] = g2 + this.H[6] | 0;
        this.H[7] = h + this.H[7] | 0;
      }
    }, "SHA256");
    K2 = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
  }
});
var K3;
var init_sha512 = __esm({
  "node_modules/.pnpm/@oslojs+crypto@1.0.1/node_modules/@oslojs/crypto/dist/sha2/sha512.js"() {
    init_dist2();
    init_dist2();
    K3 = new BigUint64Array([
      0x428a2f98d728ae22n,
      0x7137449123ef65cdn,
      0xb5c0fbcfec4d3b2fn,
      0xe9b5dba58189dbbcn,
      0x3956c25bf348b538n,
      0x59f111f1b605d019n,
      0x923f82a4af194f9bn,
      0xab1c5ed5da6d8118n,
      0xd807aa98a3030242n,
      0x12835b0145706fben,
      0x243185be4ee4b28cn,
      0x550c7dc3d5ffb4e2n,
      0x72be5d74f27b896fn,
      0x80deb1fe3b1696b1n,
      0x9bdc06a725c71235n,
      0xc19bf174cf692694n,
      0xe49b69c19ef14ad2n,
      0xefbe4786384f25e3n,
      0x0fc19dc68b8cd5b5n,
      0x240ca1cc77ac9c65n,
      0x2de92c6f592b0275n,
      0x4a7484aa6ea6e483n,
      0x5cb0a9dcbd41fbd4n,
      0x76f988da831153b5n,
      0x983e5152ee66dfabn,
      0xa831c66d2db43210n,
      0xb00327c898fb213fn,
      0xbf597fc7beef0ee4n,
      0xc6e00bf33da88fc2n,
      0xd5a79147930aa725n,
      0x06ca6351e003826fn,
      0x142929670a0e6e70n,
      0x27b70a8546d22ffcn,
      0x2e1b21385c26c926n,
      0x4d2c6dfc5ac42aedn,
      0x53380d139d95b3dfn,
      0x650a73548baf63den,
      0x766a0abb3c77b2a8n,
      0x81c2c92e47edaee6n,
      0x92722c851482353bn,
      0xa2bfe8a14cf10364n,
      0xa81a664bbc423001n,
      0xc24b8b70d0f89791n,
      0xc76c51a30654be30n,
      0xd192e819d6ef5218n,
      0xd69906245565a910n,
      0xf40e35855771202an,
      0x106aa07032bbd1b8n,
      0x19a4c116b8d2d0c8n,
      0x1e376c085141ab53n,
      0x2748774cdf8eeb99n,
      0x34b0bcb5e19b48a8n,
      0x391c0cb3c5c95a63n,
      0x4ed8aa4ae3418acbn,
      0x5b9cca4f7763e373n,
      0x682e6ff3d6b2b8a3n,
      0x748f82ee5defb2fcn,
      0x78a5636f43172f60n,
      0x84c87814a1f0ab72n,
      0x8cc702081a6439ecn,
      0x90befffa23631e28n,
      0xa4506cebde82bde9n,
      0xbef9a3f7b2c67915n,
      0xc67178f2e372532bn,
      0xca273eceea26619cn,
      0xd186b8c721c0c207n,
      0xeada7dd6cde0eb1en,
      0xf57d4f7fee6ed178n,
      0x06f067aa72176fban,
      0x0a637dc5a2c898a6n,
      0x113f9804bef90daen,
      0x1b710b35131c471bn,
      0x28db77f523047d84n,
      0x32caab7b40c72493n,
      0x3c9ebe0a15c9bebcn,
      0x431d67c49c100d4cn,
      0x4cc5d4becb3e42b6n,
      0x597f299cfc657e2an,
      0x5fcb6fab3ad6faecn,
      0x6c44198c4a475817n
    ]);
  }
});
var init_sha384 = __esm({
  "node_modules/.pnpm/@oslojs+crypto@1.0.1/node_modules/@oslojs/crypto/dist/sha2/sha384.js"() {
    init_sha512();
  }
});
var init_sha512_224 = __esm({
  "node_modules/.pnpm/@oslojs+crypto@1.0.1/node_modules/@oslojs/crypto/dist/sha2/sha512_224.js"() {
    init_sha512();
  }
});
var init_sha512_256 = __esm({
  "node_modules/.pnpm/@oslojs+crypto@1.0.1/node_modules/@oslojs/crypto/dist/sha2/sha512_256.js"() {
    init_sha512();
  }
});
var init_sha2 = __esm({
  "node_modules/.pnpm/@oslojs+crypto@1.0.1/node_modules/@oslojs/crypto/dist/sha2/index.js"() {
    init_sha224();
    init_sha256();
    init_sha384();
    init_sha512();
    init_sha512_224();
    init_sha512_256();
  }
});
var init_alias2 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/alias.js"() {
  }
});
var CheckBuilder;
var Check;
var init_checks = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/checks.js"() {
    init_entity();
    CheckBuilder = /* @__PURE__ */ __name(class {
      constructor(name3, value) {
        this.name = name3;
        this.value = value;
      }
      static [entityKind] = "SQLiteCheckBuilder";
      brand;
      build(table) {
        return new Check(table, this);
      }
    }, "CheckBuilder");
    Check = /* @__PURE__ */ __name(class {
      constructor(table, builder) {
        this.table = table;
        this.name = builder.name;
        this.value = builder.value;
      }
      static [entityKind] = "SQLiteCheck";
      name;
      value;
    }, "Check");
  }
});
var ForeignKeyBuilder2;
var ForeignKey2;
var init_foreign_keys2 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/foreign-keys.js"() {
    init_entity();
    init_table_utils();
    ForeignKeyBuilder2 = /* @__PURE__ */ __name(class {
      static [entityKind] = "SQLiteForeignKeyBuilder";
      /** @internal */
      reference;
      /** @internal */
      _onUpdate;
      /** @internal */
      _onDelete;
      constructor(config, actions4) {
        this.reference = () => {
          const { name: name3, columns, foreignColumns } = config();
          return { name: name3, columns, foreignTable: foreignColumns[0].table, foreignColumns };
        };
        if (actions4) {
          this._onUpdate = actions4.onUpdate;
          this._onDelete = actions4.onDelete;
        }
      }
      onUpdate(action) {
        this._onUpdate = action;
        return this;
      }
      onDelete(action) {
        this._onDelete = action;
        return this;
      }
      /** @internal */
      build(table) {
        return new ForeignKey2(table, this);
      }
    }, "ForeignKeyBuilder2");
    ForeignKey2 = /* @__PURE__ */ __name(class {
      constructor(table, builder) {
        this.table = table;
        this.reference = builder.reference;
        this.onUpdate = builder._onUpdate;
        this.onDelete = builder._onDelete;
      }
      static [entityKind] = "SQLiteForeignKey";
      reference;
      onUpdate;
      onDelete;
      getName() {
        const { name: name3, columns, foreignColumns } = this.reference();
        const columnNames = columns.map((column) => column.name);
        const foreignColumnNames = foreignColumns.map((column) => column.name);
        const chunks = [
          this.table[TableName],
          ...columnNames,
          foreignColumns[0].table[TableName],
          ...foreignColumnNames
        ];
        return name3 ?? `${chunks.join("_")}_fk`;
      }
    }, "ForeignKey2");
  }
});
function uniqueKeyName2(table, columns) {
  return `${table[TableName]}_${columns.join("_")}_unique`;
}
__name(uniqueKeyName2, "uniqueKeyName2");
var UniqueConstraintBuilder2;
var UniqueOnConstraintBuilder2;
var UniqueConstraint2;
var init_unique_constraint2 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/unique-constraint.js"() {
    init_entity();
    init_table_utils();
    UniqueConstraintBuilder2 = /* @__PURE__ */ __name(class {
      constructor(columns, name3) {
        this.name = name3;
        this.columns = columns;
      }
      static [entityKind] = "SQLiteUniqueConstraintBuilder";
      /** @internal */
      columns;
      /** @internal */
      build(table) {
        return new UniqueConstraint2(table, this.columns, this.name);
      }
    }, "UniqueConstraintBuilder2");
    UniqueOnConstraintBuilder2 = /* @__PURE__ */ __name(class {
      static [entityKind] = "SQLiteUniqueOnConstraintBuilder";
      /** @internal */
      name;
      constructor(name3) {
        this.name = name3;
      }
      on(...columns) {
        return new UniqueConstraintBuilder2(columns, this.name);
      }
    }, "UniqueOnConstraintBuilder2");
    UniqueConstraint2 = /* @__PURE__ */ __name(class {
      constructor(table, columns, name3) {
        this.table = table;
        this.columns = columns;
        this.name = name3 ?? uniqueKeyName2(this.table, this.columns.map((column) => column.name));
      }
      static [entityKind] = "SQLiteUniqueConstraint";
      columns;
      name;
      getName() {
        return this.name;
      }
    }, "UniqueConstraint2");
  }
});
var SQLiteColumnBuilder;
var SQLiteColumn;
var init_common2 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/columns/common.js"() {
    init_column_builder();
    init_column();
    init_entity();
    init_foreign_keys2();
    init_unique_constraint2();
    SQLiteColumnBuilder = /* @__PURE__ */ __name(class extends ColumnBuilder {
      static [entityKind] = "SQLiteColumnBuilder";
      foreignKeyConfigs = [];
      references(ref, actions4 = {}) {
        this.foreignKeyConfigs.push({ ref, actions: actions4 });
        return this;
      }
      unique(name3) {
        this.config.isUnique = true;
        this.config.uniqueName = name3;
        return this;
      }
      generatedAlwaysAs(as, config) {
        this.config.generated = {
          as,
          type: "always",
          mode: config?.mode ?? "virtual"
        };
        return this;
      }
      /** @internal */
      buildForeignKeys(column, table) {
        return this.foreignKeyConfigs.map(({ ref, actions: actions4 }) => {
          return ((ref2, actions22) => {
            const builder = new ForeignKeyBuilder2(() => {
              const foreignColumn = ref2();
              return { columns: [column], foreignColumns: [foreignColumn] };
            });
            if (actions22.onUpdate) {
              builder.onUpdate(actions22.onUpdate);
            }
            if (actions22.onDelete) {
              builder.onDelete(actions22.onDelete);
            }
            return builder.build(table);
          })(ref, actions4);
        });
      }
    }, "SQLiteColumnBuilder");
    SQLiteColumn = /* @__PURE__ */ __name(class extends Column {
      constructor(table, config) {
        if (!config.uniqueName) {
          config.uniqueName = uniqueKeyName2(table, [config.name]);
        }
        super(table, config);
        this.table = table;
      }
      static [entityKind] = "SQLiteColumn";
    }, "SQLiteColumn");
  }
});
function blob(a2, b) {
  const { name: name3, config } = getColumnNameAndConfig(a2, b);
  if (config?.mode === "json") {
    return new SQLiteBlobJsonBuilder(name3);
  }
  if (config?.mode === "bigint") {
    return new SQLiteBigIntBuilder(name3);
  }
  return new SQLiteBlobBufferBuilder(name3);
}
__name(blob, "blob");
var SQLiteBigIntBuilder;
var SQLiteBigInt;
var SQLiteBlobJsonBuilder;
var SQLiteBlobJson;
var SQLiteBlobBufferBuilder;
var SQLiteBlobBuffer;
var init_blob = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/columns/blob.js"() {
    init_entity();
    init_utils();
    init_common2();
    SQLiteBigIntBuilder = /* @__PURE__ */ __name(class extends SQLiteColumnBuilder {
      static [entityKind] = "SQLiteBigIntBuilder";
      constructor(name3) {
        super(name3, "bigint", "SQLiteBigInt");
      }
      /** @internal */
      build(table) {
        return new SQLiteBigInt(table, this.config);
      }
    }, "SQLiteBigIntBuilder");
    SQLiteBigInt = /* @__PURE__ */ __name(class extends SQLiteColumn {
      static [entityKind] = "SQLiteBigInt";
      getSQLType() {
        return "blob";
      }
      mapFromDriverValue(value) {
        return BigInt(value.toString());
      }
      mapToDriverValue(value) {
        return Buffer.from(value.toString());
      }
    }, "SQLiteBigInt");
    SQLiteBlobJsonBuilder = /* @__PURE__ */ __name(class extends SQLiteColumnBuilder {
      static [entityKind] = "SQLiteBlobJsonBuilder";
      constructor(name3) {
        super(name3, "json", "SQLiteBlobJson");
      }
      /** @internal */
      build(table) {
        return new SQLiteBlobJson(
          table,
          this.config
        );
      }
    }, "SQLiteBlobJsonBuilder");
    SQLiteBlobJson = /* @__PURE__ */ __name(class extends SQLiteColumn {
      static [entityKind] = "SQLiteBlobJson";
      getSQLType() {
        return "blob";
      }
      mapFromDriverValue(value) {
        return JSON.parse(value.toString());
      }
      mapToDriverValue(value) {
        return Buffer.from(JSON.stringify(value));
      }
    }, "SQLiteBlobJson");
    SQLiteBlobBufferBuilder = /* @__PURE__ */ __name(class extends SQLiteColumnBuilder {
      static [entityKind] = "SQLiteBlobBufferBuilder";
      constructor(name3) {
        super(name3, "buffer", "SQLiteBlobBuffer");
      }
      /** @internal */
      build(table) {
        return new SQLiteBlobBuffer(table, this.config);
      }
    }, "SQLiteBlobBufferBuilder");
    SQLiteBlobBuffer = /* @__PURE__ */ __name(class extends SQLiteColumn {
      static [entityKind] = "SQLiteBlobBuffer";
      getSQLType() {
        return "blob";
      }
    }, "SQLiteBlobBuffer");
  }
});
function customType(customTypeParams) {
  return (a2, b) => {
    const { name: name3, config } = getColumnNameAndConfig(a2, b);
    return new SQLiteCustomColumnBuilder(
      name3,
      config,
      customTypeParams
    );
  };
}
__name(customType, "customType");
var SQLiteCustomColumnBuilder;
var SQLiteCustomColumn;
var init_custom = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/columns/custom.js"() {
    init_entity();
    init_utils();
    init_common2();
    SQLiteCustomColumnBuilder = /* @__PURE__ */ __name(class extends SQLiteColumnBuilder {
      static [entityKind] = "SQLiteCustomColumnBuilder";
      constructor(name3, fieldConfig, customTypeParams) {
        super(name3, "custom", "SQLiteCustomColumn");
        this.config.fieldConfig = fieldConfig;
        this.config.customTypeParams = customTypeParams;
      }
      /** @internal */
      build(table) {
        return new SQLiteCustomColumn(
          table,
          this.config
        );
      }
    }, "SQLiteCustomColumnBuilder");
    SQLiteCustomColumn = /* @__PURE__ */ __name(class extends SQLiteColumn {
      static [entityKind] = "SQLiteCustomColumn";
      sqlName;
      mapTo;
      mapFrom;
      constructor(table, config) {
        super(table, config);
        this.sqlName = config.customTypeParams.dataType(config.fieldConfig);
        this.mapTo = config.customTypeParams.toDriver;
        this.mapFrom = config.customTypeParams.fromDriver;
      }
      getSQLType() {
        return this.sqlName;
      }
      mapFromDriverValue(value) {
        return typeof this.mapFrom === "function" ? this.mapFrom(value) : value;
      }
      mapToDriverValue(value) {
        return typeof this.mapTo === "function" ? this.mapTo(value) : value;
      }
    }, "SQLiteCustomColumn");
  }
});
function integer(a2, b) {
  const { name: name3, config } = getColumnNameAndConfig(a2, b);
  if (config?.mode === "timestamp" || config?.mode === "timestamp_ms") {
    return new SQLiteTimestampBuilder(name3, config.mode);
  }
  if (config?.mode === "boolean") {
    return new SQLiteBooleanBuilder(name3, config.mode);
  }
  return new SQLiteIntegerBuilder(name3);
}
__name(integer, "integer");
var SQLiteBaseIntegerBuilder;
var SQLiteBaseInteger;
var SQLiteIntegerBuilder;
var SQLiteInteger;
var SQLiteTimestampBuilder;
var SQLiteTimestamp;
var SQLiteBooleanBuilder;
var SQLiteBoolean;
var init_integer = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/columns/integer.js"() {
    init_entity();
    init_sql();
    init_utils();
    init_common2();
    SQLiteBaseIntegerBuilder = /* @__PURE__ */ __name(class extends SQLiteColumnBuilder {
      static [entityKind] = "SQLiteBaseIntegerBuilder";
      constructor(name3, dataType, columnType) {
        super(name3, dataType, columnType);
        this.config.autoIncrement = false;
      }
      primaryKey(config) {
        if (config?.autoIncrement) {
          this.config.autoIncrement = true;
        }
        this.config.hasDefault = true;
        return super.primaryKey();
      }
    }, "SQLiteBaseIntegerBuilder");
    SQLiteBaseInteger = /* @__PURE__ */ __name(class extends SQLiteColumn {
      static [entityKind] = "SQLiteBaseInteger";
      autoIncrement = this.config.autoIncrement;
      getSQLType() {
        return "integer";
      }
    }, "SQLiteBaseInteger");
    SQLiteIntegerBuilder = /* @__PURE__ */ __name(class extends SQLiteBaseIntegerBuilder {
      static [entityKind] = "SQLiteIntegerBuilder";
      constructor(name3) {
        super(name3, "number", "SQLiteInteger");
      }
      build(table) {
        return new SQLiteInteger(
          table,
          this.config
        );
      }
    }, "SQLiteIntegerBuilder");
    SQLiteInteger = /* @__PURE__ */ __name(class extends SQLiteBaseInteger {
      static [entityKind] = "SQLiteInteger";
    }, "SQLiteInteger");
    SQLiteTimestampBuilder = /* @__PURE__ */ __name(class extends SQLiteBaseIntegerBuilder {
      static [entityKind] = "SQLiteTimestampBuilder";
      constructor(name3, mode) {
        super(name3, "date", "SQLiteTimestamp");
        this.config.mode = mode;
      }
      /**
       * @deprecated Use `default()` with your own expression instead.
       *
       * Adds `DEFAULT (cast((julianday('now') - 2440587.5)*86400000 as integer))` to the column, which is the current epoch timestamp in milliseconds.
       */
      defaultNow() {
        return this.default(sql`(cast((julianday('now') - 2440587.5)*86400000 as integer))`);
      }
      build(table) {
        return new SQLiteTimestamp(
          table,
          this.config
        );
      }
    }, "SQLiteTimestampBuilder");
    SQLiteTimestamp = /* @__PURE__ */ __name(class extends SQLiteBaseInteger {
      static [entityKind] = "SQLiteTimestamp";
      mode = this.config.mode;
      mapFromDriverValue(value) {
        if (this.config.mode === "timestamp") {
          return new Date(value * 1e3);
        }
        return new Date(value);
      }
      mapToDriverValue(value) {
        const unix = value.getTime();
        if (this.config.mode === "timestamp") {
          return Math.floor(unix / 1e3);
        }
        return unix;
      }
    }, "SQLiteTimestamp");
    SQLiteBooleanBuilder = /* @__PURE__ */ __name(class extends SQLiteBaseIntegerBuilder {
      static [entityKind] = "SQLiteBooleanBuilder";
      constructor(name3, mode) {
        super(name3, "boolean", "SQLiteBoolean");
        this.config.mode = mode;
      }
      build(table) {
        return new SQLiteBoolean(
          table,
          this.config
        );
      }
    }, "SQLiteBooleanBuilder");
    SQLiteBoolean = /* @__PURE__ */ __name(class extends SQLiteBaseInteger {
      static [entityKind] = "SQLiteBoolean";
      mode = this.config.mode;
      mapFromDriverValue(value) {
        return Number(value) === 1;
      }
      mapToDriverValue(value) {
        return value ? 1 : 0;
      }
    }, "SQLiteBoolean");
  }
});
function numeric(name3) {
  return new SQLiteNumericBuilder(name3 ?? "");
}
__name(numeric, "numeric");
var SQLiteNumericBuilder;
var SQLiteNumeric;
var init_numeric = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/columns/numeric.js"() {
    init_entity();
    init_common2();
    SQLiteNumericBuilder = /* @__PURE__ */ __name(class extends SQLiteColumnBuilder {
      static [entityKind] = "SQLiteNumericBuilder";
      constructor(name3) {
        super(name3, "string", "SQLiteNumeric");
      }
      /** @internal */
      build(table) {
        return new SQLiteNumeric(
          table,
          this.config
        );
      }
    }, "SQLiteNumericBuilder");
    SQLiteNumeric = /* @__PURE__ */ __name(class extends SQLiteColumn {
      static [entityKind] = "SQLiteNumeric";
      getSQLType() {
        return "numeric";
      }
    }, "SQLiteNumeric");
  }
});
function real(name3) {
  return new SQLiteRealBuilder(name3 ?? "");
}
__name(real, "real");
var SQLiteRealBuilder;
var SQLiteReal;
var init_real = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/columns/real.js"() {
    init_entity();
    init_common2();
    SQLiteRealBuilder = /* @__PURE__ */ __name(class extends SQLiteColumnBuilder {
      static [entityKind] = "SQLiteRealBuilder";
      constructor(name3) {
        super(name3, "number", "SQLiteReal");
      }
      /** @internal */
      build(table) {
        return new SQLiteReal(table, this.config);
      }
    }, "SQLiteRealBuilder");
    SQLiteReal = /* @__PURE__ */ __name(class extends SQLiteColumn {
      static [entityKind] = "SQLiteReal";
      getSQLType() {
        return "real";
      }
    }, "SQLiteReal");
  }
});
function text(a2, b = {}) {
  const { name: name3, config } = getColumnNameAndConfig(a2, b);
  if (config.mode === "json") {
    return new SQLiteTextJsonBuilder(name3);
  }
  return new SQLiteTextBuilder(name3, config);
}
__name(text, "text");
var SQLiteTextBuilder;
var SQLiteText;
var SQLiteTextJsonBuilder;
var SQLiteTextJson;
var init_text = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/columns/text.js"() {
    init_entity();
    init_utils();
    init_common2();
    SQLiteTextBuilder = /* @__PURE__ */ __name(class extends SQLiteColumnBuilder {
      static [entityKind] = "SQLiteTextBuilder";
      constructor(name3, config) {
        super(name3, "string", "SQLiteText");
        this.config.enumValues = config.enum;
        this.config.length = config.length;
      }
      /** @internal */
      build(table) {
        return new SQLiteText(table, this.config);
      }
    }, "SQLiteTextBuilder");
    SQLiteText = /* @__PURE__ */ __name(class extends SQLiteColumn {
      static [entityKind] = "SQLiteText";
      enumValues = this.config.enumValues;
      length = this.config.length;
      constructor(table, config) {
        super(table, config);
      }
      getSQLType() {
        return `text${this.config.length ? `(${this.config.length})` : ""}`;
      }
    }, "SQLiteText");
    SQLiteTextJsonBuilder = /* @__PURE__ */ __name(class extends SQLiteColumnBuilder {
      static [entityKind] = "SQLiteTextJsonBuilder";
      constructor(name3) {
        super(name3, "json", "SQLiteTextJson");
      }
      /** @internal */
      build(table) {
        return new SQLiteTextJson(
          table,
          this.config
        );
      }
    }, "SQLiteTextJsonBuilder");
    SQLiteTextJson = /* @__PURE__ */ __name(class extends SQLiteColumn {
      static [entityKind] = "SQLiteTextJson";
      getSQLType() {
        return "text";
      }
      mapFromDriverValue(value) {
        return JSON.parse(value);
      }
      mapToDriverValue(value) {
        return JSON.stringify(value);
      }
    }, "SQLiteTextJson");
  }
});
var init_columns = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/columns/index.js"() {
    init_blob();
    init_common2();
    init_custom();
    init_integer();
    init_numeric();
    init_real();
    init_text();
  }
});
var SelectionProxyHandler;
var init_selection_proxy = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/selection-proxy.js"() {
    init_alias();
    init_column();
    init_entity();
    init_sql();
    init_subquery();
    init_view_common();
    SelectionProxyHandler = /* @__PURE__ */ __name(class _SelectionProxyHandler {
      static [entityKind] = "SelectionProxyHandler";
      config;
      constructor(config) {
        this.config = { ...config };
      }
      get(subquery, prop) {
        if (prop === "_") {
          return {
            ...subquery["_"],
            selectedFields: new Proxy(
              subquery._.selectedFields,
              this
            )
          };
        }
        if (prop === ViewBaseConfig) {
          return {
            ...subquery[ViewBaseConfig],
            selectedFields: new Proxy(
              subquery[ViewBaseConfig].selectedFields,
              this
            )
          };
        }
        if (typeof prop === "symbol") {
          return subquery[prop];
        }
        const columns = is(subquery, Subquery) ? subquery._.selectedFields : is(subquery, View) ? subquery[ViewBaseConfig].selectedFields : subquery;
        const value = columns[prop];
        if (is(value, SQL.Aliased)) {
          if (this.config.sqlAliasedBehavior === "sql" && !value.isSelectionField) {
            return value.sql;
          }
          const newValue = value.clone();
          newValue.isSelectionField = true;
          return newValue;
        }
        if (is(value, SQL)) {
          if (this.config.sqlBehavior === "sql") {
            return value;
          }
          throw new Error(
            `You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`
          );
        }
        if (is(value, Column)) {
          if (this.config.alias) {
            return new Proxy(
              value,
              new ColumnAliasProxyHandler(
                new Proxy(
                  value.table,
                  new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false)
                )
              )
            );
          }
          return value;
        }
        if (typeof value !== "object" || value === null) {
          return value;
        }
        return new Proxy(value, new _SelectionProxyHandler(this.config));
      }
    }, "_SelectionProxyHandler");
  }
});
function getSQLiteColumnBuilders() {
  return {
    blob,
    customType,
    integer,
    numeric,
    real,
    text
  };
}
__name(getSQLiteColumnBuilders, "getSQLiteColumnBuilders");
var init_all = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/columns/all.js"() {
    init_blob();
    init_custom();
    init_integer();
    init_numeric();
    init_real();
    init_text();
  }
});
function sqliteTableBase(name3, columns, extraConfig, schema2, baseName = name3) {
  const rawTable = new SQLiteTable(name3, schema2, baseName);
  const parsedColumns = typeof columns === "function" ? columns(getSQLiteColumnBuilders()) : columns;
  const builtColumns = Object.fromEntries(
    Object.entries(parsedColumns).map(([name22, colBuilderBase]) => {
      const colBuilder = colBuilderBase;
      colBuilder.setName(name22);
      const column = colBuilder.build(rawTable);
      rawTable[InlineForeignKeys2].push(...colBuilder.buildForeignKeys(column, rawTable));
      return [name22, column];
    })
  );
  const table = Object.assign(rawTable, builtColumns);
  table[Table.Symbol.Columns] = builtColumns;
  table[Table.Symbol.ExtraConfigColumns] = builtColumns;
  if (extraConfig) {
    table[SQLiteTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return table;
}
__name(sqliteTableBase, "sqliteTableBase");
var InlineForeignKeys2;
var SQLiteTable;
var sqliteTable;
var init_table3 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/table.js"() {
    init_entity();
    init_table();
    init_all();
    InlineForeignKeys2 = Symbol.for("drizzle:SQLiteInlineForeignKeys");
    SQLiteTable = /* @__PURE__ */ __name(class extends Table {
      static [entityKind] = "SQLiteTable";
      /** @internal */
      static Symbol = Object.assign({}, Table.Symbol, {
        InlineForeignKeys: InlineForeignKeys2
      });
      /** @internal */
      [Table.Symbol.Columns];
      /** @internal */
      [InlineForeignKeys2] = [];
      /** @internal */
      [Table.Symbol.ExtraConfigBuilder] = void 0;
    }, "SQLiteTable");
    sqliteTable = /* @__PURE__ */ __name((name3, columns, extraConfig) => {
      return sqliteTableBase(name3, columns, extraConfig);
    }, "sqliteTable");
  }
});
var SQLiteDeleteBase;
var init_delete = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/query-builders/delete.js"() {
    init_entity();
    init_query_promise();
    init_table3();
    init_utils();
    SQLiteDeleteBase = /* @__PURE__ */ __name(class extends QueryPromise {
      constructor(table, session, dialect, withList) {
        super();
        this.table = table;
        this.session = session;
        this.dialect = dialect;
        this.config = { table, withList };
      }
      static [entityKind] = "SQLiteDelete";
      /** @internal */
      config;
      /**
       * Adds a `where` clause to the query.
       *
       * Calling this method will delete only those rows that fulfill a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/delete}
       *
       * @param where the `where` clause.
       *
       * @example
       * You can use conditional operators and `sql function` to filter the rows to be deleted.
       *
       * ```ts
       * // Delete all cars with green color
       * db.delete(cars).where(eq(cars.color, 'green'));
       * // or
       * db.delete(cars).where(sql`${cars.color} = 'green'`)
       * ```
       *
       * You can logically combine conditional operators with `and()` and `or()` operators:
       *
       * ```ts
       * // Delete all BMW cars with a green color
       * db.delete(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
       *
       * // Delete all cars with the green or blue color
       * db.delete(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
       * ```
       */
      where(where) {
        this.config.where = where;
        return this;
      }
      returning(fields = this.table[SQLiteTable.Symbol.Columns]) {
        this.config.returning = orderSelectedFields(fields);
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildDeleteQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      /** @internal */
      _prepare(isOneTimeQuery = true) {
        return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
          this.dialect.sqlToQuery(this.getSQL()),
          this.config.returning,
          this.config.returning ? "all" : "run",
          true
        );
      }
      prepare() {
        return this._prepare(false);
      }
      run = (placeholderValues) => {
        return this._prepare().run(placeholderValues);
      };
      all = (placeholderValues) => {
        return this._prepare().all(placeholderValues);
      };
      get = (placeholderValues) => {
        return this._prepare().get(placeholderValues);
      };
      values = (placeholderValues) => {
        return this._prepare().values(placeholderValues);
      };
      async execute(placeholderValues) {
        return this._prepare().execute(placeholderValues);
      }
      $dynamic() {
        return this;
      }
    }, "SQLiteDeleteBase");
  }
});
var SQLiteInsertBuilder;
var SQLiteInsertBase;
var init_insert = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/query-builders/insert.js"() {
    init_entity();
    init_query_promise();
    init_sql();
    init_table3();
    init_table();
    init_utils();
    SQLiteInsertBuilder = /* @__PURE__ */ __name(class {
      constructor(table, session, dialect, withList) {
        this.table = table;
        this.session = session;
        this.dialect = dialect;
        this.withList = withList;
      }
      static [entityKind] = "SQLiteInsertBuilder";
      values(values) {
        values = Array.isArray(values) ? values : [values];
        if (values.length === 0) {
          throw new Error("values() must be called with at least one value");
        }
        const mappedValues = values.map((entry) => {
          const result = {};
          const cols = this.table[Table.Symbol.Columns];
          for (const colKey of Object.keys(entry)) {
            const colValue = entry[colKey];
            result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
          }
          return result;
        });
        return new SQLiteInsertBase(this.table, mappedValues, this.session, this.dialect, this.withList);
      }
    }, "SQLiteInsertBuilder");
    SQLiteInsertBase = /* @__PURE__ */ __name(class extends QueryPromise {
      constructor(table, values, session, dialect, withList) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.config = { table, values, withList };
      }
      static [entityKind] = "SQLiteInsert";
      /** @internal */
      config;
      returning(fields = this.config.table[SQLiteTable.Symbol.Columns]) {
        this.config.returning = orderSelectedFields(fields);
        return this;
      }
      /**
       * Adds an `on conflict do nothing` clause to the query.
       *
       * Calling this method simply avoids inserting a row as its alternative action.
       *
       * See docs: {@link https://orm.drizzle.team/docs/insert#on-conflict-do-nothing}
       *
       * @param config The `target` and `where` clauses.
       *
       * @example
       * ```ts
       * // Insert one row and cancel the insert if there's a conflict
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW' })
       *   .onConflictDoNothing();
       *
       * // Explicitly specify conflict target
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW' })
       *   .onConflictDoNothing({ target: cars.id });
       * ```
       */
      onConflictDoNothing(config = {}) {
        if (config.target === void 0) {
          this.config.onConflict = sql`do nothing`;
        } else {
          const targetSql = Array.isArray(config.target) ? sql`${config.target}` : sql`${[config.target]}`;
          const whereSql = config.where ? sql` where ${config.where}` : sql``;
          this.config.onConflict = sql`${targetSql} do nothing${whereSql}`;
        }
        return this;
      }
      /**
       * Adds an `on conflict do update` clause to the query.
       *
       * Calling this method will update the existing row that conflicts with the row proposed for insertion as its alternative action.
       *
       * See docs: {@link https://orm.drizzle.team/docs/insert#upserts-and-conflicts}
       *
       * @param config The `target`, `set` and `where` clauses.
       *
       * @example
       * ```ts
       * // Update the row if there's a conflict
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW' })
       *   .onConflictDoUpdate({
       *     target: cars.id,
       *     set: { brand: 'Porsche' }
       *   });
       *
       * // Upsert with 'where' clause
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW' })
       *   .onConflictDoUpdate({
       *     target: cars.id,
       *     set: { brand: 'newBMW' },
       *     where: sql`${cars.createdAt} > '2023-01-01'::date`,
       *   });
       * ```
       */
      onConflictDoUpdate(config) {
        if (config.where && (config.targetWhere || config.setWhere)) {
          throw new Error(
            'You cannot use both "where" and "targetWhere"/"setWhere" at the same time - "where" is deprecated, use "targetWhere" or "setWhere" instead.'
          );
        }
        const whereSql = config.where ? sql` where ${config.where}` : void 0;
        const targetWhereSql = config.targetWhere ? sql` where ${config.targetWhere}` : void 0;
        const setWhereSql = config.setWhere ? sql` where ${config.setWhere}` : void 0;
        const targetSql = Array.isArray(config.target) ? sql`${config.target}` : sql`${[config.target]}`;
        const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config.set));
        this.config.onConflict = sql`${targetSql}${targetWhereSql} do update set ${setSql}${whereSql}${setWhereSql}`;
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildInsertQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      /** @internal */
      _prepare(isOneTimeQuery = true) {
        return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
          this.dialect.sqlToQuery(this.getSQL()),
          this.config.returning,
          this.config.returning ? "all" : "run",
          true
        );
      }
      prepare() {
        return this._prepare(false);
      }
      run = (placeholderValues) => {
        return this._prepare().run(placeholderValues);
      };
      all = (placeholderValues) => {
        return this._prepare().all(placeholderValues);
      };
      get = (placeholderValues) => {
        return this._prepare().get(placeholderValues);
      };
      values = (placeholderValues) => {
        return this._prepare().values(placeholderValues);
      };
      async execute() {
        return this.config.returning ? this.all() : this.run();
      }
      $dynamic() {
        return this;
      }
    }, "SQLiteInsertBase");
  }
});
function toSnakeCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.map((word) => word.toLowerCase()).join("_");
}
__name(toSnakeCase, "toSnakeCase");
function toCamelCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.reduce((acc, word, i2) => {
    const formattedWord = i2 === 0 ? word.toLowerCase() : `${word[0].toUpperCase()}${word.slice(1)}`;
    return acc + formattedWord;
  }, "");
}
__name(toCamelCase, "toCamelCase");
function noopCase(input) {
  return input;
}
__name(noopCase, "noopCase");
var CasingCache;
var init_casing = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/casing.js"() {
    init_entity();
    init_table();
    CasingCache = /* @__PURE__ */ __name(class {
      static [entityKind] = "CasingCache";
      /** @internal */
      cache = {};
      cachedTables = {};
      convert;
      constructor(casing) {
        this.convert = casing === "snake_case" ? toSnakeCase : casing === "camelCase" ? toCamelCase : noopCase;
      }
      getColumnCasing(column) {
        if (!column.keyAsName)
          return column.name;
        const schema2 = column.table[Table.Symbol.Schema] ?? "public";
        const tableName = column.table[Table.Symbol.OriginalName];
        const key2 = `${schema2}.${tableName}.${column.name}`;
        if (!this.cache[key2]) {
          this.cacheTable(column.table);
        }
        return this.cache[key2];
      }
      cacheTable(table) {
        const schema2 = table[Table.Symbol.Schema] ?? "public";
        const tableName = table[Table.Symbol.OriginalName];
        const tableKey = `${schema2}.${tableName}`;
        if (!this.cachedTables[tableKey]) {
          for (const column of Object.values(table[Table.Symbol.Columns])) {
            const columnKey = `${tableKey}.${column.name}`;
            this.cache[columnKey] = this.convert(column.name);
          }
          this.cachedTables[tableKey] = true;
        }
      }
      clearCache() {
        this.cache = {};
        this.cachedTables = {};
      }
    }, "CasingCache");
  }
});
var SQLiteViewBase;
var init_view_base = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/view-base.js"() {
    init_entity();
    init_sql();
    SQLiteViewBase = /* @__PURE__ */ __name(class extends View {
      static [entityKind] = "SQLiteViewBase";
    }, "SQLiteViewBase");
  }
});
var SQLiteDialect;
var SQLiteSyncDialect;
var SQLiteAsyncDialect;
var init_dialect = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/dialect.js"() {
    init_alias();
    init_casing();
    init_column();
    init_entity();
    init_errors();
    init_relations();
    init_sql2();
    init_sql();
    init_columns();
    init_table3();
    init_subquery();
    init_table();
    init_utils();
    init_view_common();
    init_view_base();
    SQLiteDialect = /* @__PURE__ */ __name(class {
      static [entityKind] = "SQLiteDialect";
      /** @internal */
      casing;
      constructor(config) {
        this.casing = new CasingCache(config?.casing);
      }
      escapeName(name3) {
        return `"${name3}"`;
      }
      escapeParam(_num) {
        return "?";
      }
      escapeString(str) {
        return `'${str.replace(/'/g, "''")}'`;
      }
      buildWithCTE(queries) {
        if (!queries?.length)
          return void 0;
        const withSqlChunks = [sql`with `];
        for (const [i2, w] of queries.entries()) {
          withSqlChunks.push(sql`${sql.identifier(w._.alias)} as (${w._.sql})`);
          if (i2 < queries.length - 1) {
            withSqlChunks.push(sql`, `);
          }
        }
        withSqlChunks.push(sql` `);
        return sql.join(withSqlChunks);
      }
      buildDeleteQuery({ table, where, returning, withList }) {
        const withSql = this.buildWithCTE(withList);
        const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
        const whereSql = where ? sql` where ${where}` : void 0;
        return sql`${withSql}delete from ${table}${whereSql}${returningSql}`;
      }
      buildUpdateSet(table, set3) {
        const tableColumns = table[Table.Symbol.Columns];
        const columnNames = Object.keys(tableColumns).filter(
          (colName) => set3[colName] !== void 0 || tableColumns[colName]?.onUpdateFn !== void 0
        );
        const setSize = columnNames.length;
        return sql.join(columnNames.flatMap((colName, i2) => {
          const col = tableColumns[colName];
          const value = set3[colName] ?? sql.param(col.onUpdateFn(), col);
          const res = sql`${sql.identifier(this.casing.getColumnCasing(col))} = ${value}`;
          if (i2 < setSize - 1) {
            return [res, sql.raw(", ")];
          }
          return [res];
        }));
      }
      buildUpdateQuery({ table, set: set3, where, returning, withList }) {
        const withSql = this.buildWithCTE(withList);
        const setSql = this.buildUpdateSet(table, set3);
        const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
        const whereSql = where ? sql` where ${where}` : void 0;
        return sql`${withSql}update ${table} set ${setSql}${whereSql}${returningSql}`;
      }
      /**
       * Builds selection SQL with provided fields/expressions
       *
       * Examples:
       *
       * `select <selection> from`
       *
       * `insert ... returning <selection>`
       *
       * If `isSingleTable` is true, then columns won't be prefixed with table name
       */
      buildSelection(fields, { isSingleTable = false } = {}) {
        const columnsLen = fields.length;
        const chunks = fields.flatMap(({ field }, i2) => {
          const chunk = [];
          if (is(field, SQL.Aliased) && field.isSelectionField) {
            chunk.push(sql.identifier(field.fieldAlias));
          } else if (is(field, SQL.Aliased) || is(field, SQL)) {
            const query = is(field, SQL.Aliased) ? field.sql : field;
            if (isSingleTable) {
              chunk.push(
                new SQL(
                  query.queryChunks.map((c2) => {
                    if (is(c2, Column)) {
                      return sql.identifier(this.casing.getColumnCasing(c2));
                    }
                    return c2;
                  })
                )
              );
            } else {
              chunk.push(query);
            }
            if (is(field, SQL.Aliased)) {
              chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);
            }
          } else if (is(field, Column)) {
            const tableName = field.table[Table.Symbol.Name];
            if (isSingleTable) {
              chunk.push(sql.identifier(this.casing.getColumnCasing(field)));
            } else {
              chunk.push(sql`${sql.identifier(tableName)}.${sql.identifier(this.casing.getColumnCasing(field))}`);
            }
          }
          if (i2 < columnsLen - 1) {
            chunk.push(sql`, `);
          }
          return chunk;
        });
        return sql.join(chunks);
      }
      buildSelectQuery({
        withList,
        fields,
        fieldsFlat,
        where,
        having,
        table,
        joins,
        orderBy,
        groupBy,
        limit,
        offset: offset2,
        distinct,
        setOperators
      }) {
        const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
        for (const f of fieldsList) {
          if (is(f.field, Column) && getTableName(f.field.table) !== (is(table, Subquery) ? table._.alias : is(table, SQLiteViewBase) ? table[ViewBaseConfig].name : is(table, SQL) ? void 0 : getTableName(table)) && !((table2) => joins?.some(
            ({ alias }) => alias === (table2[Table.Symbol.IsAlias] ? getTableName(table2) : table2[Table.Symbol.BaseName])
          ))(f.field.table)) {
            const tableName = getTableName(f.field.table);
            throw new Error(
              `Your "${f.path.join("->")}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`
            );
          }
        }
        const isSingleTable = !joins || joins.length === 0;
        const withSql = this.buildWithCTE(withList);
        const distinctSql = distinct ? sql` distinct` : void 0;
        const selection = this.buildSelection(fieldsList, { isSingleTable });
        const tableSql = (() => {
          if (is(table, Table) && table[Table.Symbol.OriginalName] !== table[Table.Symbol.Name]) {
            return sql`${sql.identifier(table[Table.Symbol.OriginalName])} ${sql.identifier(table[Table.Symbol.Name])}`;
          }
          return table;
        })();
        const joinsArray = [];
        if (joins) {
          for (const [index39, joinMeta] of joins.entries()) {
            if (index39 === 0) {
              joinsArray.push(sql` `);
            }
            const table2 = joinMeta.table;
            if (is(table2, SQLiteTable)) {
              const tableName = table2[SQLiteTable.Symbol.Name];
              const tableSchema = table2[SQLiteTable.Symbol.Schema];
              const origTableName = table2[SQLiteTable.Symbol.OriginalName];
              const alias = tableName === origTableName ? void 0 : joinMeta.alias;
              joinsArray.push(
                sql`${sql.raw(joinMeta.joinType)} join ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : void 0}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`
              );
            } else {
              joinsArray.push(
                sql`${sql.raw(joinMeta.joinType)} join ${table2} on ${joinMeta.on}`
              );
            }
            if (index39 < joins.length - 1) {
              joinsArray.push(sql` `);
            }
          }
        }
        const joinsSql = sql.join(joinsArray);
        const whereSql = where ? sql` where ${where}` : void 0;
        const havingSql = having ? sql` having ${having}` : void 0;
        const orderByList = [];
        if (orderBy) {
          for (const [index39, orderByValue] of orderBy.entries()) {
            orderByList.push(orderByValue);
            if (index39 < orderBy.length - 1) {
              orderByList.push(sql`, `);
            }
          }
        }
        const groupByList = [];
        if (groupBy) {
          for (const [index39, groupByValue] of groupBy.entries()) {
            groupByList.push(groupByValue);
            if (index39 < groupBy.length - 1) {
              groupByList.push(sql`, `);
            }
          }
        }
        const groupBySql = groupByList.length > 0 ? sql` group by ${sql.join(groupByList)}` : void 0;
        const orderBySql = orderByList.length > 0 ? sql` order by ${sql.join(orderByList)}` : void 0;
        const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : void 0;
        const offsetSql = offset2 ? sql` offset ${offset2}` : void 0;
        const finalQuery = sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}`;
        if (setOperators.length > 0) {
          return this.buildSetOperations(finalQuery, setOperators);
        }
        return finalQuery;
      }
      buildSetOperations(leftSelect, setOperators) {
        const [setOperator, ...rest] = setOperators;
        if (!setOperator) {
          throw new Error("Cannot pass undefined values to any set operator");
        }
        if (rest.length === 0) {
          return this.buildSetOperationQuery({ leftSelect, setOperator });
        }
        return this.buildSetOperations(
          this.buildSetOperationQuery({ leftSelect, setOperator }),
          rest
        );
      }
      buildSetOperationQuery({
        leftSelect,
        setOperator: { type, isAll, rightSelect, limit, orderBy, offset: offset2 }
      }) {
        const leftChunk = sql`${leftSelect.getSQL()} `;
        const rightChunk = sql`${rightSelect.getSQL()}`;
        let orderBySql;
        if (orderBy && orderBy.length > 0) {
          const orderByValues = [];
          for (const singleOrderBy of orderBy) {
            if (is(singleOrderBy, SQLiteColumn)) {
              orderByValues.push(sql.identifier(singleOrderBy.name));
            } else if (is(singleOrderBy, SQL)) {
              for (let i2 = 0; i2 < singleOrderBy.queryChunks.length; i2++) {
                const chunk = singleOrderBy.queryChunks[i2];
                if (is(chunk, SQLiteColumn)) {
                  singleOrderBy.queryChunks[i2] = sql.identifier(this.casing.getColumnCasing(chunk));
                }
              }
              orderByValues.push(sql`${singleOrderBy}`);
            } else {
              orderByValues.push(sql`${singleOrderBy}`);
            }
          }
          orderBySql = sql` order by ${sql.join(orderByValues, sql`, `)}`;
        }
        const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : void 0;
        const operatorChunk = sql.raw(`${type} ${isAll ? "all " : ""}`);
        const offsetSql = offset2 ? sql` offset ${offset2}` : void 0;
        return sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;
      }
      buildInsertQuery({ table, values, onConflict, returning, withList }) {
        const valuesSqlList = [];
        const columns = table[Table.Symbol.Columns];
        const colEntries = Object.entries(columns).filter(
          ([_2, col]) => !col.shouldDisableInsert()
        );
        const insertOrder = colEntries.map(([, column]) => sql.identifier(this.casing.getColumnCasing(column)));
        for (const [valueIndex, value] of values.entries()) {
          const valueList = [];
          for (const [fieldName, col] of colEntries) {
            const colValue = value[fieldName];
            if (colValue === void 0 || is(colValue, Param) && colValue.value === void 0) {
              let defaultValue2;
              if (col.default !== null && col.default !== void 0) {
                defaultValue2 = is(col.default, SQL) ? col.default : sql.param(col.default, col);
              } else if (col.defaultFn !== void 0) {
                const defaultFnResult = col.defaultFn();
                defaultValue2 = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
              } else if (!col.default && col.onUpdateFn !== void 0) {
                const onUpdateFnResult = col.onUpdateFn();
                defaultValue2 = is(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col);
              } else {
                defaultValue2 = sql`null`;
              }
              valueList.push(defaultValue2);
            } else {
              valueList.push(colValue);
            }
          }
          valuesSqlList.push(valueList);
          if (valueIndex < values.length - 1) {
            valuesSqlList.push(sql`, `);
          }
        }
        const withSql = this.buildWithCTE(withList);
        const valuesSql = sql.join(valuesSqlList);
        const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
        const onConflictSql = onConflict ? sql` on conflict ${onConflict}` : void 0;
        return sql`${withSql}insert into ${table} ${insertOrder} values ${valuesSql}${onConflictSql}${returningSql}`;
      }
      sqlToQuery(sql2, invokeSource) {
        return sql2.toQuery({
          casing: this.casing,
          escapeName: this.escapeName,
          escapeParam: this.escapeParam,
          escapeString: this.escapeString,
          invokeSource
        });
      }
      buildRelationalQuery({
        fullSchema,
        schema: schema2,
        tableNamesMap,
        table,
        tableConfig,
        queryConfig: config,
        tableAlias,
        nestedQueryRelation,
        joinOn
      }) {
        let selection = [];
        let limit, offset2, orderBy = [], where;
        const joins = [];
        if (config === true) {
          const selectionEntries = Object.entries(tableConfig.columns);
          selection = selectionEntries.map(([key2, value]) => ({
            dbKey: value.name,
            tsKey: key2,
            field: aliasedTableColumn(value, tableAlias),
            relationTableTsKey: void 0,
            isJson: false,
            selection: []
          }));
        } else {
          const aliasedColumns = Object.fromEntries(
            Object.entries(tableConfig.columns).map(([key2, value]) => [key2, aliasedTableColumn(value, tableAlias)])
          );
          if (config.where) {
            const whereSql = typeof config.where === "function" ? config.where(aliasedColumns, getOperators()) : config.where;
            where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
          }
          const fieldsSelection = [];
          let selectedColumns = [];
          if (config.columns) {
            let isIncludeMode = false;
            for (const [field, value] of Object.entries(config.columns)) {
              if (value === void 0) {
                continue;
              }
              if (field in tableConfig.columns) {
                if (!isIncludeMode && value === true) {
                  isIncludeMode = true;
                }
                selectedColumns.push(field);
              }
            }
            if (selectedColumns.length > 0) {
              selectedColumns = isIncludeMode ? selectedColumns.filter((c2) => config.columns?.[c2] === true) : Object.keys(tableConfig.columns).filter((key2) => !selectedColumns.includes(key2));
            }
          } else {
            selectedColumns = Object.keys(tableConfig.columns);
          }
          for (const field of selectedColumns) {
            const column = tableConfig.columns[field];
            fieldsSelection.push({ tsKey: field, value: column });
          }
          let selectedRelations = [];
          if (config.with) {
            selectedRelations = Object.entries(config.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
          }
          let extras;
          if (config.extras) {
            extras = typeof config.extras === "function" ? config.extras(aliasedColumns, { sql }) : config.extras;
            for (const [tsKey, value] of Object.entries(extras)) {
              fieldsSelection.push({
                tsKey,
                value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
              });
            }
          }
          for (const { tsKey, value } of fieldsSelection) {
            selection.push({
              dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
              tsKey,
              field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
              relationTableTsKey: void 0,
              isJson: false,
              selection: []
            });
          }
          let orderByOrig = typeof config.orderBy === "function" ? config.orderBy(aliasedColumns, getOrderByOperators()) : config.orderBy ?? [];
          if (!Array.isArray(orderByOrig)) {
            orderByOrig = [orderByOrig];
          }
          orderBy = orderByOrig.map((orderByValue) => {
            if (is(orderByValue, Column)) {
              return aliasedTableColumn(orderByValue, tableAlias);
            }
            return mapColumnsInSQLToAlias(orderByValue, tableAlias);
          });
          limit = config.limit;
          offset2 = config.offset;
          for (const {
            tsKey: selectedRelationTsKey,
            queryConfig: selectedRelationConfigValue,
            relation
          } of selectedRelations) {
            const normalizedRelation = normalizeRelation(schema2, tableNamesMap, relation);
            const relationTableName = getTableUniqueName(relation.referencedTable);
            const relationTableTsName = tableNamesMap[relationTableName];
            const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
            const joinOn2 = and(
              ...normalizedRelation.fields.map(
                (field2, i2) => eq(
                  aliasedTableColumn(normalizedRelation.references[i2], relationTableAlias),
                  aliasedTableColumn(field2, tableAlias)
                )
              )
            );
            const builtRelation = this.buildRelationalQuery({
              fullSchema,
              schema: schema2,
              tableNamesMap,
              table: fullSchema[relationTableTsName],
              tableConfig: schema2[relationTableTsName],
              queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
              tableAlias: relationTableAlias,
              joinOn: joinOn2,
              nestedQueryRelation: relation
            });
            const field = sql`(${builtRelation.sql})`.as(selectedRelationTsKey);
            selection.push({
              dbKey: selectedRelationTsKey,
              tsKey: selectedRelationTsKey,
              field,
              relationTableTsKey: relationTableTsName,
              isJson: true,
              selection: builtRelation.selection
            });
          }
        }
        if (selection.length === 0) {
          throw new DrizzleError({
            message: `No fields selected for table "${tableConfig.tsName}" ("${tableAlias}"). You need to have at least one item in "columns", "with" or "extras". If you need to select all columns, omit the "columns" key or set it to undefined.`
          });
        }
        let result;
        where = and(joinOn, where);
        if (nestedQueryRelation) {
          let field = sql`json_array(${sql.join(
            selection.map(
              ({ field: field2 }) => is(field2, SQLiteColumn) ? sql.identifier(this.casing.getColumnCasing(field2)) : is(field2, SQL.Aliased) ? field2.sql : field2
            ),
            sql`, `
          )})`;
          if (is(nestedQueryRelation, Many)) {
            field = sql`coalesce(json_group_array(${field}), json_array())`;
          }
          const nestedSelection = [{
            dbKey: "data",
            tsKey: "data",
            field: field.as("data"),
            isJson: true,
            relationTableTsKey: tableConfig.tsName,
            selection
          }];
          const needsSubquery = limit !== void 0 || offset2 !== void 0 || orderBy.length > 0;
          if (needsSubquery) {
            result = this.buildSelectQuery({
              table: aliasedTable(table, tableAlias),
              fields: {},
              fieldsFlat: [
                {
                  path: [],
                  field: sql.raw("*")
                }
              ],
              where,
              limit,
              offset: offset2,
              orderBy,
              setOperators: []
            });
            where = void 0;
            limit = void 0;
            offset2 = void 0;
            orderBy = void 0;
          } else {
            result = aliasedTable(table, tableAlias);
          }
          result = this.buildSelectQuery({
            table: is(result, SQLiteTable) ? result : new Subquery(result, {}, tableAlias),
            fields: {},
            fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
              path: [],
              field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
            })),
            joins,
            where,
            limit,
            offset: offset2,
            orderBy,
            setOperators: []
          });
        } else {
          result = this.buildSelectQuery({
            table: aliasedTable(table, tableAlias),
            fields: {},
            fieldsFlat: selection.map(({ field }) => ({
              path: [],
              field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
            })),
            joins,
            where,
            limit,
            offset: offset2,
            orderBy,
            setOperators: []
          });
        }
        return {
          tableTsKey: tableConfig.tsName,
          sql: result,
          selection
        };
      }
    }, "SQLiteDialect");
    SQLiteSyncDialect = /* @__PURE__ */ __name(class extends SQLiteDialect {
      static [entityKind] = "SQLiteSyncDialect";
      migrate(migrations, session, config) {
        const migrationsTable = config === void 0 ? "__drizzle_migrations" : typeof config === "string" ? "__drizzle_migrations" : config.migrationsTable ?? "__drizzle_migrations";
        const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;
        session.run(migrationTableCreate);
        const dbMigrations = session.values(
          sql`SELECT id, hash, created_at FROM ${sql.identifier(migrationsTable)} ORDER BY created_at DESC LIMIT 1`
        );
        const lastDbMigration = dbMigrations[0] ?? void 0;
        session.run(sql`BEGIN`);
        try {
          for (const migration of migrations) {
            if (!lastDbMigration || Number(lastDbMigration[2]) < migration.folderMillis) {
              for (const stmt of migration.sql) {
                session.run(sql.raw(stmt));
              }
              session.run(
                sql`INSERT INTO ${sql.identifier(migrationsTable)} ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`
              );
            }
          }
          session.run(sql`COMMIT`);
        } catch (e3) {
          session.run(sql`ROLLBACK`);
          throw e3;
        }
      }
    }, "SQLiteSyncDialect");
    SQLiteAsyncDialect = /* @__PURE__ */ __name(class extends SQLiteDialect {
      static [entityKind] = "SQLiteAsyncDialect";
      async migrate(migrations, session, config) {
        const migrationsTable = config === void 0 ? "__drizzle_migrations" : typeof config === "string" ? "__drizzle_migrations" : config.migrationsTable ?? "__drizzle_migrations";
        const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;
        await session.run(migrationTableCreate);
        const dbMigrations = await session.values(
          sql`SELECT id, hash, created_at FROM ${sql.identifier(migrationsTable)} ORDER BY created_at DESC LIMIT 1`
        );
        const lastDbMigration = dbMigrations[0] ?? void 0;
        await session.transaction(async (tx) => {
          for (const migration of migrations) {
            if (!lastDbMigration || Number(lastDbMigration[2]) < migration.folderMillis) {
              for (const stmt of migration.sql) {
                await tx.run(sql.raw(stmt));
              }
              await tx.run(
                sql`INSERT INTO ${sql.identifier(migrationsTable)} ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`
              );
            }
          }
        });
      }
    }, "SQLiteAsyncDialect");
  }
});
var TypedQueryBuilder;
var init_query_builder = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/query-builders/query-builder.js"() {
    init_entity();
    TypedQueryBuilder = /* @__PURE__ */ __name(class {
      static [entityKind] = "TypedQueryBuilder";
      /** @internal */
      getSelectedFields() {
        return this._.selectedFields;
      }
    }, "TypedQueryBuilder");
  }
});
function createSetOperator(type, isAll) {
  return (leftSelect, rightSelect, ...restSelects) => {
    const setOperators = [rightSelect, ...restSelects].map((select) => ({
      type,
      isAll,
      rightSelect: select
    }));
    for (const setOperator of setOperators) {
      if (!haveSameKeys(leftSelect.getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {
        throw new Error(
          "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
        );
      }
    }
    return leftSelect.addSetOperators(setOperators);
  };
}
__name(createSetOperator, "createSetOperator");
var SQLiteSelectBuilder;
var SQLiteSelectQueryBuilderBase;
var SQLiteSelectBase;
var getSQLiteSetOperators;
var union;
var unionAll;
var intersect;
var except;
var init_select2 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/query-builders/select.js"() {
    init_entity();
    init_query_builder();
    init_query_promise();
    init_selection_proxy();
    init_sql();
    init_subquery();
    init_table();
    init_utils();
    init_view_common();
    init_view_base();
    SQLiteSelectBuilder = /* @__PURE__ */ __name(class {
      static [entityKind] = "SQLiteSelectBuilder";
      fields;
      session;
      dialect;
      withList;
      distinct;
      constructor(config) {
        this.fields = config.fields;
        this.session = config.session;
        this.dialect = config.dialect;
        this.withList = config.withList;
        this.distinct = config.distinct;
      }
      from(source2) {
        const isPartialSelect = !!this.fields;
        let fields;
        if (this.fields) {
          fields = this.fields;
        } else if (is(source2, Subquery)) {
          fields = Object.fromEntries(
            Object.keys(source2._.selectedFields).map((key2) => [key2, source2[key2]])
          );
        } else if (is(source2, SQLiteViewBase)) {
          fields = source2[ViewBaseConfig].selectedFields;
        } else if (is(source2, SQL)) {
          fields = {};
        } else {
          fields = getTableColumns(source2);
        }
        return new SQLiteSelectBase({
          table: source2,
          fields,
          isPartialSelect,
          session: this.session,
          dialect: this.dialect,
          withList: this.withList,
          distinct: this.distinct
        });
      }
    }, "SQLiteSelectBuilder");
    SQLiteSelectQueryBuilderBase = /* @__PURE__ */ __name(class extends TypedQueryBuilder {
      static [entityKind] = "SQLiteSelectQueryBuilder";
      _;
      /** @internal */
      config;
      joinsNotNullableMap;
      tableName;
      isPartialSelect;
      session;
      dialect;
      constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }) {
        super();
        this.config = {
          withList,
          table,
          fields: { ...fields },
          distinct,
          setOperators: []
        };
        this.isPartialSelect = isPartialSelect;
        this.session = session;
        this.dialect = dialect;
        this._ = {
          selectedFields: fields
        };
        this.tableName = getTableLikeName(table);
        this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
      }
      createJoin(joinType) {
        return (table, on) => {
          const baseTableName = this.tableName;
          const tableName = getTableLikeName(table);
          if (typeof tableName === "string" && this.config.joins?.some((join) => join.alias === tableName)) {
            throw new Error(`Alias "${tableName}" is already used in this query`);
          }
          if (!this.isPartialSelect) {
            if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
              this.config.fields = {
                [baseTableName]: this.config.fields
              };
            }
            if (typeof tableName === "string" && !is(table, SQL)) {
              const selection = is(table, Subquery) ? table._.selectedFields : is(table, View) ? table[ViewBaseConfig].selectedFields : table[Table.Symbol.Columns];
              this.config.fields[tableName] = selection;
            }
          }
          if (typeof on === "function") {
            on = on(
              new Proxy(
                this.config.fields,
                new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
              )
            );
          }
          if (!this.config.joins) {
            this.config.joins = [];
          }
          this.config.joins.push({ on, table, joinType, alias: tableName });
          if (typeof tableName === "string") {
            switch (joinType) {
              case "left": {
                this.joinsNotNullableMap[tableName] = false;
                break;
              }
              case "right": {
                this.joinsNotNullableMap = Object.fromEntries(
                  Object.entries(this.joinsNotNullableMap).map(([key2]) => [key2, false])
                );
                this.joinsNotNullableMap[tableName] = true;
                break;
              }
              case "inner": {
                this.joinsNotNullableMap[tableName] = true;
                break;
              }
              case "full": {
                this.joinsNotNullableMap = Object.fromEntries(
                  Object.entries(this.joinsNotNullableMap).map(([key2]) => [key2, false])
                );
                this.joinsNotNullableMap[tableName] = false;
                break;
              }
            }
          }
          return this;
        };
      }
      /**
       * Executes a `left join` operation by adding another table to the current query.
       *
       * Calling this method associates each row of the table with the corresponding row from the joined table, if a match is found. If no matching row exists, it sets all columns of the joined table to null.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#left-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User; pets: Pet | null }[] = await db.select()
       *   .from(users)
       *   .leftJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number; petId: number | null }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .leftJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      leftJoin = this.createJoin("left");
      /**
       * Executes a `right join` operation by adding another table to the current query.
       *
       * Calling this method associates each row of the joined table with the corresponding row from the main table, if a match is found. If no matching row exists, it sets all columns of the main table to null.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#right-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User | null; pets: Pet }[] = await db.select()
       *   .from(users)
       *   .rightJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number | null; petId: number }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .rightJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      rightJoin = this.createJoin("right");
      /**
       * Executes an `inner join` operation, creating a new table by combining rows from two tables that have matching values.
       *
       * Calling this method retrieves rows that have corresponding entries in both joined tables. Rows without matching entries in either table are excluded, resulting in a table that includes only matching pairs.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#inner-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User; pets: Pet }[] = await db.select()
       *   .from(users)
       *   .innerJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number; petId: number }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .innerJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      innerJoin = this.createJoin("inner");
      /**
       * Executes a `full join` operation by combining rows from two tables into a new table.
       *
       * Calling this method retrieves all rows from both main and joined tables, merging rows with matching values and filling in `null` for non-matching columns.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#full-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User | null; pets: Pet | null }[] = await db.select()
       *   .from(users)
       *   .fullJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number | null; petId: number | null }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .fullJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      fullJoin = this.createJoin("full");
      createSetOperator(type, isAll) {
        return (rightSelection) => {
          const rightSelect = typeof rightSelection === "function" ? rightSelection(getSQLiteSetOperators()) : rightSelection;
          if (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {
            throw new Error(
              "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
            );
          }
          this.config.setOperators.push({ type, isAll, rightSelect });
          return this;
        };
      }
      /**
       * Adds `union` set operator to the query.
       *
       * Calling this method will combine the result sets of the `select` statements and remove any duplicate rows that appear across them.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#union}
       *
       * @example
       *
       * ```ts
       * // Select all unique names from customers and users tables
       * await db.select({ name: users.name })
       *   .from(users)
       *   .union(
       *     db.select({ name: customers.name }).from(customers)
       *   );
       * // or
       * import { union } from 'drizzle-orm/sqlite-core'
       *
       * await union(
       *   db.select({ name: users.name }).from(users),
       *   db.select({ name: customers.name }).from(customers)
       * );
       * ```
       */
      union = this.createSetOperator("union", false);
      /**
       * Adds `union all` set operator to the query.
       *
       * Calling this method will combine the result-set of the `select` statements and keep all duplicate rows that appear across them.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#union-all}
       *
       * @example
       *
       * ```ts
       * // Select all transaction ids from both online and in-store sales
       * await db.select({ transaction: onlineSales.transactionId })
       *   .from(onlineSales)
       *   .unionAll(
       *     db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
       *   );
       * // or
       * import { unionAll } from 'drizzle-orm/sqlite-core'
       *
       * await unionAll(
       *   db.select({ transaction: onlineSales.transactionId }).from(onlineSales),
       *   db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
       * );
       * ```
       */
      unionAll = this.createSetOperator("union", true);
      /**
       * Adds `intersect` set operator to the query.
       *
       * Calling this method will retain only the rows that are present in both result sets and eliminate duplicates.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect}
       *
       * @example
       *
       * ```ts
       * // Select course names that are offered in both departments A and B
       * await db.select({ courseName: depA.courseName })
       *   .from(depA)
       *   .intersect(
       *     db.select({ courseName: depB.courseName }).from(depB)
       *   );
       * // or
       * import { intersect } from 'drizzle-orm/sqlite-core'
       *
       * await intersect(
       *   db.select({ courseName: depA.courseName }).from(depA),
       *   db.select({ courseName: depB.courseName }).from(depB)
       * );
       * ```
       */
      intersect = this.createSetOperator("intersect", false);
      /**
       * Adds `except` set operator to the query.
       *
       * Calling this method will retrieve all unique rows from the left query, except for the rows that are present in the result set of the right query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#except}
       *
       * @example
       *
       * ```ts
       * // Select all courses offered in department A but not in department B
       * await db.select({ courseName: depA.courseName })
       *   .from(depA)
       *   .except(
       *     db.select({ courseName: depB.courseName }).from(depB)
       *   );
       * // or
       * import { except } from 'drizzle-orm/sqlite-core'
       *
       * await except(
       *   db.select({ courseName: depA.courseName }).from(depA),
       *   db.select({ courseName: depB.courseName }).from(depB)
       * );
       * ```
       */
      except = this.createSetOperator("except", false);
      /** @internal */
      addSetOperators(setOperators) {
        this.config.setOperators.push(...setOperators);
        return this;
      }
      /**
       * Adds a `where` clause to the query.
       *
       * Calling this method will select only those rows that fulfill a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#filtering}
       *
       * @param where the `where` clause.
       *
       * @example
       * You can use conditional operators and `sql function` to filter the rows to be selected.
       *
       * ```ts
       * // Select all cars with green color
       * await db.select().from(cars).where(eq(cars.color, 'green'));
       * // or
       * await db.select().from(cars).where(sql`${cars.color} = 'green'`)
       * ```
       *
       * You can logically combine conditional operators with `and()` and `or()` operators:
       *
       * ```ts
       * // Select all BMW cars with a green color
       * await db.select().from(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
       *
       * // Select all cars with the green or blue color
       * await db.select().from(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
       * ```
       */
      where(where) {
        if (typeof where === "function") {
          where = where(
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
            )
          );
        }
        this.config.where = where;
        return this;
      }
      /**
       * Adds a `having` clause to the query.
       *
       * Calling this method will select only those rows that fulfill a specified condition. It is typically used with aggregate functions to filter the aggregated data based on a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#aggregations}
       *
       * @param having the `having` clause.
       *
       * @example
       *
       * ```ts
       * // Select all brands with more than one car
       * await db.select({
       * 	brand: cars.brand,
       * 	count: sql<number>`cast(count(${cars.id}) as int)`,
       * })
       *   .from(cars)
       *   .groupBy(cars.brand)
       *   .having(({ count }) => gt(count, 1));
       * ```
       */
      having(having) {
        if (typeof having === "function") {
          having = having(
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
            )
          );
        }
        this.config.having = having;
        return this;
      }
      groupBy(...columns) {
        if (typeof columns[0] === "function") {
          const groupBy = columns[0](
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
            )
          );
          this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
        } else {
          this.config.groupBy = columns;
        }
        return this;
      }
      orderBy(...columns) {
        if (typeof columns[0] === "function") {
          const orderBy = columns[0](
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
            )
          );
          const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
          if (this.config.setOperators.length > 0) {
            this.config.setOperators.at(-1).orderBy = orderByArray;
          } else {
            this.config.orderBy = orderByArray;
          }
        } else {
          const orderByArray = columns;
          if (this.config.setOperators.length > 0) {
            this.config.setOperators.at(-1).orderBy = orderByArray;
          } else {
            this.config.orderBy = orderByArray;
          }
        }
        return this;
      }
      /**
       * Adds a `limit` clause to the query.
       *
       * Calling this method will set the maximum number of rows that will be returned by this query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}
       *
       * @param limit the `limit` clause.
       *
       * @example
       *
       * ```ts
       * // Get the first 10 people from this query.
       * await db.select().from(people).limit(10);
       * ```
       */
      limit(limit) {
        if (this.config.setOperators.length > 0) {
          this.config.setOperators.at(-1).limit = limit;
        } else {
          this.config.limit = limit;
        }
        return this;
      }
      /**
       * Adds an `offset` clause to the query.
       *
       * Calling this method will skip a number of rows when returning results from this query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}
       *
       * @param offset the `offset` clause.
       *
       * @example
       *
       * ```ts
       * // Get the 10th-20th people from this query.
       * await db.select().from(people).offset(10).limit(10);
       * ```
       */
      offset(offset2) {
        if (this.config.setOperators.length > 0) {
          this.config.setOperators.at(-1).offset = offset2;
        } else {
          this.config.offset = offset2;
        }
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildSelectQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      as(alias) {
        return new Proxy(
          new Subquery(this.getSQL(), this.config.fields, alias),
          new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
        );
      }
      /** @internal */
      getSelectedFields() {
        return new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
        );
      }
      $dynamic() {
        return this;
      }
    }, "SQLiteSelectQueryBuilderBase");
    SQLiteSelectBase = /* @__PURE__ */ __name(class extends SQLiteSelectQueryBuilderBase {
      static [entityKind] = "SQLiteSelect";
      /** @internal */
      _prepare(isOneTimeQuery = true) {
        if (!this.session) {
          throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
        }
        const fieldsList = orderSelectedFields(this.config.fields);
        const query = this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
          this.dialect.sqlToQuery(this.getSQL()),
          fieldsList,
          "all",
          true
        );
        query.joinsNotNullableMap = this.joinsNotNullableMap;
        return query;
      }
      prepare() {
        return this._prepare(false);
      }
      run = (placeholderValues) => {
        return this._prepare().run(placeholderValues);
      };
      all = (placeholderValues) => {
        return this._prepare().all(placeholderValues);
      };
      get = (placeholderValues) => {
        return this._prepare().get(placeholderValues);
      };
      values = (placeholderValues) => {
        return this._prepare().values(placeholderValues);
      };
      async execute() {
        return this.all();
      }
    }, "SQLiteSelectBase");
    applyMixins(SQLiteSelectBase, [QueryPromise]);
    getSQLiteSetOperators = /* @__PURE__ */ __name(() => ({
      union,
      unionAll,
      intersect,
      except
    }), "getSQLiteSetOperators");
    union = createSetOperator("union", false);
    unionAll = createSetOperator("union", true);
    intersect = createSetOperator("intersect", false);
    except = createSetOperator("except", false);
  }
});
var QueryBuilder;
var init_query_builder2 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/query-builders/query-builder.js"() {
    init_entity();
    init_selection_proxy();
    init_dialect();
    init_subquery();
    init_select2();
    QueryBuilder = /* @__PURE__ */ __name(class {
      static [entityKind] = "SQLiteQueryBuilder";
      dialect;
      dialectConfig;
      constructor(dialect) {
        this.dialect = is(dialect, SQLiteDialect) ? dialect : void 0;
        this.dialectConfig = is(dialect, SQLiteDialect) ? void 0 : dialect;
      }
      $with(alias) {
        const queryBuilder = this;
        return {
          as(qb) {
            if (typeof qb === "function") {
              qb = qb(queryBuilder);
            }
            return new Proxy(
              new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true),
              new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
            );
          }
        };
      }
      with(...queries) {
        const self = this;
        function select(fields) {
          return new SQLiteSelectBuilder({
            fields: fields ?? void 0,
            session: void 0,
            dialect: self.getDialect(),
            withList: queries
          });
        }
        __name(select, "select");
        function selectDistinct(fields) {
          return new SQLiteSelectBuilder({
            fields: fields ?? void 0,
            session: void 0,
            dialect: self.getDialect(),
            withList: queries,
            distinct: true
          });
        }
        __name(selectDistinct, "selectDistinct");
        return { select, selectDistinct };
      }
      select(fields) {
        return new SQLiteSelectBuilder({ fields: fields ?? void 0, session: void 0, dialect: this.getDialect() });
      }
      selectDistinct(fields) {
        return new SQLiteSelectBuilder({
          fields: fields ?? void 0,
          session: void 0,
          dialect: this.getDialect(),
          distinct: true
        });
      }
      // Lazy load dialect to avoid circular dependency
      getDialect() {
        if (!this.dialect) {
          this.dialect = new SQLiteSyncDialect(this.dialectConfig);
        }
        return this.dialect;
      }
    }, "QueryBuilder");
  }
});
var init_select_types = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/query-builders/select.types.js"() {
  }
});
var SQLiteUpdateBuilder;
var SQLiteUpdateBase;
var init_update = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/query-builders/update.js"() {
    init_entity();
    init_query_promise();
    init_table3();
    init_utils();
    SQLiteUpdateBuilder = /* @__PURE__ */ __name(class {
      constructor(table, session, dialect, withList) {
        this.table = table;
        this.session = session;
        this.dialect = dialect;
        this.withList = withList;
      }
      static [entityKind] = "SQLiteUpdateBuilder";
      set(values) {
        return new SQLiteUpdateBase(
          this.table,
          mapUpdateSet(this.table, values),
          this.session,
          this.dialect,
          this.withList
        );
      }
    }, "SQLiteUpdateBuilder");
    SQLiteUpdateBase = /* @__PURE__ */ __name(class extends QueryPromise {
      constructor(table, set3, session, dialect, withList) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.config = { set: set3, table, withList };
      }
      static [entityKind] = "SQLiteUpdate";
      /** @internal */
      config;
      /**
       * Adds a 'where' clause to the query.
       *
       * Calling this method will update only those rows that fulfill a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/update}
       *
       * @param where the 'where' clause.
       *
       * @example
       * You can use conditional operators and `sql function` to filter the rows to be updated.
       *
       * ```ts
       * // Update all cars with green color
       * db.update(cars).set({ color: 'red' })
       *   .where(eq(cars.color, 'green'));
       * // or
       * db.update(cars).set({ color: 'red' })
       *   .where(sql`${cars.color} = 'green'`)
       * ```
       *
       * You can logically combine conditional operators with `and()` and `or()` operators:
       *
       * ```ts
       * // Update all BMW cars with a green color
       * db.update(cars).set({ color: 'red' })
       *   .where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
       *
       * // Update all cars with the green or blue color
       * db.update(cars).set({ color: 'red' })
       *   .where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
       * ```
       */
      where(where) {
        this.config.where = where;
        return this;
      }
      returning(fields = this.config.table[SQLiteTable.Symbol.Columns]) {
        this.config.returning = orderSelectedFields(fields);
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildUpdateQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      /** @internal */
      _prepare(isOneTimeQuery = true) {
        return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
          this.dialect.sqlToQuery(this.getSQL()),
          this.config.returning,
          this.config.returning ? "all" : "run",
          true
        );
      }
      prepare() {
        return this._prepare(false);
      }
      run = (placeholderValues) => {
        return this._prepare().run(placeholderValues);
      };
      all = (placeholderValues) => {
        return this._prepare().all(placeholderValues);
      };
      get = (placeholderValues) => {
        return this._prepare().get(placeholderValues);
      };
      values = (placeholderValues) => {
        return this._prepare().values(placeholderValues);
      };
      async execute() {
        return this.config.returning ? this.all() : this.run();
      }
      $dynamic() {
        return this;
      }
    }, "SQLiteUpdateBase");
  }
});
var init_query_builders = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/query-builders/index.js"() {
    init_delete();
    init_insert();
    init_query_builder2();
    init_select2();
    init_select_types();
    init_update();
  }
});
var SQLiteCountBuilder;
var init_count = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/query-builders/count.js"() {
    init_entity();
    init_sql();
    SQLiteCountBuilder = /* @__PURE__ */ __name(class _SQLiteCountBuilder extends SQL {
      constructor(params) {
        super(_SQLiteCountBuilder.buildEmbeddedCount(params.source, params.filters).queryChunks);
        this.params = params;
        this.session = params.session;
        this.sql = _SQLiteCountBuilder.buildCount(
          params.source,
          params.filters
        );
      }
      sql;
      static [entityKind] = "SQLiteCountBuilderAsync";
      [Symbol.toStringTag] = "SQLiteCountBuilderAsync";
      session;
      static buildEmbeddedCount(source2, filters) {
        return sql`(select count(*) from ${source2}${sql.raw(" where ").if(filters)}${filters})`;
      }
      static buildCount(source2, filters) {
        return sql`select count(*) from ${source2}${sql.raw(" where ").if(filters)}${filters}`;
      }
      then(onfulfilled, onrejected) {
        return Promise.resolve(this.session.count(this.sql)).then(
          onfulfilled,
          onrejected
        );
      }
      catch(onRejected) {
        return this.then(void 0, onRejected);
      }
      finally(onFinally) {
        return this.then(
          (value) => {
            onFinally?.();
            return value;
          },
          (reason) => {
            onFinally?.();
            throw reason;
          }
        );
      }
    }, "_SQLiteCountBuilder");
  }
});
var RelationalQueryBuilder;
var SQLiteRelationalQuery;
var SQLiteSyncRelationalQuery;
var init_query = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/query-builders/query.js"() {
    init_entity();
    init_query_promise();
    init_relations();
    RelationalQueryBuilder = /* @__PURE__ */ __name(class {
      constructor(mode, fullSchema, schema2, tableNamesMap, table, tableConfig, dialect, session) {
        this.mode = mode;
        this.fullSchema = fullSchema;
        this.schema = schema2;
        this.tableNamesMap = tableNamesMap;
        this.table = table;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
      }
      static [entityKind] = "SQLiteAsyncRelationalQueryBuilder";
      findMany(config) {
        return this.mode === "sync" ? new SQLiteSyncRelationalQuery(
          this.fullSchema,
          this.schema,
          this.tableNamesMap,
          this.table,
          this.tableConfig,
          this.dialect,
          this.session,
          config ? config : {},
          "many"
        ) : new SQLiteRelationalQuery(
          this.fullSchema,
          this.schema,
          this.tableNamesMap,
          this.table,
          this.tableConfig,
          this.dialect,
          this.session,
          config ? config : {},
          "many"
        );
      }
      findFirst(config) {
        return this.mode === "sync" ? new SQLiteSyncRelationalQuery(
          this.fullSchema,
          this.schema,
          this.tableNamesMap,
          this.table,
          this.tableConfig,
          this.dialect,
          this.session,
          config ? { ...config, limit: 1 } : { limit: 1 },
          "first"
        ) : new SQLiteRelationalQuery(
          this.fullSchema,
          this.schema,
          this.tableNamesMap,
          this.table,
          this.tableConfig,
          this.dialect,
          this.session,
          config ? { ...config, limit: 1 } : { limit: 1 },
          "first"
        );
      }
    }, "RelationalQueryBuilder");
    SQLiteRelationalQuery = /* @__PURE__ */ __name(class extends QueryPromise {
      constructor(fullSchema, schema2, tableNamesMap, table, tableConfig, dialect, session, config, mode) {
        super();
        this.fullSchema = fullSchema;
        this.schema = schema2;
        this.tableNamesMap = tableNamesMap;
        this.table = table;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
        this.config = config;
        this.mode = mode;
      }
      static [entityKind] = "SQLiteAsyncRelationalQuery";
      /** @internal */
      mode;
      /** @internal */
      getSQL() {
        return this.dialect.buildRelationalQuery({
          fullSchema: this.fullSchema,
          schema: this.schema,
          tableNamesMap: this.tableNamesMap,
          table: this.table,
          tableConfig: this.tableConfig,
          queryConfig: this.config,
          tableAlias: this.tableConfig.tsName
        }).sql;
      }
      /** @internal */
      _prepare(isOneTimeQuery = false) {
        const { query, builtQuery } = this._toSQL();
        return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
          builtQuery,
          void 0,
          this.mode === "first" ? "get" : "all",
          true,
          (rawRows, mapColumnValue) => {
            const rows = rawRows.map(
              (row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue)
            );
            if (this.mode === "first") {
              return rows[0];
            }
            return rows;
          }
        );
      }
      prepare() {
        return this._prepare(false);
      }
      _toSQL() {
        const query = this.dialect.buildRelationalQuery({
          fullSchema: this.fullSchema,
          schema: this.schema,
          tableNamesMap: this.tableNamesMap,
          table: this.table,
          tableConfig: this.tableConfig,
          queryConfig: this.config,
          tableAlias: this.tableConfig.tsName
        });
        const builtQuery = this.dialect.sqlToQuery(query.sql);
        return { query, builtQuery };
      }
      toSQL() {
        return this._toSQL().builtQuery;
      }
      /** @internal */
      executeRaw() {
        if (this.mode === "first") {
          return this._prepare(false).get();
        }
        return this._prepare(false).all();
      }
      async execute() {
        return this.executeRaw();
      }
    }, "SQLiteRelationalQuery");
    SQLiteSyncRelationalQuery = /* @__PURE__ */ __name(class extends SQLiteRelationalQuery {
      static [entityKind] = "SQLiteSyncRelationalQuery";
      sync() {
        return this.executeRaw();
      }
    }, "SQLiteSyncRelationalQuery");
  }
});
var SQLiteRaw;
var init_raw = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/query-builders/raw.js"() {
    init_entity();
    init_query_promise();
    SQLiteRaw = /* @__PURE__ */ __name(class extends QueryPromise {
      constructor(execute, getSQL, action, dialect, mapBatchResult) {
        super();
        this.execute = execute;
        this.getSQL = getSQL;
        this.dialect = dialect;
        this.mapBatchResult = mapBatchResult;
        this.config = { action };
      }
      static [entityKind] = "SQLiteRaw";
      /** @internal */
      config;
      getQuery() {
        return { ...this.dialect.sqlToQuery(this.getSQL()), method: this.config.action };
      }
      mapResult(result, isFromBatch) {
        return isFromBatch ? this.mapBatchResult(result) : result;
      }
      _prepare() {
        return this;
      }
      /** @internal */
      isResponseInArrayMode() {
        return false;
      }
    }, "SQLiteRaw");
  }
});
var BaseSQLiteDatabase;
var init_db = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/db.js"() {
    init_entity();
    init_selection_proxy();
    init_sql();
    init_query_builders();
    init_subquery();
    init_count();
    init_query();
    init_raw();
    BaseSQLiteDatabase = /* @__PURE__ */ __name(class {
      constructor(resultKind, dialect, session, schema2) {
        this.resultKind = resultKind;
        this.dialect = dialect;
        this.session = session;
        this._ = schema2 ? {
          schema: schema2.schema,
          fullSchema: schema2.fullSchema,
          tableNamesMap: schema2.tableNamesMap
        } : {
          schema: void 0,
          fullSchema: {},
          tableNamesMap: {}
        };
        this.query = {};
        const query = this.query;
        if (this._.schema) {
          for (const [tableName, columns] of Object.entries(this._.schema)) {
            query[tableName] = new RelationalQueryBuilder(
              resultKind,
              schema2.fullSchema,
              this._.schema,
              this._.tableNamesMap,
              schema2.fullSchema[tableName],
              columns,
              dialect,
              session
            );
          }
        }
      }
      static [entityKind] = "BaseSQLiteDatabase";
      query;
      /**
       * Creates a subquery that defines a temporary named result set as a CTE.
       *
       * It is useful for breaking down complex queries into simpler parts and for reusing the result set in subsequent parts of the query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
       *
       * @param alias The alias for the subquery.
       *
       * Failure to provide an alias will result in a DrizzleTypeError, preventing the subquery from being referenced in other queries.
       *
       * @example
       *
       * ```ts
       * // Create a subquery with alias 'sq' and use it in the select query
       * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
       *
       * const result = await db.with(sq).select().from(sq);
       * ```
       *
       * To select arbitrary SQL values as fields in a CTE and reference them in other CTEs or in the main query, you need to add aliases to them:
       *
       * ```ts
       * // Select an arbitrary SQL value as a field in a CTE and reference it in the main query
       * const sq = db.$with('sq').as(db.select({
       *   name: sql<string>`upper(${users.name})`.as('name'),
       * })
       * .from(users));
       *
       * const result = await db.with(sq).select({ name: sq.name }).from(sq);
       * ```
       */
      $with(alias) {
        const self = this;
        return {
          as(qb) {
            if (typeof qb === "function") {
              qb = qb(new QueryBuilder(self.dialect));
            }
            return new Proxy(
              new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true),
              new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
            );
          }
        };
      }
      $count(source2, filters) {
        return new SQLiteCountBuilder({ source: source2, filters, session: this.session });
      }
      /**
       * Incorporates a previously defined CTE (using `$with`) into the main query.
       *
       * This method allows the main query to reference a temporary named result set.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
       *
       * @param queries The CTEs to incorporate into the main query.
       *
       * @example
       *
       * ```ts
       * // Define a subquery 'sq' as a CTE using $with
       * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
       *
       * // Incorporate the CTE 'sq' into the main query and select from it
       * const result = await db.with(sq).select().from(sq);
       * ```
       */
      with(...queries) {
        const self = this;
        function select(fields) {
          return new SQLiteSelectBuilder({
            fields: fields ?? void 0,
            session: self.session,
            dialect: self.dialect,
            withList: queries
          });
        }
        __name(select, "select");
        function selectDistinct(fields) {
          return new SQLiteSelectBuilder({
            fields: fields ?? void 0,
            session: self.session,
            dialect: self.dialect,
            withList: queries,
            distinct: true
          });
        }
        __name(selectDistinct, "selectDistinct");
        function update(table) {
          return new SQLiteUpdateBuilder(table, self.session, self.dialect, queries);
        }
        __name(update, "update");
        function insert(into) {
          return new SQLiteInsertBuilder(into, self.session, self.dialect, queries);
        }
        __name(insert, "insert");
        function delete_(from) {
          return new SQLiteDeleteBase(from, self.session, self.dialect, queries);
        }
        __name(delete_, "delete_");
        return { select, selectDistinct, update, insert, delete: delete_ };
      }
      select(fields) {
        return new SQLiteSelectBuilder({ fields: fields ?? void 0, session: this.session, dialect: this.dialect });
      }
      selectDistinct(fields) {
        return new SQLiteSelectBuilder({
          fields: fields ?? void 0,
          session: this.session,
          dialect: this.dialect,
          distinct: true
        });
      }
      /**
       * Creates an update query.
       *
       * Calling this method without `.where()` clause will update all rows in a table. The `.where()` clause specifies which rows should be updated.
       *
       * Use `.set()` method to specify which values to update.
       *
       * See docs: {@link https://orm.drizzle.team/docs/update}
       *
       * @param table The table to update.
       *
       * @example
       *
       * ```ts
       * // Update all rows in the 'cars' table
       * await db.update(cars).set({ color: 'red' });
       *
       * // Update rows with filters and conditions
       * await db.update(cars).set({ color: 'red' }).where(eq(cars.brand, 'BMW'));
       *
       * // Update with returning clause
       * const updatedCar: Car[] = await db.update(cars)
       *   .set({ color: 'red' })
       *   .where(eq(cars.id, 1))
       *   .returning();
       * ```
       */
      update(table) {
        return new SQLiteUpdateBuilder(table, this.session, this.dialect);
      }
      /**
       * Creates an insert query.
       *
       * Calling this method will create new rows in a table. Use `.values()` method to specify which values to insert.
       *
       * See docs: {@link https://orm.drizzle.team/docs/insert}
       *
       * @param table The table to insert into.
       *
       * @example
       *
       * ```ts
       * // Insert one row
       * await db.insert(cars).values({ brand: 'BMW' });
       *
       * // Insert multiple rows
       * await db.insert(cars).values([{ brand: 'BMW' }, { brand: 'Porsche' }]);
       *
       * // Insert with returning clause
       * const insertedCar: Car[] = await db.insert(cars)
       *   .values({ brand: 'BMW' })
       *   .returning();
       * ```
       */
      insert(into) {
        return new SQLiteInsertBuilder(into, this.session, this.dialect);
      }
      /**
       * Creates a delete query.
       *
       * Calling this method without `.where()` clause will delete all rows in a table. The `.where()` clause specifies which rows should be deleted.
       *
       * See docs: {@link https://orm.drizzle.team/docs/delete}
       *
       * @param table The table to delete from.
       *
       * @example
       *
       * ```ts
       * // Delete all rows in the 'cars' table
       * await db.delete(cars);
       *
       * // Delete rows with filters and conditions
       * await db.delete(cars).where(eq(cars.color, 'green'));
       *
       * // Delete with returning clause
       * const deletedCar: Car[] = await db.delete(cars)
       *   .where(eq(cars.id, 1))
       *   .returning();
       * ```
       */
      delete(from) {
        return new SQLiteDeleteBase(from, this.session, this.dialect);
      }
      run(query) {
        const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
        if (this.resultKind === "async") {
          return new SQLiteRaw(
            async () => this.session.run(sequel),
            () => sequel,
            "run",
            this.dialect,
            this.session.extractRawRunValueFromBatchResult.bind(this.session)
          );
        }
        return this.session.run(sequel);
      }
      all(query) {
        const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
        if (this.resultKind === "async") {
          return new SQLiteRaw(
            async () => this.session.all(sequel),
            () => sequel,
            "all",
            this.dialect,
            this.session.extractRawAllValueFromBatchResult.bind(this.session)
          );
        }
        return this.session.all(sequel);
      }
      get(query) {
        const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
        if (this.resultKind === "async") {
          return new SQLiteRaw(
            async () => this.session.get(sequel),
            () => sequel,
            "get",
            this.dialect,
            this.session.extractRawGetValueFromBatchResult.bind(this.session)
          );
        }
        return this.session.get(sequel);
      }
      values(query) {
        const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
        if (this.resultKind === "async") {
          return new SQLiteRaw(
            async () => this.session.values(sequel),
            () => sequel,
            "values",
            this.dialect,
            this.session.extractRawValuesValueFromBatchResult.bind(this.session)
          );
        }
        return this.session.values(sequel);
      }
      transaction(transaction, config) {
        return this.session.transaction(transaction, config);
      }
    }, "BaseSQLiteDatabase");
  }
});
var IndexBuilderOn;
var IndexBuilder;
var Index;
var init_indexes = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/indexes.js"() {
    init_entity();
    IndexBuilderOn = /* @__PURE__ */ __name(class {
      constructor(name3, unique) {
        this.name = name3;
        this.unique = unique;
      }
      static [entityKind] = "SQLiteIndexBuilderOn";
      on(...columns) {
        return new IndexBuilder(this.name, columns, this.unique);
      }
    }, "IndexBuilderOn");
    IndexBuilder = /* @__PURE__ */ __name(class {
      static [entityKind] = "SQLiteIndexBuilder";
      /** @internal */
      config;
      constructor(name3, columns, unique) {
        this.config = {
          name: name3,
          columns,
          unique,
          where: void 0
        };
      }
      /**
       * Condition for partial index.
       */
      where(condition) {
        this.config.where = condition;
        return this;
      }
      /** @internal */
      build(table) {
        return new Index(this.config, table);
      }
    }, "IndexBuilder");
    Index = /* @__PURE__ */ __name(class {
      static [entityKind] = "SQLiteIndex";
      config;
      constructor(config, table) {
        this.config = { ...config, table };
      }
    }, "Index");
  }
});
function primaryKey(...config) {
  if (config[0].columns) {
    return new PrimaryKeyBuilder2(config[0].columns, config[0].name);
  }
  return new PrimaryKeyBuilder2(config);
}
__name(primaryKey, "primaryKey");
var PrimaryKeyBuilder2;
var PrimaryKey2;
var init_primary_keys2 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/primary-keys.js"() {
    init_entity();
    init_table3();
    PrimaryKeyBuilder2 = /* @__PURE__ */ __name(class {
      static [entityKind] = "SQLitePrimaryKeyBuilder";
      /** @internal */
      columns;
      /** @internal */
      name;
      constructor(columns, name3) {
        this.columns = columns;
        this.name = name3;
      }
      /** @internal */
      build(table) {
        return new PrimaryKey2(table, this.columns, this.name);
      }
    }, "PrimaryKeyBuilder2");
    PrimaryKey2 = /* @__PURE__ */ __name(class {
      constructor(table, columns, name3) {
        this.table = table;
        this.columns = columns;
        this.name = name3;
      }
      static [entityKind] = "SQLitePrimaryKey";
      columns;
      name;
      getName() {
        return this.name ?? `${this.table[SQLiteTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
      }
    }, "PrimaryKey2");
  }
});
var ExecuteResultSync;
var SQLitePreparedQuery;
var SQLiteSession;
var SQLiteTransaction;
var init_session = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/session.js"() {
    init_entity();
    init_errors();
    init_query_promise();
    init_db();
    ExecuteResultSync = /* @__PURE__ */ __name(class extends QueryPromise {
      constructor(resultCb) {
        super();
        this.resultCb = resultCb;
      }
      static [entityKind] = "ExecuteResultSync";
      async execute() {
        return this.resultCb();
      }
      sync() {
        return this.resultCb();
      }
    }, "ExecuteResultSync");
    SQLitePreparedQuery = /* @__PURE__ */ __name(class {
      constructor(mode, executeMethod, query) {
        this.mode = mode;
        this.executeMethod = executeMethod;
        this.query = query;
      }
      static [entityKind] = "PreparedQuery";
      /** @internal */
      joinsNotNullableMap;
      getQuery() {
        return this.query;
      }
      mapRunResult(result, _isFromBatch) {
        return result;
      }
      mapAllResult(_result, _isFromBatch) {
        throw new Error("Not implemented");
      }
      mapGetResult(_result, _isFromBatch) {
        throw new Error("Not implemented");
      }
      execute(placeholderValues) {
        if (this.mode === "async") {
          return this[this.executeMethod](placeholderValues);
        }
        return new ExecuteResultSync(() => this[this.executeMethod](placeholderValues));
      }
      mapResult(response, isFromBatch) {
        switch (this.executeMethod) {
          case "run": {
            return this.mapRunResult(response, isFromBatch);
          }
          case "all": {
            return this.mapAllResult(response, isFromBatch);
          }
          case "get": {
            return this.mapGetResult(response, isFromBatch);
          }
        }
      }
    }, "SQLitePreparedQuery");
    SQLiteSession = /* @__PURE__ */ __name(class {
      constructor(dialect) {
        this.dialect = dialect;
      }
      static [entityKind] = "SQLiteSession";
      prepareOneTimeQuery(query, fields, executeMethod, isResponseInArrayMode) {
        return this.prepareQuery(query, fields, executeMethod, isResponseInArrayMode);
      }
      run(query) {
        const staticQuery = this.dialect.sqlToQuery(query);
        try {
          return this.prepareOneTimeQuery(staticQuery, void 0, "run", false).run();
        } catch (err) {
          throw new DrizzleError({ cause: err, message: `Failed to run the query '${staticQuery.sql}'` });
        }
      }
      /** @internal */
      extractRawRunValueFromBatchResult(result) {
        return result;
      }
      all(query) {
        return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), void 0, "run", false).all();
      }
      /** @internal */
      extractRawAllValueFromBatchResult(_result) {
        throw new Error("Not implemented");
      }
      get(query) {
        return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), void 0, "run", false).get();
      }
      /** @internal */
      extractRawGetValueFromBatchResult(_result) {
        throw new Error("Not implemented");
      }
      values(query) {
        return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), void 0, "run", false).values();
      }
      async count(sql2) {
        const result = await this.values(sql2);
        return result[0][0];
      }
      /** @internal */
      extractRawValuesValueFromBatchResult(_result) {
        throw new Error("Not implemented");
      }
    }, "SQLiteSession");
    SQLiteTransaction = /* @__PURE__ */ __name(class extends BaseSQLiteDatabase {
      constructor(resultType, dialect, session, schema2, nestedIndex = 0) {
        super(resultType, dialect, session, schema2);
        this.schema = schema2;
        this.nestedIndex = nestedIndex;
      }
      static [entityKind] = "SQLiteTransaction";
      rollback() {
        throw new TransactionRollbackError();
      }
    }, "SQLiteTransaction");
  }
});
var init_subquery2 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/subquery.js"() {
  }
});
var SQLiteViewConfig;
var init_view_common2 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/view-common.js"() {
    SQLiteViewConfig = Symbol.for("drizzle:SQLiteViewConfig");
  }
});
var init_utils2 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/utils.js"() {
  }
});
var ViewBuilderCore;
var ViewBuilder;
var ManualViewBuilder;
var SQLiteView;
var init_view = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/view.js"() {
    init_entity();
    init_selection_proxy();
    init_utils();
    init_query_builder2();
    init_table3();
    init_view_base();
    init_view_common2();
    ViewBuilderCore = /* @__PURE__ */ __name(class {
      constructor(name3) {
        this.name = name3;
      }
      static [entityKind] = "SQLiteViewBuilderCore";
      config = {};
    }, "ViewBuilderCore");
    ViewBuilder = /* @__PURE__ */ __name(class extends ViewBuilderCore {
      static [entityKind] = "SQLiteViewBuilder";
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(new QueryBuilder());
        }
        const selectionProxy = new SelectionProxyHandler({
          alias: this.name,
          sqlBehavior: "error",
          sqlAliasedBehavior: "alias",
          replaceOriginalName: true
        });
        const aliasedSelectedFields = qb.getSelectedFields();
        return new Proxy(
          new SQLiteView({
            sqliteConfig: this.config,
            config: {
              name: this.name,
              schema: void 0,
              selectedFields: aliasedSelectedFields,
              query: qb.getSQL().inlineParams()
            }
          }),
          selectionProxy
        );
      }
    }, "ViewBuilder");
    ManualViewBuilder = /* @__PURE__ */ __name(class extends ViewBuilderCore {
      static [entityKind] = "SQLiteManualViewBuilder";
      columns;
      constructor(name3, columns) {
        super(name3);
        this.columns = getTableColumns(sqliteTable(name3, columns));
      }
      existing() {
        return new Proxy(
          new SQLiteView({
            sqliteConfig: void 0,
            config: {
              name: this.name,
              schema: void 0,
              selectedFields: this.columns,
              query: void 0
            }
          }),
          new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: "error",
            sqlAliasedBehavior: "alias",
            replaceOriginalName: true
          })
        );
      }
      as(query) {
        return new Proxy(
          new SQLiteView({
            sqliteConfig: this.config,
            config: {
              name: this.name,
              schema: void 0,
              selectedFields: this.columns,
              query: query.inlineParams()
            }
          }),
          new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: "error",
            sqlAliasedBehavior: "alias",
            replaceOriginalName: true
          })
        );
      }
    }, "ManualViewBuilder");
    SQLiteView = /* @__PURE__ */ __name(class extends SQLiteViewBase {
      static [entityKind] = "SQLiteView";
      /** @internal */
      [SQLiteViewConfig];
      constructor({ sqliteConfig, config }) {
        super(config);
        this[SQLiteViewConfig] = sqliteConfig;
      }
    }, "SQLiteView");
  }
});
var init_sqlite_core = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/sqlite-core/index.js"() {
    init_alias2();
    init_checks();
    init_columns();
    init_db();
    init_dialect();
    init_foreign_keys2();
    init_indexes();
    init_primary_keys2();
    init_query_builders();
    init_session();
    init_subquery2();
    init_table3();
    init_unique_constraint2();
    init_utils2();
    init_view();
  }
});
function array() {
  return text("", { mode: "json" }).$type();
}
__name(array, "array");
var GAME_STATUS;
var timestamps;
var usersTable;
var sessionTable;
var gamesTable;
var statsTable;
var userRelations;
var gamesRelations;
var statsRelations;
var gameHistoryTable;
var movesTable;
var tournamentsTable;
var participantsTable;
var matches;
var schema;
var init_schema = __esm({
  ".svelte-kit/output/server/chunks/schema.js"() {
    init_drizzle_orm();
    init_sqlite_core();
    GAME_STATUS = ["IN_PROGRESS", "COMPLETED", "ABORTED"];
    timestamps = {
      createdAt: text().default(sql`(CURRENT_TIMESTAMP)`),
      updatedAt: text().$onUpdate(() => sql`(CURRENT_TIMESTAMP)`)
    };
    usersTable = sqliteTable("users", {
      id: integer("id").primaryKey(),
      googleId: text("google_id").unique(),
      name: text("name").notNull(),
      email: text("email").unique(),
      picture: text("picture"),
      xHandle: text(),
      instagramHandle: text(),
      facebookHandle: text(),
      ...timestamps
    });
    sessionTable = sqliteTable("session", {
      id: text("id").primaryKey(),
      userId: integer("user_id").notNull().references(() => usersTable.id),
      expiresAt: integer("expires_at", {
        mode: "timestamp"
      }).notNull()
    });
    gamesTable = sqliteTable("games", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      name: text("name").notNull().unique()
    });
    statsTable = sqliteTable(
      "stats",
      {
        userId: integer().notNull().references(() => usersTable.id),
        gameId: integer("game_id").notNull().references(() => gamesTable.id),
        globalRanking: integer("global_ranking").notNull(),
        gamesPlayed: integer("games_played").notNull().default(0),
        gamesWon: integer("games_won").notNull().default(0),
        gamesLost: integer("games_lost").notNull().default(0),
        gamesDrawn: integer("games_drawn").notNull().default(0),
        ...timestamps
      },
      (table) => ({
        pk: primaryKey({ columns: [table.userId, table.gameId] })
      })
    );
    userRelations = relations(usersTable, ({ many }) => ({
      stats: many(statsTable)
    }));
    gamesRelations = relations(gamesTable, ({ many }) => ({
      stats: many(statsTable)
    }));
    statsRelations = relations(statsTable, ({ one }) => ({
      game: one(gamesTable, {
        fields: [statsTable.gameId],
        references: [gamesTable.id]
      }),
      user: one(usersTable, {
        fields: [statsTable.userId],
        references: [usersTable.id]
      })
    }));
    gameHistoryTable = sqliteTable("game_history", {
      id: integer().primaryKey({ autoIncrement: true }),
      gameId: integer().notNull().references(() => gamesTable.id),
      playerOneId: integer().notNull().references(() => usersTable.id),
      // Nullable for computer opponent
      playerTwoId: integer().references(() => usersTable.id),
      // true for computer opponent
      isComputerOpponent: integer({ mode: "boolean" }).notNull().default(false),
      winner: integer().references(() => usersTable.id),
      status: text({ enum: GAME_STATUS }).notNull().default("IN_PROGRESS"),
      ...timestamps
    });
    movesTable = sqliteTable("moves", {
      id: integer().primaryKey({ autoIncrement: true }),
      gameHistoryId: integer().notNull().references(() => gameHistoryTable.id),
      playerId: integer().notNull().references(() => usersTable.id),
      // Store move as JSON to support different game move types
      move: text("move").notNull(),
      roundNumber: integer().notNull().default(1),
      ...timestamps
    });
    tournamentsTable = sqliteTable("tournaments", {
      id: integer().primaryKey({ autoIncrement: true }),
      name: text().notNull(),
      gameId: integer().references(() => gamesTable.id),
      prize: integer().notNull(),
      gameMode: text().notNull(),
      duration: integer().notNull(),
      type: text({ enum: ["PUBLIC", "PRIVATE"] }).notNull(),
      maxPlayers: integer().notNull(),
      startTime: integer("start", { mode: "timestamp" }).notNull(),
      endTime: integer("end", { mode: "timestamp" }),
      status: text({ enum: ["UPCOMING", "LIVE", "COMPLETED"] }).notNull(),
      currentPlayers: integer().default(0)
    });
    participantsTable = sqliteTable(
      "participants",
      {
        tournamentId: integer().references(() => tournamentsTable.id),
        userId: integer().references(() => usersTable.id),
        points: integer().default(0),
        wins: integer().default(0),
        draws: integer().default(0),
        losses: integer().default(0),
        joinedAt: integer("joined", { mode: "timestamp" }).notNull().default(sql`CURRENT_TIMESTAMP`)
      },
      (table) => ({
        pk: primaryKey({ columns: [table.tournamentId, table.userId], name: "id" })
      })
    );
    matches = sqliteTable("matches", {
      id: integer().primaryKey({ autoIncrement: true }),
      tournamentId: integer().references(() => tournamentsTable.id),
      player1Id: integer().references(() => usersTable.id),
      player2Id: integer().references(() => usersTable.id),
      winnerId: integer().references(() => usersTable.id),
      result: text({ enum: ["WIN", "DRAW", "ONGOING"] }),
      startTime: integer("start", { mode: "timestamp" }),
      endTime: integer("end", { mode: "timestamp" }),
      status: text({ enum: ["SCHEDULED", "LIVE", "COMPLETED"] }).default("SCHEDULED")
    });
    schema = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      array,
      gameHistoryTable,
      gamesRelations,
      gamesTable,
      matches,
      movesTable,
      participantsTable,
      sessionTable,
      statsRelations,
      statsTable,
      timestamps,
      tournamentsTable,
      userRelations,
      usersTable
    }, Symbol.toStringTag, { value: "Module" }));
  }
});
function generateSessionToken() {
  const bytes = new Uint8Array(20);
  crypto.getRandomValues(bytes);
  const token = encodeBase32LowerCaseNoPadding(bytes);
  return token;
}
__name(generateSessionToken, "generateSessionToken");
async function createSession(token, userId, db) {
  const sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));
  const session = {
    id: sessionId,
    userId,
    expiresAt: new Date(Date.now() + 1e3 * 60 * 60 * 24 * 30)
  };
  await db.insert(sessionTable).values(session);
  return session;
}
__name(createSession, "createSession");
async function validateSessionToken(token, db) {
  const sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));
  const result = await db.select({ user: usersTable, session: sessionTable }).from(sessionTable).innerJoin(usersTable, eq(sessionTable.userId, usersTable.id)).where(eq(sessionTable.id, sessionId));
  if (result.length < 1) {
    return { session: null, user: null };
  }
  const { user, session } = result[0];
  if (Date.now() >= session.expiresAt.getTime()) {
    await db.delete(sessionTable).where(eq(sessionTable.id, session.id));
    return { session: null, user: null };
  }
  if (Date.now() >= session.expiresAt.getTime() - 1e3 * 60 * 60 * 24 * 15) {
    session.expiresAt = new Date(Date.now() + 1e3 * 60 * 60 * 24 * 30);
    await db.update(sessionTable).set({
      expiresAt: session.expiresAt
    }).where(eq(sessionTable.id, session.id));
  }
  return { session, user };
}
__name(validateSessionToken, "validateSessionToken");
function setSessionTokenCookie(event, token, expiresAt) {
  event.cookies.set("session", token, {
    httpOnly: true,
    sameSite: "lax",
    expires: expiresAt,
    path: "/"
  });
}
__name(setSessionTokenCookie, "setSessionTokenCookie");
function deleteSessionTokenCookie(event) {
  event.cookies.set("session", "", {
    httpOnly: true,
    sameSite: "lax",
    maxAge: 0,
    path: "/"
  });
}
__name(deleteSessionTokenCookie, "deleteSessionTokenCookie");
var init_session2 = __esm({
  ".svelte-kit/output/server/chunks/session.js"() {
    init_drizzle_orm();
    init_dist();
    init_sha2();
    init_schema();
  }
});
function d1ToRawMapping(results) {
  const rows = [];
  for (const row of results) {
    const entry = Object.keys(row).map((k) => row[k]);
    rows.push(entry);
  }
  return rows;
}
__name(d1ToRawMapping, "d1ToRawMapping");
var SQLiteD1Session;
var D1Transaction;
var D1PreparedQuery;
var init_session3 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/d1/session.js"() {
    init_entity();
    init_logger();
    init_sql();
    init_sqlite_core();
    init_session();
    init_utils();
    SQLiteD1Session = /* @__PURE__ */ __name(class extends SQLiteSession {
      constructor(client, dialect, schema2, options2 = {}) {
        super(dialect);
        this.client = client;
        this.schema = schema2;
        this.options = options2;
        this.logger = options2.logger ?? new NoopLogger();
      }
      static [entityKind] = "SQLiteD1Session";
      logger;
      prepareQuery(query, fields, executeMethod, isResponseInArrayMode, customResultMapper) {
        const stmt = this.client.prepare(query.sql);
        return new D1PreparedQuery(
          stmt,
          query,
          this.logger,
          fields,
          executeMethod,
          isResponseInArrayMode,
          customResultMapper
        );
      }
      async batch(queries) {
        const preparedQueries = [];
        const builtQueries = [];
        for (const query of queries) {
          const preparedQuery = query._prepare();
          const builtQuery = preparedQuery.getQuery();
          preparedQueries.push(preparedQuery);
          if (builtQuery.params.length > 0) {
            builtQueries.push(preparedQuery.stmt.bind(...builtQuery.params));
          } else {
            const builtQuery2 = preparedQuery.getQuery();
            builtQueries.push(
              this.client.prepare(builtQuery2.sql).bind(...builtQuery2.params)
            );
          }
        }
        const batchResults = await this.client.batch(builtQueries);
        return batchResults.map((result, i2) => preparedQueries[i2].mapResult(result, true));
      }
      extractRawAllValueFromBatchResult(result) {
        return result.results;
      }
      extractRawGetValueFromBatchResult(result) {
        return result.results[0];
      }
      extractRawValuesValueFromBatchResult(result) {
        return d1ToRawMapping(result.results);
      }
      async transaction(transaction, config) {
        const tx = new D1Transaction("async", this.dialect, this, this.schema);
        await this.run(sql.raw(`begin${config?.behavior ? " " + config.behavior : ""}`));
        try {
          const result = await transaction(tx);
          await this.run(sql`commit`);
          return result;
        } catch (err) {
          await this.run(sql`rollback`);
          throw err;
        }
      }
    }, "SQLiteD1Session");
    D1Transaction = /* @__PURE__ */ __name(class _D1Transaction extends SQLiteTransaction {
      static [entityKind] = "D1Transaction";
      async transaction(transaction) {
        const savepointName = `sp${this.nestedIndex}`;
        const tx = new _D1Transaction("async", this.dialect, this.session, this.schema, this.nestedIndex + 1);
        await this.session.run(sql.raw(`savepoint ${savepointName}`));
        try {
          const result = await transaction(tx);
          await this.session.run(sql.raw(`release savepoint ${savepointName}`));
          return result;
        } catch (err) {
          await this.session.run(sql.raw(`rollback to savepoint ${savepointName}`));
          throw err;
        }
      }
    }, "_D1Transaction");
    D1PreparedQuery = /* @__PURE__ */ __name(class extends SQLitePreparedQuery {
      constructor(stmt, query, logger, fields, executeMethod, _isResponseInArrayMode, customResultMapper) {
        super("async", executeMethod, query);
        this.logger = logger;
        this._isResponseInArrayMode = _isResponseInArrayMode;
        this.customResultMapper = customResultMapper;
        this.fields = fields;
        this.stmt = stmt;
      }
      static [entityKind] = "D1PreparedQuery";
      /** @internal */
      customResultMapper;
      /** @internal */
      fields;
      /** @internal */
      stmt;
      run(placeholderValues) {
        const params = fillPlaceholders(this.query.params, placeholderValues ?? {});
        this.logger.logQuery(this.query.sql, params);
        return this.stmt.bind(...params).run();
      }
      async all(placeholderValues) {
        const { fields, query, logger, stmt, customResultMapper } = this;
        if (!fields && !customResultMapper) {
          const params = fillPlaceholders(query.params, placeholderValues ?? {});
          logger.logQuery(query.sql, params);
          return stmt.bind(...params).all().then(({ results }) => this.mapAllResult(results));
        }
        const rows = await this.values(placeholderValues);
        return this.mapAllResult(rows);
      }
      mapAllResult(rows, isFromBatch) {
        if (isFromBatch) {
          rows = d1ToRawMapping(rows.results);
        }
        if (!this.fields && !this.customResultMapper) {
          return rows;
        }
        if (this.customResultMapper) {
          return this.customResultMapper(rows);
        }
        return rows.map((row) => mapResultRow(this.fields, row, this.joinsNotNullableMap));
      }
      async get(placeholderValues) {
        const { fields, joinsNotNullableMap, query, logger, stmt, customResultMapper } = this;
        if (!fields && !customResultMapper) {
          const params = fillPlaceholders(query.params, placeholderValues ?? {});
          logger.logQuery(query.sql, params);
          return stmt.bind(...params).all().then(({ results }) => results[0]);
        }
        const rows = await this.values(placeholderValues);
        if (!rows[0]) {
          return void 0;
        }
        if (customResultMapper) {
          return customResultMapper(rows);
        }
        return mapResultRow(fields, rows[0], joinsNotNullableMap);
      }
      mapGetResult(result, isFromBatch) {
        if (isFromBatch) {
          result = d1ToRawMapping(result.results)[0];
        }
        if (!this.fields && !this.customResultMapper) {
          return result;
        }
        if (this.customResultMapper) {
          return this.customResultMapper([result]);
        }
        return mapResultRow(this.fields, result, this.joinsNotNullableMap);
      }
      values(placeholderValues) {
        const params = fillPlaceholders(this.query.params, placeholderValues ?? {});
        this.logger.logQuery(this.query.sql, params);
        return this.stmt.bind(...params).raw();
      }
      /** @internal */
      isResponseInArrayMode() {
        return this._isResponseInArrayMode;
      }
    }, "D1PreparedQuery");
  }
});
function drizzle(client, config = {}) {
  const dialect = new SQLiteAsyncDialect({ casing: config.casing });
  let logger;
  if (config.logger === true) {
    logger = new DefaultLogger();
  } else if (config.logger !== false) {
    logger = config.logger;
  }
  let schema2;
  if (config.schema) {
    const tablesConfig = extractTablesRelationalConfig(
      config.schema,
      createTableRelationsHelpers
    );
    schema2 = {
      fullSchema: config.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const session = new SQLiteD1Session(client, dialect, schema2, { logger });
  const db = new DrizzleD1Database("async", dialect, session, schema2);
  db.$client = client;
  return db;
}
__name(drizzle, "drizzle");
var DrizzleD1Database;
var init_driver = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/d1/driver.js"() {
    init_entity();
    init_logger();
    init_relations();
    init_db();
    init_dialect();
    init_session3();
    DrizzleD1Database = /* @__PURE__ */ __name(class extends BaseSQLiteDatabase {
      static [entityKind] = "D1Database";
      async batch(batch) {
        return this.session.batch(batch);
      }
    }, "DrizzleD1Database");
  }
});
var init_d1 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.34.1_@cloudflare+workers-types@4.20241022.0_@types+better-sqlite3@7.6.11_better-sqlite3@10.1.0/node_modules/drizzle-orm/d1/index.js"() {
    init_driver();
    init_session3();
  }
});
var hooks_server_exports = {};
__export(hooks_server_exports, {
  handle: () => handle,
  handleAuth: () => handleAuth,
  handleDb: () => handleDb
});
async function createClient(dbInstance) {
  const db = drizzle(dbInstance, { schema, casing: "snake_case" });
  return db;
}
__name(createClient, "createClient");
function sequence(...handlers) {
  const length = handlers.length;
  if (!length)
    return ({ event, resolve: resolve2 }) => resolve2(event);
  return ({ event, resolve: resolve2 }) => {
    return apply_handle(0, event, {});
    function apply_handle(i2, event2, parent_options) {
      const handle2 = handlers[i2];
      return handle2({
        event: event2,
        resolve: (event3, options2) => {
          const transformPageChunk = /* @__PURE__ */ __name(async ({ html, done }) => {
            if (options2?.transformPageChunk) {
              html = await options2.transformPageChunk({ html, done }) ?? "";
            }
            if (parent_options?.transformPageChunk) {
              html = await parent_options.transformPageChunk({ html, done }) ?? "";
            }
            return html;
          }, "transformPageChunk");
          const filterSerializedResponseHeaders = parent_options?.filterSerializedResponseHeaders ?? options2?.filterSerializedResponseHeaders;
          const preload = parent_options?.preload ?? options2?.preload;
          return i2 < length - 1 ? apply_handle(i2 + 1, event3, {
            transformPageChunk,
            filterSerializedResponseHeaders,
            preload
          }) : resolve2(event3, { transformPageChunk, filterSerializedResponseHeaders, preload });
        }
      });
    }
    __name(apply_handle, "apply_handle");
  };
}
__name(sequence, "sequence");
var preloadFonts;
var handleDb;
var handleAuth;
var handle;
var init_hooks_server = __esm({
  ".svelte-kit/output/server/chunks/hooks.server.js"() {
    init_session2();
    init_d1();
    init_schema();
    preloadFonts = /* @__PURE__ */ __name(async ({ event, resolve: resolve2 }) => {
      const response = await resolve2(event, {
        preload: ({ type }) => type === "font"
      });
      return response;
    }, "preloadFonts");
    handleDb = /* @__PURE__ */ __name(async ({ event, resolve: resolve2 }) => {
      const platform2 = event.platform;
      if (platform2) {
        const db = await createClient(platform2.env.DB);
        event.locals.db = db;
      }
      return resolve2(event);
    }, "handleDb");
    handleAuth = /* @__PURE__ */ __name(async ({ event, resolve: resolve2 }) => {
      if (!event.locals.db) {
        console.error("Database not initialized");
        return resolve2(event);
      }
      const token = event.cookies.get("session") ?? null;
      if (token === null) {
        event.locals.user = null;
        event.locals.session = null;
        return resolve2(event);
      }
      const { session, user } = await validateSessionToken(token, event.locals.db);
      if (session !== null) {
        setSessionTokenCookie(event, token, session.expiresAt);
      } else {
        deleteSessionTokenCookie(event);
      }
      event.locals.session = session;
      event.locals.user = user;
      return resolve2(event);
    }, "handleAuth");
    handle = sequence(preloadFonts, handleDb, handleAuth);
  }
});
function error(status, body2) {
  if (isNaN(status) || status < 400 || status > 599) {
    throw new Error(`HTTP error status codes must be between 400 and 599 \u2014 ${status} is invalid`);
  }
  throw new HttpError(status, body2);
}
__name(error, "error");
function redirect(status, location2) {
  if (isNaN(status) || status < 300 || status > 308) {
    throw new Error("Invalid status code");
  }
  throw new Redirect(
    // @ts-ignore
    status,
    location2.toString()
  );
}
__name(redirect, "redirect");
function json(data, init2) {
  const body2 = JSON.stringify(data);
  const headers2 = new Headers(init2?.headers);
  if (!headers2.has("content-length")) {
    headers2.set("content-length", encoder.encode(body2).byteLength.toString());
  }
  if (!headers2.has("content-type")) {
    headers2.set("content-type", "application/json");
  }
  return new Response(body2, {
    ...init2,
    headers: headers2
  });
}
__name(json, "json");
function text2(body2, init2) {
  const headers2 = new Headers(init2?.headers);
  if (!headers2.has("content-length")) {
    const encoded = encoder.encode(body2);
    headers2.set("content-length", encoded.byteLength.toString());
    return new Response(encoded, {
      ...init2,
      headers: headers2
    });
  }
  return new Response(body2, {
    ...init2,
    headers: headers2
  });
}
__name(text2, "text2");
var HttpError;
var Redirect;
var SvelteKitError;
var ActionFailure;
var encoder;
var init_chunks = __esm({
  ".svelte-kit/output/server/chunks/index.js"() {
    HttpError = /* @__PURE__ */ __name(class {
      /**
       * @param {number} status
       * @param {{message: string} extends App.Error ? (App.Error | string | undefined) : App.Error} body
       */
      constructor(status, body2) {
        this.status = status;
        if (typeof body2 === "string") {
          this.body = { message: body2 };
        } else if (body2) {
          this.body = body2;
        } else {
          this.body = { message: `Error: ${status}` };
        }
      }
      toString() {
        return JSON.stringify(this.body);
      }
    }, "HttpError");
    Redirect = /* @__PURE__ */ __name(class {
      /**
       * @param {300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308} status
       * @param {string} location
       */
      constructor(status, location2) {
        this.status = status;
        this.location = location2;
      }
    }, "Redirect");
    SvelteKitError = /* @__PURE__ */ __name(class extends Error {
      /**
       * @param {number} status
       * @param {string} text
       * @param {string} message
       */
      constructor(status, text22, message) {
        super(message);
        this.status = status;
        this.text = text22;
      }
    }, "SvelteKitError");
    ActionFailure = /* @__PURE__ */ __name(class {
      /**
       * @param {number} status
       * @param {T} data
       */
      constructor(status, data) {
        this.status = status;
        this.data = data;
      }
    }, "ActionFailure");
    encoder = new TextEncoder();
  }
});
function resolve(base2, path) {
  if (path[0] === "/" && path[1] === "/")
    return path;
  let url = new URL(base2, internal);
  url = new URL(path, url);
  return url.protocol === internal.protocol ? url.pathname + url.search + url.hash : url.href;
}
__name(resolve, "resolve");
function normalize_path(path, trailing_slash) {
  if (path === "/" || trailing_slash === "ignore")
    return path;
  if (trailing_slash === "never") {
    return path.endsWith("/") ? path.slice(0, -1) : path;
  } else if (trailing_slash === "always" && !path.endsWith("/")) {
    return path + "/";
  }
  return path;
}
__name(normalize_path, "normalize_path");
function decode_pathname(pathname) {
  return pathname.split("%25").map(decodeURI).join("%25");
}
__name(decode_pathname, "decode_pathname");
function decode_params(params) {
  for (const key2 in params) {
    params[key2] = decodeURIComponent(params[key2]);
  }
  return params;
}
__name(decode_params, "decode_params");
function make_trackable(url, callback, search_params_callback) {
  const tracked = new URL(url);
  Object.defineProperty(tracked, "searchParams", {
    value: new Proxy(tracked.searchParams, {
      get(obj, key2) {
        if (key2 === "get" || key2 === "getAll" || key2 === "has") {
          return (param) => {
            search_params_callback(param);
            return obj[key2](param);
          };
        }
        callback();
        const value = Reflect.get(obj, key2);
        return typeof value === "function" ? value.bind(obj) : value;
      }
    }),
    enumerable: true,
    configurable: true
  });
  for (const property of tracked_url_properties) {
    Object.defineProperty(tracked, property, {
      get() {
        callback();
        return url[property];
      },
      enumerable: true,
      configurable: true
    });
  }
  {
    tracked[Symbol.for("nodejs.util.inspect.custom")] = (depth, opts, inspect) => {
      return inspect(url, opts);
    };
    tracked.searchParams[Symbol.for("nodejs.util.inspect.custom")] = (depth, opts, inspect) => {
      return inspect(url.searchParams, opts);
    };
  }
  {
    disable_hash(tracked);
  }
  return tracked;
}
__name(make_trackable, "make_trackable");
function disable_hash(url) {
  allow_nodejs_console_log(url);
  Object.defineProperty(url, "hash", {
    get() {
      throw new Error(
        "Cannot access event.url.hash. Consider using `$page.url.hash` inside a component instead"
      );
    }
  });
}
__name(disable_hash, "disable_hash");
function disable_search(url) {
  allow_nodejs_console_log(url);
  for (const property of ["search", "searchParams"]) {
    Object.defineProperty(url, property, {
      get() {
        throw new Error(`Cannot access url.${property} on a page with prerendering enabled`);
      }
    });
  }
}
__name(disable_search, "disable_search");
function allow_nodejs_console_log(url) {
  {
    url[Symbol.for("nodejs.util.inspect.custom")] = (depth, opts, inspect) => {
      return inspect(new URL(url), opts);
    };
  }
}
__name(allow_nodejs_console_log, "allow_nodejs_console_log");
function has_data_suffix(pathname) {
  return pathname.endsWith(DATA_SUFFIX) || pathname.endsWith(HTML_DATA_SUFFIX);
}
__name(has_data_suffix, "has_data_suffix");
function add_data_suffix(pathname) {
  if (pathname.endsWith(".html"))
    return pathname.replace(/\.html$/, HTML_DATA_SUFFIX);
  return pathname.replace(/\/$/, "") + DATA_SUFFIX;
}
__name(add_data_suffix, "add_data_suffix");
function strip_data_suffix(pathname) {
  if (pathname.endsWith(HTML_DATA_SUFFIX)) {
    return pathname.slice(0, -HTML_DATA_SUFFIX.length) + ".html";
  }
  return pathname.slice(0, -DATA_SUFFIX.length);
}
__name(strip_data_suffix, "strip_data_suffix");
function validator(expected) {
  function validate2(module, file) {
    if (!module)
      return;
    for (const key2 in module) {
      if (key2[0] === "_" || expected.has(key2))
        continue;
      const values = [...expected.values()];
      const hint = hint_for_supported_files(key2, file?.slice(file.lastIndexOf("."))) ?? `valid exports are ${values.join(", ")}, or anything with a '_' prefix`;
      throw new Error(`Invalid export '${key2}'${file ? ` in ${file}` : ""} (${hint})`);
    }
  }
  __name(validate2, "validate2");
  return validate2;
}
__name(validator, "validator");
function hint_for_supported_files(key2, ext = ".js") {
  const supported_files = [];
  if (valid_layout_exports.has(key2)) {
    supported_files.push(`+layout${ext}`);
  }
  if (valid_page_exports.has(key2)) {
    supported_files.push(`+page${ext}`);
  }
  if (valid_layout_server_exports.has(key2)) {
    supported_files.push(`+layout.server${ext}`);
  }
  if (valid_page_server_exports.has(key2)) {
    supported_files.push(`+page.server${ext}`);
  }
  if (valid_server_exports.has(key2)) {
    supported_files.push(`+server${ext}`);
  }
  if (supported_files.length > 0) {
    return `'${key2}' is a valid export in ${supported_files.slice(0, -1).join(", ")}${supported_files.length > 1 ? " or " : ""}${supported_files.at(-1)}`;
  }
}
__name(hint_for_supported_files, "hint_for_supported_files");
var internal;
var tracked_url_properties;
var DATA_SUFFIX;
var HTML_DATA_SUFFIX;
var valid_layout_exports;
var valid_page_exports;
var valid_layout_server_exports;
var valid_page_server_exports;
var valid_server_exports;
var validate_layout_exports;
var validate_page_exports;
var validate_layout_server_exports;
var validate_page_server_exports;
var validate_server_exports;
var init_exports = __esm({
  ".svelte-kit/output/server/chunks/exports.js"() {
    internal = new URL("sveltekit-internal://");
    tracked_url_properties = /** @type {const} */
    [
      "href",
      "pathname",
      "search",
      "toString",
      "toJSON"
    ];
    DATA_SUFFIX = "/__data.json";
    HTML_DATA_SUFFIX = ".html__data.json";
    valid_layout_exports = /* @__PURE__ */ new Set([
      "load",
      "prerender",
      "csr",
      "ssr",
      "trailingSlash",
      "config"
    ]);
    valid_page_exports = /* @__PURE__ */ new Set([...valid_layout_exports, "entries"]);
    valid_layout_server_exports = /* @__PURE__ */ new Set([...valid_layout_exports]);
    valid_page_server_exports = /* @__PURE__ */ new Set([...valid_layout_server_exports, "actions", "entries"]);
    valid_server_exports = /* @__PURE__ */ new Set([
      "GET",
      "POST",
      "PATCH",
      "PUT",
      "DELETE",
      "OPTIONS",
      "HEAD",
      "fallback",
      "prerender",
      "trailingSlash",
      "config",
      "entries"
    ]);
    validate_layout_exports = validator(valid_layout_exports);
    validate_page_exports = validator(valid_page_exports);
    validate_layout_server_exports = validator(valid_layout_server_exports);
    validate_page_server_exports = validator(valid_page_server_exports);
    validate_server_exports = validator(valid_server_exports);
  }
});
function is_primitive(thing) {
  return Object(thing) !== thing;
}
__name(is_primitive, "is_primitive");
function is_plain_object(thing) {
  const proto = Object.getPrototypeOf(thing);
  return proto === Object.prototype || proto === null || Object.getOwnPropertyNames(proto).sort().join("\0") === object_proto_names;
}
__name(is_plain_object, "is_plain_object");
function get_type(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
__name(get_type, "get_type");
function get_escaped_char(char) {
  switch (char) {
    case '"':
      return '\\"';
    case "<":
      return "\\u003C";
    case "\\":
      return "\\\\";
    case "\n":
      return "\\n";
    case "\r":
      return "\\r";
    case "	":
      return "\\t";
    case "\b":
      return "\\b";
    case "\f":
      return "\\f";
    case "\u2028":
      return "\\u2028";
    case "\u2029":
      return "\\u2029";
    default:
      return char < " " ? `\\u${char.charCodeAt(0).toString(16).padStart(4, "0")}` : "";
  }
}
__name(get_escaped_char, "get_escaped_char");
function stringify_string(str) {
  let result = "";
  let last_pos = 0;
  const len = str.length;
  for (let i2 = 0; i2 < len; i2 += 1) {
    const char = str[i2];
    const replacement = get_escaped_char(char);
    if (replacement) {
      result += str.slice(last_pos, i2) + replacement;
      last_pos = i2 + 1;
    }
  }
  return `"${last_pos === 0 ? str : result + str.slice(last_pos)}"`;
}
__name(stringify_string, "stringify_string");
function enumerable_symbols(object) {
  return Object.getOwnPropertySymbols(object).filter(
    (symbol) => Object.getOwnPropertyDescriptor(object, symbol).enumerable
  );
}
__name(enumerable_symbols, "enumerable_symbols");
function stringify_key(key2) {
  return is_identifier.test(key2) ? "." + key2 : "[" + JSON.stringify(key2) + "]";
}
__name(stringify_key, "stringify_key");
function encode64(arraybuffer) {
  const dv = new DataView(arraybuffer);
  let binaryString = "";
  for (let i2 = 0; i2 < arraybuffer.byteLength; i2++) {
    binaryString += String.fromCharCode(dv.getUint8(i2));
  }
  return binaryToAscii(binaryString);
}
__name(encode64, "encode64");
function decode64(string) {
  const binaryString = asciiToBinary(string);
  const arraybuffer = new ArrayBuffer(binaryString.length);
  const dv = new DataView(arraybuffer);
  for (let i2 = 0; i2 < arraybuffer.byteLength; i2++) {
    dv.setUint8(i2, binaryString.charCodeAt(i2));
  }
  return arraybuffer;
}
__name(decode64, "decode64");
function asciiToBinary(data) {
  if (data.length % 4 === 0) {
    data = data.replace(/==?$/, "");
  }
  let output = "";
  let buffer = 0;
  let accumulatedBits = 0;
  for (let i2 = 0; i2 < data.length; i2++) {
    buffer <<= 6;
    buffer |= KEY_STRING.indexOf(data[i2]);
    accumulatedBits += 6;
    if (accumulatedBits === 24) {
      output += String.fromCharCode((buffer & 16711680) >> 16);
      output += String.fromCharCode((buffer & 65280) >> 8);
      output += String.fromCharCode(buffer & 255);
      buffer = accumulatedBits = 0;
    }
  }
  if (accumulatedBits === 12) {
    buffer >>= 4;
    output += String.fromCharCode(buffer);
  } else if (accumulatedBits === 18) {
    buffer >>= 2;
    output += String.fromCharCode((buffer & 65280) >> 8);
    output += String.fromCharCode(buffer & 255);
  }
  return output;
}
__name(asciiToBinary, "asciiToBinary");
function binaryToAscii(str) {
  let out = "";
  for (let i2 = 0; i2 < str.length; i2 += 3) {
    const groupsOfSix = [void 0, void 0, void 0, void 0];
    groupsOfSix[0] = str.charCodeAt(i2) >> 2;
    groupsOfSix[1] = (str.charCodeAt(i2) & 3) << 4;
    if (str.length > i2 + 1) {
      groupsOfSix[1] |= str.charCodeAt(i2 + 1) >> 4;
      groupsOfSix[2] = (str.charCodeAt(i2 + 1) & 15) << 2;
    }
    if (str.length > i2 + 2) {
      groupsOfSix[2] |= str.charCodeAt(i2 + 2) >> 6;
      groupsOfSix[3] = str.charCodeAt(i2 + 2) & 63;
    }
    for (let j2 = 0; j2 < groupsOfSix.length; j2++) {
      if (typeof groupsOfSix[j2] === "undefined") {
        out += "=";
      } else {
        out += KEY_STRING[groupsOfSix[j2]];
      }
    }
  }
  return out;
}
__name(binaryToAscii, "binaryToAscii");
function stringify2(value, reducers) {
  const stringified = [];
  const indexes = /* @__PURE__ */ new Map();
  const custom2 = [];
  if (reducers) {
    for (const key2 of Object.getOwnPropertyNames(reducers)) {
      custom2.push({ key: key2, fn: reducers[key2] });
    }
  }
  const keys = [];
  let p2 = 0;
  function flatten(thing) {
    if (typeof thing === "function") {
      throw new DevalueError(`Cannot stringify a function`, keys);
    }
    if (indexes.has(thing))
      return indexes.get(thing);
    if (thing === void 0)
      return UNDEFINED;
    if (Number.isNaN(thing))
      return NAN;
    if (thing === Infinity)
      return POSITIVE_INFINITY;
    if (thing === -Infinity)
      return NEGATIVE_INFINITY;
    if (thing === 0 && 1 / thing < 0)
      return NEGATIVE_ZERO;
    const index210 = p2++;
    indexes.set(thing, index210);
    for (const { key: key2, fn } of custom2) {
      const value2 = fn(thing);
      if (value2) {
        stringified[index210] = `["${key2}",${flatten(value2)}]`;
        return index210;
      }
    }
    let str = "";
    if (is_primitive(thing)) {
      str = stringify_primitive(thing);
    } else {
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          str = `["Object",${stringify_primitive(thing)}]`;
          break;
        case "BigInt":
          str = `["BigInt",${thing}]`;
          break;
        case "Date":
          const valid = !isNaN(thing.getDate());
          str = `["Date","${valid ? thing.toISOString() : ""}"]`;
          break;
        case "RegExp":
          const { source: source2, flags } = thing;
          str = flags ? `["RegExp",${stringify_string(source2)},"${flags}"]` : `["RegExp",${stringify_string(source2)}]`;
          break;
        case "Array":
          str = "[";
          for (let i2 = 0; i2 < thing.length; i2 += 1) {
            if (i2 > 0)
              str += ",";
            if (i2 in thing) {
              keys.push(`[${i2}]`);
              str += flatten(thing[i2]);
              keys.pop();
            } else {
              str += HOLE;
            }
          }
          str += "]";
          break;
        case "Set":
          str = '["Set"';
          for (const value2 of thing) {
            str += `,${flatten(value2)}`;
          }
          str += "]";
          break;
        case "Map":
          str = '["Map"';
          for (const [key2, value2] of thing) {
            keys.push(
              `.get(${is_primitive(key2) ? stringify_primitive(key2) : "..."})`
            );
            str += `,${flatten(key2)},${flatten(value2)}`;
            keys.pop();
          }
          str += "]";
          break;
        case "Int8Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Int16Array":
        case "Uint16Array":
        case "Int32Array":
        case "Uint32Array":
        case "Float32Array":
        case "Float64Array":
        case "BigInt64Array":
        case "BigUint64Array": {
          const typedArray = thing;
          const base642 = encode64(typedArray.buffer);
          str = '["' + type + '","' + base642 + '"]';
          break;
        }
        case "ArrayBuffer": {
          const arraybuffer = thing;
          const base642 = encode64(arraybuffer);
          str = `["ArrayBuffer","${base642}"]`;
          break;
        }
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys
            );
          }
          if (enumerable_symbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys
            );
          }
          if (Object.getPrototypeOf(thing) === null) {
            str = '["null"';
            for (const key2 in thing) {
              keys.push(stringify_key(key2));
              str += `,${stringify_string(key2)},${flatten(thing[key2])}`;
              keys.pop();
            }
            str += "]";
          } else {
            str = "{";
            let started = false;
            for (const key2 in thing) {
              if (started)
                str += ",";
              started = true;
              keys.push(stringify_key(key2));
              str += `${stringify_string(key2)}:${flatten(thing[key2])}`;
              keys.pop();
            }
            str += "}";
          }
      }
    }
    stringified[index210] = str;
    return index210;
  }
  __name(flatten, "flatten");
  const index39 = flatten(value);
  if (index39 < 0)
    return `${index39}`;
  return `[${stringified.join(",")}]`;
}
__name(stringify2, "stringify2");
function stringify_primitive(thing) {
  const type = typeof thing;
  if (type === "string")
    return stringify_string(thing);
  if (thing instanceof String)
    return stringify_string(thing.toString());
  if (thing === void 0)
    return UNDEFINED.toString();
  if (thing === 0 && 1 / thing < 0)
    return NEGATIVE_ZERO.toString();
  if (type === "bigint")
    return `["BigInt","${thing}"]`;
  return String(thing);
}
__name(stringify_primitive, "stringify_primitive");
var escaped;
var DevalueError;
var object_proto_names;
var is_identifier;
var KEY_STRING;
var UNDEFINED;
var HOLE;
var NAN;
var POSITIVE_INFINITY;
var NEGATIVE_INFINITY;
var NEGATIVE_ZERO;
var init_stringify = __esm({
  ".svelte-kit/output/server/chunks/stringify.js"() {
    escaped = {
      "<": "\\u003C",
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    DevalueError = /* @__PURE__ */ __name(class extends Error {
      /**
       * @param {string} message
       * @param {string[]} keys
       */
      constructor(message, keys) {
        super(message);
        this.name = "DevalueError";
        this.path = keys.join("");
      }
    }, "DevalueError");
    object_proto_names = /* @__PURE__ */ Object.getOwnPropertyNames(
      Object.prototype
    ).sort().join("\0");
    is_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
    KEY_STRING = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    UNDEFINED = -1;
    HOLE = -2;
    NAN = -3;
    POSITIVE_INFINITY = -4;
    NEGATIVE_INFINITY = -5;
    NEGATIVE_ZERO = -6;
  }
});
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
__name(readable, "readable");
function writable(value, start = noop) {
  let stop = null;
  const subscribers = /* @__PURE__ */ new Set();
  function set3(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue.length; i2 += 2) {
            subscriber_queue[i2][0](subscriber_queue[i2 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  __name(set3, "set3");
  function update(fn) {
    set3(fn(
      /** @type {T} */
      value
    ));
  }
  __name(update, "update");
  function subscribe(run, invalidate = noop) {
    const subscriber = [run, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set3, update) || noop;
    }
    run(
      /** @type {T} */
      value
    );
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  __name(subscribe, "subscribe");
  return { set: set3, update, subscribe };
}
__name(writable, "writable");
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  if (!stores_array.every(Boolean)) {
    throw new Error("derived() expects stores as input, got a falsy value");
  }
  const auto = fn.length < 2;
  return readable(initial_value, (set3, update) => {
    let started = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = /* @__PURE__ */ __name(() => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set3, update);
      if (auto) {
        set3(result);
      } else {
        cleanup = typeof result === "function" ? result : noop;
      }
    }, "sync");
    const unsubscribers = stores_array.map(
      (store, i2) => subscribe_to_store(
        store,
        (value) => {
          values[i2] = value;
          pending &= ~(1 << i2);
          if (started) {
            sync();
          }
        },
        () => {
          pending |= 1 << i2;
        }
      )
    );
    started = true;
    sync();
    return /* @__PURE__ */ __name(function stop() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    }, "stop");
  });
}
__name(derived, "derived");
function readonly(store) {
  return {
    // @ts-expect-error TODO i suspect the bind is unnecessary
    subscribe: store.subscribe.bind(store)
  };
}
__name(readonly, "readonly");
function get2(store) {
  let value;
  subscribe_to_store(store, (_2) => value = _2)();
  return value;
}
__name(get2, "get2");
var subscriber_queue;
var init_index4 = __esm({
  ".svelte-kit/output/server/chunks/index4.js"() {
    init_index2();
    subscriber_queue = [];
  }
});
function get3(key2, parse3 = JSON.parse) {
  try {
    return parse3(sessionStorage[key2]);
  } catch {
  }
}
__name(get3, "get3");
function invalidateAll() {
  {
    throw new Error("Cannot call invalidateAll() on the server");
  }
}
__name(invalidateAll, "invalidateAll");
async function applyAction(result) {
  {
    throw new Error("Cannot call applyAction(...) on the server");
  }
}
__name(applyAction, "applyAction");
var SNAPSHOT_KEY;
var SCROLL_KEY;
var init_client = __esm({
  ".svelte-kit/output/server/chunks/client.js"() {
    init_exports();
    SNAPSHOT_KEY = "sveltekit:snapshot";
    SCROLL_KEY = "sveltekit:scroll";
    get3(SCROLL_KEY) ?? {};
    get3(SNAPSHOT_KEY) ?? {};
  }
});
var getStores;
var page;
var navigating;
var init_stores = __esm({
  ".svelte-kit/output/server/chunks/stores.js"() {
    init_index2();
    init_client();
    getStores = /* @__PURE__ */ __name(() => {
      const stores = getContext("__svelte__");
      return {
        /** @type {typeof page} */
        page: {
          subscribe: stores.page.subscribe
        },
        /** @type {typeof navigating} */
        navigating: {
          subscribe: stores.navigating.subscribe
        },
        /** @type {typeof updated} */
        updated: stores.updated
      };
    }, "getStores");
    page = {
      subscribe(fn) {
        const store = getStores().page;
        return store.subscribe(fn);
      }
    };
    navigating = {
      subscribe(fn) {
        const store = getStores().navigating;
        return store.subscribe(fn);
      }
    };
  }
});
function r(e3) {
  var t2, f, n2 = "";
  if ("string" == typeof e3 || "number" == typeof e3)
    n2 += e3;
  else if ("object" == typeof e3)
    if (Array.isArray(e3)) {
      var o2 = e3.length;
      for (t2 = 0; t2 < o2; t2++)
        e3[t2] && (f = r(e3[t2])) && (n2 && (n2 += " "), n2 += f);
    } else
      for (f in e3)
        e3[f] && (n2 && (n2 += " "), n2 += f);
  return n2;
}
__name(r, "r");
function clsx() {
  for (var e3, t2, f = 0, n2 = "", o2 = arguments.length; f < o2; f++)
    (e3 = arguments[f]) && (t2 = r(e3)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
__name(clsx, "clsx");
var init_clsx = __esm({
  "node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs"() {
  }
});
function twJoin() {
  let index39 = 0;
  let argument;
  let resolvedValue;
  let string = "";
  while (index39 < arguments.length) {
    if (argument = arguments[index39++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
__name(twJoin, "twJoin");
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall = initTailwindMerge;
  function initTailwindMerge(classList) {
    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  }
  __name(initTailwindMerge, "initTailwindMerge");
  function tailwindMerge(classList) {
    const cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  }
  __name(tailwindMerge, "tailwindMerge");
  return /* @__PURE__ */ __name(function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  }, "callTailwindMerge");
}
__name(createTailwindMerge, "createTailwindMerge");
var CLASS_PART_SEPARATOR;
var createClassGroupUtils;
var getGroupRecursive;
var arbitraryPropertyRegex;
var getGroupIdForArbitraryProperty;
var createClassMap;
var processClassesRecursively;
var getPart;
var isThemeGetter;
var getPrefixedClassGroupEntries;
var createLruCache;
var IMPORTANT_MODIFIER;
var createParseClassName;
var sortModifiers;
var createConfigUtils;
var SPLIT_CLASSES_REGEX;
var mergeClassList;
var toValue;
var fromTheme;
var arbitraryValueRegex;
var fractionRegex;
var stringLengths;
var tshirtUnitRegex;
var lengthUnitRegex;
var colorFunctionRegex;
var shadowRegex;
var imageRegex;
var isLength;
var isArbitraryLength;
var isNumber;
var isArbitraryNumber;
var isInteger;
var isPercent;
var isArbitraryValue;
var isTshirtSize;
var sizeLabels;
var isArbitrarySize;
var isArbitraryPosition;
var imageLabels;
var isArbitraryImage;
var isArbitraryShadow;
var isAny;
var getIsArbitraryValue;
var isLengthOnly;
var isNever;
var isShadow;
var isImage;
var getDefaultConfig;
var mergeConfigs;
var overrideProperty;
var overrideConfigProperties;
var mergeConfigProperties;
var extendTailwindMerge;
var twMerge;
var init_bundle_mjs = __esm({
  "node_modules/.pnpm/tailwind-merge@2.5.4/node_modules/tailwind-merge/dist/bundle-mjs.mjs"() {
    CLASS_PART_SEPARATOR = "-";
    createClassGroupUtils = /* @__PURE__ */ __name((config) => {
      const classMap = createClassMap(config);
      const {
        conflictingClassGroups,
        conflictingClassGroupModifiers
      } = config;
      const getClassGroupId = /* @__PURE__ */ __name((className) => {
        const classParts = className.split(CLASS_PART_SEPARATOR);
        if (classParts[0] === "" && classParts.length !== 1) {
          classParts.shift();
        }
        return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
      }, "getClassGroupId");
      const getConflictingClassGroupIds = /* @__PURE__ */ __name((classGroupId, hasPostfixModifier) => {
        const conflicts = conflictingClassGroups[classGroupId] || [];
        if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
          return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
        }
        return conflicts;
      }, "getConflictingClassGroupIds");
      return {
        getClassGroupId,
        getConflictingClassGroupIds
      };
    }, "createClassGroupUtils");
    getGroupRecursive = /* @__PURE__ */ __name((classParts, classPartObject) => {
      if (classParts.length === 0) {
        return classPartObject.classGroupId;
      }
      const currentClassPart = classParts[0];
      const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
      const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
      if (classGroupFromNextClassPart) {
        return classGroupFromNextClassPart;
      }
      if (classPartObject.validators.length === 0) {
        return void 0;
      }
      const classRest = classParts.join(CLASS_PART_SEPARATOR);
      return classPartObject.validators.find(({
        validator: validator2
      }) => validator2(classRest))?.classGroupId;
    }, "getGroupRecursive");
    arbitraryPropertyRegex = /^\[(.+)\]$/;
    getGroupIdForArbitraryProperty = /* @__PURE__ */ __name((className) => {
      if (arbitraryPropertyRegex.test(className)) {
        const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
        const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(":"));
        if (property) {
          return "arbitrary.." + property;
        }
      }
    }, "getGroupIdForArbitraryProperty");
    createClassMap = /* @__PURE__ */ __name((config) => {
      const {
        theme,
        prefix
      } = config;
      const classMap = {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      };
      const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);
      prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
        processClassesRecursively(classGroup, classMap, classGroupId, theme);
      });
      return classMap;
    }, "createClassMap");
    processClassesRecursively = /* @__PURE__ */ __name((classGroup, classPartObject, classGroupId, theme) => {
      classGroup.forEach((classDefinition) => {
        if (typeof classDefinition === "string") {
          const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
          classPartObjectToEdit.classGroupId = classGroupId;
          return;
        }
        if (typeof classDefinition === "function") {
          if (isThemeGetter(classDefinition)) {
            processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
            return;
          }
          classPartObject.validators.push({
            validator: classDefinition,
            classGroupId
          });
          return;
        }
        Object.entries(classDefinition).forEach(([key2, classGroup2]) => {
          processClassesRecursively(classGroup2, getPart(classPartObject, key2), classGroupId, theme);
        });
      });
    }, "processClassesRecursively");
    getPart = /* @__PURE__ */ __name((classPartObject, path) => {
      let currentClassPartObject = classPartObject;
      path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
        if (!currentClassPartObject.nextPart.has(pathPart)) {
          currentClassPartObject.nextPart.set(pathPart, {
            nextPart: /* @__PURE__ */ new Map(),
            validators: []
          });
        }
        currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
      });
      return currentClassPartObject;
    }, "getPart");
    isThemeGetter = /* @__PURE__ */ __name((func) => func.isThemeGetter, "isThemeGetter");
    getPrefixedClassGroupEntries = /* @__PURE__ */ __name((classGroupEntries, prefix) => {
      if (!prefix) {
        return classGroupEntries;
      }
      return classGroupEntries.map(([classGroupId, classGroup]) => {
        const prefixedClassGroup = classGroup.map((classDefinition) => {
          if (typeof classDefinition === "string") {
            return prefix + classDefinition;
          }
          if (typeof classDefinition === "object") {
            return Object.fromEntries(Object.entries(classDefinition).map(([key2, value]) => [prefix + key2, value]));
          }
          return classDefinition;
        });
        return [classGroupId, prefixedClassGroup];
      });
    }, "getPrefixedClassGroupEntries");
    createLruCache = /* @__PURE__ */ __name((maxCacheSize) => {
      if (maxCacheSize < 1) {
        return {
          get: () => void 0,
          set: () => {
          }
        };
      }
      let cacheSize = 0;
      let cache2 = /* @__PURE__ */ new Map();
      let previousCache = /* @__PURE__ */ new Map();
      const update = /* @__PURE__ */ __name((key2, value) => {
        cache2.set(key2, value);
        cacheSize++;
        if (cacheSize > maxCacheSize) {
          cacheSize = 0;
          previousCache = cache2;
          cache2 = /* @__PURE__ */ new Map();
        }
      }, "update");
      return {
        get(key2) {
          let value = cache2.get(key2);
          if (value !== void 0) {
            return value;
          }
          if ((value = previousCache.get(key2)) !== void 0) {
            update(key2, value);
            return value;
          }
        },
        set(key2, value) {
          if (cache2.has(key2)) {
            cache2.set(key2, value);
          } else {
            update(key2, value);
          }
        }
      };
    }, "createLruCache");
    IMPORTANT_MODIFIER = "!";
    createParseClassName = /* @__PURE__ */ __name((config) => {
      const {
        separator,
        experimentalParseClassName
      } = config;
      const isSeparatorSingleCharacter = separator.length === 1;
      const firstSeparatorCharacter = separator[0];
      const separatorLength = separator.length;
      const parseClassName = /* @__PURE__ */ __name((className) => {
        const modifiers = [];
        let bracketDepth = 0;
        let modifierStart = 0;
        let postfixModifierPosition;
        for (let index39 = 0; index39 < className.length; index39++) {
          let currentCharacter = className[index39];
          if (bracketDepth === 0) {
            if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index39, index39 + separatorLength) === separator)) {
              modifiers.push(className.slice(modifierStart, index39));
              modifierStart = index39 + separatorLength;
              continue;
            }
            if (currentCharacter === "/") {
              postfixModifierPosition = index39;
              continue;
            }
          }
          if (currentCharacter === "[") {
            bracketDepth++;
          } else if (currentCharacter === "]") {
            bracketDepth--;
          }
        }
        const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
        const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
        const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
        const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
        return {
          modifiers,
          hasImportantModifier,
          baseClassName,
          maybePostfixModifierPosition
        };
      }, "parseClassName");
      if (experimentalParseClassName) {
        return (className) => experimentalParseClassName({
          className,
          parseClassName
        });
      }
      return parseClassName;
    }, "createParseClassName");
    sortModifiers = /* @__PURE__ */ __name((modifiers) => {
      if (modifiers.length <= 1) {
        return modifiers;
      }
      const sortedModifiers = [];
      let unsortedModifiers = [];
      modifiers.forEach((modifier) => {
        const isArbitraryVariant = modifier[0] === "[";
        if (isArbitraryVariant) {
          sortedModifiers.push(...unsortedModifiers.sort(), modifier);
          unsortedModifiers = [];
        } else {
          unsortedModifiers.push(modifier);
        }
      });
      sortedModifiers.push(...unsortedModifiers.sort());
      return sortedModifiers;
    }, "sortModifiers");
    createConfigUtils = /* @__PURE__ */ __name((config) => ({
      cache: createLruCache(config.cacheSize),
      parseClassName: createParseClassName(config),
      ...createClassGroupUtils(config)
    }), "createConfigUtils");
    SPLIT_CLASSES_REGEX = /\s+/;
    mergeClassList = /* @__PURE__ */ __name((classList, configUtils) => {
      const {
        parseClassName,
        getClassGroupId,
        getConflictingClassGroupIds
      } = configUtils;
      const classGroupsInConflict = [];
      const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
      let result = "";
      for (let index39 = classNames.length - 1; index39 >= 0; index39 -= 1) {
        const originalClassName = classNames[index39];
        const {
          modifiers,
          hasImportantModifier,
          baseClassName,
          maybePostfixModifierPosition
        } = parseClassName(originalClassName);
        let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
        let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
        if (!classGroupId) {
          if (!hasPostfixModifier) {
            result = originalClassName + (result.length > 0 ? " " + result : result);
            continue;
          }
          classGroupId = getClassGroupId(baseClassName);
          if (!classGroupId) {
            result = originalClassName + (result.length > 0 ? " " + result : result);
            continue;
          }
          hasPostfixModifier = false;
        }
        const variantModifier = sortModifiers(modifiers).join(":");
        const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
        const classId = modifierId + classGroupId;
        if (classGroupsInConflict.includes(classId)) {
          continue;
        }
        classGroupsInConflict.push(classId);
        const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
        for (let i2 = 0; i2 < conflictGroups.length; ++i2) {
          const group = conflictGroups[i2];
          classGroupsInConflict.push(modifierId + group);
        }
        result = originalClassName + (result.length > 0 ? " " + result : result);
      }
      return result;
    }, "mergeClassList");
    toValue = /* @__PURE__ */ __name((mix) => {
      if (typeof mix === "string") {
        return mix;
      }
      let resolvedValue;
      let string = "";
      for (let k = 0; k < mix.length; k++) {
        if (mix[k]) {
          if (resolvedValue = toValue(mix[k])) {
            string && (string += " ");
            string += resolvedValue;
          }
        }
      }
      return string;
    }, "toValue");
    fromTheme = /* @__PURE__ */ __name((key2) => {
      const themeGetter = /* @__PURE__ */ __name((theme) => theme[key2] || [], "themeGetter");
      themeGetter.isThemeGetter = true;
      return themeGetter;
    }, "fromTheme");
    arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
    fractionRegex = /^\d+\/\d+$/;
    stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
    tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
    lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
    colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
    shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
    imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
    isLength = /* @__PURE__ */ __name((value) => isNumber(value) || stringLengths.has(value) || fractionRegex.test(value), "isLength");
    isArbitraryLength = /* @__PURE__ */ __name((value) => getIsArbitraryValue(value, "length", isLengthOnly), "isArbitraryLength");
    isNumber = /* @__PURE__ */ __name((value) => Boolean(value) && !Number.isNaN(Number(value)), "isNumber");
    isArbitraryNumber = /* @__PURE__ */ __name((value) => getIsArbitraryValue(value, "number", isNumber), "isArbitraryNumber");
    isInteger = /* @__PURE__ */ __name((value) => Boolean(value) && Number.isInteger(Number(value)), "isInteger");
    isPercent = /* @__PURE__ */ __name((value) => value.endsWith("%") && isNumber(value.slice(0, -1)), "isPercent");
    isArbitraryValue = /* @__PURE__ */ __name((value) => arbitraryValueRegex.test(value), "isArbitraryValue");
    isTshirtSize = /* @__PURE__ */ __name((value) => tshirtUnitRegex.test(value), "isTshirtSize");
    sizeLabels = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
    isArbitrarySize = /* @__PURE__ */ __name((value) => getIsArbitraryValue(value, sizeLabels, isNever), "isArbitrarySize");
    isArbitraryPosition = /* @__PURE__ */ __name((value) => getIsArbitraryValue(value, "position", isNever), "isArbitraryPosition");
    imageLabels = /* @__PURE__ */ new Set(["image", "url"]);
    isArbitraryImage = /* @__PURE__ */ __name((value) => getIsArbitraryValue(value, imageLabels, isImage), "isArbitraryImage");
    isArbitraryShadow = /* @__PURE__ */ __name((value) => getIsArbitraryValue(value, "", isShadow), "isArbitraryShadow");
    isAny = /* @__PURE__ */ __name(() => true, "isAny");
    getIsArbitraryValue = /* @__PURE__ */ __name((value, label, testValue) => {
      const result = arbitraryValueRegex.exec(value);
      if (result) {
        if (result[1]) {
          return typeof label === "string" ? result[1] === label : label.has(result[1]);
        }
        return testValue(result[2]);
      }
      return false;
    }, "getIsArbitraryValue");
    isLengthOnly = /* @__PURE__ */ __name((value) => (
      // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
      // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
      // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
      lengthUnitRegex.test(value) && !colorFunctionRegex.test(value)
    ), "isLengthOnly");
    isNever = /* @__PURE__ */ __name(() => false, "isNever");
    isShadow = /* @__PURE__ */ __name((value) => shadowRegex.test(value), "isShadow");
    isImage = /* @__PURE__ */ __name((value) => imageRegex.test(value), "isImage");
    getDefaultConfig = /* @__PURE__ */ __name(() => {
      const colors = fromTheme("colors");
      const spacing = fromTheme("spacing");
      const blur = fromTheme("blur");
      const brightness = fromTheme("brightness");
      const borderColor = fromTheme("borderColor");
      const borderRadius = fromTheme("borderRadius");
      const borderSpacing = fromTheme("borderSpacing");
      const borderWidth = fromTheme("borderWidth");
      const contrast = fromTheme("contrast");
      const grayscale = fromTheme("grayscale");
      const hueRotate = fromTheme("hueRotate");
      const invert = fromTheme("invert");
      const gap = fromTheme("gap");
      const gradientColorStops = fromTheme("gradientColorStops");
      const gradientColorStopPositions = fromTheme("gradientColorStopPositions");
      const inset = fromTheme("inset");
      const margin = fromTheme("margin");
      const opacity = fromTheme("opacity");
      const padding = fromTheme("padding");
      const saturate = fromTheme("saturate");
      const scale = fromTheme("scale");
      const sepia = fromTheme("sepia");
      const skew = fromTheme("skew");
      const space = fromTheme("space");
      const translate = fromTheme("translate");
      const getOverscroll = /* @__PURE__ */ __name(() => ["auto", "contain", "none"], "getOverscroll");
      const getOverflow = /* @__PURE__ */ __name(() => ["auto", "hidden", "clip", "visible", "scroll"], "getOverflow");
      const getSpacingWithAutoAndArbitrary = /* @__PURE__ */ __name(() => ["auto", isArbitraryValue, spacing], "getSpacingWithAutoAndArbitrary");
      const getSpacingWithArbitrary = /* @__PURE__ */ __name(() => [isArbitraryValue, spacing], "getSpacingWithArbitrary");
      const getLengthWithEmptyAndArbitrary = /* @__PURE__ */ __name(() => ["", isLength, isArbitraryLength], "getLengthWithEmptyAndArbitrary");
      const getNumberWithAutoAndArbitrary = /* @__PURE__ */ __name(() => ["auto", isNumber, isArbitraryValue], "getNumberWithAutoAndArbitrary");
      const getPositions = /* @__PURE__ */ __name(() => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], "getPositions");
      const getLineStyles = /* @__PURE__ */ __name(() => ["solid", "dashed", "dotted", "double", "none"], "getLineStyles");
      const getBlendModes = /* @__PURE__ */ __name(() => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], "getBlendModes");
      const getAlign = /* @__PURE__ */ __name(() => ["start", "end", "center", "between", "around", "evenly", "stretch"], "getAlign");
      const getZeroAndEmpty = /* @__PURE__ */ __name(() => ["", "0", isArbitraryValue], "getZeroAndEmpty");
      const getBreaks = /* @__PURE__ */ __name(() => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], "getBreaks");
      const getNumberAndArbitrary = /* @__PURE__ */ __name(() => [isNumber, isArbitraryValue], "getNumberAndArbitrary");
      return {
        cacheSize: 500,
        separator: ":",
        theme: {
          colors: [isAny],
          spacing: [isLength, isArbitraryLength],
          blur: ["none", "", isTshirtSize, isArbitraryValue],
          brightness: getNumberAndArbitrary(),
          borderColor: [colors],
          borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
          borderSpacing: getSpacingWithArbitrary(),
          borderWidth: getLengthWithEmptyAndArbitrary(),
          contrast: getNumberAndArbitrary(),
          grayscale: getZeroAndEmpty(),
          hueRotate: getNumberAndArbitrary(),
          invert: getZeroAndEmpty(),
          gap: getSpacingWithArbitrary(),
          gradientColorStops: [colors],
          gradientColorStopPositions: [isPercent, isArbitraryLength],
          inset: getSpacingWithAutoAndArbitrary(),
          margin: getSpacingWithAutoAndArbitrary(),
          opacity: getNumberAndArbitrary(),
          padding: getSpacingWithArbitrary(),
          saturate: getNumberAndArbitrary(),
          scale: getNumberAndArbitrary(),
          sepia: getZeroAndEmpty(),
          skew: getNumberAndArbitrary(),
          space: getSpacingWithArbitrary(),
          translate: getSpacingWithArbitrary()
        },
        classGroups: {
          // Layout
          /**
           * Aspect Ratio
           * @see https://tailwindcss.com/docs/aspect-ratio
           */
          aspect: [{
            aspect: ["auto", "square", "video", isArbitraryValue]
          }],
          /**
           * Container
           * @see https://tailwindcss.com/docs/container
           */
          container: ["container"],
          /**
           * Columns
           * @see https://tailwindcss.com/docs/columns
           */
          columns: [{
            columns: [isTshirtSize]
          }],
          /**
           * Break After
           * @see https://tailwindcss.com/docs/break-after
           */
          "break-after": [{
            "break-after": getBreaks()
          }],
          /**
           * Break Before
           * @see https://tailwindcss.com/docs/break-before
           */
          "break-before": [{
            "break-before": getBreaks()
          }],
          /**
           * Break Inside
           * @see https://tailwindcss.com/docs/break-inside
           */
          "break-inside": [{
            "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
          }],
          /**
           * Box Decoration Break
           * @see https://tailwindcss.com/docs/box-decoration-break
           */
          "box-decoration": [{
            "box-decoration": ["slice", "clone"]
          }],
          /**
           * Box Sizing
           * @see https://tailwindcss.com/docs/box-sizing
           */
          box: [{
            box: ["border", "content"]
          }],
          /**
           * Display
           * @see https://tailwindcss.com/docs/display
           */
          display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
          /**
           * Floats
           * @see https://tailwindcss.com/docs/float
           */
          float: [{
            float: ["right", "left", "none", "start", "end"]
          }],
          /**
           * Clear
           * @see https://tailwindcss.com/docs/clear
           */
          clear: [{
            clear: ["left", "right", "both", "none", "start", "end"]
          }],
          /**
           * Isolation
           * @see https://tailwindcss.com/docs/isolation
           */
          isolation: ["isolate", "isolation-auto"],
          /**
           * Object Fit
           * @see https://tailwindcss.com/docs/object-fit
           */
          "object-fit": [{
            object: ["contain", "cover", "fill", "none", "scale-down"]
          }],
          /**
           * Object Position
           * @see https://tailwindcss.com/docs/object-position
           */
          "object-position": [{
            object: [...getPositions(), isArbitraryValue]
          }],
          /**
           * Overflow
           * @see https://tailwindcss.com/docs/overflow
           */
          overflow: [{
            overflow: getOverflow()
          }],
          /**
           * Overflow X
           * @see https://tailwindcss.com/docs/overflow
           */
          "overflow-x": [{
            "overflow-x": getOverflow()
          }],
          /**
           * Overflow Y
           * @see https://tailwindcss.com/docs/overflow
           */
          "overflow-y": [{
            "overflow-y": getOverflow()
          }],
          /**
           * Overscroll Behavior
           * @see https://tailwindcss.com/docs/overscroll-behavior
           */
          overscroll: [{
            overscroll: getOverscroll()
          }],
          /**
           * Overscroll Behavior X
           * @see https://tailwindcss.com/docs/overscroll-behavior
           */
          "overscroll-x": [{
            "overscroll-x": getOverscroll()
          }],
          /**
           * Overscroll Behavior Y
           * @see https://tailwindcss.com/docs/overscroll-behavior
           */
          "overscroll-y": [{
            "overscroll-y": getOverscroll()
          }],
          /**
           * Position
           * @see https://tailwindcss.com/docs/position
           */
          position: ["static", "fixed", "absolute", "relative", "sticky"],
          /**
           * Top / Right / Bottom / Left
           * @see https://tailwindcss.com/docs/top-right-bottom-left
           */
          inset: [{
            inset: [inset]
          }],
          /**
           * Right / Left
           * @see https://tailwindcss.com/docs/top-right-bottom-left
           */
          "inset-x": [{
            "inset-x": [inset]
          }],
          /**
           * Top / Bottom
           * @see https://tailwindcss.com/docs/top-right-bottom-left
           */
          "inset-y": [{
            "inset-y": [inset]
          }],
          /**
           * Start
           * @see https://tailwindcss.com/docs/top-right-bottom-left
           */
          start: [{
            start: [inset]
          }],
          /**
           * End
           * @see https://tailwindcss.com/docs/top-right-bottom-left
           */
          end: [{
            end: [inset]
          }],
          /**
           * Top
           * @see https://tailwindcss.com/docs/top-right-bottom-left
           */
          top: [{
            top: [inset]
          }],
          /**
           * Right
           * @see https://tailwindcss.com/docs/top-right-bottom-left
           */
          right: [{
            right: [inset]
          }],
          /**
           * Bottom
           * @see https://tailwindcss.com/docs/top-right-bottom-left
           */
          bottom: [{
            bottom: [inset]
          }],
          /**
           * Left
           * @see https://tailwindcss.com/docs/top-right-bottom-left
           */
          left: [{
            left: [inset]
          }],
          /**
           * Visibility
           * @see https://tailwindcss.com/docs/visibility
           */
          visibility: ["visible", "invisible", "collapse"],
          /**
           * Z-Index
           * @see https://tailwindcss.com/docs/z-index
           */
          z: [{
            z: ["auto", isInteger, isArbitraryValue]
          }],
          // Flexbox and Grid
          /**
           * Flex Basis
           * @see https://tailwindcss.com/docs/flex-basis
           */
          basis: [{
            basis: getSpacingWithAutoAndArbitrary()
          }],
          /**
           * Flex Direction
           * @see https://tailwindcss.com/docs/flex-direction
           */
          "flex-direction": [{
            flex: ["row", "row-reverse", "col", "col-reverse"]
          }],
          /**
           * Flex Wrap
           * @see https://tailwindcss.com/docs/flex-wrap
           */
          "flex-wrap": [{
            flex: ["wrap", "wrap-reverse", "nowrap"]
          }],
          /**
           * Flex
           * @see https://tailwindcss.com/docs/flex
           */
          flex: [{
            flex: ["1", "auto", "initial", "none", isArbitraryValue]
          }],
          /**
           * Flex Grow
           * @see https://tailwindcss.com/docs/flex-grow
           */
          grow: [{
            grow: getZeroAndEmpty()
          }],
          /**
           * Flex Shrink
           * @see https://tailwindcss.com/docs/flex-shrink
           */
          shrink: [{
            shrink: getZeroAndEmpty()
          }],
          /**
           * Order
           * @see https://tailwindcss.com/docs/order
           */
          order: [{
            order: ["first", "last", "none", isInteger, isArbitraryValue]
          }],
          /**
           * Grid Template Columns
           * @see https://tailwindcss.com/docs/grid-template-columns
           */
          "grid-cols": [{
            "grid-cols": [isAny]
          }],
          /**
           * Grid Column Start / End
           * @see https://tailwindcss.com/docs/grid-column
           */
          "col-start-end": [{
            col: ["auto", {
              span: ["full", isInteger, isArbitraryValue]
            }, isArbitraryValue]
          }],
          /**
           * Grid Column Start
           * @see https://tailwindcss.com/docs/grid-column
           */
          "col-start": [{
            "col-start": getNumberWithAutoAndArbitrary()
          }],
          /**
           * Grid Column End
           * @see https://tailwindcss.com/docs/grid-column
           */
          "col-end": [{
            "col-end": getNumberWithAutoAndArbitrary()
          }],
          /**
           * Grid Template Rows
           * @see https://tailwindcss.com/docs/grid-template-rows
           */
          "grid-rows": [{
            "grid-rows": [isAny]
          }],
          /**
           * Grid Row Start / End
           * @see https://tailwindcss.com/docs/grid-row
           */
          "row-start-end": [{
            row: ["auto", {
              span: [isInteger, isArbitraryValue]
            }, isArbitraryValue]
          }],
          /**
           * Grid Row Start
           * @see https://tailwindcss.com/docs/grid-row
           */
          "row-start": [{
            "row-start": getNumberWithAutoAndArbitrary()
          }],
          /**
           * Grid Row End
           * @see https://tailwindcss.com/docs/grid-row
           */
          "row-end": [{
            "row-end": getNumberWithAutoAndArbitrary()
          }],
          /**
           * Grid Auto Flow
           * @see https://tailwindcss.com/docs/grid-auto-flow
           */
          "grid-flow": [{
            "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
          }],
          /**
           * Grid Auto Columns
           * @see https://tailwindcss.com/docs/grid-auto-columns
           */
          "auto-cols": [{
            "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
          }],
          /**
           * Grid Auto Rows
           * @see https://tailwindcss.com/docs/grid-auto-rows
           */
          "auto-rows": [{
            "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
          }],
          /**
           * Gap
           * @see https://tailwindcss.com/docs/gap
           */
          gap: [{
            gap: [gap]
          }],
          /**
           * Gap X
           * @see https://tailwindcss.com/docs/gap
           */
          "gap-x": [{
            "gap-x": [gap]
          }],
          /**
           * Gap Y
           * @see https://tailwindcss.com/docs/gap
           */
          "gap-y": [{
            "gap-y": [gap]
          }],
          /**
           * Justify Content
           * @see https://tailwindcss.com/docs/justify-content
           */
          "justify-content": [{
            justify: ["normal", ...getAlign()]
          }],
          /**
           * Justify Items
           * @see https://tailwindcss.com/docs/justify-items
           */
          "justify-items": [{
            "justify-items": ["start", "end", "center", "stretch"]
          }],
          /**
           * Justify Self
           * @see https://tailwindcss.com/docs/justify-self
           */
          "justify-self": [{
            "justify-self": ["auto", "start", "end", "center", "stretch"]
          }],
          /**
           * Align Content
           * @see https://tailwindcss.com/docs/align-content
           */
          "align-content": [{
            content: ["normal", ...getAlign(), "baseline"]
          }],
          /**
           * Align Items
           * @see https://tailwindcss.com/docs/align-items
           */
          "align-items": [{
            items: ["start", "end", "center", "baseline", "stretch"]
          }],
          /**
           * Align Self
           * @see https://tailwindcss.com/docs/align-self
           */
          "align-self": [{
            self: ["auto", "start", "end", "center", "stretch", "baseline"]
          }],
          /**
           * Place Content
           * @see https://tailwindcss.com/docs/place-content
           */
          "place-content": [{
            "place-content": [...getAlign(), "baseline"]
          }],
          /**
           * Place Items
           * @see https://tailwindcss.com/docs/place-items
           */
          "place-items": [{
            "place-items": ["start", "end", "center", "baseline", "stretch"]
          }],
          /**
           * Place Self
           * @see https://tailwindcss.com/docs/place-self
           */
          "place-self": [{
            "place-self": ["auto", "start", "end", "center", "stretch"]
          }],
          // Spacing
          /**
           * Padding
           * @see https://tailwindcss.com/docs/padding
           */
          p: [{
            p: [padding]
          }],
          /**
           * Padding X
           * @see https://tailwindcss.com/docs/padding
           */
          px: [{
            px: [padding]
          }],
          /**
           * Padding Y
           * @see https://tailwindcss.com/docs/padding
           */
          py: [{
            py: [padding]
          }],
          /**
           * Padding Start
           * @see https://tailwindcss.com/docs/padding
           */
          ps: [{
            ps: [padding]
          }],
          /**
           * Padding End
           * @see https://tailwindcss.com/docs/padding
           */
          pe: [{
            pe: [padding]
          }],
          /**
           * Padding Top
           * @see https://tailwindcss.com/docs/padding
           */
          pt: [{
            pt: [padding]
          }],
          /**
           * Padding Right
           * @see https://tailwindcss.com/docs/padding
           */
          pr: [{
            pr: [padding]
          }],
          /**
           * Padding Bottom
           * @see https://tailwindcss.com/docs/padding
           */
          pb: [{
            pb: [padding]
          }],
          /**
           * Padding Left
           * @see https://tailwindcss.com/docs/padding
           */
          pl: [{
            pl: [padding]
          }],
          /**
           * Margin
           * @see https://tailwindcss.com/docs/margin
           */
          m: [{
            m: [margin]
          }],
          /**
           * Margin X
           * @see https://tailwindcss.com/docs/margin
           */
          mx: [{
            mx: [margin]
          }],
          /**
           * Margin Y
           * @see https://tailwindcss.com/docs/margin
           */
          my: [{
            my: [margin]
          }],
          /**
           * Margin Start
           * @see https://tailwindcss.com/docs/margin
           */
          ms: [{
            ms: [margin]
          }],
          /**
           * Margin End
           * @see https://tailwindcss.com/docs/margin
           */
          me: [{
            me: [margin]
          }],
          /**
           * Margin Top
           * @see https://tailwindcss.com/docs/margin
           */
          mt: [{
            mt: [margin]
          }],
          /**
           * Margin Right
           * @see https://tailwindcss.com/docs/margin
           */
          mr: [{
            mr: [margin]
          }],
          /**
           * Margin Bottom
           * @see https://tailwindcss.com/docs/margin
           */
          mb: [{
            mb: [margin]
          }],
          /**
           * Margin Left
           * @see https://tailwindcss.com/docs/margin
           */
          ml: [{
            ml: [margin]
          }],
          /**
           * Space Between X
           * @see https://tailwindcss.com/docs/space
           */
          "space-x": [{
            "space-x": [space]
          }],
          /**
           * Space Between X Reverse
           * @see https://tailwindcss.com/docs/space
           */
          "space-x-reverse": ["space-x-reverse"],
          /**
           * Space Between Y
           * @see https://tailwindcss.com/docs/space
           */
          "space-y": [{
            "space-y": [space]
          }],
          /**
           * Space Between Y Reverse
           * @see https://tailwindcss.com/docs/space
           */
          "space-y-reverse": ["space-y-reverse"],
          // Sizing
          /**
           * Width
           * @see https://tailwindcss.com/docs/width
           */
          w: [{
            w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", isArbitraryValue, spacing]
          }],
          /**
           * Min-Width
           * @see https://tailwindcss.com/docs/min-width
           */
          "min-w": [{
            "min-w": [isArbitraryValue, spacing, "min", "max", "fit"]
          }],
          /**
           * Max-Width
           * @see https://tailwindcss.com/docs/max-width
           */
          "max-w": [{
            "max-w": [isArbitraryValue, spacing, "none", "full", "min", "max", "fit", "prose", {
              screen: [isTshirtSize]
            }, isTshirtSize]
          }],
          /**
           * Height
           * @see https://tailwindcss.com/docs/height
           */
          h: [{
            h: [isArbitraryValue, spacing, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
          }],
          /**
           * Min-Height
           * @see https://tailwindcss.com/docs/min-height
           */
          "min-h": [{
            "min-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
          }],
          /**
           * Max-Height
           * @see https://tailwindcss.com/docs/max-height
           */
          "max-h": [{
            "max-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
          }],
          /**
           * Size
           * @see https://tailwindcss.com/docs/size
           */
          size: [{
            size: [isArbitraryValue, spacing, "auto", "min", "max", "fit"]
          }],
          // Typography
          /**
           * Font Size
           * @see https://tailwindcss.com/docs/font-size
           */
          "font-size": [{
            text: ["base", isTshirtSize, isArbitraryLength]
          }],
          /**
           * Font Smoothing
           * @see https://tailwindcss.com/docs/font-smoothing
           */
          "font-smoothing": ["antialiased", "subpixel-antialiased"],
          /**
           * Font Style
           * @see https://tailwindcss.com/docs/font-style
           */
          "font-style": ["italic", "not-italic"],
          /**
           * Font Weight
           * @see https://tailwindcss.com/docs/font-weight
           */
          "font-weight": [{
            font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
          }],
          /**
           * Font Family
           * @see https://tailwindcss.com/docs/font-family
           */
          "font-family": [{
            font: [isAny]
          }],
          /**
           * Font Variant Numeric
           * @see https://tailwindcss.com/docs/font-variant-numeric
           */
          "fvn-normal": ["normal-nums"],
          /**
           * Font Variant Numeric
           * @see https://tailwindcss.com/docs/font-variant-numeric
           */
          "fvn-ordinal": ["ordinal"],
          /**
           * Font Variant Numeric
           * @see https://tailwindcss.com/docs/font-variant-numeric
           */
          "fvn-slashed-zero": ["slashed-zero"],
          /**
           * Font Variant Numeric
           * @see https://tailwindcss.com/docs/font-variant-numeric
           */
          "fvn-figure": ["lining-nums", "oldstyle-nums"],
          /**
           * Font Variant Numeric
           * @see https://tailwindcss.com/docs/font-variant-numeric
           */
          "fvn-spacing": ["proportional-nums", "tabular-nums"],
          /**
           * Font Variant Numeric
           * @see https://tailwindcss.com/docs/font-variant-numeric
           */
          "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
          /**
           * Letter Spacing
           * @see https://tailwindcss.com/docs/letter-spacing
           */
          tracking: [{
            tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
          }],
          /**
           * Line Clamp
           * @see https://tailwindcss.com/docs/line-clamp
           */
          "line-clamp": [{
            "line-clamp": ["none", isNumber, isArbitraryNumber]
          }],
          /**
           * Line Height
           * @see https://tailwindcss.com/docs/line-height
           */
          leading: [{
            leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isLength, isArbitraryValue]
          }],
          /**
           * List Style Image
           * @see https://tailwindcss.com/docs/list-style-image
           */
          "list-image": [{
            "list-image": ["none", isArbitraryValue]
          }],
          /**
           * List Style Type
           * @see https://tailwindcss.com/docs/list-style-type
           */
          "list-style-type": [{
            list: ["none", "disc", "decimal", isArbitraryValue]
          }],
          /**
           * List Style Position
           * @see https://tailwindcss.com/docs/list-style-position
           */
          "list-style-position": [{
            list: ["inside", "outside"]
          }],
          /**
           * Placeholder Color
           * @deprecated since Tailwind CSS v3.0.0
           * @see https://tailwindcss.com/docs/placeholder-color
           */
          "placeholder-color": [{
            placeholder: [colors]
          }],
          /**
           * Placeholder Opacity
           * @see https://tailwindcss.com/docs/placeholder-opacity
           */
          "placeholder-opacity": [{
            "placeholder-opacity": [opacity]
          }],
          /**
           * Text Alignment
           * @see https://tailwindcss.com/docs/text-align
           */
          "text-alignment": [{
            text: ["left", "center", "right", "justify", "start", "end"]
          }],
          /**
           * Text Color
           * @see https://tailwindcss.com/docs/text-color
           */
          "text-color": [{
            text: [colors]
          }],
          /**
           * Text Opacity
           * @see https://tailwindcss.com/docs/text-opacity
           */
          "text-opacity": [{
            "text-opacity": [opacity]
          }],
          /**
           * Text Decoration
           * @see https://tailwindcss.com/docs/text-decoration
           */
          "text-decoration": ["underline", "overline", "line-through", "no-underline"],
          /**
           * Text Decoration Style
           * @see https://tailwindcss.com/docs/text-decoration-style
           */
          "text-decoration-style": [{
            decoration: [...getLineStyles(), "wavy"]
          }],
          /**
           * Text Decoration Thickness
           * @see https://tailwindcss.com/docs/text-decoration-thickness
           */
          "text-decoration-thickness": [{
            decoration: ["auto", "from-font", isLength, isArbitraryLength]
          }],
          /**
           * Text Underline Offset
           * @see https://tailwindcss.com/docs/text-underline-offset
           */
          "underline-offset": [{
            "underline-offset": ["auto", isLength, isArbitraryValue]
          }],
          /**
           * Text Decoration Color
           * @see https://tailwindcss.com/docs/text-decoration-color
           */
          "text-decoration-color": [{
            decoration: [colors]
          }],
          /**
           * Text Transform
           * @see https://tailwindcss.com/docs/text-transform
           */
          "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
          /**
           * Text Overflow
           * @see https://tailwindcss.com/docs/text-overflow
           */
          "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
          /**
           * Text Wrap
           * @see https://tailwindcss.com/docs/text-wrap
           */
          "text-wrap": [{
            text: ["wrap", "nowrap", "balance", "pretty"]
          }],
          /**
           * Text Indent
           * @see https://tailwindcss.com/docs/text-indent
           */
          indent: [{
            indent: getSpacingWithArbitrary()
          }],
          /**
           * Vertical Alignment
           * @see https://tailwindcss.com/docs/vertical-align
           */
          "vertical-align": [{
            align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
          }],
          /**
           * Whitespace
           * @see https://tailwindcss.com/docs/whitespace
           */
          whitespace: [{
            whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
          }],
          /**
           * Word Break
           * @see https://tailwindcss.com/docs/word-break
           */
          break: [{
            break: ["normal", "words", "all", "keep"]
          }],
          /**
           * Hyphens
           * @see https://tailwindcss.com/docs/hyphens
           */
          hyphens: [{
            hyphens: ["none", "manual", "auto"]
          }],
          /**
           * Content
           * @see https://tailwindcss.com/docs/content
           */
          content: [{
            content: ["none", isArbitraryValue]
          }],
          // Backgrounds
          /**
           * Background Attachment
           * @see https://tailwindcss.com/docs/background-attachment
           */
          "bg-attachment": [{
            bg: ["fixed", "local", "scroll"]
          }],
          /**
           * Background Clip
           * @see https://tailwindcss.com/docs/background-clip
           */
          "bg-clip": [{
            "bg-clip": ["border", "padding", "content", "text"]
          }],
          /**
           * Background Opacity
           * @deprecated since Tailwind CSS v3.0.0
           * @see https://tailwindcss.com/docs/background-opacity
           */
          "bg-opacity": [{
            "bg-opacity": [opacity]
          }],
          /**
           * Background Origin
           * @see https://tailwindcss.com/docs/background-origin
           */
          "bg-origin": [{
            "bg-origin": ["border", "padding", "content"]
          }],
          /**
           * Background Position
           * @see https://tailwindcss.com/docs/background-position
           */
          "bg-position": [{
            bg: [...getPositions(), isArbitraryPosition]
          }],
          /**
           * Background Repeat
           * @see https://tailwindcss.com/docs/background-repeat
           */
          "bg-repeat": [{
            bg: ["no-repeat", {
              repeat: ["", "x", "y", "round", "space"]
            }]
          }],
          /**
           * Background Size
           * @see https://tailwindcss.com/docs/background-size
           */
          "bg-size": [{
            bg: ["auto", "cover", "contain", isArbitrarySize]
          }],
          /**
           * Background Image
           * @see https://tailwindcss.com/docs/background-image
           */
          "bg-image": [{
            bg: ["none", {
              "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
            }, isArbitraryImage]
          }],
          /**
           * Background Color
           * @see https://tailwindcss.com/docs/background-color
           */
          "bg-color": [{
            bg: [colors]
          }],
          /**
           * Gradient Color Stops From Position
           * @see https://tailwindcss.com/docs/gradient-color-stops
           */
          "gradient-from-pos": [{
            from: [gradientColorStopPositions]
          }],
          /**
           * Gradient Color Stops Via Position
           * @see https://tailwindcss.com/docs/gradient-color-stops
           */
          "gradient-via-pos": [{
            via: [gradientColorStopPositions]
          }],
          /**
           * Gradient Color Stops To Position
           * @see https://tailwindcss.com/docs/gradient-color-stops
           */
          "gradient-to-pos": [{
            to: [gradientColorStopPositions]
          }],
          /**
           * Gradient Color Stops From
           * @see https://tailwindcss.com/docs/gradient-color-stops
           */
          "gradient-from": [{
            from: [gradientColorStops]
          }],
          /**
           * Gradient Color Stops Via
           * @see https://tailwindcss.com/docs/gradient-color-stops
           */
          "gradient-via": [{
            via: [gradientColorStops]
          }],
          /**
           * Gradient Color Stops To
           * @see https://tailwindcss.com/docs/gradient-color-stops
           */
          "gradient-to": [{
            to: [gradientColorStops]
          }],
          // Borders
          /**
           * Border Radius
           * @see https://tailwindcss.com/docs/border-radius
           */
          rounded: [{
            rounded: [borderRadius]
          }],
          /**
           * Border Radius Start
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-s": [{
            "rounded-s": [borderRadius]
          }],
          /**
           * Border Radius End
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-e": [{
            "rounded-e": [borderRadius]
          }],
          /**
           * Border Radius Top
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-t": [{
            "rounded-t": [borderRadius]
          }],
          /**
           * Border Radius Right
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-r": [{
            "rounded-r": [borderRadius]
          }],
          /**
           * Border Radius Bottom
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-b": [{
            "rounded-b": [borderRadius]
          }],
          /**
           * Border Radius Left
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-l": [{
            "rounded-l": [borderRadius]
          }],
          /**
           * Border Radius Start Start
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-ss": [{
            "rounded-ss": [borderRadius]
          }],
          /**
           * Border Radius Start End
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-se": [{
            "rounded-se": [borderRadius]
          }],
          /**
           * Border Radius End End
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-ee": [{
            "rounded-ee": [borderRadius]
          }],
          /**
           * Border Radius End Start
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-es": [{
            "rounded-es": [borderRadius]
          }],
          /**
           * Border Radius Top Left
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-tl": [{
            "rounded-tl": [borderRadius]
          }],
          /**
           * Border Radius Top Right
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-tr": [{
            "rounded-tr": [borderRadius]
          }],
          /**
           * Border Radius Bottom Right
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-br": [{
            "rounded-br": [borderRadius]
          }],
          /**
           * Border Radius Bottom Left
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-bl": [{
            "rounded-bl": [borderRadius]
          }],
          /**
           * Border Width
           * @see https://tailwindcss.com/docs/border-width
           */
          "border-w": [{
            border: [borderWidth]
          }],
          /**
           * Border Width X
           * @see https://tailwindcss.com/docs/border-width
           */
          "border-w-x": [{
            "border-x": [borderWidth]
          }],
          /**
           * Border Width Y
           * @see https://tailwindcss.com/docs/border-width
           */
          "border-w-y": [{
            "border-y": [borderWidth]
          }],
          /**
           * Border Width Start
           * @see https://tailwindcss.com/docs/border-width
           */
          "border-w-s": [{
            "border-s": [borderWidth]
          }],
          /**
           * Border Width End
           * @see https://tailwindcss.com/docs/border-width
           */
          "border-w-e": [{
            "border-e": [borderWidth]
          }],
          /**
           * Border Width Top
           * @see https://tailwindcss.com/docs/border-width
           */
          "border-w-t": [{
            "border-t": [borderWidth]
          }],
          /**
           * Border Width Right
           * @see https://tailwindcss.com/docs/border-width
           */
          "border-w-r": [{
            "border-r": [borderWidth]
          }],
          /**
           * Border Width Bottom
           * @see https://tailwindcss.com/docs/border-width
           */
          "border-w-b": [{
            "border-b": [borderWidth]
          }],
          /**
           * Border Width Left
           * @see https://tailwindcss.com/docs/border-width
           */
          "border-w-l": [{
            "border-l": [borderWidth]
          }],
          /**
           * Border Opacity
           * @see https://tailwindcss.com/docs/border-opacity
           */
          "border-opacity": [{
            "border-opacity": [opacity]
          }],
          /**
           * Border Style
           * @see https://tailwindcss.com/docs/border-style
           */
          "border-style": [{
            border: [...getLineStyles(), "hidden"]
          }],
          /**
           * Divide Width X
           * @see https://tailwindcss.com/docs/divide-width
           */
          "divide-x": [{
            "divide-x": [borderWidth]
          }],
          /**
           * Divide Width X Reverse
           * @see https://tailwindcss.com/docs/divide-width
           */
          "divide-x-reverse": ["divide-x-reverse"],
          /**
           * Divide Width Y
           * @see https://tailwindcss.com/docs/divide-width
           */
          "divide-y": [{
            "divide-y": [borderWidth]
          }],
          /**
           * Divide Width Y Reverse
           * @see https://tailwindcss.com/docs/divide-width
           */
          "divide-y-reverse": ["divide-y-reverse"],
          /**
           * Divide Opacity
           * @see https://tailwindcss.com/docs/divide-opacity
           */
          "divide-opacity": [{
            "divide-opacity": [opacity]
          }],
          /**
           * Divide Style
           * @see https://tailwindcss.com/docs/divide-style
           */
          "divide-style": [{
            divide: getLineStyles()
          }],
          /**
           * Border Color
           * @see https://tailwindcss.com/docs/border-color
           */
          "border-color": [{
            border: [borderColor]
          }],
          /**
           * Border Color X
           * @see https://tailwindcss.com/docs/border-color
           */
          "border-color-x": [{
            "border-x": [borderColor]
          }],
          /**
           * Border Color Y
           * @see https://tailwindcss.com/docs/border-color
           */
          "border-color-y": [{
            "border-y": [borderColor]
          }],
          /**
           * Border Color S
           * @see https://tailwindcss.com/docs/border-color
           */
          "border-color-s": [{
            "border-s": [borderColor]
          }],
          /**
           * Border Color E
           * @see https://tailwindcss.com/docs/border-color
           */
          "border-color-e": [{
            "border-e": [borderColor]
          }],
          /**
           * Border Color Top
           * @see https://tailwindcss.com/docs/border-color
           */
          "border-color-t": [{
            "border-t": [borderColor]
          }],
          /**
           * Border Color Right
           * @see https://tailwindcss.com/docs/border-color
           */
          "border-color-r": [{
            "border-r": [borderColor]
          }],
          /**
           * Border Color Bottom
           * @see https://tailwindcss.com/docs/border-color
           */
          "border-color-b": [{
            "border-b": [borderColor]
          }],
          /**
           * Border Color Left
           * @see https://tailwindcss.com/docs/border-color
           */
          "border-color-l": [{
            "border-l": [borderColor]
          }],
          /**
           * Divide Color
           * @see https://tailwindcss.com/docs/divide-color
           */
          "divide-color": [{
            divide: [borderColor]
          }],
          /**
           * Outline Style
           * @see https://tailwindcss.com/docs/outline-style
           */
          "outline-style": [{
            outline: ["", ...getLineStyles()]
          }],
          /**
           * Outline Offset
           * @see https://tailwindcss.com/docs/outline-offset
           */
          "outline-offset": [{
            "outline-offset": [isLength, isArbitraryValue]
          }],
          /**
           * Outline Width
           * @see https://tailwindcss.com/docs/outline-width
           */
          "outline-w": [{
            outline: [isLength, isArbitraryLength]
          }],
          /**
           * Outline Color
           * @see https://tailwindcss.com/docs/outline-color
           */
          "outline-color": [{
            outline: [colors]
          }],
          /**
           * Ring Width
           * @see https://tailwindcss.com/docs/ring-width
           */
          "ring-w": [{
            ring: getLengthWithEmptyAndArbitrary()
          }],
          /**
           * Ring Width Inset
           * @see https://tailwindcss.com/docs/ring-width
           */
          "ring-w-inset": ["ring-inset"],
          /**
           * Ring Color
           * @see https://tailwindcss.com/docs/ring-color
           */
          "ring-color": [{
            ring: [colors]
          }],
          /**
           * Ring Opacity
           * @see https://tailwindcss.com/docs/ring-opacity
           */
          "ring-opacity": [{
            "ring-opacity": [opacity]
          }],
          /**
           * Ring Offset Width
           * @see https://tailwindcss.com/docs/ring-offset-width
           */
          "ring-offset-w": [{
            "ring-offset": [isLength, isArbitraryLength]
          }],
          /**
           * Ring Offset Color
           * @see https://tailwindcss.com/docs/ring-offset-color
           */
          "ring-offset-color": [{
            "ring-offset": [colors]
          }],
          // Effects
          /**
           * Box Shadow
           * @see https://tailwindcss.com/docs/box-shadow
           */
          shadow: [{
            shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
          }],
          /**
           * Box Shadow Color
           * @see https://tailwindcss.com/docs/box-shadow-color
           */
          "shadow-color": [{
            shadow: [isAny]
          }],
          /**
           * Opacity
           * @see https://tailwindcss.com/docs/opacity
           */
          opacity: [{
            opacity: [opacity]
          }],
          /**
           * Mix Blend Mode
           * @see https://tailwindcss.com/docs/mix-blend-mode
           */
          "mix-blend": [{
            "mix-blend": [...getBlendModes(), "plus-lighter", "plus-darker"]
          }],
          /**
           * Background Blend Mode
           * @see https://tailwindcss.com/docs/background-blend-mode
           */
          "bg-blend": [{
            "bg-blend": getBlendModes()
          }],
          // Filters
          /**
           * Filter
           * @deprecated since Tailwind CSS v3.0.0
           * @see https://tailwindcss.com/docs/filter
           */
          filter: [{
            filter: ["", "none"]
          }],
          /**
           * Blur
           * @see https://tailwindcss.com/docs/blur
           */
          blur: [{
            blur: [blur]
          }],
          /**
           * Brightness
           * @see https://tailwindcss.com/docs/brightness
           */
          brightness: [{
            brightness: [brightness]
          }],
          /**
           * Contrast
           * @see https://tailwindcss.com/docs/contrast
           */
          contrast: [{
            contrast: [contrast]
          }],
          /**
           * Drop Shadow
           * @see https://tailwindcss.com/docs/drop-shadow
           */
          "drop-shadow": [{
            "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
          }],
          /**
           * Grayscale
           * @see https://tailwindcss.com/docs/grayscale
           */
          grayscale: [{
            grayscale: [grayscale]
          }],
          /**
           * Hue Rotate
           * @see https://tailwindcss.com/docs/hue-rotate
           */
          "hue-rotate": [{
            "hue-rotate": [hueRotate]
          }],
          /**
           * Invert
           * @see https://tailwindcss.com/docs/invert
           */
          invert: [{
            invert: [invert]
          }],
          /**
           * Saturate
           * @see https://tailwindcss.com/docs/saturate
           */
          saturate: [{
            saturate: [saturate]
          }],
          /**
           * Sepia
           * @see https://tailwindcss.com/docs/sepia
           */
          sepia: [{
            sepia: [sepia]
          }],
          /**
           * Backdrop Filter
           * @deprecated since Tailwind CSS v3.0.0
           * @see https://tailwindcss.com/docs/backdrop-filter
           */
          "backdrop-filter": [{
            "backdrop-filter": ["", "none"]
          }],
          /**
           * Backdrop Blur
           * @see https://tailwindcss.com/docs/backdrop-blur
           */
          "backdrop-blur": [{
            "backdrop-blur": [blur]
          }],
          /**
           * Backdrop Brightness
           * @see https://tailwindcss.com/docs/backdrop-brightness
           */
          "backdrop-brightness": [{
            "backdrop-brightness": [brightness]
          }],
          /**
           * Backdrop Contrast
           * @see https://tailwindcss.com/docs/backdrop-contrast
           */
          "backdrop-contrast": [{
            "backdrop-contrast": [contrast]
          }],
          /**
           * Backdrop Grayscale
           * @see https://tailwindcss.com/docs/backdrop-grayscale
           */
          "backdrop-grayscale": [{
            "backdrop-grayscale": [grayscale]
          }],
          /**
           * Backdrop Hue Rotate
           * @see https://tailwindcss.com/docs/backdrop-hue-rotate
           */
          "backdrop-hue-rotate": [{
            "backdrop-hue-rotate": [hueRotate]
          }],
          /**
           * Backdrop Invert
           * @see https://tailwindcss.com/docs/backdrop-invert
           */
          "backdrop-invert": [{
            "backdrop-invert": [invert]
          }],
          /**
           * Backdrop Opacity
           * @see https://tailwindcss.com/docs/backdrop-opacity
           */
          "backdrop-opacity": [{
            "backdrop-opacity": [opacity]
          }],
          /**
           * Backdrop Saturate
           * @see https://tailwindcss.com/docs/backdrop-saturate
           */
          "backdrop-saturate": [{
            "backdrop-saturate": [saturate]
          }],
          /**
           * Backdrop Sepia
           * @see https://tailwindcss.com/docs/backdrop-sepia
           */
          "backdrop-sepia": [{
            "backdrop-sepia": [sepia]
          }],
          // Tables
          /**
           * Border Collapse
           * @see https://tailwindcss.com/docs/border-collapse
           */
          "border-collapse": [{
            border: ["collapse", "separate"]
          }],
          /**
           * Border Spacing
           * @see https://tailwindcss.com/docs/border-spacing
           */
          "border-spacing": [{
            "border-spacing": [borderSpacing]
          }],
          /**
           * Border Spacing X
           * @see https://tailwindcss.com/docs/border-spacing
           */
          "border-spacing-x": [{
            "border-spacing-x": [borderSpacing]
          }],
          /**
           * Border Spacing Y
           * @see https://tailwindcss.com/docs/border-spacing
           */
          "border-spacing-y": [{
            "border-spacing-y": [borderSpacing]
          }],
          /**
           * Table Layout
           * @see https://tailwindcss.com/docs/table-layout
           */
          "table-layout": [{
            table: ["auto", "fixed"]
          }],
          /**
           * Caption Side
           * @see https://tailwindcss.com/docs/caption-side
           */
          caption: [{
            caption: ["top", "bottom"]
          }],
          // Transitions and Animation
          /**
           * Tranisition Property
           * @see https://tailwindcss.com/docs/transition-property
           */
          transition: [{
            transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
          }],
          /**
           * Transition Duration
           * @see https://tailwindcss.com/docs/transition-duration
           */
          duration: [{
            duration: getNumberAndArbitrary()
          }],
          /**
           * Transition Timing Function
           * @see https://tailwindcss.com/docs/transition-timing-function
           */
          ease: [{
            ease: ["linear", "in", "out", "in-out", isArbitraryValue]
          }],
          /**
           * Transition Delay
           * @see https://tailwindcss.com/docs/transition-delay
           */
          delay: [{
            delay: getNumberAndArbitrary()
          }],
          /**
           * Animation
           * @see https://tailwindcss.com/docs/animation
           */
          animate: [{
            animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
          }],
          // Transforms
          /**
           * Transform
           * @see https://tailwindcss.com/docs/transform
           */
          transform: [{
            transform: ["", "gpu", "none"]
          }],
          /**
           * Scale
           * @see https://tailwindcss.com/docs/scale
           */
          scale: [{
            scale: [scale]
          }],
          /**
           * Scale X
           * @see https://tailwindcss.com/docs/scale
           */
          "scale-x": [{
            "scale-x": [scale]
          }],
          /**
           * Scale Y
           * @see https://tailwindcss.com/docs/scale
           */
          "scale-y": [{
            "scale-y": [scale]
          }],
          /**
           * Rotate
           * @see https://tailwindcss.com/docs/rotate
           */
          rotate: [{
            rotate: [isInteger, isArbitraryValue]
          }],
          /**
           * Translate X
           * @see https://tailwindcss.com/docs/translate
           */
          "translate-x": [{
            "translate-x": [translate]
          }],
          /**
           * Translate Y
           * @see https://tailwindcss.com/docs/translate
           */
          "translate-y": [{
            "translate-y": [translate]
          }],
          /**
           * Skew X
           * @see https://tailwindcss.com/docs/skew
           */
          "skew-x": [{
            "skew-x": [skew]
          }],
          /**
           * Skew Y
           * @see https://tailwindcss.com/docs/skew
           */
          "skew-y": [{
            "skew-y": [skew]
          }],
          /**
           * Transform Origin
           * @see https://tailwindcss.com/docs/transform-origin
           */
          "transform-origin": [{
            origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
          }],
          // Interactivity
          /**
           * Accent Color
           * @see https://tailwindcss.com/docs/accent-color
           */
          accent: [{
            accent: ["auto", colors]
          }],
          /**
           * Appearance
           * @see https://tailwindcss.com/docs/appearance
           */
          appearance: [{
            appearance: ["none", "auto"]
          }],
          /**
           * Cursor
           * @see https://tailwindcss.com/docs/cursor
           */
          cursor: [{
            cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
          }],
          /**
           * Caret Color
           * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
           */
          "caret-color": [{
            caret: [colors]
          }],
          /**
           * Pointer Events
           * @see https://tailwindcss.com/docs/pointer-events
           */
          "pointer-events": [{
            "pointer-events": ["none", "auto"]
          }],
          /**
           * Resize
           * @see https://tailwindcss.com/docs/resize
           */
          resize: [{
            resize: ["none", "y", "x", ""]
          }],
          /**
           * Scroll Behavior
           * @see https://tailwindcss.com/docs/scroll-behavior
           */
          "scroll-behavior": [{
            scroll: ["auto", "smooth"]
          }],
          /**
           * Scroll Margin
           * @see https://tailwindcss.com/docs/scroll-margin
           */
          "scroll-m": [{
            "scroll-m": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Margin X
           * @see https://tailwindcss.com/docs/scroll-margin
           */
          "scroll-mx": [{
            "scroll-mx": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Margin Y
           * @see https://tailwindcss.com/docs/scroll-margin
           */
          "scroll-my": [{
            "scroll-my": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Margin Start
           * @see https://tailwindcss.com/docs/scroll-margin
           */
          "scroll-ms": [{
            "scroll-ms": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Margin End
           * @see https://tailwindcss.com/docs/scroll-margin
           */
          "scroll-me": [{
            "scroll-me": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Margin Top
           * @see https://tailwindcss.com/docs/scroll-margin
           */
          "scroll-mt": [{
            "scroll-mt": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Margin Right
           * @see https://tailwindcss.com/docs/scroll-margin
           */
          "scroll-mr": [{
            "scroll-mr": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Margin Bottom
           * @see https://tailwindcss.com/docs/scroll-margin
           */
          "scroll-mb": [{
            "scroll-mb": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Margin Left
           * @see https://tailwindcss.com/docs/scroll-margin
           */
          "scroll-ml": [{
            "scroll-ml": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Padding
           * @see https://tailwindcss.com/docs/scroll-padding
           */
          "scroll-p": [{
            "scroll-p": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Padding X
           * @see https://tailwindcss.com/docs/scroll-padding
           */
          "scroll-px": [{
            "scroll-px": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Padding Y
           * @see https://tailwindcss.com/docs/scroll-padding
           */
          "scroll-py": [{
            "scroll-py": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Padding Start
           * @see https://tailwindcss.com/docs/scroll-padding
           */
          "scroll-ps": [{
            "scroll-ps": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Padding End
           * @see https://tailwindcss.com/docs/scroll-padding
           */
          "scroll-pe": [{
            "scroll-pe": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Padding Top
           * @see https://tailwindcss.com/docs/scroll-padding
           */
          "scroll-pt": [{
            "scroll-pt": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Padding Right
           * @see https://tailwindcss.com/docs/scroll-padding
           */
          "scroll-pr": [{
            "scroll-pr": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Padding Bottom
           * @see https://tailwindcss.com/docs/scroll-padding
           */
          "scroll-pb": [{
            "scroll-pb": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Padding Left
           * @see https://tailwindcss.com/docs/scroll-padding
           */
          "scroll-pl": [{
            "scroll-pl": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Snap Align
           * @see https://tailwindcss.com/docs/scroll-snap-align
           */
          "snap-align": [{
            snap: ["start", "end", "center", "align-none"]
          }],
          /**
           * Scroll Snap Stop
           * @see https://tailwindcss.com/docs/scroll-snap-stop
           */
          "snap-stop": [{
            snap: ["normal", "always"]
          }],
          /**
           * Scroll Snap Type
           * @see https://tailwindcss.com/docs/scroll-snap-type
           */
          "snap-type": [{
            snap: ["none", "x", "y", "both"]
          }],
          /**
           * Scroll Snap Type Strictness
           * @see https://tailwindcss.com/docs/scroll-snap-type
           */
          "snap-strictness": [{
            snap: ["mandatory", "proximity"]
          }],
          /**
           * Touch Action
           * @see https://tailwindcss.com/docs/touch-action
           */
          touch: [{
            touch: ["auto", "none", "manipulation"]
          }],
          /**
           * Touch Action X
           * @see https://tailwindcss.com/docs/touch-action
           */
          "touch-x": [{
            "touch-pan": ["x", "left", "right"]
          }],
          /**
           * Touch Action Y
           * @see https://tailwindcss.com/docs/touch-action
           */
          "touch-y": [{
            "touch-pan": ["y", "up", "down"]
          }],
          /**
           * Touch Action Pinch Zoom
           * @see https://tailwindcss.com/docs/touch-action
           */
          "touch-pz": ["touch-pinch-zoom"],
          /**
           * User Select
           * @see https://tailwindcss.com/docs/user-select
           */
          select: [{
            select: ["none", "text", "all", "auto"]
          }],
          /**
           * Will Change
           * @see https://tailwindcss.com/docs/will-change
           */
          "will-change": [{
            "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
          }],
          // SVG
          /**
           * Fill
           * @see https://tailwindcss.com/docs/fill
           */
          fill: [{
            fill: [colors, "none"]
          }],
          /**
           * Stroke Width
           * @see https://tailwindcss.com/docs/stroke-width
           */
          "stroke-w": [{
            stroke: [isLength, isArbitraryLength, isArbitraryNumber]
          }],
          /**
           * Stroke
           * @see https://tailwindcss.com/docs/stroke
           */
          stroke: [{
            stroke: [colors, "none"]
          }],
          // Accessibility
          /**
           * Screen Readers
           * @see https://tailwindcss.com/docs/screen-readers
           */
          sr: ["sr-only", "not-sr-only"],
          /**
           * Forced Color Adjust
           * @see https://tailwindcss.com/docs/forced-color-adjust
           */
          "forced-color-adjust": [{
            "forced-color-adjust": ["auto", "none"]
          }]
        },
        conflictingClassGroups: {
          overflow: ["overflow-x", "overflow-y"],
          overscroll: ["overscroll-x", "overscroll-y"],
          inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
          "inset-x": ["right", "left"],
          "inset-y": ["top", "bottom"],
          flex: ["basis", "grow", "shrink"],
          gap: ["gap-x", "gap-y"],
          p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
          px: ["pr", "pl"],
          py: ["pt", "pb"],
          m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
          mx: ["mr", "ml"],
          my: ["mt", "mb"],
          size: ["w", "h"],
          "font-size": ["leading"],
          "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
          "fvn-ordinal": ["fvn-normal"],
          "fvn-slashed-zero": ["fvn-normal"],
          "fvn-figure": ["fvn-normal"],
          "fvn-spacing": ["fvn-normal"],
          "fvn-fraction": ["fvn-normal"],
          "line-clamp": ["display", "overflow"],
          rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
          "rounded-s": ["rounded-ss", "rounded-es"],
          "rounded-e": ["rounded-se", "rounded-ee"],
          "rounded-t": ["rounded-tl", "rounded-tr"],
          "rounded-r": ["rounded-tr", "rounded-br"],
          "rounded-b": ["rounded-br", "rounded-bl"],
          "rounded-l": ["rounded-tl", "rounded-bl"],
          "border-spacing": ["border-spacing-x", "border-spacing-y"],
          "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
          "border-w-x": ["border-w-r", "border-w-l"],
          "border-w-y": ["border-w-t", "border-w-b"],
          "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
          "border-color-x": ["border-color-r", "border-color-l"],
          "border-color-y": ["border-color-t", "border-color-b"],
          "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
          "scroll-mx": ["scroll-mr", "scroll-ml"],
          "scroll-my": ["scroll-mt", "scroll-mb"],
          "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
          "scroll-px": ["scroll-pr", "scroll-pl"],
          "scroll-py": ["scroll-pt", "scroll-pb"],
          touch: ["touch-x", "touch-y", "touch-pz"],
          "touch-x": ["touch"],
          "touch-y": ["touch"],
          "touch-pz": ["touch"]
        },
        conflictingClassGroupModifiers: {
          "font-size": ["leading"]
        }
      };
    }, "getDefaultConfig");
    mergeConfigs = /* @__PURE__ */ __name((baseConfig, {
      cacheSize,
      prefix,
      separator,
      experimentalParseClassName,
      extend = {},
      override: override2 = {}
    }) => {
      overrideProperty(baseConfig, "cacheSize", cacheSize);
      overrideProperty(baseConfig, "prefix", prefix);
      overrideProperty(baseConfig, "separator", separator);
      overrideProperty(baseConfig, "experimentalParseClassName", experimentalParseClassName);
      for (const configKey in override2) {
        overrideConfigProperties(baseConfig[configKey], override2[configKey]);
      }
      for (const key2 in extend) {
        mergeConfigProperties(baseConfig[key2], extend[key2]);
      }
      return baseConfig;
    }, "mergeConfigs");
    overrideProperty = /* @__PURE__ */ __name((baseObject, overrideKey, overrideValue) => {
      if (overrideValue !== void 0) {
        baseObject[overrideKey] = overrideValue;
      }
    }, "overrideProperty");
    overrideConfigProperties = /* @__PURE__ */ __name((baseObject, overrideObject) => {
      if (overrideObject) {
        for (const key2 in overrideObject) {
          overrideProperty(baseObject, key2, overrideObject[key2]);
        }
      }
    }, "overrideConfigProperties");
    mergeConfigProperties = /* @__PURE__ */ __name((baseObject, mergeObject) => {
      if (mergeObject) {
        for (const key2 in mergeObject) {
          const mergeValue = mergeObject[key2];
          if (mergeValue !== void 0) {
            baseObject[key2] = (baseObject[key2] || []).concat(mergeValue);
          }
        }
      }
    }, "mergeConfigProperties");
    extendTailwindMerge = /* @__PURE__ */ __name((configExtension, ...createConfig) => typeof configExtension === "function" ? createTailwindMerge(getDefaultConfig, configExtension, ...createConfig) : createTailwindMerge(() => mergeConfigs(getDefaultConfig(), configExtension), ...createConfig), "extendTailwindMerge");
    twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);
  }
});
function cubicOut(t2) {
  const f = t2 - 1;
  return f * f * f + 1;
}
__name(cubicOut, "cubicOut");
function cn(...inputs) {
  return twMerge(clsx(inputs));
}
__name(cn, "cn");
var flyAndScale;
var init_utils3 = __esm({
  ".svelte-kit/output/server/chunks/utils.js"() {
    init_clsx();
    init_bundle_mjs();
    flyAndScale = /* @__PURE__ */ __name((node, params = { y: -8, x: 0, start: 0.95, duration: 150 }) => {
      const style = getComputedStyle(node);
      const transform = style.transform === "none" ? "" : style.transform;
      const scaleConversion = /* @__PURE__ */ __name((valueA, scaleA, scaleB) => {
        const [minA, maxA] = scaleA;
        const [minB, maxB] = scaleB;
        const percentage = (valueA - minA) / (maxA - minA);
        const valueB = percentage * (maxB - minB) + minB;
        return valueB;
      }, "scaleConversion");
      const styleToString3 = /* @__PURE__ */ __name((style2) => {
        return Object.keys(style2).reduce((str, key2) => {
          if (style2[key2] === void 0)
            return str;
          return str + `${key2}:${style2[key2]};`;
        }, "");
      }, "styleToString3");
      return {
        duration: params.duration ?? 200,
        delay: 0,
        css: (t2) => {
          const y2 = scaleConversion(t2, [0, 1], [params.y ?? 5, 0]);
          const x2 = scaleConversion(t2, [0, 1], [params.x ?? 0, 0]);
          const scale = scaleConversion(t2, [0, 1], [params.start ?? 0.95, 1]);
          return styleToString3({
            transform: `${transform} translate3d(${x2}px, ${y2}px, 0) scale(${scale})`,
            opacity: t2
          });
        },
        easing: cubicOut
      };
    }, "flyAndScale");
  }
});
var layout_svelte_exports = {};
__export(layout_svelte_exports, {
  default: () => _layout
});
function Explore($$payload) {
  $$payload.out += `<svg width="25" height="24" viewBox="0 0 25 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.5 12H16.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path><path d="M12.5 16V8" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path><path d="M9.5 22H15.5C20.5 22 22.5 20 22.5 15V9C22.5 4 20.5 2 15.5 2H9.5C4.5 2 2.5 4 2.5 9V15C2.5 20 4.5 22 9.5 22Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg>`;
}
__name(Explore, "Explore");
function Home($$payload) {
  $$payload.out += `<svg width="23" height="22" viewBox="0 0 23 22" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9.57002 1.82L2.64002 7.37C1.86002 7.99 1.36002 9.3 1.53002 10.28L2.86002 18.24C3.10002 19.66 4.46002 20.81 5.90002 20.81H17.1C18.53 20.81 19.9 19.65 20.14 18.24L21.47 10.28C21.63 9.3 21.13 7.99 20.36 7.37L13.43 1.83C12.36 0.970002 10.63 0.970002 9.57002 1.82Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg>`;
}
__name(Home, "Home");
function More($$payload) {
  $$payload.out += `<svg width="25" height="24" viewBox="0 0 25 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.5 7H21.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"></path><path d="M3.5 12H21.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"></path><path d="M3.5 17H21.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"></path></svg>`;
}
__name(More, "More");
function Tournament($$payload) {
  $$payload.out += `<svg width="25" height="24" viewBox="0 0 25 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12.65 16.5V18.6" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path><path d="M7.65002 22H17.65V21C17.65 19.9 16.75 19 15.65 19H9.65002C8.55002 19 7.65002 19.9 7.65002 21V22V22Z" stroke="currentColor" stroke-width="1.5" stroke-miterlimit="10"></path><path d="M6.65002 22H18.65" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path><path d="M12.5 16C8.63 16 5.5 12.87 5.5 9V6C5.5 3.79 7.29 2 9.5 2H15.5C17.71 2 19.5 3.79 19.5 6V9C19.5 12.87 16.37 16 12.5 16Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path><path d="M5.97004 11.65C5.22004 11.41 4.56004 10.97 4.04004 10.45C3.14004 9.44998 2.54004 8.24998 2.54004 6.84998C2.54004 5.44998 3.64004 4.34998 5.04004 4.34998H5.69004C5.49004 4.80998 5.39004 5.31998 5.39004 5.84998V8.84998C5.39004 9.84998 5.60004 10.79 5.97004 11.65Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path><path d="M19.03 11.65C19.78 11.41 20.44 10.97 20.96 10.45C21.86 9.44998 22.46 8.24998 22.46 6.84998C22.46 5.44998 21.36 4.34998 19.96 4.34998H19.31C19.51 4.80998 19.61 5.31998 19.61 5.84998V8.84998C19.61 9.84998 19.4 10.79 19.03 11.65Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg>`;
}
__name(Tournament, "Tournament");
function Footer($$payload, $$props) {
  push();
  var $$store_subs;
  const items = [
    { name: "home", icon: Home, href: "/" },
    {
      name: "explore",
      icon: Explore,
      href: "/explore"
    },
    {
      name: "tournament",
      icon: Tournament,
      href: "/tournament"
    },
    { name: "more", icon: More, href: "/more" }
  ];
  let activeLink = store_get($$store_subs ??= {}, "$page", page).url.pathname;
  const each_array = ensure_array_like(items);
  $$payload.out += `<div class="sticky bottom-0 flex items-center gap-5 bg-background px-5"><!--[-->`;
  for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
    let item = each_array[$$index];
    $$payload.out += `<a${attr("href", item.href)}${attr("class", cn("flex w-full max-w-28 flex-col items-center  py-2.5 text-center", {
      "border-t-2 border-[#3574F5] text-[#3574F5]": activeLink === item.href
    }))}><!---->`;
    item.icon?.($$payload, {});
    $$payload.out += `<!----> <p class="text-xs capitalize text-inherit">${escape_html(item.name)}</p></a>`;
  }
  $$payload.out += `<!--]--></div>`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
__name(Footer, "Footer");
function _layout($$payload, $$props) {
  push();
  var $$store_subs;
  $$payload.out += `<div class="mx-auto max-w-md"><main class="h-full min-h-svh"><!---->`;
  slot($$payload, $$props, "default", {}, null);
  $$payload.out += `<!----></main> `;
  if (![
    "/login",
    "/chess",
    "/uno",
    "/rps",
    "/checkers"
  ].some((path) => store_get($$store_subs ??= {}, "$page", page).url.pathname.startsWith(path))) {
    $$payload.out += "<!--[-->";
    Footer($$payload);
  } else {
    $$payload.out += "<!--[!-->";
  }
  $$payload.out += `<!--]--></div>`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
__name(_layout, "_layout");
var init_layout_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/_layout.svelte.js"() {
    init_index2();
    init_stores();
    init_utils3();
  }
});
var __exports = {};
__export(__exports, {
  component: () => component,
  fonts: () => fonts,
  imports: () => imports,
  index: () => index,
  stylesheets: () => stylesheets
});
var index;
var component_cache;
var component;
var imports;
var stylesheets;
var fonts;
var init__ = __esm({
  ".svelte-kit/output/server/nodes/0.js"() {
    index = 0;
    component = /* @__PURE__ */ __name(async () => component_cache ??= (await Promise.resolve().then(() => (init_layout_svelte(), layout_svelte_exports))).default, "component");
    imports = ["_app/immutable/nodes/0.WPgdFBDp.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/if.DLf01pqE.js", "_app/immutable/chunks/slot.BDgc6-mN.js", "_app/immutable/chunks/lifecycle.BX15fcyy.js", "_app/immutable/chunks/store.CDnLvhlJ.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/stores.DSH2_rmp.js", "_app/immutable/chunks/entry.Zk5XMwWG.js", "_app/immutable/chunks/index-client.bJHR976g.js", "_app/immutable/chunks/index.bE0HzIKx.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/svelte-component.CXtuGKwm.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js", "_app/immutable/chunks/class.waVxCJrB.js", "_app/immutable/chunks/utils.B8KE5qsB.js", "_app/immutable/chunks/bundle-mjs.BNYwEHuQ.js"];
    stylesheets = ["_app/immutable/assets/0.Cx18_t1p.css"];
    fonts = [];
  }
});
var error_svelte_exports = {};
__export(error_svelte_exports, {
  default: () => Error2
});
function Error2($$payload, $$props) {
  push();
  var $$store_subs;
  $$payload.out += `<h1>${escape_html(store_get($$store_subs ??= {}, "$page", page).status)}</h1> <p>${escape_html(store_get($$store_subs ??= {}, "$page", page).error?.message)}</p>`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
__name(Error2, "Error2");
var init_error_svelte = __esm({
  ".svelte-kit/output/server/entries/fallbacks/error.svelte.js"() {
    init_index2();
    init_stores();
  }
});
var __exports2 = {};
__export(__exports2, {
  component: () => component2,
  fonts: () => fonts2,
  imports: () => imports2,
  index: () => index2,
  stylesheets: () => stylesheets2
});
var index2;
var component_cache2;
var component2;
var imports2;
var stylesheets2;
var fonts2;
var init__2 = __esm({
  ".svelte-kit/output/server/nodes/1.js"() {
    index2 = 1;
    component2 = /* @__PURE__ */ __name(async () => component_cache2 ??= (await Promise.resolve().then(() => (init_error_svelte(), error_svelte_exports))).default, "component2");
    imports2 = ["_app/immutable/nodes/1.gLVXDHzS.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/lifecycle.BX15fcyy.js", "_app/immutable/chunks/store.CDnLvhlJ.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/stores.DSH2_rmp.js", "_app/immutable/chunks/entry.Zk5XMwWG.js", "_app/immutable/chunks/index-client.bJHR976g.js", "_app/immutable/chunks/index.bE0HzIKx.js"];
    stylesheets2 = [];
    fonts2 = [];
  }
});
var layout_server_ts_exports = {};
__export(layout_server_ts_exports, {
  load: () => load
});
async function getUserWithStats(db, userId) {
  const user = await db.query.usersTable.findFirst({
    where: (users) => eq(users.id, userId),
    with: {
      stats: {
        with: {
          game: true
        }
      }
    }
  });
  return user;
}
__name(getUserWithStats, "getUserWithStats");
var load;
var init_layout_server_ts = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/_layout.server.ts.js"() {
    init_schema();
    init_drizzle_orm();
    init_chunks();
    load = /* @__PURE__ */ __name(async ({ locals: { user, db } }) => {
      if (!user) {
        redirect(308, "/login");
      }
      const userWithStats = await getUserWithStats(db, user.id);
      return {
        user,
        userWithStats
      };
    }, "load");
  }
});
var layout_svelte_exports2 = {};
__export(layout_svelte_exports2, {
  default: () => _layout2
});
function _layout2($$payload, $$props) {
  $$payload.out += `<a href="../" class="mb-10 mt-5 block"><img src="./backBtn.svg" alt=""></a> <main class="px-2"><!---->`;
  slot($$payload, $$props, "default", {}, null);
  $$payload.out += `<!----></main>`;
}
__name(_layout2, "_layout2");
var init_layout_svelte2 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/_layout.svelte.js"() {
    init_index2();
  }
});
var __exports3 = {};
__export(__exports3, {
  component: () => component3,
  fonts: () => fonts3,
  imports: () => imports3,
  index: () => index3,
  server: () => layout_server_ts_exports,
  server_id: () => server_id,
  stylesheets: () => stylesheets3
});
var index3;
var component_cache3;
var component3;
var server_id;
var imports3;
var stylesheets3;
var fonts3;
var init__3 = __esm({
  ".svelte-kit/output/server/nodes/2.js"() {
    init_layout_server_ts();
    index3 = 2;
    component3 = /* @__PURE__ */ __name(async () => component_cache3 ??= (await Promise.resolve().then(() => (init_layout_svelte2(), layout_svelte_exports2))).default, "component3");
    server_id = "src/routes/(app)/+layout.server.ts";
    imports3 = ["_app/immutable/nodes/2.BX0PdA2x.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/slot.BDgc6-mN.js"];
    stylesheets3 = [];
    fonts3 = [];
  }
});
var layout_svelte_exports3 = {};
__export(layout_svelte_exports3, {
  default: () => _layout3
});
function _layout3($$payload, $$props) {
  $$payload.out += `<div class="px-4"><!---->`;
  slot($$payload, $$props, "default", {}, null);
  $$payload.out += `<!----></div>`;
}
__name(_layout3, "_layout3");
var init_layout_svelte3 = __esm({
  ".svelte-kit/output/server/entries/pages/(auth)/_layout.svelte.js"() {
    init_index2();
  }
});
var __exports4 = {};
__export(__exports4, {
  component: () => component4,
  fonts: () => fonts4,
  imports: () => imports4,
  index: () => index4,
  stylesheets: () => stylesheets4
});
var index4;
var component_cache4;
var component4;
var imports4;
var stylesheets4;
var fonts4;
var init__4 = __esm({
  ".svelte-kit/output/server/nodes/3.js"() {
    index4 = 3;
    component4 = /* @__PURE__ */ __name(async () => component_cache4 ??= (await Promise.resolve().then(() => (init_layout_svelte3(), layout_svelte_exports3))).default, "component4");
    imports4 = ["_app/immutable/nodes/3.DTcuiY5R.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/slot.BDgc6-mN.js"];
    stylesheets4 = [];
    fonts4 = [];
  }
});
var page_server_ts_exports = {};
var init_page_server_ts = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/_page.server.ts.js"() {
  }
});
function onDestroy(fn) {
  var context = (
    /** @type {Component} */
    current_component
  );
  (context.d ??= []).push(fn);
}
__name(onDestroy, "onDestroy");
async function tick() {
}
__name(tick, "tick");
var init_index_server = __esm({
  ".svelte-kit/output/server/chunks/index-server.js"() {
    init_index2();
  }
});
function styleToString(style) {
  return Object.keys(style).reduce((str, key2) => {
    if (style[key2] === void 0)
      return str;
    return str + `${key2}:${style[key2]};`;
  }, "");
}
__name(styleToString, "styleToString");
function disabledAttr(disabled) {
  return disabled ? true : void 0;
}
__name(disabledAttr, "disabledAttr");
function portalAttr(portal) {
  if (portal !== null) {
    return "";
  }
  return void 0;
}
__name(portalAttr, "portalAttr");
function lightable(value) {
  function subscribe(run) {
    run(value);
    return () => {
    };
  }
  __name(subscribe, "subscribe");
  return { subscribe };
}
__name(lightable, "lightable");
function makeElement(name3, args) {
  const { stores, action, returned } = args ?? {};
  const derivedStore = (() => {
    if (stores && returned) {
      return derived(stores, (values) => {
        const result = returned(values);
        if (isFunctionWithParams(result)) {
          const fn = /* @__PURE__ */ __name((...args2) => {
            return hiddenAction({
              ...result(...args2),
              [`data-melt-${name3}`]: "",
              action: action ?? noop2
            });
          }, "fn");
          fn.action = action ?? noop2;
          return fn;
        }
        return hiddenAction({
          ...result,
          [`data-melt-${name3}`]: "",
          action: action ?? noop2
        });
      });
    } else {
      const returnedFn = returned;
      const result = returnedFn?.();
      if (isFunctionWithParams(result)) {
        const resultFn = /* @__PURE__ */ __name((...args2) => {
          return hiddenAction({
            ...result(...args2),
            [`data-melt-${name3}`]: "",
            action: action ?? noop2
          });
        }, "resultFn");
        resultFn.action = action ?? noop2;
        return lightable(resultFn);
      }
      return lightable(hiddenAction({
        ...result,
        [`data-melt-${name3}`]: "",
        action: action ?? noop2
      }));
    }
  })();
  const actionFn = action ?? (() => {
  });
  actionFn.subscribe = derivedStore.subscribe;
  return actionFn;
}
__name(makeElement, "makeElement");
function createElHelpers(prefix) {
  const name3 = /* @__PURE__ */ __name((part) => part ? `${prefix}-${part}` : prefix, "name3");
  const attribute = /* @__PURE__ */ __name((part) => `data-melt-${prefix}${part ? `-${part}` : ""}`, "attribute");
  const selector2 = /* @__PURE__ */ __name((part) => `[data-melt-${prefix}${part ? `-${part}` : ""}]`, "selector2");
  const getEl = /* @__PURE__ */ __name((part) => document.querySelector(selector2(part)), "getEl");
  return {
    name: name3,
    attribute,
    selector: selector2,
    getEl
  };
}
__name(createElHelpers, "createElHelpers");
function isElement(element2) {
  return element2 instanceof Element;
}
__name(isElement, "isElement");
function isHTMLElement(element2) {
  return element2 instanceof HTMLElement;
}
__name(isHTMLElement, "isHTMLElement");
function isElementDisabled(element2) {
  const ariaDisabled = element2.getAttribute("aria-disabled");
  const disabled = element2.getAttribute("disabled");
  const dataDisabled = element2.hasAttribute("data-disabled");
  if (ariaDisabled === "true" || disabled !== null || dataDisabled) {
    return true;
  }
  return false;
}
__name(isElementDisabled, "isElementDisabled");
function isObject(value) {
  return value !== null && typeof value === "object";
}
__name(isObject, "isObject");
function isReadable(value) {
  return isObject(value) && "subscribe" in value;
}
__name(isReadable, "isReadable");
function executeCallbacks(...callbacks) {
  return (...args) => {
    for (const callback of callbacks) {
      if (typeof callback === "function") {
        callback(...args);
      }
    }
  };
}
__name(executeCallbacks, "executeCallbacks");
function noop2() {
}
__name(noop2, "noop2");
function addEventListener(target, event, handler, options2) {
  const events = Array.isArray(event) ? event : [event];
  events.forEach((_event) => target.addEventListener(_event, handler, options2));
  return () => {
    events.forEach((_event) => target.removeEventListener(_event, handler, options2));
  };
}
__name(addEventListener, "addEventListener");
function addMeltEventListener(target, event, handler, options2) {
  const events = Array.isArray(event) ? event : [event];
  if (typeof handler === "function") {
    const handlerWithMelt = withMelt((_event) => handler(_event));
    events.forEach((_event) => target.addEventListener(_event, handlerWithMelt, options2));
    return () => {
      events.forEach((_event) => target.removeEventListener(_event, handlerWithMelt, options2));
    };
  }
  return () => noop2();
}
__name(addMeltEventListener, "addMeltEventListener");
function dispatchMeltEvent(originalEvent) {
  const node = originalEvent.currentTarget;
  if (!isHTMLElement(node))
    return null;
  const customMeltEvent = new CustomEvent(`m-${originalEvent.type}`, {
    detail: {
      originalEvent
    },
    cancelable: true
  });
  node.dispatchEvent(customMeltEvent);
  return customMeltEvent;
}
__name(dispatchMeltEvent, "dispatchMeltEvent");
function withMelt(handler) {
  return (event) => {
    const customEvent = dispatchMeltEvent(event);
    if (customEvent?.defaultPrevented)
      return;
    return handler(event);
  };
}
__name(withMelt, "withMelt");
function omit(obj, ...keys) {
  const result = {};
  for (const key2 of Object.keys(obj)) {
    if (!keys.includes(key2)) {
      result[key2] = obj[key2];
    }
  }
  return result;
}
__name(omit, "omit");
function withGet(store) {
  return {
    ...store,
    get: () => get2(store)
  };
}
__name(withGet, "withGet");
function effect2(stores, fn) {
  let cb = void 0;
  const destroy = derived(stores, (stores2) => {
    cb?.();
    cb = fn(stores2);
  }).subscribe(noop2);
  const unsub = /* @__PURE__ */ __name(() => {
    destroy();
    cb?.();
  }, "unsub");
  safeOnDestroy(unsub);
  return unsub;
}
__name(effect2, "effect2");
var hiddenAction;
var isFunctionWithParams;
var isBrowser;
var isFunction;
var safeOnMount;
var safeOnDestroy;
var kbd;
var FIRST_KEYS;
var LAST_KEYS;
var FIRST_LAST_KEYS;
var SELECTION_KEYS;
var getNextKey;
var getPrevKey;
var getDirectionalKeys;
var documentEscapeKeyStore;
var useEscapeKeydown;
var defaults;
var init_create = __esm({
  ".svelte-kit/output/server/chunks/create.js"() {
    init_index4();
    init_index_server();
    init_index2();
    ({
      type: "hidden",
      "aria-hidden": true,
      hidden: true,
      tabIndex: -1,
      style: styleToString({
        position: "absolute",
        opacity: 0,
        "pointer-events": "none",
        margin: 0,
        transform: "translateX(-100%)"
      })
    });
    hiddenAction = /* @__PURE__ */ __name((obj) => {
      return new Proxy(obj, {
        get(target, prop, receiver) {
          return Reflect.get(target, prop, receiver);
        },
        ownKeys(target) {
          return Reflect.ownKeys(target).filter((key2) => key2 !== "action");
        }
      });
    }, "hiddenAction");
    isFunctionWithParams = /* @__PURE__ */ __name((fn) => {
      return typeof fn === "function";
    }, "isFunctionWithParams");
    makeElement("empty");
    isBrowser = typeof document !== "undefined";
    isFunction = /* @__PURE__ */ __name((v2) => typeof v2 === "function", "isFunction");
    safeOnMount = /* @__PURE__ */ __name((fn) => {
      try {
        noop(fn);
      } catch {
        return fn;
      }
    }, "safeOnMount");
    safeOnDestroy = /* @__PURE__ */ __name((fn) => {
      try {
        onDestroy(fn);
      } catch {
        return fn;
      }
    }, "safeOnDestroy");
    withGet.writable = function(initial2) {
      const internal2 = writable(initial2);
      let value = initial2;
      return {
        subscribe: internal2.subscribe,
        set(newValue) {
          internal2.set(newValue);
          value = newValue;
        },
        update(updater) {
          const newValue = updater(value);
          internal2.set(newValue);
          value = newValue;
        },
        get() {
          return value;
        }
      };
    };
    withGet.derived = function(stores, fn) {
      const subscribers = /* @__PURE__ */ new Map();
      const get23 = /* @__PURE__ */ __name(() => {
        const values = Array.isArray(stores) ? stores.map((store) => store.get()) : stores.get();
        return fn(values);
      }, "get23");
      const subscribe = /* @__PURE__ */ __name((subscriber) => {
        const unsubscribers = [];
        const storesArr = Array.isArray(stores) ? stores : [stores];
        storesArr.forEach((store) => {
          unsubscribers.push(store.subscribe(() => {
            subscriber(get23());
          }));
        });
        subscriber(get23());
        subscribers.set(subscriber, unsubscribers);
        return () => {
          const unsubscribers2 = subscribers.get(subscriber);
          if (unsubscribers2) {
            for (const unsubscribe of unsubscribers2) {
              unsubscribe();
            }
          }
          subscribers.delete(subscriber);
        };
      }, "subscribe");
      return {
        get: get23,
        subscribe
      };
    };
    kbd = {
      ALT: "Alt",
      ARROW_DOWN: "ArrowDown",
      ARROW_LEFT: "ArrowLeft",
      ARROW_RIGHT: "ArrowRight",
      ARROW_UP: "ArrowUp",
      BACKSPACE: "Backspace",
      CAPS_LOCK: "CapsLock",
      CONTROL: "Control",
      DELETE: "Delete",
      END: "End",
      ENTER: "Enter",
      ESCAPE: "Escape",
      F1: "F1",
      F10: "F10",
      F11: "F11",
      F12: "F12",
      F2: "F2",
      F3: "F3",
      F4: "F4",
      F5: "F5",
      F6: "F6",
      F7: "F7",
      F8: "F8",
      F9: "F9",
      HOME: "Home",
      META: "Meta",
      PAGE_DOWN: "PageDown",
      PAGE_UP: "PageUp",
      SHIFT: "Shift",
      SPACE: " ",
      TAB: "Tab",
      CTRL: "Control",
      ASTERISK: "*",
      A: "a",
      P: "p"
    };
    FIRST_KEYS = [kbd.ARROW_DOWN, kbd.PAGE_UP, kbd.HOME];
    LAST_KEYS = [kbd.ARROW_UP, kbd.PAGE_DOWN, kbd.END];
    FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
    SELECTION_KEYS = [kbd.ENTER, kbd.SPACE];
    getNextKey = /* @__PURE__ */ __name((dir = "ltr", orientation = "horizontal") => {
      return {
        horizontal: dir === "rtl" ? kbd.ARROW_LEFT : kbd.ARROW_RIGHT,
        vertical: kbd.ARROW_DOWN
      }[orientation];
    }, "getNextKey");
    getPrevKey = /* @__PURE__ */ __name((dir = "ltr", orientation = "horizontal") => {
      return {
        horizontal: dir === "rtl" ? kbd.ARROW_RIGHT : kbd.ARROW_LEFT,
        vertical: kbd.ARROW_UP
      }[orientation];
    }, "getPrevKey");
    getDirectionalKeys = /* @__PURE__ */ __name((dir = "ltr", orientation = "horizontal") => {
      return {
        nextKey: getNextKey(dir, orientation),
        prevKey: getPrevKey(dir, orientation)
      };
    }, "getDirectionalKeys");
    readable(void 0, (set3) => {
      function clicked(event) {
        set3(event);
        set3(void 0);
      }
      __name(clicked, "clicked");
      const unsubscribe = addEventListener(document, "pointerup", clicked, {
        passive: false,
        capture: true
      });
      return unsubscribe;
    });
    documentEscapeKeyStore = readable(void 0, (set3) => {
      function keydown(event) {
        if (event && event.key === kbd.ESCAPE) {
          set3(event);
        }
        set3(void 0);
      }
      __name(keydown, "keydown");
      const unsubscribe = addEventListener(document, "keydown", keydown, {
        passive: false
      });
      return unsubscribe;
    });
    useEscapeKeydown = /* @__PURE__ */ __name((node, config = {}) => {
      let unsub = noop2;
      function update(config2 = {}) {
        unsub();
        const options2 = { enabled: true, ...config2 };
        const enabled = isReadable(options2.enabled) ? options2.enabled : readable(options2.enabled);
        unsub = executeCallbacks(
          // Handle escape keydowns
          documentEscapeKeyStore.subscribe((e3) => {
            if (!e3 || !get2(enabled))
              return;
            const target = e3.target;
            if (!isHTMLElement(target) || target.closest("[data-escapee]") !== node) {
              return;
            }
            e3.preventDefault();
            if (options2.ignore) {
              if (isFunction(options2.ignore)) {
                if (options2.ignore(e3))
                  return;
              } else if (Array.isArray(options2.ignore)) {
                if (options2.ignore.length > 0 && options2.ignore.some((ignoreEl) => {
                  return ignoreEl && target === ignoreEl;
                }))
                  return;
              }
            }
            options2.handler?.(e3);
          }),
          effect2(enabled, ($enabled) => {
            if ($enabled) {
              node.dataset.escapee = "";
            } else {
              delete node.dataset.escapee;
            }
          })
        );
      }
      __name(update, "update");
      update(config);
      return {
        update,
        destroy() {
          node.removeAttribute("data-escapee");
          unsub();
        }
      };
    }, "useEscapeKeydown");
    ({
      prefix: "",
      disabled: readable(false),
      required: readable(false),
      name: readable(void 0)
    });
    defaults = {
      isDateDisabled: void 0,
      isDateUnavailable: void 0,
      value: void 0,
      preventDeselect: false,
      numberOfMonths: 1,
      pagedNavigation: false,
      weekStartsOn: 0,
      fixedWeeks: false,
      calendarLabel: "Event Date",
      locale: "en",
      minValue: void 0,
      maxValue: void 0,
      disabled: false,
      readonly: false,
      weekdayFormat: "narrow"
    };
    ({
      isDateDisabled: void 0,
      isDateUnavailable: void 0,
      value: void 0,
      positioning: {
        placement: "bottom"
      },
      closeOnEscape: true,
      closeOnOutsideClick: true,
      onOutsideClick: void 0,
      preventScroll: false,
      forceVisible: false,
      locale: "en",
      granularity: void 0,
      disabled: false,
      readonly: false,
      minValue: void 0,
      maxValue: void 0,
      weekdayFormat: "narrow",
      ...omit(defaults, "isDateDisabled", "isDateUnavailable", "value", "locale", "disabled", "readonly", "minValue", "maxValue", "weekdayFormat")
    });
  }
});
function i(e3, o2) {
  e3.forEach(function(r3) {
    Array.isArray(r3) ? i(r3, o2) : o2.push(r3);
  });
}
__name(i, "i");
function y(e3) {
  let o2 = [];
  return i(e3, o2), o2;
}
__name(y, "y");
var l;
var u;
var x;
var a;
var p;
var g;
var init_chunk_JXBJZR5A = __esm({
  "node_modules/.pnpm/tailwind-variants@0.2.1_tailwindcss@3.4.14/node_modules/tailwind-variants/dist/chunk-JXBJZR5A.js"() {
    l = /* @__PURE__ */ __name((e3) => typeof e3 == "boolean" ? `${e3}` : e3 === 0 ? "0" : e3, "l");
    u = /* @__PURE__ */ __name((e3) => !e3 || typeof e3 != "object" || Object.keys(e3).length === 0, "u");
    x = /* @__PURE__ */ __name((e3, o2) => JSON.stringify(e3) === JSON.stringify(o2), "x");
    a = /* @__PURE__ */ __name((...e3) => y(e3).filter(Boolean), "a");
    p = /* @__PURE__ */ __name((e3, o2) => {
      let r3 = {}, c2 = Object.keys(e3), f = Object.keys(o2);
      for (let t2 of c2)
        if (f.includes(t2)) {
          let s3 = e3[t2], n2 = o2[t2];
          typeof s3 == "object" && typeof n2 == "object" ? r3[t2] = p(s3, n2) : Array.isArray(s3) || Array.isArray(n2) ? r3[t2] = a(n2, s3) : r3[t2] = n2 + " " + s3;
        } else
          r3[t2] = e3[t2];
      for (let t2 of f)
        c2.includes(t2) || (r3[t2] = o2[t2]);
      return r3;
    }, "p");
    g = /* @__PURE__ */ __name((e3) => !e3 || typeof e3 != "string" ? e3 : e3.replace(/\s+/g, " ").trim(), "g");
  }
});
var ie;
var _;
var M;
var R;
var v;
var q;
var j;
var Z;
var ce;
var init_dist3 = __esm({
  "node_modules/.pnpm/tailwind-variants@0.2.1_tailwindcss@3.4.14/node_modules/tailwind-variants/dist/index.js"() {
    init_chunk_JXBJZR5A();
    init_bundle_mjs();
    ie = { twMerge: true, twMergeConfig: {}, responsiveVariants: false };
    _ = /* @__PURE__ */ __name((s3) => s3 || void 0, "_");
    M = /* @__PURE__ */ __name((...s3) => _(y(s3).filter(Boolean).join(" ")), "M");
    R = null;
    v = {};
    q = false;
    j = /* @__PURE__ */ __name((...s3) => (b$1) => b$1.twMerge ? ((!R || q) && (q = false, R = u(v) ? twMerge : extendTailwindMerge({ ...v, extend: { theme: v.theme, classGroups: v.classGroups, conflictingClassGroupModifiers: v.conflictingClassGroupModifiers, conflictingClassGroups: v.conflictingClassGroups, ...v.extend } })), _(R(M(s3)))) : M(s3), "j");
    Z = /* @__PURE__ */ __name((s3, b) => {
      for (let e3 in b)
        s3.hasOwnProperty(e3) ? s3[e3] = M(s3[e3], b[e3]) : s3[e3] = b[e3];
      return s3;
    }, "Z");
    ce = /* @__PURE__ */ __name((s3, b$1) => {
      let { extend: e3 = null, slots: N = {}, variants: F = {}, compoundVariants: U = [], compoundSlots: C = [], defaultVariants: W = {} } = s3, m = { ...ie, ...b$1 }, S = e3 != null && e3.base ? M(e3.base, s3 == null ? void 0 : s3.base) : s3 == null ? void 0 : s3.base, g$1 = e3 != null && e3.variants && !u(e3.variants) ? p(F, e3.variants) : F, A = e3 != null && e3.defaultVariants && !u(e3.defaultVariants) ? { ...e3.defaultVariants, ...W } : W;
      !u(m.twMergeConfig) && !x(m.twMergeConfig, v) && (q = true, v = m.twMergeConfig);
      let O = u(e3 == null ? void 0 : e3.slots), $ = u(N) ? {} : { base: M(s3 == null ? void 0 : s3.base, O && (e3 == null ? void 0 : e3.base)), ...N }, w = O ? $ : Z({ ...e3 == null ? void 0 : e3.slots }, u($) ? { base: s3 == null ? void 0 : s3.base } : $), h$1 = u(e3 == null ? void 0 : e3.compoundVariants) ? U : a(e3 == null ? void 0 : e3.compoundVariants, U), V = /* @__PURE__ */ __name((f) => {
        if (u(g$1) && u(N) && O)
          return j(S, f == null ? void 0 : f.class, f == null ? void 0 : f.className)(m);
        if (h$1 && !Array.isArray(h$1))
          throw new TypeError(`The "compoundVariants" prop must be an array. Received: ${typeof h$1}`);
        if (C && !Array.isArray(C))
          throw new TypeError(`The "compoundSlots" prop must be an array. Received: ${typeof C}`);
        let K7 = /* @__PURE__ */ __name((t2, n2, a2 = [], i2) => {
          let r3 = a2;
          if (typeof n2 == "string")
            r3 = r3.concat(g(n2).split(" ").map((o2) => `${t2}:${o2}`));
          else if (Array.isArray(n2))
            r3 = r3.concat(n2.reduce((o2, c2) => o2.concat(`${t2}:${c2}`), []));
          else if (typeof n2 == "object" && typeof i2 == "string") {
            for (let o2 in n2)
              if (n2.hasOwnProperty(o2) && o2 === i2) {
                let c2 = n2[o2];
                if (c2 && typeof c2 == "string") {
                  let l2 = g(c2);
                  r3[i2] ? r3[i2] = r3[i2].concat(l2.split(" ").map((u2) => `${t2}:${u2}`)) : r3[i2] = l2.split(" ").map((u2) => `${t2}:${u2}`);
                } else
                  Array.isArray(c2) && c2.length > 0 && (r3[i2] = c2.reduce((l2, u2) => l2.concat(`${t2}:${u2}`), []));
              }
          }
          return r3;
        }, "K7"), z2 = /* @__PURE__ */ __name((t2, n2 = g$1, a$1 = null, i2 = null) => {
          var J;
          let r3 = n2[t2];
          if (!r3 || u(r3))
            return null;
          let o2 = (J = i2 == null ? void 0 : i2[t2]) != null ? J : f == null ? void 0 : f[t2];
          if (o2 === null)
            return null;
          let c2 = l(o2), l2 = Array.isArray(m.responsiveVariants) && m.responsiveVariants.length > 0 || m.responsiveVariants === true, u2 = A == null ? void 0 : A[t2], d = [];
          if (typeof c2 == "object" && l2)
            for (let [T, L] of Object.entries(c2)) {
              let ne2 = r3[L];
              if (T === "initial") {
                u2 = L;
                continue;
              }
              Array.isArray(m.responsiveVariants) && !m.responsiveVariants.includes(T) || (d = K7(T, ne2, d, a$1));
            }
          let ae = c2 != null && typeof c2 != "object" ? c2 : l(u2), k = r3[ae || "false"];
          return typeof d == "object" && typeof a$1 == "string" && d[a$1] ? Z(d, k) : d.length > 0 ? (d.push(k), d) : k;
        }, "z2"), P = /* @__PURE__ */ __name(() => g$1 ? Object.keys(g$1).map((t2) => z2(t2, g$1)) : null, "P"), p2 = /* @__PURE__ */ __name((t2, n2) => {
          if (!g$1 || typeof g$1 != "object")
            return null;
          let a2 = new Array();
          for (let i2 in g$1) {
            let r3 = z2(i2, g$1, t2, n2), o2 = t2 === "base" && typeof r3 == "string" ? r3 : r3 && r3[t2];
            o2 && (a2[a2.length] = o2);
          }
          return a2;
        }, "p2"), D = {};
        for (let t2 in f)
          f[t2] !== void 0 && (D[t2] = f[t2]);
        let H = /* @__PURE__ */ __name((t2, n2) => {
          var i2;
          let a2 = typeof (f == null ? void 0 : f[t2]) == "object" ? { [t2]: (i2 = f[t2]) == null ? void 0 : i2.initial } : {};
          return { ...A, ...D, ...a2, ...n2 };
        }, "H"), I = /* @__PURE__ */ __name((t2 = [], n2) => {
          let a2 = [];
          for (let { class: i2, className: r3, ...o2 } of t2) {
            let c2 = true;
            for (let [l2, u2] of Object.entries(o2)) {
              let d = H(l2, n2);
              if (Array.isArray(u2)) {
                if (!u2.includes(d[l2])) {
                  c2 = false;
                  break;
                }
              } else if (d[l2] !== u2) {
                c2 = false;
                break;
              }
            }
            c2 && (i2 && a2.push(i2), r3 && a2.push(r3));
          }
          return a2;
        }, "I"), ee = /* @__PURE__ */ __name((t2) => {
          let n2 = I(h$1, t2);
          if (!Array.isArray(n2))
            return n2;
          let a2 = {};
          for (let i2 of n2)
            if (typeof i2 == "string" && (a2.base = j(a2.base, i2)(m)), typeof i2 == "object")
              for (let [r3, o2] of Object.entries(i2))
                a2[r3] = j(a2[r3], o2)(m);
          return a2;
        }, "ee"), te = /* @__PURE__ */ __name((t2) => {
          if (C.length < 1)
            return null;
          let n2 = {};
          for (let { slots: a2 = [], class: i2, className: r3, ...o2 } of C) {
            if (!u(o2)) {
              let c2 = true;
              for (let l2 of Object.keys(o2)) {
                let u2 = H(l2, t2)[l2];
                if (u2 === void 0 || (Array.isArray(o2[l2]) ? !o2[l2].includes(u2) : o2[l2] !== u2)) {
                  c2 = false;
                  break;
                }
              }
              if (!c2)
                continue;
            }
            for (let c2 of a2)
              n2[c2] = n2[c2] || [], n2[c2].push([i2, r3]);
          }
          return n2;
        }, "te");
        if (!u(N) || !O) {
          let t2 = {};
          if (typeof w == "object" && !u(w))
            for (let n2 of Object.keys(w))
              t2[n2] = (a2) => {
                var i2, r3;
                return j(w[n2], p2(n2, a2), ((i2 = ee(a2)) != null ? i2 : [])[n2], ((r3 = te(a2)) != null ? r3 : [])[n2], a2 == null ? void 0 : a2.class, a2 == null ? void 0 : a2.className)(m);
              };
          return t2;
        }
        return j(S, P(), I(h$1), f == null ? void 0 : f.class, f == null ? void 0 : f.className)(m);
      }, "V"), x2 = /* @__PURE__ */ __name(() => {
        if (!(!g$1 || typeof g$1 != "object"))
          return Object.keys(g$1);
      }, "x2");
      return V.variantKeys = x2(), V.extend = e3, V.base = S, V.slots = w, V.variants = g$1, V.defaultVariants = A, V.compoundSlots = C, V.compoundVariants = h$1, V;
    }, "ce");
  }
});
var buttonVariants;
var init_index3 = __esm({
  ".svelte-kit/output/server/chunks/index3.js"() {
    init_dist3();
    init_create();
    init_clsx();
    buttonVariants = ce({
      base: "inline-flex items-center justify-center whitespace-nowrap  rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
      variants: {
        variant: {
          default: "bg-primary text-primary-foreground hover:bg-primary/90",
          destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
          outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
          secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
          ghost: "hover:bg-accent hover:text-accent-foreground",
          link: "text-primary underline-offset-4 hover:underline"
        },
        size: {
          default: "h-[40px] px-4 py-2",
          sm: "h-9 rounded-md px-3",
          lg: "h-11 rounded-md px-8",
          icon: "h-10 w-10"
        }
      },
      defaultVariants: {
        variant: "default",
        size: "default"
      }
    });
  }
});
function Table2($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  let className = fallback($$props["class"], void 0);
  $$payload.out += `<div class="relative w-full overflow-auto"><table${spread_attributes({
    class: cn("w-full caption-bottom text-sm", className),
    ...$$restProps
  })}><!---->`;
  slot($$payload, $$props, "default", {}, null);
  $$payload.out += `<!----></table></div>`;
  bind_props($$props, { class: className });
  pop();
}
__name(Table2, "Table2");
function Table_body($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  let className = fallback($$props["class"], void 0);
  $$payload.out += `<tbody${spread_attributes({
    class: cn("[&_tr:last-child]:border-0", className),
    ...$$restProps
  })}><!---->`;
  slot($$payload, $$props, "default", {}, null);
  $$payload.out += `<!----></tbody>`;
  bind_props($$props, { class: className });
  pop();
}
__name(Table_body, "Table_body");
function Table_cell($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  let className = fallback($$props["class"], void 0);
  $$payload.out += `<td${spread_attributes({
    class: cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className),
    ...$$restProps
  })}><!---->`;
  slot($$payload, $$props, "default", {}, null);
  $$payload.out += `<!----></td>`;
  bind_props($$props, { class: className });
  pop();
}
__name(Table_cell, "Table_cell");
function Table_head($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  let className = fallback($$props["class"], void 0);
  $$payload.out += `<th${spread_attributes({
    class: cn("h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0", className),
    ...$$restProps
  })}><!---->`;
  slot($$payload, $$props, "default", {}, null);
  $$payload.out += `<!----></th>`;
  bind_props($$props, { class: className });
  pop();
}
__name(Table_head, "Table_head");
function Table_header($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  let className = fallback($$props["class"], void 0);
  $$payload.out += `<thead${spread_attributes({
    class: cn("[&_tr]:border-b", className),
    ...$$restProps
  })}><!---->`;
  slot($$payload, $$props, "default", {}, null);
  $$payload.out += `<!----></thead>`;
  bind_props($$props, { class: className });
  pop();
}
__name(Table_header, "Table_header");
function Table_row($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  let className = fallback($$props["class"], void 0);
  $$payload.out += `<tr${spread_attributes({
    class: cn("border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted", className),
    ...$$restProps
  })}><!---->`;
  slot($$payload, $$props, "default", {}, null);
  $$payload.out += `<!----></tr>`;
  bind_props($$props, { class: className });
  pop();
}
__name(Table_row, "Table_row");
var init_table_row = __esm({
  ".svelte-kit/output/server/chunks/table-row.js"() {
    init_index2();
    init_utils3();
  }
});
function next(array3, index39, loop = true) {
  if (index39 === array3.length - 1) {
    return loop ? array3[0] : array3[index39];
  }
  return array3[index39 + 1];
}
__name(next, "next");
function prev(array3, currentIndex, loop = true) {
  if (currentIndex <= 0) {
    return loop ? array3[array3.length - 1] : array3[0];
  }
  return array3[currentIndex - 1];
}
__name(prev, "prev");
function last(array3) {
  return array3[array3.length - 1];
}
__name(last, "last");
function wrapArray(array3, startIndex) {
  return array3.map((_2, index39) => array3[(startIndex + index39) % array3.length]);
}
__name(wrapArray, "wrapArray");
var init_array2 = __esm({
  ".svelte-kit/output/server/chunks/array.js"() {
  }
});
function toWritableStores(properties) {
  const result = {};
  Object.keys(properties).forEach((key2) => {
    const propertyKey = key2;
    const value = properties[propertyKey];
    result[propertyKey] = withGet(writable(value));
  });
  return result;
}
__name(toWritableStores, "toWritableStores");
function createBitAttrs(bit, parts) {
  const attrs = {};
  parts.forEach((part) => {
    attrs[part] = {
      [`data-${bit}-${part}`]: ""
    };
  });
  return (part) => attrs[part];
}
__name(createBitAttrs, "createBitAttrs");
function disabledAttrs(disabled) {
  return disabled ? { "aria-disabled": "true", "data-disabled": "" } : { "aria-disabled": void 0, "data-disabled": void 0 };
}
__name(disabledAttrs, "disabledAttrs");
function removeUndefined(obj) {
  const result = {};
  for (const key2 in obj) {
    const value = obj[key2];
    if (value !== void 0) {
      result[key2] = value;
    }
  }
  return result;
}
__name(removeUndefined, "removeUndefined");
function getOptionUpdater(options2) {
  return function(key2, value) {
    if (value === void 0)
      return;
    const store = options2[key2];
    if (store) {
      store.set(value);
    }
  };
}
__name(getOptionUpdater, "getOptionUpdater");
var overridable;
var init_updater = __esm({
  ".svelte-kit/output/server/chunks/updater.js"() {
    init_create();
    init_index4();
    overridable = /* @__PURE__ */ __name((_store, onChange) => {
      const store = withGet(_store);
      const update = /* @__PURE__ */ __name((updater, sideEffect) => {
        store.update((curr) => {
          const next2 = updater(curr);
          let res = next2;
          if (onChange) {
            res = onChange({ curr, next: next2 });
          }
          sideEffect?.(res);
          return res;
        });
      }, "update");
      const set3 = /* @__PURE__ */ __name((curr) => {
        update(() => curr);
      }, "set3");
      return {
        ...store,
        update,
        set: set3
      };
    }, "overridable");
  }
});
function getElemDirection(elem) {
  const style = window.getComputedStyle(elem);
  const direction = style.getPropertyValue("direction");
  return direction;
}
__name(getElemDirection, "getElemDirection");
function createTabs(props) {
  const withDefaults = { ...defaults2, ...props };
  const options2 = toWritableStores(omit(withDefaults, "defaultValue", "value", "onValueChange", "autoSet"));
  const { orientation, activateOnFocus, loop } = options2;
  const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);
  const value = overridable(valueWritable, withDefaults?.onValueChange);
  let ssrValue = withDefaults.defaultValue ?? value.get();
  const root2 = makeElement(name(), {
    stores: orientation,
    returned: ($orientation) => {
      return {
        "data-orientation": $orientation
      };
    }
  });
  const list = makeElement(name("list"), {
    stores: orientation,
    returned: ($orientation) => {
      return {
        role: "tablist",
        "aria-orientation": $orientation,
        "data-orientation": $orientation
      };
    }
  });
  const parseTriggerProps = /* @__PURE__ */ __name((props2) => {
    if (typeof props2 === "string") {
      return { value: props2 };
    } else {
      return props2;
    }
  }, "parseTriggerProps");
  const trigger = makeElement(name("trigger"), {
    stores: [value, orientation],
    returned: ([$value, $orientation]) => {
      return (props2) => {
        const { value: tabValue, disabled } = parseTriggerProps(props2);
        if (!$value && !ssrValue && withDefaults.autoSet) {
          ssrValue = tabValue;
          $value = tabValue;
          value.set(tabValue);
        }
        const sourceOfTruth = isBrowser ? $value : ssrValue;
        const isActive = sourceOfTruth === tabValue;
        return {
          type: "button",
          role: "tab",
          "data-state": isActive ? "active" : "inactive",
          tabindex: isActive ? 0 : -1,
          "data-value": tabValue,
          "data-orientation": $orientation,
          "data-disabled": disabledAttr(disabled),
          disabled: disabledAttr(disabled)
        };
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "focus", () => {
        const disabled = node.dataset.disabled === "true";
        const tabValue = node.dataset.value;
        if (activateOnFocus.get() && !disabled && tabValue !== void 0) {
          value.set(tabValue);
        }
      }), addMeltEventListener(node, "click", (e3) => {
        node.focus();
        e3.preventDefault();
        const disabled = node.dataset.disabled === "true";
        if (disabled)
          return;
        const tabValue = node.dataset.value;
        node.focus();
        if (tabValue !== void 0) {
          value.set(tabValue);
        }
      }), addMeltEventListener(node, "keydown", (e3) => {
        const tabValue = node.dataset.value;
        if (!tabValue)
          return;
        const el = e3.currentTarget;
        if (!isHTMLElement(el))
          return;
        const rootEl = el.closest(selector());
        if (!isHTMLElement(rootEl))
          return;
        const $loop = loop.get();
        const triggers = Array.from(rootEl.querySelectorAll('[role="tab"]')).filter((trigger2) => isHTMLElement(trigger2));
        const enabledTriggers = triggers.filter((el2) => !el2.hasAttribute("data-disabled"));
        const triggerIdx = enabledTriggers.findIndex((el2) => el2 === e3.target);
        const dir = getElemDirection(rootEl);
        const { nextKey, prevKey } = getDirectionalKeys(dir, orientation.get());
        if (e3.key === nextKey) {
          e3.preventDefault();
          const nextEl = next(enabledTriggers, triggerIdx, $loop);
          nextEl.focus();
        } else if (e3.key === prevKey) {
          e3.preventDefault();
          const prevEl = prev(enabledTriggers, triggerIdx, $loop);
          prevEl.focus();
        } else if (e3.key === kbd.ENTER || e3.key === kbd.SPACE) {
          e3.preventDefault();
          value.set(tabValue);
        } else if (e3.key === kbd.HOME) {
          e3.preventDefault();
          const firstTrigger = enabledTriggers[0];
          firstTrigger.focus();
        } else if (e3.key === kbd.END) {
          e3.preventDefault();
          const lastTrigger = last(enabledTriggers);
          lastTrigger.focus();
        }
      }));
      return {
        destroy: unsub
      };
    }
  });
  const content = makeElement(name("content"), {
    stores: value,
    returned: ($value) => {
      return (tabValue) => {
        return {
          role: "tabpanel",
          // TODO: improve
          "aria-labelledby": tabValue,
          hidden: isBrowser ? $value === tabValue ? void 0 : true : ssrValue === tabValue ? void 0 : true,
          tabindex: 0
        };
      };
    }
  });
  return {
    elements: {
      root: root2,
      list,
      trigger,
      content
    },
    states: {
      value
    },
    options: options2
  };
}
__name(createTabs, "createTabs");
function getTabsData() {
  const NAME = "tabs";
  const PARTS = ["root", "content", "list", "trigger"];
  return {
    NAME,
    PARTS
  };
}
__name(getTabsData, "getTabsData");
function setCtx(props) {
  const { NAME, PARTS } = getTabsData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const tabs = { ...createTabs(removeUndefined(props)), getAttrs: getAttrs2 };
  setContext(NAME, tabs);
  return {
    ...tabs,
    updateOption: getOptionUpdater(tabs.options)
  };
}
__name(setCtx, "setCtx");
function getCtx() {
  const { NAME } = getTabsData();
  return getContext(NAME);
}
__name(getCtx, "getCtx");
function Tabs($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "orientation",
    "activateOnFocus",
    "loop",
    "autoSet",
    "value",
    "onValueChange",
    "asChild",
    "el"
  ]);
  push();
  var $$store_subs;
  let builder;
  let orientation = fallback($$props["orientation"], () => void 0, true);
  let activateOnFocus = fallback($$props["activateOnFocus"], () => void 0, true);
  let loop = fallback($$props["loop"], () => void 0, true);
  let autoSet = fallback($$props["autoSet"], () => void 0, true);
  let value = fallback($$props["value"], () => void 0, true);
  let onValueChange = fallback($$props["onValueChange"], () => void 0, true);
  let asChild = fallback($$props["asChild"], false);
  let el = fallback($$props["el"], () => void 0, true);
  const {
    elements: { root: root2 },
    states: { value: localValue },
    updateOption,
    getAttrs: getAttrs2
  } = setCtx({
    orientation,
    activateOnFocus,
    loop,
    autoSet,
    defaultValue: value,
    onValueChange: ({ next: next2 }) => {
      if (value !== next2) {
        onValueChange?.(next2);
        value = next2;
      }
      return next2;
    }
  });
  const attrs = getAttrs2("root");
  value !== void 0 && localValue.set(value);
  updateOption("orientation", orientation);
  updateOption("activateOnFocus", activateOnFocus);
  updateOption("loop", loop);
  updateOption("autoSet", autoSet);
  builder = store_get($$store_subs ??= {}, "$root", root2);
  Object.assign(builder, attrs);
  if (asChild) {
    $$payload.out += "<!--[-->";
    $$payload.out += `<!---->`;
    slot(
      $$payload,
      $$props,
      "default",
      {
        builder,
        value: store_get($$store_subs ??= {}, "$localValue", localValue)
      },
      null
    );
    $$payload.out += `<!---->`;
  } else {
    $$payload.out += "<!--[!-->";
    $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!---->`;
    slot(
      $$payload,
      $$props,
      "default",
      {
        builder,
        value: store_get($$store_subs ??= {}, "$localValue", localValue)
      },
      null
    );
    $$payload.out += `<!----></div>`;
  }
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, {
    orientation,
    activateOnFocus,
    loop,
    autoSet,
    value,
    onValueChange,
    asChild,
    el
  });
  pop();
}
__name(Tabs, "Tabs");
function Tabs_content$1($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["value", "asChild", "el"]);
  push();
  var $$store_subs;
  let builder;
  let value = $$props["value"];
  let asChild = fallback($$props["asChild"], false);
  let el = fallback($$props["el"], () => void 0, true);
  const { elements: { content }, getAttrs: getAttrs2 } = getCtx();
  const attrs = getAttrs2("content");
  builder = store_get($$store_subs ??= {}, "$content", content)(value);
  Object.assign(builder, attrs);
  if (asChild) {
    $$payload.out += "<!--[-->";
    $$payload.out += `<!---->`;
    slot($$payload, $$props, "default", { builder }, null);
    $$payload.out += `<!---->`;
  } else {
    $$payload.out += "<!--[!-->";
    $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!---->`;
    slot($$payload, $$props, "default", { builder }, null);
    $$payload.out += `<!----></div>`;
  }
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { value, asChild, el });
  pop();
}
__name(Tabs_content$1, "Tabs_content$1");
function Tabs_list$1($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["asChild", "el"]);
  push();
  var $$store_subs;
  let builder;
  let asChild = fallback($$props["asChild"], false);
  let el = fallback($$props["el"], () => void 0, true);
  const { elements: { list }, getAttrs: getAttrs2 } = getCtx();
  const attrs = getAttrs2("list");
  builder = store_get($$store_subs ??= {}, "$list", list);
  Object.assign(builder, attrs);
  if (asChild) {
    $$payload.out += "<!--[-->";
    $$payload.out += `<!---->`;
    slot($$payload, $$props, "default", { builder }, null);
    $$payload.out += `<!---->`;
  } else {
    $$payload.out += "<!--[!-->";
    $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!---->`;
    slot($$payload, $$props, "default", { builder }, null);
    $$payload.out += `<!----></div>`;
  }
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { asChild, el });
  pop();
}
__name(Tabs_list$1, "Tabs_list$1");
function Tabs_trigger$1($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["value", "disabled", "asChild", "el"]);
  push();
  var $$store_subs;
  let builder;
  let value = $$props["value"];
  let disabled = fallback($$props["disabled"], () => void 0, true);
  let asChild = fallback($$props["asChild"], false);
  let el = fallback($$props["el"], () => void 0, true);
  const { elements: { trigger }, getAttrs: getAttrs2 } = getCtx();
  const attrs = getAttrs2("trigger");
  builder = store_get($$store_subs ??= {}, "$trigger", trigger)({ value, disabled });
  Object.assign(builder, attrs);
  if (asChild) {
    $$payload.out += "<!--[-->";
    $$payload.out += `<!---->`;
    slot($$payload, $$props, "default", { builder }, null);
    $$payload.out += `<!---->`;
  } else {
    $$payload.out += "<!--[!-->";
    $$payload.out += `<button${spread_attributes({ ...builder, type: "button", ...$$restProps })}><!---->`;
    slot($$payload, $$props, "default", { builder }, null);
    $$payload.out += `<!----></button>`;
  }
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { value, disabled, asChild, el });
  pop();
}
__name(Tabs_trigger$1, "Tabs_trigger$1");
function Tabs_content($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "value"]);
  push();
  let className = fallback($$props["class"], void 0);
  let value = $$props["value"];
  Tabs_content$1($$payload, spread_props([
    {
      class: cn("mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2", className),
      value
    },
    $$restProps,
    {
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
  bind_props($$props, { class: className, value });
  pop();
}
__name(Tabs_content, "Tabs_content");
function Tabs_list($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  let className = fallback($$props["class"], void 0);
  Tabs_list$1($$payload, spread_props([
    {
      class: cn("inline-flex h-10 items-center justify-center rounded-md  p-1 text-[#8C8C8C]", className)
    },
    $$restProps,
    {
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
  bind_props($$props, { class: className });
  pop();
}
__name(Tabs_list, "Tabs_list");
function Tabs_trigger($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "value"]);
  push();
  let className = fallback($$props["class"], void 0);
  let value = $$props["value"];
  Tabs_trigger$1($$payload, spread_props([
    {
      class: cn("mr-1 inline-flex items-center justify-center whitespace-nowrap border-b  border-transparent px-3 py-3 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:border-white data-[state=active]:text-white ", className),
      value
    },
    $$restProps,
    {
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
  bind_props($$props, { class: className, value });
  pop();
}
__name(Tabs_trigger, "Tabs_trigger");
var defaults2;
var name;
var selector;
var Root2;
var init_index5 = __esm({
  ".svelte-kit/output/server/chunks/index5.js"() {
    init_index2();
    init_create();
    init_utils3();
    init_array2();
    init_updater();
    init_index4();
    init_clsx();
    defaults2 = {
      orientation: "horizontal",
      activateOnFocus: true,
      loop: true,
      autoSet: true
    };
    ({ name, selector } = createElHelpers("tabs"));
    Root2 = Tabs;
  }
});
function Icon($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "name",
    "color",
    "size",
    "strokeWidth",
    "absoluteStrokeWidth",
    "iconNode"
  ]);
  push();
  let name3 = fallback($$props["name"], void 0);
  let color = fallback($$props["color"], "currentColor");
  let size2 = fallback($$props["size"], 24);
  let strokeWidth = fallback($$props["strokeWidth"], 2);
  let absoluteStrokeWidth = fallback($$props["absoluteStrokeWidth"], false);
  let iconNode = fallback($$props["iconNode"], () => [], true);
  const mergeClasses = /* @__PURE__ */ __name((...classes) => classes.filter((className, index39, array3) => {
    return Boolean(className) && array3.indexOf(className) === index39;
  }).join(" "), "mergeClasses");
  const each_array = ensure_array_like(iconNode);
  $$payload.out += `<svg${spread_attributes(
    {
      ...defaultAttributes,
      ...$$restProps,
      width: size2,
      height: size2,
      stroke: color,
      "stroke-width": absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size2) : strokeWidth,
      class: mergeClasses("lucide-icon", "lucide", name3 ? `lucide-${name3}` : "", $$sanitized_props.class)
    },
    void 0,
    void 0,
    3
  )}><!--[-->`;
  for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
    let [tag, attrs] = each_array[$$index];
    element($$payload, tag, () => {
      $$payload.out += `${spread_attributes({ ...attrs }, void 0, void 0, 3)}`;
    });
  }
  $$payload.out += `<!--]--><!---->`;
  slot($$payload, $$props, "default", {}, null);
  $$payload.out += `<!----></svg>`;
  bind_props($$props, {
    name: name3,
    color,
    size: size2,
    strokeWidth,
    absoluteStrokeWidth,
    iconNode
  });
  pop();
}
__name(Icon, "Icon");
var defaultAttributes;
var init_Icon = __esm({
  ".svelte-kit/output/server/chunks/Icon.js"() {
    init_index2();
    defaultAttributes = {
      xmlns: "http://www.w3.org/2000/svg",
      width: 24,
      height: 24,
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      "stroke-width": 2,
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    };
  }
});
function sleep(ms) {
  return new Promise((resolve2) => setTimeout(resolve2, ms));
}
__name(sleep, "sleep");
function generateId() {
  return nanoid(10);
}
__name(generateId, "generateId");
function generateIds(args) {
  return args.reduce((acc, curr) => {
    acc[curr] = generateId();
    return acc;
  }, {});
}
__name(generateIds, "generateIds");
function getPlatform() {
  const agent = navigator.userAgentData;
  return agent?.platform ?? navigator.platform;
}
__name(getPlatform, "getPlatform");
function assignStyle(el, style) {
  if (!el)
    return;
  const previousStyle = el.style.cssText;
  Object.assign(el.style, style);
  return () => {
    el.style.cssText = previousStyle;
  };
}
__name(assignStyle, "assignStyle");
function setCSSProperty(el, property, value) {
  if (!el)
    return;
  const previousValue = el.style.getPropertyValue(property);
  el.style.setProperty(property, value);
  return () => {
    if (previousValue) {
      el.style.setProperty(property, previousValue);
    } else {
      el.style.removeProperty(property);
    }
  };
}
__name(setCSSProperty, "setCSSProperty");
function getPaddingProperty(documentElement) {
  const documentLeft = documentElement.getBoundingClientRect().left;
  const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;
  return scrollbarX ? "paddingLeft" : "paddingRight";
}
__name(getPaddingProperty, "getPaddingProperty");
function removeScroll(_document) {
  const doc = document;
  const win = doc.defaultView ?? window;
  const { documentElement, body: body2 } = doc;
  const locked = body2.hasAttribute(LOCK_CLASSNAME);
  if (locked)
    return noop2;
  body2.setAttribute(LOCK_CLASSNAME, "");
  const scrollbarWidth = win.innerWidth - documentElement.clientWidth;
  const setScrollbarWidthProperty = /* @__PURE__ */ __name(() => setCSSProperty(documentElement, "--scrollbar-width", `${scrollbarWidth}px`), "setScrollbarWidthProperty");
  const paddingProperty = getPaddingProperty(documentElement);
  const scrollbarSidePadding = win.getComputedStyle(body2)[paddingProperty];
  const setStyle2 = /* @__PURE__ */ __name(() => assignStyle(body2, {
    overflow: "hidden",
    [paddingProperty]: `calc(${scrollbarSidePadding} + ${scrollbarWidth}px)`
  }), "setStyle2");
  const setIOSStyle = /* @__PURE__ */ __name(() => {
    const { scrollX, scrollY, visualViewport: visualViewport2 } = win;
    const offsetLeft = visualViewport2?.offsetLeft ?? 0;
    const offsetTop = visualViewport2?.offsetTop ?? 0;
    const restoreStyle = assignStyle(body2, {
      position: "fixed",
      overflow: "hidden",
      top: `${-(scrollY - Math.floor(offsetTop))}px`,
      left: `${-(scrollX - Math.floor(offsetLeft))}px`,
      right: "0",
      [paddingProperty]: `calc(${scrollbarSidePadding} + ${scrollbarWidth}px)`
    });
    return () => {
      restoreStyle?.();
      win.scrollTo(scrollX, scrollY);
    };
  }, "setIOSStyle");
  const cleanups = [setScrollbarWidthProperty(), isIos() ? setIOSStyle() : setStyle2()];
  return () => {
    cleanups.forEach((fn) => fn?.());
    body2.removeAttribute(LOCK_CLASSNAME);
  };
}
__name(removeScroll, "removeScroll");
function getPortalParent(node) {
  let parent = node.parentElement;
  while (isHTMLElement(parent) && !parent.hasAttribute("data-portal")) {
    parent = parent.parentElement;
  }
  return parent || "body";
}
__name(getPortalParent, "getPortalParent");
function getPortalDestination(node, portalProp) {
  if (portalProp !== void 0)
    return portalProp;
  const portalParent = getPortalParent(node);
  if (portalParent === "body")
    return document.body;
  return null;
}
__name(getPortalDestination, "getPortalDestination");
async function handleFocus(args) {
  const { prop, defaultEl } = args;
  await Promise.all([sleep(1), tick]);
  if (prop === void 0) {
    defaultEl?.focus();
    return;
  }
  const returned = isFunction(prop) ? prop(defaultEl) : prop;
  if (typeof returned === "string") {
    const el = document.querySelector(returned);
    if (!isHTMLElement(el))
      return;
    el.focus();
  } else if (isHTMLElement(returned)) {
    returned.focus();
  }
}
__name(handleFocus, "handleFocus");
function _defineProperty(e3, r3, t2) {
  return (r3 = _toPropertyKey(r3)) in e3 ? Object.defineProperty(e3, r3, {
    value: t2,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e3[r3] = t2, e3;
}
__name(_defineProperty, "_defineProperty");
function ownKeys(e3, r3) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r3 && (o2 = o2.filter(function(r23) {
      return Object.getOwnPropertyDescriptor(e3, r23).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
__name(ownKeys, "ownKeys");
function _objectSpread2(e3) {
  for (var r3 = 1; r3 < arguments.length; r3++) {
    var t2 = null != arguments[r3] ? arguments[r3] : {};
    r3 % 2 ? ownKeys(Object(t2), true).forEach(function(r23) {
      _defineProperty(e3, r23, t2[r23]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r23) {
      Object.defineProperty(e3, r23, Object.getOwnPropertyDescriptor(t2, r23));
    });
  }
  return e3;
}
__name(_objectSpread2, "_objectSpread2");
function _toPrimitive(t2, r3) {
  if ("object" != typeof t2 || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r3 || "default");
    if ("object" != typeof i2)
      return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r3 ? String : Number)(t2);
}
__name(_toPrimitive, "_toPrimitive");
function _toPropertyKey(t2) {
  var i2 = _toPrimitive(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
__name(_toPropertyKey, "_toPropertyKey");
function createFocusTrap2(config = {}) {
  let trap;
  const { immediate, ...focusTrapOptions } = config;
  const hasFocus = writable(false);
  const isPaused = writable(false);
  const activate = /* @__PURE__ */ __name((opts) => trap?.activate(opts), "activate");
  const deactivate = /* @__PURE__ */ __name((opts) => {
    trap?.deactivate(opts);
  }, "deactivate");
  const pause = /* @__PURE__ */ __name(() => {
    if (trap) {
      trap.pause();
      isPaused.set(true);
    }
  }, "pause");
  const unpause = /* @__PURE__ */ __name(() => {
    if (trap) {
      trap.unpause();
      isPaused.set(false);
    }
  }, "unpause");
  const useFocusTrap = /* @__PURE__ */ __name((node) => {
    trap = createFocusTrap$1(node, {
      ...focusTrapOptions,
      onActivate() {
        hasFocus.set(true);
        config.onActivate?.();
      },
      onDeactivate() {
        hasFocus.set(false);
        config.onDeactivate?.();
      }
    });
    if (immediate) {
      activate();
    }
    return {
      destroy() {
        deactivate();
        trap = void 0;
      }
    };
  }, "useFocusTrap");
  return {
    useFocusTrap,
    hasFocus: readonly(hasFocus),
    isPaused: readonly(isPaused),
    activate,
    deactivate,
    pause,
    unpause
  };
}
__name(createFocusTrap2, "createFocusTrap2");
function isValidEvent(e3, node) {
  if ("button" in e3 && e3.button > 0)
    return false;
  const target = e3.target;
  if (!isElement(target))
    return false;
  const ownerDocument = target.ownerDocument;
  if (!ownerDocument || !ownerDocument.documentElement.contains(target)) {
    return false;
  }
  return node && !isOrContainsTarget(node, target);
}
__name(isValidEvent, "isValidEvent");
function isOrContainsTarget(node, target) {
  return node === target || node.contains(target);
}
__name(isOrContainsTarget, "isOrContainsTarget");
function getOwnerDocument(el) {
  return el?.ownerDocument ?? document;
}
__name(getOwnerDocument, "getOwnerDocument");
var urlAlphabet;
var nanoid;
var isDom;
var pt;
var isTouchDevice;
var isMac;
var isApple;
var isIos;
var LOCK_CLASSNAME;
var candidateSelectors;
var candidateSelector;
var NoElement;
var matches2;
var getRootNode;
var isInert;
var isContentEditable;
var getCandidates;
var getCandidatesIteratively;
var hasTabIndex;
var getTabIndex;
var getSortOrderTabIndex;
var sortOrderedTabbables;
var isInput;
var isHiddenInput;
var isDetailsWithSummary;
var getCheckedRadio;
var isTabbableRadio;
var isRadio;
var isNonTabbableRadio;
var isNodeAttached;
var isZeroArea;
var isHidden;
var isDisabledFromFieldset;
var isNodeMatchingSelectorFocusable;
var isNodeMatchingSelectorTabbable;
var isValidShadowRootTabbable;
var sortByOrder;
var tabbable;
var focusable;
var isTabbable;
var focusableCandidateSelector;
var isFocusable;
var activeFocusTraps;
var isSelectableInput;
var isEscapeEvent;
var isTabEvent;
var isKeyForward;
var isKeyBackward;
var delay;
var findIndex;
var valueOrHandler;
var getActualTarget;
var internalTrapStack;
var createFocusTrap$1;
var visibleModals;
var useModal;
var usePortal;
var useInteractOutside;
var init_action = __esm({
  ".svelte-kit/output/server/chunks/action.js"() {
    init_create();
    init_index_server();
    init_index4();
    init_array2();
    urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    nanoid = /* @__PURE__ */ __name((size2 = 21) => {
      let id = "";
      let i2 = size2;
      while (i2--) {
        id += urlAlphabet[Math.random() * 64 | 0];
      }
      return id;
    }, "nanoid");
    isDom = /* @__PURE__ */ __name(() => typeof window !== "undefined", "isDom");
    pt = /* @__PURE__ */ __name((v2) => isDom() && v2.test(getPlatform().toLowerCase()), "pt");
    isTouchDevice = /* @__PURE__ */ __name(() => isDom() && !!navigator.maxTouchPoints, "isTouchDevice");
    isMac = /* @__PURE__ */ __name(() => pt(/^mac/) && !isTouchDevice(), "isMac");
    isApple = /* @__PURE__ */ __name(() => pt(/mac|iphone|ipad|ipod/i), "isApple");
    isIos = /* @__PURE__ */ __name(() => isApple() && !isMac(), "isIos");
    LOCK_CLASSNAME = "data-melt-scroll-lock";
    candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
    candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
    NoElement = typeof Element === "undefined";
    matches2 = NoElement ? function() {
    } : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    getRootNode = !NoElement && Element.prototype.getRootNode ? function(element2) {
      var _element$getRootNode;
      return element2 === null || element2 === void 0 ? void 0 : (_element$getRootNode = element2.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element2);
    } : function(element2) {
      return element2 === null || element2 === void 0 ? void 0 : element2.ownerDocument;
    };
    isInert = /* @__PURE__ */ __name(function isInert2(node, lookUp) {
      var _node$getAttribute;
      if (lookUp === void 0) {
        lookUp = true;
      }
      var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, "inert");
      var inert = inertAtt === "" || inertAtt === "true";
      var result = inert || lookUp && node && isInert2(node.parentNode);
      return result;
    }, "isInert2");
    isContentEditable = /* @__PURE__ */ __name(function isContentEditable2(node) {
      var _node$getAttribute2;
      var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, "contenteditable");
      return attValue === "" || attValue === "true";
    }, "isContentEditable2");
    getCandidates = /* @__PURE__ */ __name(function getCandidates2(el, includeContainer, filter) {
      if (isInert(el)) {
        return [];
      }
      var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
      if (includeContainer && matches2.call(el, candidateSelector)) {
        candidates.unshift(el);
      }
      candidates = candidates.filter(filter);
      return candidates;
    }, "getCandidates2");
    getCandidatesIteratively = /* @__PURE__ */ __name(function getCandidatesIteratively2(elements, includeContainer, options2) {
      var candidates = [];
      var elementsToCheck = Array.from(elements);
      while (elementsToCheck.length) {
        var element2 = elementsToCheck.shift();
        if (isInert(element2, false)) {
          continue;
        }
        if (element2.tagName === "SLOT") {
          var assigned = element2.assignedElements();
          var content = assigned.length ? assigned : element2.children;
          var nestedCandidates = getCandidatesIteratively2(content, true, options2);
          if (options2.flatten) {
            candidates.push.apply(candidates, nestedCandidates);
          } else {
            candidates.push({
              scopeParent: element2,
              candidates: nestedCandidates
            });
          }
        } else {
          var validCandidate = matches2.call(element2, candidateSelector);
          if (validCandidate && options2.filter(element2) && (includeContainer || !elements.includes(element2))) {
            candidates.push(element2);
          }
          var shadowRoot = element2.shadowRoot || // check for an undisclosed shadow
          typeof options2.getShadowRoot === "function" && options2.getShadowRoot(element2);
          var validShadowRoot = !isInert(shadowRoot, false) && (!options2.shadowRootFilter || options2.shadowRootFilter(element2));
          if (shadowRoot && validShadowRoot) {
            var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element2.children : shadowRoot.children, true, options2);
            if (options2.flatten) {
              candidates.push.apply(candidates, _nestedCandidates);
            } else {
              candidates.push({
                scopeParent: element2,
                candidates: _nestedCandidates
              });
            }
          } else {
            elementsToCheck.unshift.apply(elementsToCheck, element2.children);
          }
        }
      }
      return candidates;
    }, "getCandidatesIteratively2");
    hasTabIndex = /* @__PURE__ */ __name(function hasTabIndex2(node) {
      return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
    }, "hasTabIndex2");
    getTabIndex = /* @__PURE__ */ __name(function getTabIndex2(node) {
      if (!node) {
        throw new Error("No node provided");
      }
      if (node.tabIndex < 0) {
        if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
          return 0;
        }
      }
      return node.tabIndex;
    }, "getTabIndex2");
    getSortOrderTabIndex = /* @__PURE__ */ __name(function getSortOrderTabIndex2(node, isScope) {
      var tabIndex = getTabIndex(node);
      if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
        return 0;
      }
      return tabIndex;
    }, "getSortOrderTabIndex2");
    sortOrderedTabbables = /* @__PURE__ */ __name(function sortOrderedTabbables2(a2, b) {
      return a2.tabIndex === b.tabIndex ? a2.documentOrder - b.documentOrder : a2.tabIndex - b.tabIndex;
    }, "sortOrderedTabbables2");
    isInput = /* @__PURE__ */ __name(function isInput2(node) {
      return node.tagName === "INPUT";
    }, "isInput2");
    isHiddenInput = /* @__PURE__ */ __name(function isHiddenInput2(node) {
      return isInput(node) && node.type === "hidden";
    }, "isHiddenInput2");
    isDetailsWithSummary = /* @__PURE__ */ __name(function isDetailsWithSummary2(node) {
      var r3 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
        return child.tagName === "SUMMARY";
      });
      return r3;
    }, "isDetailsWithSummary2");
    getCheckedRadio = /* @__PURE__ */ __name(function getCheckedRadio2(nodes, form) {
      for (var i2 = 0; i2 < nodes.length; i2++) {
        if (nodes[i2].checked && nodes[i2].form === form) {
          return nodes[i2];
        }
      }
    }, "getCheckedRadio2");
    isTabbableRadio = /* @__PURE__ */ __name(function isTabbableRadio2(node) {
      if (!node.name) {
        return true;
      }
      var radioScope = node.form || getRootNode(node);
      var queryRadios = /* @__PURE__ */ __name(function queryRadios2(name3) {
        return radioScope.querySelectorAll('input[type="radio"][name="' + name3 + '"]');
      }, "queryRadios2");
      var radioSet;
      if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
        radioSet = queryRadios(window.CSS.escape(node.name));
      } else {
        try {
          radioSet = queryRadios(node.name);
        } catch (err) {
          console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
          return false;
        }
      }
      var checked = getCheckedRadio(radioSet, node.form);
      return !checked || checked === node;
    }, "isTabbableRadio2");
    isRadio = /* @__PURE__ */ __name(function isRadio2(node) {
      return isInput(node) && node.type === "radio";
    }, "isRadio2");
    isNonTabbableRadio = /* @__PURE__ */ __name(function isNonTabbableRadio2(node) {
      return isRadio(node) && !isTabbableRadio(node);
    }, "isNonTabbableRadio2");
    isNodeAttached = /* @__PURE__ */ __name(function isNodeAttached2(node) {
      var _nodeRoot;
      var nodeRoot = node && getRootNode(node);
      var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
      var attached = false;
      if (nodeRoot && nodeRoot !== node) {
        var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
        attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
        while (!attached && nodeRootHost) {
          var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
          nodeRoot = getRootNode(nodeRootHost);
          nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
          attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
        }
      }
      return attached;
    }, "isNodeAttached2");
    isZeroArea = /* @__PURE__ */ __name(function isZeroArea2(node) {
      var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
      return width === 0 && height === 0;
    }, "isZeroArea2");
    isHidden = /* @__PURE__ */ __name(function isHidden2(node, _ref) {
      var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
      if (getComputedStyle(node).visibility === "hidden") {
        return true;
      }
      var isDirectSummary = matches2.call(node, "details>summary:first-of-type");
      var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
      if (matches2.call(nodeUnderDetails, "details:not([open]) *")) {
        return true;
      }
      if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
        if (typeof getShadowRoot === "function") {
          var originalNode = node;
          while (node) {
            var parentElement = node.parentElement;
            var rootNode = getRootNode(node);
            if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
              return isZeroArea(node);
            } else if (node.assignedSlot) {
              node = node.assignedSlot;
            } else if (!parentElement && rootNode !== node.ownerDocument) {
              node = rootNode.host;
            } else {
              node = parentElement;
            }
          }
          node = originalNode;
        }
        if (isNodeAttached(node)) {
          return !node.getClientRects().length;
        }
        if (displayCheck !== "legacy-full") {
          return true;
        }
      } else if (displayCheck === "non-zero-area") {
        return isZeroArea(node);
      }
      return false;
    }, "isHidden2");
    isDisabledFromFieldset = /* @__PURE__ */ __name(function isDisabledFromFieldset2(node) {
      if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
        var parentNode = node.parentElement;
        while (parentNode) {
          if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
            for (var i2 = 0; i2 < parentNode.children.length; i2++) {
              var child = parentNode.children.item(i2);
              if (child.tagName === "LEGEND") {
                return matches2.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
              }
            }
            return true;
          }
          parentNode = parentNode.parentElement;
        }
      }
      return false;
    }, "isDisabledFromFieldset2");
    isNodeMatchingSelectorFocusable = /* @__PURE__ */ __name(function isNodeMatchingSelectorFocusable2(options2, node) {
      if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
      //  because we're limited in the type of selectors we can use in JSDom (see related
      //  note related to `candidateSelectors`)
      isInert(node) || isHiddenInput(node) || isHidden(node, options2) || // For a details element with a summary, the summary element gets the focus
      isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
        return false;
      }
      return true;
    }, "isNodeMatchingSelectorFocusable2");
    isNodeMatchingSelectorTabbable = /* @__PURE__ */ __name(function isNodeMatchingSelectorTabbable2(options2, node) {
      if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options2, node)) {
        return false;
      }
      return true;
    }, "isNodeMatchingSelectorTabbable2");
    isValidShadowRootTabbable = /* @__PURE__ */ __name(function isValidShadowRootTabbable2(shadowHostNode) {
      var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
      if (isNaN(tabIndex) || tabIndex >= 0) {
        return true;
      }
      return false;
    }, "isValidShadowRootTabbable2");
    sortByOrder = /* @__PURE__ */ __name(function sortByOrder2(candidates) {
      var regularTabbables = [];
      var orderedTabbables = [];
      candidates.forEach(function(item, i2) {
        var isScope = !!item.scopeParent;
        var element2 = isScope ? item.scopeParent : item;
        var candidateTabindex = getSortOrderTabIndex(element2, isScope);
        var elements = isScope ? sortByOrder2(item.candidates) : element2;
        if (candidateTabindex === 0) {
          isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element2);
        } else {
          orderedTabbables.push({
            documentOrder: i2,
            tabIndex: candidateTabindex,
            item,
            isScope,
            content: elements
          });
        }
      });
      return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
        sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
        return acc;
      }, []).concat(regularTabbables);
    }, "sortByOrder2");
    tabbable = /* @__PURE__ */ __name(function tabbable2(container, options2) {
      options2 = options2 || {};
      var candidates;
      if (options2.getShadowRoot) {
        candidates = getCandidatesIteratively([container], options2.includeContainer, {
          filter: isNodeMatchingSelectorTabbable.bind(null, options2),
          flatten: false,
          getShadowRoot: options2.getShadowRoot,
          shadowRootFilter: isValidShadowRootTabbable
        });
      } else {
        candidates = getCandidates(container, options2.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options2));
      }
      return sortByOrder(candidates);
    }, "tabbable2");
    focusable = /* @__PURE__ */ __name(function focusable2(container, options2) {
      options2 = options2 || {};
      var candidates;
      if (options2.getShadowRoot) {
        candidates = getCandidatesIteratively([container], options2.includeContainer, {
          filter: isNodeMatchingSelectorFocusable.bind(null, options2),
          flatten: true,
          getShadowRoot: options2.getShadowRoot
        });
      } else {
        candidates = getCandidates(container, options2.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options2));
      }
      return candidates;
    }, "focusable2");
    isTabbable = /* @__PURE__ */ __name(function isTabbable2(node, options2) {
      options2 = options2 || {};
      if (!node) {
        throw new Error("No node provided");
      }
      if (matches2.call(node, candidateSelector) === false) {
        return false;
      }
      return isNodeMatchingSelectorTabbable(options2, node);
    }, "isTabbable2");
    focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
    isFocusable = /* @__PURE__ */ __name(function isFocusable2(node, options2) {
      options2 = options2 || {};
      if (!node) {
        throw new Error("No node provided");
      }
      if (matches2.call(node, focusableCandidateSelector) === false) {
        return false;
      }
      return isNodeMatchingSelectorFocusable(options2, node);
    }, "isFocusable2");
    activeFocusTraps = {
      activateTrap: /* @__PURE__ */ __name(function activateTrap(trapStack, trap) {
        if (trapStack.length > 0) {
          var activeTrap = trapStack[trapStack.length - 1];
          if (activeTrap !== trap) {
            activeTrap.pause();
          }
        }
        var trapIndex = trapStack.indexOf(trap);
        if (trapIndex === -1) {
          trapStack.push(trap);
        } else {
          trapStack.splice(trapIndex, 1);
          trapStack.push(trap);
        }
      }, "activateTrap"),
      deactivateTrap: /* @__PURE__ */ __name(function deactivateTrap(trapStack, trap) {
        var trapIndex = trapStack.indexOf(trap);
        if (trapIndex !== -1) {
          trapStack.splice(trapIndex, 1);
        }
        if (trapStack.length > 0) {
          trapStack[trapStack.length - 1].unpause();
        }
      }, "deactivateTrap")
    };
    isSelectableInput = /* @__PURE__ */ __name(function isSelectableInput2(node) {
      return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
    }, "isSelectableInput2");
    isEscapeEvent = /* @__PURE__ */ __name(function isEscapeEvent2(e3) {
      return (e3 === null || e3 === void 0 ? void 0 : e3.key) === "Escape" || (e3 === null || e3 === void 0 ? void 0 : e3.key) === "Esc" || (e3 === null || e3 === void 0 ? void 0 : e3.keyCode) === 27;
    }, "isEscapeEvent2");
    isTabEvent = /* @__PURE__ */ __name(function isTabEvent2(e3) {
      return (e3 === null || e3 === void 0 ? void 0 : e3.key) === "Tab" || (e3 === null || e3 === void 0 ? void 0 : e3.keyCode) === 9;
    }, "isTabEvent2");
    isKeyForward = /* @__PURE__ */ __name(function isKeyForward2(e3) {
      return isTabEvent(e3) && !e3.shiftKey;
    }, "isKeyForward2");
    isKeyBackward = /* @__PURE__ */ __name(function isKeyBackward2(e3) {
      return isTabEvent(e3) && e3.shiftKey;
    }, "isKeyBackward2");
    delay = /* @__PURE__ */ __name(function delay2(fn) {
      return setTimeout(fn, 0);
    }, "delay2");
    findIndex = /* @__PURE__ */ __name(function findIndex2(arr, fn) {
      var idx = -1;
      arr.every(function(value, i2) {
        if (fn(value)) {
          idx = i2;
          return false;
        }
        return true;
      });
      return idx;
    }, "findIndex2");
    valueOrHandler = /* @__PURE__ */ __name(function valueOrHandler2(value) {
      for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        params[_key - 1] = arguments[_key];
      }
      return typeof value === "function" ? value.apply(void 0, params) : value;
    }, "valueOrHandler2");
    getActualTarget = /* @__PURE__ */ __name(function getActualTarget2(event) {
      return event.target.shadowRoot && typeof event.composedPath === "function" ? event.composedPath()[0] : event.target;
    }, "getActualTarget2");
    internalTrapStack = [];
    createFocusTrap$1 = /* @__PURE__ */ __name(function createFocusTrap(elements, userOptions) {
      var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
      var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;
      var config = _objectSpread2({
        returnFocusOnDeactivate: true,
        escapeDeactivates: true,
        delayInitialFocus: true,
        isKeyForward,
        isKeyBackward
      }, userOptions);
      var state = {
        // containers given to createFocusTrap()
        // @type {Array<HTMLElement>}
        containers: [],
        // list of objects identifying tabbable nodes in `containers` in the trap
        // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
        //  is active, but the trap should never get to a state where there isn't at least one group
        //  with at least one tabbable node in it (that would lead to an error condition that would
        //  result in an error being thrown)
        // @type {Array<{
        //   container: HTMLElement,
        //   tabbableNodes: Array<HTMLElement>, // empty if none
        //   focusableNodes: Array<HTMLElement>, // empty if none
        //   posTabIndexesFound: boolean,
        //   firstTabbableNode: HTMLElement|undefined,
        //   lastTabbableNode: HTMLElement|undefined,
        //   firstDomTabbableNode: HTMLElement|undefined,
        //   lastDomTabbableNode: HTMLElement|undefined,
        //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
        // }>}
        containerGroups: [],
        // same order/length as `containers` list
        // references to objects in `containerGroups`, but only those that actually have
        //  tabbable nodes in them
        // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
        //  the same length
        tabbableGroups: [],
        nodeFocusedBeforeActivation: null,
        mostRecentlyFocusedNode: null,
        active: false,
        paused: false,
        // timer ID for when delayInitialFocus is true and initial focus in this trap
        //  has been delayed during activation
        delayInitialFocusTimer: void 0,
        // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
        recentNavEvent: void 0
      };
      var trap;
      var getOption = /* @__PURE__ */ __name(function getOption2(configOverrideOptions, optionName, configOptionName) {
        return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config[configOptionName || optionName];
      }, "getOption2");
      var findContainerIndex = /* @__PURE__ */ __name(function findContainerIndex2(element2, event) {
        var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === "function" ? event.composedPath() : void 0;
        return state.containerGroups.findIndex(function(_ref) {
          var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
          return container.contains(element2) || // fall back to explicit tabbable search which will take into consideration any
          //  web components if the `tabbableOptions.getShadowRoot` option was used for
          //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
          //  look inside web components even if open)
          (composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function(node) {
            return node === element2;
          });
        });
      }, "findContainerIndex2");
      var getNodeForOption = /* @__PURE__ */ __name(function getNodeForOption2(optionName) {
        var optionValue = config[optionName];
        if (typeof optionValue === "function") {
          for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            params[_key2 - 1] = arguments[_key2];
          }
          optionValue = optionValue.apply(void 0, params);
        }
        if (optionValue === true) {
          optionValue = void 0;
        }
        if (!optionValue) {
          if (optionValue === void 0 || optionValue === false) {
            return optionValue;
          }
          throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
        }
        var node = optionValue;
        if (typeof optionValue === "string") {
          node = doc.querySelector(optionValue);
          if (!node) {
            throw new Error("`".concat(optionName, "` as selector refers to no known node"));
          }
        }
        return node;
      }, "getNodeForOption2");
      var getInitialFocusNode = /* @__PURE__ */ __name(function getInitialFocusNode2() {
        var node = getNodeForOption("initialFocus");
        if (node === false) {
          return false;
        }
        if (node === void 0 || !isFocusable(node, config.tabbableOptions)) {
          if (findContainerIndex(doc.activeElement) >= 0) {
            node = doc.activeElement;
          } else {
            var firstTabbableGroup = state.tabbableGroups[0];
            var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
            node = firstTabbableNode || getNodeForOption("fallbackFocus");
          }
        }
        if (!node) {
          throw new Error("Your focus-trap needs to have at least one focusable element");
        }
        return node;
      }, "getInitialFocusNode2");
      var updateTabbableNodes = /* @__PURE__ */ __name(function updateTabbableNodes2() {
        state.containerGroups = state.containers.map(function(container) {
          var tabbableNodes = tabbable(container, config.tabbableOptions);
          var focusableNodes = focusable(container, config.tabbableOptions);
          var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
          var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
          var firstDomTabbableNode = focusableNodes.find(function(node) {
            return isTabbable(node);
          });
          var lastDomTabbableNode = focusableNodes.slice().reverse().find(function(node) {
            return isTabbable(node);
          });
          var posTabIndexesFound = !!tabbableNodes.find(function(node) {
            return getTabIndex(node) > 0;
          });
          return {
            container,
            tabbableNodes,
            focusableNodes,
            /** True if at least one node with positive `tabindex` was found in this container. */
            posTabIndexesFound,
            /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
            firstTabbableNode,
            /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
            lastTabbableNode,
            // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
            //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
            //  because that API doesn't work with Shadow DOM as well as it should (@see
            //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
            //  to address an edge case related to positive tabindex support, this seems like a much easier,
            //  "close enough most of the time" alternative for positive tabindexes which should generally
            //  be avoided anyway...
            /** First tabbable node in container, __DOM__ order; `undefined` if none. */
            firstDomTabbableNode,
            /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
            lastDomTabbableNode,
            /**
             * Finds the __tabbable__ node that follows the given node in the specified direction,
             *  in this container, if any.
             * @param {HTMLElement} node
             * @param {boolean} [forward] True if going in forward tab order; false if going
             *  in reverse.
             * @returns {HTMLElement|undefined} The next tabbable node, if any.
             */
            nextTabbableNode: /* @__PURE__ */ __name(function nextTabbableNode(node) {
              var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
              var nodeIdx = tabbableNodes.indexOf(node);
              if (nodeIdx < 0) {
                if (forward) {
                  return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function(el) {
                    return isTabbable(el);
                  });
                }
                return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function(el) {
                  return isTabbable(el);
                });
              }
              return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
            }, "nextTabbableNode")
          };
        });
        state.tabbableGroups = state.containerGroups.filter(function(group) {
          return group.tabbableNodes.length > 0;
        });
        if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
          throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
        }
        if (state.containerGroups.find(function(g2) {
          return g2.posTabIndexesFound;
        }) && state.containerGroups.length > 1) {
          throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
        }
      }, "updateTabbableNodes2");
      var _getActiveElement = /* @__PURE__ */ __name(function getActiveElement(el) {
        var activeElement = el.activeElement;
        if (!activeElement) {
          return;
        }
        if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {
          return _getActiveElement(activeElement.shadowRoot);
        }
        return activeElement;
      }, "getActiveElement");
      var _tryFocus = /* @__PURE__ */ __name(function tryFocus(node) {
        if (node === false) {
          return;
        }
        if (node === _getActiveElement(document)) {
          return;
        }
        if (!node || !node.focus) {
          _tryFocus(getInitialFocusNode());
          return;
        }
        node.focus({
          preventScroll: !!config.preventScroll
        });
        state.mostRecentlyFocusedNode = node;
        if (isSelectableInput(node)) {
          node.select();
        }
      }, "tryFocus");
      var getReturnFocusNode = /* @__PURE__ */ __name(function getReturnFocusNode2(previousActiveElement) {
        var node = getNodeForOption("setReturnFocus", previousActiveElement);
        return node ? node : node === false ? false : previousActiveElement;
      }, "getReturnFocusNode2");
      var findNextNavNode = /* @__PURE__ */ __name(function findNextNavNode2(_ref2) {
        var target = _ref2.target, event = _ref2.event, _ref2$isBackward = _ref2.isBackward, isBackward = _ref2$isBackward === void 0 ? false : _ref2$isBackward;
        target = target || getActualTarget(event);
        updateTabbableNodes();
        var destinationNode = null;
        if (state.tabbableGroups.length > 0) {
          var containerIndex = findContainerIndex(target, event);
          var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
          if (containerIndex < 0) {
            if (isBackward) {
              destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
            } else {
              destinationNode = state.tabbableGroups[0].firstTabbableNode;
            }
          } else if (isBackward) {
            var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {
              var firstTabbableNode = _ref3.firstTabbableNode;
              return target === firstTabbableNode;
            });
            if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
              startOfGroupIndex = containerIndex;
            }
            if (startOfGroupIndex >= 0) {
              var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
              var destinationGroup = state.tabbableGroups[destinationGroupIndex];
              destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
            } else if (!isTabEvent(event)) {
              destinationNode = containerGroup.nextTabbableNode(target, false);
            }
          } else {
            var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref4) {
              var lastTabbableNode = _ref4.lastTabbableNode;
              return target === lastTabbableNode;
            });
            if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
              lastOfGroupIndex = containerIndex;
            }
            if (lastOfGroupIndex >= 0) {
              var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
              var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
              destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;
            } else if (!isTabEvent(event)) {
              destinationNode = containerGroup.nextTabbableNode(target);
            }
          }
        } else {
          destinationNode = getNodeForOption("fallbackFocus");
        }
        return destinationNode;
      }, "findNextNavNode2");
      var checkPointerDown = /* @__PURE__ */ __name(function checkPointerDown2(e3) {
        var target = getActualTarget(e3);
        if (findContainerIndex(target, e3) >= 0) {
          return;
        }
        if (valueOrHandler(config.clickOutsideDeactivates, e3)) {
          trap.deactivate({
            // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
            //  which will result in the outside click setting focus to the node
            //  that was clicked (and if not focusable, to "nothing"); by setting
            //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
            //  on activation (or the configured `setReturnFocus` node), whether the
            //  outside click was on a focusable node or not
            returnFocus: config.returnFocusOnDeactivate
          });
          return;
        }
        if (valueOrHandler(config.allowOutsideClick, e3)) {
          return;
        }
        e3.preventDefault();
      }, "checkPointerDown2");
      var checkFocusIn = /* @__PURE__ */ __name(function checkFocusIn2(event) {
        var target = getActualTarget(event);
        var targetContained = findContainerIndex(target, event) >= 0;
        if (targetContained || target instanceof Document) {
          if (targetContained) {
            state.mostRecentlyFocusedNode = target;
          }
        } else {
          event.stopImmediatePropagation();
          var nextNode;
          var navAcrossContainers = true;
          if (state.mostRecentlyFocusedNode) {
            if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {
              var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);
              var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;
              if (tabbableNodes.length > 0) {
                var mruTabIdx = tabbableNodes.findIndex(function(node) {
                  return node === state.mostRecentlyFocusedNode;
                });
                if (mruTabIdx >= 0) {
                  if (config.isKeyForward(state.recentNavEvent)) {
                    if (mruTabIdx + 1 < tabbableNodes.length) {
                      nextNode = tabbableNodes[mruTabIdx + 1];
                      navAcrossContainers = false;
                    }
                  } else {
                    if (mruTabIdx - 1 >= 0) {
                      nextNode = tabbableNodes[mruTabIdx - 1];
                      navAcrossContainers = false;
                    }
                  }
                }
              }
            } else {
              if (!state.containerGroups.some(function(g2) {
                return g2.tabbableNodes.some(function(n2) {
                  return getTabIndex(n2) > 0;
                });
              })) {
                navAcrossContainers = false;
              }
            }
          } else {
            navAcrossContainers = false;
          }
          if (navAcrossContainers) {
            nextNode = findNextNavNode({
              // move FROM the MRU node, not event-related node (which will be the node that is
              //  outside the trap causing the focus escape we're trying to fix)
              target: state.mostRecentlyFocusedNode,
              isBackward: config.isKeyBackward(state.recentNavEvent)
            });
          }
          if (nextNode) {
            _tryFocus(nextNode);
          } else {
            _tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
          }
        }
        state.recentNavEvent = void 0;
      }, "checkFocusIn2");
      var checkKeyNav = /* @__PURE__ */ __name(function checkKeyNav2(event) {
        var isBackward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        state.recentNavEvent = event;
        var destinationNode = findNextNavNode({
          event,
          isBackward
        });
        if (destinationNode) {
          if (isTabEvent(event)) {
            event.preventDefault();
          }
          _tryFocus(destinationNode);
        }
      }, "checkKeyNav2");
      var checkTabKey = /* @__PURE__ */ __name(function checkTabKey2(event) {
        if (config.isKeyForward(event) || config.isKeyBackward(event)) {
          checkKeyNav(event, config.isKeyBackward(event));
        }
      }, "checkTabKey2");
      var checkEscapeKey = /* @__PURE__ */ __name(function checkEscapeKey2(event) {
        if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {
          event.preventDefault();
          trap.deactivate();
        }
      }, "checkEscapeKey2");
      var checkClick = /* @__PURE__ */ __name(function checkClick2(e3) {
        var target = getActualTarget(e3);
        if (findContainerIndex(target, e3) >= 0) {
          return;
        }
        if (valueOrHandler(config.clickOutsideDeactivates, e3)) {
          return;
        }
        if (valueOrHandler(config.allowOutsideClick, e3)) {
          return;
        }
        e3.preventDefault();
        e3.stopImmediatePropagation();
      }, "checkClick2");
      var addListeners = /* @__PURE__ */ __name(function addListeners2() {
        if (!state.active) {
          return;
        }
        activeFocusTraps.activateTrap(trapStack, trap);
        state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
          _tryFocus(getInitialFocusNode());
        }) : _tryFocus(getInitialFocusNode());
        doc.addEventListener("focusin", checkFocusIn, true);
        doc.addEventListener("mousedown", checkPointerDown, {
          capture: true,
          passive: false
        });
        doc.addEventListener("touchstart", checkPointerDown, {
          capture: true,
          passive: false
        });
        doc.addEventListener("click", checkClick, {
          capture: true,
          passive: false
        });
        doc.addEventListener("keydown", checkTabKey, {
          capture: true,
          passive: false
        });
        doc.addEventListener("keydown", checkEscapeKey);
        return trap;
      }, "addListeners2");
      var removeListeners = /* @__PURE__ */ __name(function removeListeners2() {
        if (!state.active) {
          return;
        }
        doc.removeEventListener("focusin", checkFocusIn, true);
        doc.removeEventListener("mousedown", checkPointerDown, true);
        doc.removeEventListener("touchstart", checkPointerDown, true);
        doc.removeEventListener("click", checkClick, true);
        doc.removeEventListener("keydown", checkTabKey, true);
        doc.removeEventListener("keydown", checkEscapeKey);
        return trap;
      }, "removeListeners2");
      var checkDomRemoval = /* @__PURE__ */ __name(function checkDomRemoval2(mutations) {
        var isFocusedNodeRemoved = mutations.some(function(mutation) {
          var removedNodes = Array.from(mutation.removedNodes);
          return removedNodes.some(function(node) {
            return node === state.mostRecentlyFocusedNode;
          });
        });
        if (isFocusedNodeRemoved) {
          _tryFocus(getInitialFocusNode());
        }
      }, "checkDomRemoval2");
      var mutationObserver = typeof window !== "undefined" && "MutationObserver" in window ? new MutationObserver(checkDomRemoval) : void 0;
      var updateObservedNodes = /* @__PURE__ */ __name(function updateObservedNodes2() {
        if (!mutationObserver) {
          return;
        }
        mutationObserver.disconnect();
        if (state.active && !state.paused) {
          state.containers.map(function(container) {
            mutationObserver.observe(container, {
              subtree: true,
              childList: true
            });
          });
        }
      }, "updateObservedNodes2");
      trap = {
        get active() {
          return state.active;
        },
        get paused() {
          return state.paused;
        },
        activate: /* @__PURE__ */ __name(function activate(activateOptions) {
          if (state.active) {
            return this;
          }
          var onActivate = getOption(activateOptions, "onActivate");
          var onPostActivate = getOption(activateOptions, "onPostActivate");
          var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
          if (!checkCanFocusTrap) {
            updateTabbableNodes();
          }
          state.active = true;
          state.paused = false;
          state.nodeFocusedBeforeActivation = doc.activeElement;
          onActivate === null || onActivate === void 0 || onActivate();
          var finishActivation = /* @__PURE__ */ __name(function finishActivation2() {
            if (checkCanFocusTrap) {
              updateTabbableNodes();
            }
            addListeners();
            updateObservedNodes();
            onPostActivate === null || onPostActivate === void 0 || onPostActivate();
          }, "finishActivation2");
          if (checkCanFocusTrap) {
            checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
            return this;
          }
          finishActivation();
          return this;
        }, "activate"),
        deactivate: /* @__PURE__ */ __name(function deactivate(deactivateOptions) {
          if (!state.active) {
            return this;
          }
          var options2 = _objectSpread2({
            onDeactivate: config.onDeactivate,
            onPostDeactivate: config.onPostDeactivate,
            checkCanReturnFocus: config.checkCanReturnFocus
          }, deactivateOptions);
          clearTimeout(state.delayInitialFocusTimer);
          state.delayInitialFocusTimer = void 0;
          removeListeners();
          state.active = false;
          state.paused = false;
          updateObservedNodes();
          activeFocusTraps.deactivateTrap(trapStack, trap);
          var onDeactivate = getOption(options2, "onDeactivate");
          var onPostDeactivate = getOption(options2, "onPostDeactivate");
          var checkCanReturnFocus = getOption(options2, "checkCanReturnFocus");
          var returnFocus = getOption(options2, "returnFocus", "returnFocusOnDeactivate");
          onDeactivate === null || onDeactivate === void 0 || onDeactivate();
          var finishDeactivation = /* @__PURE__ */ __name(function finishDeactivation2() {
            delay(function() {
              if (returnFocus) {
                _tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
              }
              onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();
            });
          }, "finishDeactivation2");
          if (returnFocus && checkCanReturnFocus) {
            checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
            return this;
          }
          finishDeactivation();
          return this;
        }, "deactivate"),
        pause: /* @__PURE__ */ __name(function pause(pauseOptions) {
          if (state.paused || !state.active) {
            return this;
          }
          var onPause = getOption(pauseOptions, "onPause");
          var onPostPause = getOption(pauseOptions, "onPostPause");
          state.paused = true;
          onPause === null || onPause === void 0 || onPause();
          removeListeners();
          updateObservedNodes();
          onPostPause === null || onPostPause === void 0 || onPostPause();
          return this;
        }, "pause"),
        unpause: /* @__PURE__ */ __name(function unpause(unpauseOptions) {
          if (!state.paused || !state.active) {
            return this;
          }
          var onUnpause = getOption(unpauseOptions, "onUnpause");
          var onPostUnpause = getOption(unpauseOptions, "onPostUnpause");
          state.paused = false;
          onUnpause === null || onUnpause === void 0 || onUnpause();
          updateTabbableNodes();
          addListeners();
          updateObservedNodes();
          onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();
          return this;
        }, "unpause"),
        updateContainerElements: /* @__PURE__ */ __name(function updateContainerElements(containerElements) {
          var elementsAsArray = [].concat(containerElements).filter(Boolean);
          state.containers = elementsAsArray.map(function(element2) {
            return typeof element2 === "string" ? doc.querySelector(element2) : element2;
          });
          if (state.active) {
            updateTabbableNodes();
          }
          updateObservedNodes();
          return this;
        }, "updateContainerElements")
      };
      trap.updateContainerElements(elements);
      return trap;
    }, "createFocusTrap");
    visibleModals = [];
    useModal = /* @__PURE__ */ __name((node, config) => {
      let unsubInteractOutside = noop2;
      function removeNodeFromVisibleModals() {
        const index39 = visibleModals.indexOf(node);
        if (index39 >= 0) {
          visibleModals.splice(index39, 1);
        }
      }
      __name(removeNodeFromVisibleModals, "removeNodeFromVisibleModals");
      function update(config2) {
        unsubInteractOutside();
        const { open, onClose, shouldCloseOnInteractOutside, closeOnInteractOutside } = config2;
        sleep(100).then(() => {
          if (open) {
            visibleModals.push(node);
          } else {
            removeNodeFromVisibleModals();
          }
        });
        function isLastModal() {
          return last(visibleModals) === node;
        }
        __name(isLastModal, "isLastModal");
        function closeModal() {
          if (isLastModal() && onClose) {
            onClose();
            removeNodeFromVisibleModals();
          }
        }
        __name(closeModal, "closeModal");
        function onInteractOutsideStart(e3) {
          const target = e3.target;
          if (!isElement(target))
            return;
          if (target && isLastModal()) {
            e3.preventDefault();
            e3.stopPropagation();
            e3.stopImmediatePropagation();
          }
        }
        __name(onInteractOutsideStart, "onInteractOutsideStart");
        function onInteractOutside(e3) {
          if (shouldCloseOnInteractOutside?.(e3) && isLastModal()) {
            e3.preventDefault();
            e3.stopPropagation();
            e3.stopImmediatePropagation();
            closeModal();
          }
        }
        __name(onInteractOutside, "onInteractOutside");
        unsubInteractOutside = useInteractOutside(node, {
          onInteractOutsideStart,
          onInteractOutside: closeOnInteractOutside ? onInteractOutside : void 0,
          enabled: open
        }).destroy;
      }
      __name(update, "update");
      update(config);
      return {
        update,
        destroy() {
          removeNodeFromVisibleModals();
          unsubInteractOutside();
        }
      };
    }, "useModal");
    usePortal = /* @__PURE__ */ __name((el, target = "body") => {
      let targetEl;
      if (!isHTMLElement(target) && typeof target !== "string") {
        return {
          destroy: noop2
        };
      }
      async function update(newTarget) {
        target = newTarget;
        if (typeof target === "string") {
          targetEl = document.querySelector(target);
          if (targetEl === null) {
            await tick();
            targetEl = document.querySelector(target);
          }
          if (targetEl === null) {
            throw new Error(`No element found matching css selector: "${target}"`);
          }
        } else if (target instanceof HTMLElement) {
          targetEl = target;
        } else {
          throw new TypeError(`Unknown portal target type: ${target === null ? "null" : typeof target}. Allowed types: string (CSS selector) or HTMLElement.`);
        }
        el.dataset.portal = "";
        targetEl.appendChild(el);
        el.hidden = false;
      }
      __name(update, "update");
      function destroy() {
        el.remove();
      }
      __name(destroy, "destroy");
      update(target);
      return {
        update,
        destroy
      };
    }, "usePortal");
    useInteractOutside = /* @__PURE__ */ __name((node, config) => {
      let unsub = noop2;
      let unsubClick = noop2;
      let isPointerDown = false;
      let isPointerDownInside = false;
      let ignoreEmulatedMouseEvents = false;
      function update(config2) {
        unsub();
        unsubClick();
        const { onInteractOutside, onInteractOutsideStart, enabled } = config2;
        if (!enabled)
          return;
        function onPointerDown(e3) {
          if (onInteractOutside && isValidEvent(e3, node)) {
            onInteractOutsideStart?.(e3);
          }
          const target = e3.target;
          if (isElement(target) && isOrContainsTarget(node, target)) {
            isPointerDownInside = true;
          }
          isPointerDown = true;
        }
        __name(onPointerDown, "onPointerDown");
        function triggerInteractOutside(e3) {
          onInteractOutside?.(e3);
        }
        __name(triggerInteractOutside, "triggerInteractOutside");
        const documentObj = getOwnerDocument(node);
        if (typeof PointerEvent !== "undefined") {
          const onPointerUp = /* @__PURE__ */ __name((e3) => {
            unsubClick();
            const handler = /* @__PURE__ */ __name((e22) => {
              if (shouldTriggerInteractOutside(e22)) {
                triggerInteractOutside(e22);
              }
              resetPointerState();
            }, "handler");
            if (e3.pointerType === "touch") {
              unsubClick = addEventListener(documentObj, "click", handler, {
                capture: true,
                once: true
              });
              return;
            }
            handler(e3);
          }, "onPointerUp");
          unsub = executeCallbacks(addEventListener(documentObj, "pointerdown", onPointerDown, true), addEventListener(documentObj, "pointerup", onPointerUp, true));
        } else {
          const onMouseUp = /* @__PURE__ */ __name((e3) => {
            if (ignoreEmulatedMouseEvents) {
              ignoreEmulatedMouseEvents = false;
            } else if (shouldTriggerInteractOutside(e3)) {
              triggerInteractOutside(e3);
            }
            resetPointerState();
          }, "onMouseUp");
          const onTouchEnd = /* @__PURE__ */ __name((e3) => {
            ignoreEmulatedMouseEvents = true;
            if (shouldTriggerInteractOutside(e3)) {
              triggerInteractOutside(e3);
            }
            resetPointerState();
          }, "onTouchEnd");
          unsub = executeCallbacks(addEventListener(documentObj, "mousedown", onPointerDown, true), addEventListener(documentObj, "mouseup", onMouseUp, true), addEventListener(documentObj, "touchstart", onPointerDown, true), addEventListener(documentObj, "touchend", onTouchEnd, true));
        }
      }
      __name(update, "update");
      function shouldTriggerInteractOutside(e3) {
        if (isPointerDown && !isPointerDownInside && isValidEvent(e3, node)) {
          return true;
        }
        return false;
      }
      __name(shouldTriggerInteractOutside, "shouldTriggerInteractOutside");
      function resetPointerState() {
        isPointerDown = false;
        isPointerDownInside = false;
      }
      __name(resetPointerState, "resetPointerState");
      update(config);
      return {
        update,
        destroy() {
          unsub();
          unsubClick();
        }
      };
    }, "useInteractOutside");
  }
});
function X($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const iconNode = [
    ["path", { "d": "M18 6 6 18" }],
    ["path", { "d": "m6 6 12 12" }]
  ];
  Icon($$payload, spread_props([
    { name: "x" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
}
__name(X, "X");
function createDialog(props) {
  const withDefaults = { ...defaults3, ...props };
  const options2 = toWritableStores(omit(withDefaults, "ids"));
  const { preventScroll: preventScroll2, closeOnEscape, closeOnOutsideClick, role, portal, forceVisible, openFocus, closeFocus, onOutsideClick } = options2;
  const activeTrigger = withGet.writable(null);
  const ids = toWritableStores({
    ...generateIds(dialogIdParts),
    ...withDefaults.ids
  });
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const open = overridable(openWritable, withDefaults?.onOpenChange);
  const isVisible = derived([open, forceVisible], ([$open, $forceVisible]) => {
    return $open || $forceVisible;
  });
  let unsubScroll = noop2;
  function handleOpen(e3) {
    const el = e3.currentTarget;
    const triggerEl = e3.currentTarget;
    if (!isHTMLElement(el) || !isHTMLElement(triggerEl))
      return;
    open.set(true);
    activeTrigger.set(triggerEl);
  }
  __name(handleOpen, "handleOpen");
  function handleClose() {
    open.set(false);
    handleFocus({
      prop: closeFocus.get(),
      defaultEl: activeTrigger.get()
    });
  }
  __name(handleClose, "handleClose");
  const trigger = makeElement(name2("trigger"), {
    stores: [open],
    returned: ([$open]) => {
      return {
        "aria-haspopup": "dialog",
        "aria-expanded": $open,
        type: "button"
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", (e3) => {
        handleOpen(e3);
      }), addMeltEventListener(node, "keydown", (e3) => {
        if (e3.key !== kbd.ENTER && e3.key !== kbd.SPACE)
          return;
        e3.preventDefault();
        handleOpen(e3);
      }));
      return {
        destroy: unsub
      };
    }
  });
  const overlay = makeElement(name2("overlay"), {
    stores: [isVisible, open],
    returned: ([$isVisible, $open]) => {
      return {
        hidden: $isVisible ? void 0 : true,
        tabindex: -1,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        }),
        "aria-hidden": true,
        "data-state": $open ? "open" : "closed"
      };
    },
    action: (node) => {
      let unsubEscapeKeydown = noop2;
      if (closeOnEscape.get()) {
        const escapeKeydown = useEscapeKeydown(node, {
          handler: () => {
            handleClose();
          }
        });
        if (escapeKeydown && escapeKeydown.destroy) {
          unsubEscapeKeydown = escapeKeydown.destroy;
        }
      }
      return {
        destroy() {
          unsubEscapeKeydown();
        }
      };
    }
  });
  const content = makeElement(name2("content"), {
    stores: [isVisible, ids.content, ids.description, ids.title, open],
    returned: ([$isVisible, $contentId, $descriptionId, $titleId, $open]) => {
      return {
        id: $contentId,
        role: role.get(),
        "aria-describedby": $descriptionId,
        "aria-labelledby": $titleId,
        "aria-modal": $isVisible ? "true" : void 0,
        "data-state": $open ? "open" : "closed",
        tabindex: -1,
        hidden: $isVisible ? void 0 : true,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        })
      };
    },
    action: (node) => {
      let activate = noop2;
      let deactivate = noop2;
      const destroy = executeCallbacks(effect2([open, closeOnOutsideClick, closeOnEscape], ([$open, $closeOnOutsideClick, $closeOnEscape]) => {
        if (!$open)
          return;
        const focusTrap = createFocusTrap2({
          immediate: false,
          escapeDeactivates: $closeOnEscape,
          clickOutsideDeactivates: $closeOnOutsideClick,
          allowOutsideClick: true,
          returnFocusOnDeactivate: false,
          fallbackFocus: node
        });
        activate = focusTrap.activate;
        deactivate = focusTrap.deactivate;
        const ac = focusTrap.useFocusTrap(node);
        if (ac && ac.destroy) {
          return ac.destroy;
        } else {
          return focusTrap.deactivate;
        }
      }), effect2([closeOnOutsideClick, open], ([$closeOnOutsideClick, $open]) => {
        return useModal(node, {
          open: $open,
          closeOnInteractOutside: $closeOnOutsideClick,
          onClose() {
            handleClose();
          },
          shouldCloseOnInteractOutside(e3) {
            onOutsideClick.get()?.(e3);
            if (e3.defaultPrevented)
              return false;
            return true;
          }
        }).destroy;
      }), effect2([closeOnEscape], ([$closeOnEscape]) => {
        if (!$closeOnEscape)
          return noop2;
        return useEscapeKeydown(node, { handler: handleClose }).destroy;
      }), effect2([isVisible], ([$isVisible]) => {
        tick().then(() => {
          if (!$isVisible) {
            deactivate();
          } else {
            activate();
          }
        });
      }));
      return {
        destroy: () => {
          unsubScroll();
          destroy();
        }
      };
    }
  });
  const portalled = makeElement(name2("portalled"), {
    stores: portal,
    returned: ($portal) => ({
      "data-portal": portalAttr($portal)
    }),
    action: (node) => {
      const unsubPortal = effect2([portal], ([$portal]) => {
        if ($portal === null)
          return noop2;
        const portalDestination = getPortalDestination(node, $portal);
        if (portalDestination === null)
          return noop2;
        return usePortal(node, portalDestination).destroy;
      });
      return {
        destroy() {
          unsubPortal();
        }
      };
    }
  });
  const title = makeElement(name2("title"), {
    stores: [ids.title],
    returned: ([$titleId]) => ({
      id: $titleId
    })
  });
  const description = makeElement(name2("description"), {
    stores: [ids.description],
    returned: ([$descriptionId]) => ({
      id: $descriptionId
    })
  });
  const close = makeElement(name2("close"), {
    returned: () => ({
      type: "button"
    }),
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        handleClose();
      }), addMeltEventListener(node, "keydown", (e3) => {
        if (e3.key !== kbd.SPACE && e3.key !== kbd.ENTER)
          return;
        e3.preventDefault();
        handleClose();
      }));
      return {
        destroy: unsub
      };
    }
  });
  effect2([open, preventScroll2], ([$open, $preventScroll]) => {
    if (!isBrowser)
      return;
    if ($preventScroll && $open)
      unsubScroll = removeScroll();
    if ($open) {
      const contentEl = document.getElementById(ids.content.get());
      handleFocus({ prop: openFocus.get(), defaultEl: contentEl });
    }
    return () => {
      if (!forceVisible.get()) {
        unsubScroll();
      }
    };
  });
  return {
    ids,
    elements: {
      content,
      trigger,
      title,
      description,
      overlay,
      close,
      portalled
    },
    states: {
      open
    },
    options: options2
  };
}
__name(createDialog, "createDialog");
function getDialogData() {
  const NAME = "dialog";
  const PARTS = [
    "close",
    "content",
    "description",
    "overlay",
    "portal",
    "title",
    "trigger"
  ];
  return {
    NAME,
    PARTS
  };
}
__name(getDialogData, "getDialogData");
function setCtx$1(props) {
  const { NAME, PARTS } = getDialogData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const dialog = {
    ...createDialog({ ...removeUndefined(props), role: "dialog", forceVisible: true }),
    getAttrs: getAttrs2
  };
  setContext(NAME, dialog);
  return {
    ...dialog,
    updateOption: getOptionUpdater(dialog.options)
  };
}
__name(setCtx$1, "setCtx$1");
function getCtx$1() {
  const { NAME } = getDialogData();
  return getContext(NAME);
}
__name(getCtx$1, "getCtx$1");
function Dialog($$payload, $$props) {
  push();
  var $$store_subs;
  let preventScroll2 = fallback($$props["preventScroll"], () => void 0, true);
  let closeOnEscape = fallback($$props["closeOnEscape"], () => void 0, true);
  let closeOnOutsideClick = fallback($$props["closeOnOutsideClick"], () => void 0, true);
  let portal = fallback($$props["portal"], () => void 0, true);
  let open = fallback($$props["open"], () => void 0, true);
  let onOpenChange = fallback($$props["onOpenChange"], () => void 0, true);
  let openFocus = fallback($$props["openFocus"], () => void 0, true);
  let closeFocus = fallback($$props["closeFocus"], () => void 0, true);
  let onOutsideClick = fallback($$props["onOutsideClick"], () => void 0, true);
  const {
    states: { open: localOpen },
    updateOption,
    ids
  } = setCtx$1({
    closeOnEscape,
    preventScroll: preventScroll2,
    closeOnOutsideClick,
    portal,
    forceVisible: true,
    defaultOpen: open,
    openFocus,
    closeFocus,
    onOutsideClick,
    onOpenChange: ({ next: next2 }) => {
      if (open !== next2) {
        onOpenChange?.(next2);
        open = next2;
      }
      return next2;
    }
  });
  const idValues = derived([ids.content, ids.description, ids.title], ([$contentId, $descriptionId, $titleId]) => ({
    content: $contentId,
    description: $descriptionId,
    title: $titleId
  }));
  open !== void 0 && localOpen.set(open);
  updateOption("preventScroll", preventScroll2);
  updateOption("closeOnEscape", closeOnEscape);
  updateOption("closeOnOutsideClick", closeOnOutsideClick);
  updateOption("portal", portal);
  updateOption("openFocus", openFocus);
  updateOption("closeFocus", closeFocus);
  updateOption("onOutsideClick", onOutsideClick);
  $$payload.out += `<!---->`;
  slot(
    $$payload,
    $$props,
    "default",
    {
      ids: store_get($$store_subs ??= {}, "$idValues", idValues)
    },
    null
  );
  $$payload.out += `<!---->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, {
    preventScroll: preventScroll2,
    closeOnEscape,
    closeOnOutsideClick,
    portal,
    open,
    onOpenChange,
    openFocus,
    closeFocus,
    onOutsideClick
  });
  pop();
}
__name(Dialog, "Dialog");
function Dialog_close($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["asChild", "el"]);
  push();
  var $$store_subs;
  let builder;
  let asChild = fallback($$props["asChild"], false);
  let el = fallback($$props["el"], () => void 0, true);
  const { elements: { close }, getAttrs: getAttrs2 } = getCtx$1();
  const attrs = getAttrs2("close");
  builder = store_get($$store_subs ??= {}, "$close", close);
  Object.assign(builder, attrs);
  if (asChild) {
    $$payload.out += "<!--[-->";
    $$payload.out += `<!---->`;
    slot($$payload, $$props, "default", { builder }, null);
    $$payload.out += `<!---->`;
  } else {
    $$payload.out += "<!--[!-->";
    $$payload.out += `<button${spread_attributes({ ...builder, type: "button", ...$$restProps })}><!---->`;
    slot($$payload, $$props, "default", { builder }, null);
    $$payload.out += `<!----></button>`;
  }
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { asChild, el });
  pop();
}
__name(Dialog_close, "Dialog_close");
function Dialog_portal($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["asChild", "el"]);
  push();
  var $$store_subs;
  let builder;
  let asChild = fallback($$props["asChild"], false);
  let el = fallback($$props["el"], () => void 0, true);
  const { elements: { portalled }, getAttrs: getAttrs2 } = getCtx$1();
  const attrs = getAttrs2("portal");
  builder = store_get($$store_subs ??= {}, "$portalled", portalled);
  Object.assign(builder, attrs);
  if (asChild) {
    $$payload.out += "<!--[-->";
    $$payload.out += `<!---->`;
    slot($$payload, $$props, "default", { builder }, null);
    $$payload.out += `<!---->`;
  } else {
    $$payload.out += "<!--[!-->";
    $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!---->`;
    slot($$payload, $$props, "default", { builder }, null);
    $$payload.out += `<!----></div>`;
  }
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { asChild, el });
  pop();
}
__name(Dialog_portal, "Dialog_portal");
function Dialog_content($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "id",
    "el"
  ]);
  push();
  var $$store_subs;
  let builder;
  let transition = fallback($$props["transition"], () => void 0, true);
  let transitionConfig = fallback($$props["transitionConfig"], () => void 0, true);
  let inTransition = fallback($$props["inTransition"], () => void 0, true);
  let inTransitionConfig = fallback($$props["inTransitionConfig"], () => void 0, true);
  let outTransition = fallback($$props["outTransition"], () => void 0, true);
  let outTransitionConfig = fallback($$props["outTransitionConfig"], () => void 0, true);
  let asChild = fallback($$props["asChild"], false);
  let id = fallback($$props["id"], () => void 0, true);
  let el = fallback($$props["el"], () => void 0, true);
  const {
    elements: { content },
    states: { open },
    ids,
    getAttrs: getAttrs2
  } = getCtx$1();
  const attrs = getAttrs2("content");
  if (id) {
    ids.content.set(id);
  }
  builder = store_get($$store_subs ??= {}, "$content", content);
  Object.assign(builder, attrs);
  if (asChild && store_get($$store_subs ??= {}, "$open", open)) {
    $$payload.out += "<!--[-->";
    $$payload.out += `<!---->`;
    slot($$payload, $$props, "default", { builder }, null);
    $$payload.out += `<!---->`;
  } else {
    $$payload.out += "<!--[!-->";
    if (transition && store_get($$store_subs ??= {}, "$open", open)) {
      $$payload.out += "<!--[-->";
      $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!---->`;
      slot($$payload, $$props, "default", { builder }, null);
      $$payload.out += `<!----></div>`;
    } else {
      $$payload.out += "<!--[!-->";
      if (inTransition && outTransition && store_get($$store_subs ??= {}, "$open", open)) {
        $$payload.out += "<!--[-->";
        $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!---->`;
        slot($$payload, $$props, "default", { builder }, null);
        $$payload.out += `<!----></div>`;
      } else {
        $$payload.out += "<!--[!-->";
        if (inTransition && store_get($$store_subs ??= {}, "$open", open)) {
          $$payload.out += "<!--[-->";
          $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!---->`;
          slot($$payload, $$props, "default", { builder }, null);
          $$payload.out += `<!----></div>`;
        } else {
          $$payload.out += "<!--[!-->";
          if (outTransition && store_get($$store_subs ??= {}, "$open", open)) {
            $$payload.out += "<!--[-->";
            $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!---->`;
            slot($$payload, $$props, "default", { builder }, null);
            $$payload.out += `<!----></div>`;
          } else {
            $$payload.out += "<!--[!-->";
            if (store_get($$store_subs ??= {}, "$open", open)) {
              $$payload.out += "<!--[-->";
              $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!---->`;
              slot($$payload, $$props, "default", { builder }, null);
              $$payload.out += `<!----></div>`;
            } else {
              $$payload.out += "<!--[!-->";
            }
            $$payload.out += `<!--]-->`;
          }
          $$payload.out += `<!--]-->`;
        }
        $$payload.out += `<!--]-->`;
      }
      $$payload.out += `<!--]-->`;
    }
    $$payload.out += `<!--]-->`;
  }
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, {
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    id,
    el
  });
  pop();
}
__name(Dialog_content, "Dialog_content");
function Dialog_overlay($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "el"
  ]);
  push();
  var $$store_subs;
  let builder;
  let transition = fallback($$props["transition"], () => void 0, true);
  let transitionConfig = fallback($$props["transitionConfig"], () => void 0, true);
  let inTransition = fallback($$props["inTransition"], () => void 0, true);
  let inTransitionConfig = fallback($$props["inTransitionConfig"], () => void 0, true);
  let outTransition = fallback($$props["outTransition"], () => void 0, true);
  let outTransitionConfig = fallback($$props["outTransitionConfig"], () => void 0, true);
  let asChild = fallback($$props["asChild"], false);
  let el = fallback($$props["el"], () => void 0, true);
  const {
    elements: { overlay },
    states: { open },
    getAttrs: getAttrs2
  } = getCtx$1();
  const attrs = getAttrs2("overlay");
  builder = store_get($$store_subs ??= {}, "$overlay", overlay);
  Object.assign(builder, attrs);
  if (asChild && store_get($$store_subs ??= {}, "$open", open)) {
    $$payload.out += "<!--[-->";
    $$payload.out += `<!---->`;
    slot($$payload, $$props, "default", { builder }, null);
    $$payload.out += `<!---->`;
  } else {
    $$payload.out += "<!--[!-->";
    if (transition && store_get($$store_subs ??= {}, "$open", open)) {
      $$payload.out += "<!--[-->";
      $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}></div>`;
    } else {
      $$payload.out += "<!--[!-->";
      if (inTransition && outTransition && store_get($$store_subs ??= {}, "$open", open)) {
        $$payload.out += "<!--[-->";
        $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}></div>`;
      } else {
        $$payload.out += "<!--[!-->";
        if (inTransition && store_get($$store_subs ??= {}, "$open", open)) {
          $$payload.out += "<!--[-->";
          $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}></div>`;
        } else {
          $$payload.out += "<!--[!-->";
          if (outTransition && store_get($$store_subs ??= {}, "$open", open)) {
            $$payload.out += "<!--[-->";
            $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}></div>`;
          } else {
            $$payload.out += "<!--[!-->";
            if (store_get($$store_subs ??= {}, "$open", open)) {
              $$payload.out += "<!--[-->";
              $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}></div>`;
            } else {
              $$payload.out += "<!--[!-->";
            }
            $$payload.out += `<!--]-->`;
          }
          $$payload.out += `<!--]-->`;
        }
        $$payload.out += `<!--]-->`;
      }
      $$payload.out += `<!--]-->`;
    }
    $$payload.out += `<!--]-->`;
  }
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, {
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    el
  });
  pop();
}
__name(Dialog_overlay, "Dialog_overlay");
function Dialog_trigger($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["asChild", "el"]);
  push();
  var $$store_subs;
  let builder;
  let asChild = fallback($$props["asChild"], false);
  let el = fallback($$props["el"], () => void 0, true);
  const { elements: { trigger }, getAttrs: getAttrs2 } = getCtx$1();
  const attrs = getAttrs2("trigger");
  builder = store_get($$store_subs ??= {}, "$trigger", trigger);
  Object.assign(builder, attrs);
  if (asChild) {
    $$payload.out += "<!--[-->";
    $$payload.out += `<!---->`;
    slot($$payload, $$props, "default", { builder }, null);
    $$payload.out += `<!---->`;
  } else {
    $$payload.out += "<!--[!-->";
    $$payload.out += `<button${spread_attributes({ ...builder, type: "button", ...$$restProps })}><!---->`;
    slot($$payload, $$props, "default", { builder }, null);
    $$payload.out += `<!----></button>`;
  }
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { asChild, el });
  pop();
}
__name(Dialog_trigger, "Dialog_trigger");
function getOptionUpdater2(options2) {
  return function(key2, value) {
    if (value === void 0)
      return;
    const store = options2[key2];
    if (store) {
      store.set(value);
    }
  };
}
__name(getOptionUpdater2, "getOptionUpdater2");
function effect3(stores, fn) {
  if (typeof document === "undefined") {
    return () => {
    };
  }
  const unsub = derivedWithUnsubscribe(stores, (stores2, onUnsubscribe) => {
    return {
      stores: stores2,
      onUnsubscribe
    };
  }).subscribe(({ stores: stores2, onUnsubscribe }) => {
    const returned = fn(stores2);
    if (returned) {
      onUnsubscribe(returned);
    }
  });
  safeOnDestroy2(unsub);
  return unsub;
}
__name(effect3, "effect3");
function derivedWithUnsubscribe(stores, fn) {
  let unsubscribers = [];
  const onUnsubscribe = /* @__PURE__ */ __name((cb) => {
    unsubscribers.push(cb);
  }, "onUnsubscribe");
  const unsubscribe = /* @__PURE__ */ __name(() => {
    unsubscribers.forEach((fn2) => fn2());
    unsubscribers = [];
  }, "unsubscribe");
  const derivedStore = derived(stores, ($storeValues) => {
    unsubscribe();
    return fn($storeValues, onUnsubscribe);
  });
  safeOnDestroy2(unsubscribe);
  const subscribe = /* @__PURE__ */ __name((...args) => {
    const unsub = derivedStore.subscribe(...args);
    return () => {
      unsub();
      unsubscribe();
    };
  }, "subscribe");
  return {
    ...derivedStore,
    subscribe
  };
}
__name(derivedWithUnsubscribe, "derivedWithUnsubscribe");
function toWritableStores2(properties) {
  const result = {};
  Object.keys(properties).forEach((key2) => {
    const propertyKey = key2;
    const value = properties[propertyKey];
    result[propertyKey] = writable(value);
  });
  return result;
}
__name(toWritableStores2, "toWritableStores2");
function omit2(obj, ...keys) {
  const result = {};
  for (const key2 of Object.keys(obj)) {
    if (!keys.includes(key2)) {
      result[key2] = obj[key2];
    }
  }
  return result;
}
__name(omit2, "omit2");
function removeUndefined2(obj) {
  const result = {};
  for (const key2 in obj) {
    const value = obj[key2];
    if (value !== void 0) {
      result[key2] = value;
    }
  }
  return result;
}
__name(removeUndefined2, "removeUndefined2");
function set2(el, styles, ignoreCache = false) {
  if (!el || !(el instanceof HTMLElement) || !styles)
    return;
  const originalStyles = {};
  Object.entries(styles).forEach(([key2, value]) => {
    if (key2.startsWith("--")) {
      el.style.setProperty(key2, value);
      return;
    }
    originalStyles[key2] = el.style[key2];
    el.style[key2] = value;
  });
  if (ignoreCache)
    return;
  cache.set(el, originalStyles);
}
__name(set2, "set2");
function reset2(el, prop) {
  if (!el || !(el instanceof HTMLElement))
    return;
  const originalStyles = cache.get(el);
  if (!originalStyles) {
    return;
  }
  if (prop) {
    el.style[prop] = originalStyles[prop];
  } else {
    Object.entries(originalStyles).forEach(([key2, value]) => {
      el.style[key2] = value;
    });
  }
}
__name(reset2, "reset2");
function getTranslate(element2, direction) {
  const style = window.getComputedStyle(element2);
  const transform = (
    // @ts-expect-error - vendor prefix
    style.transform || style.webkitTransform || style.mozTransform
  );
  let mat = transform.match(/^matrix3d\((.+)\)$/);
  if (mat) {
    return parseFloat(mat[1].split(", ")[isVertical(direction) ? 13 : 12]);
  }
  mat = transform.match(/^matrix\((.+)\)$/);
  return mat ? parseFloat(mat[1].split(", ")[isVertical(direction) ? 5 : 4]) : null;
}
__name(getTranslate, "getTranslate");
function styleToString2(style) {
  return Object.keys(style).reduce((str, key2) => {
    if (style[key2] === void 0)
      return str;
    return str + `${key2}:${style[key2]};`;
  }, "");
}
__name(styleToString2, "styleToString2");
function noop3() {
}
__name(noop3, "noop3");
function addEventListener2(target, event, handler, options2) {
  const events = Array.isArray(event) ? event : [event];
  events.forEach((_event) => target.addEventListener(_event, handler, options2));
  return () => {
    events.forEach((_event) => target.removeEventListener(_event, handler, options2));
  };
}
__name(addEventListener2, "addEventListener2");
function isInput3(target) {
  return target instanceof HTMLInputElement && !nonTextInputTypes.has(target.type) || target instanceof HTMLTextAreaElement || target instanceof HTMLElement && target.isContentEditable;
}
__name(isInput3, "isInput3");
function isVertical(direction) {
  if (direction === "top" || direction === "bottom")
    return true;
  return false;
}
__name(isVertical, "isVertical");
function isBottomOrRight(direction) {
  if (direction === "bottom" || direction === "right")
    return true;
  return false;
}
__name(isBottomOrRight, "isBottomOrRight");
function chain(...callbacks) {
  return (...args) => {
    for (const callback of callbacks) {
      if (typeof callback === "function") {
        callback(...args);
      }
    }
  };
}
__name(chain, "chain");
function sleep2(ms) {
  return new Promise((resolve2) => setTimeout(resolve2, ms));
}
__name(sleep2, "sleep2");
function handleSnapPoints({ activeSnapPoint, snapPoints, drawerRef, overlayRef, fadeFromIndex, openTime, direction }) {
  const isLastSnapPoint = derived([snapPoints, activeSnapPoint], ([$snapPoints, $activeSnapPoint]) => {
    return $activeSnapPoint === $snapPoints?.[$snapPoints.length - 1];
  });
  const shouldFade = derived([snapPoints, fadeFromIndex, activeSnapPoint], ([$snapPoints, $fadeFromIndex, $activeSnapPoint]) => {
    return $snapPoints && $snapPoints.length > 0 && ($fadeFromIndex || $fadeFromIndex === 0) && !Number.isNaN($fadeFromIndex) && $snapPoints[$fadeFromIndex] === $activeSnapPoint || !$snapPoints;
  });
  const activeSnapPointIndex = derived([snapPoints, activeSnapPoint], ([$snapPoints, $activeSnapPoint]) => $snapPoints?.findIndex((snapPoint) => snapPoint === $activeSnapPoint) ?? null);
  const snapPointsOffset = derived(snapPoints, ($snapPoints) => {
    if ($snapPoints) {
      return $snapPoints.map((snapPoint) => {
        const hasWindow2 = typeof window !== "undefined";
        const isPx = typeof snapPoint === "string";
        let snapPointAsNumber = 0;
        if (isPx) {
          snapPointAsNumber = parseInt(snapPoint, 10);
        }
        const $direction = get2(direction);
        if (isVertical($direction)) {
          const height = isPx ? snapPointAsNumber : hasWindow2 ? snapPoint * window.innerHeight : 0;
          if (hasWindow2) {
            return $direction === "bottom" ? window.innerHeight - height : window.innerHeight + height;
          }
          return height;
        }
        const width = isPx ? snapPointAsNumber : hasWindow2 ? snapPoint * window.innerWidth : 0;
        if (hasWindow2) {
          return $direction === "right" ? window.innerWidth - width : window.innerWidth + width;
        }
        return width;
      });
    }
    return [];
  });
  const activeSnapPointOffset = derived([snapPointsOffset, activeSnapPointIndex], ([$snapPointsOffset, $activeSnapPointIndex]) => $activeSnapPointIndex !== null ? $snapPointsOffset?.[$activeSnapPointIndex] : null);
  effect3([activeSnapPoint, drawerRef], ([$activeSnapPoint, $drawerRef]) => {
    if ($activeSnapPoint && $drawerRef) {
      const $snapPoints = get2(snapPoints);
      const $snapPointsOffset = get2(snapPointsOffset);
      const newIndex = $snapPoints?.findIndex((snapPoint) => snapPoint === $activeSnapPoint) ?? -1;
      if ($snapPointsOffset && newIndex !== -1 && typeof $snapPointsOffset[newIndex] === "number") {
        snapToPoint($snapPointsOffset[newIndex]);
      }
    }
  });
  function snapToPoint(dimension) {
    tick().then(() => {
      const $snapPointsOffset = get2(snapPointsOffset);
      const newSnapPointIndex = $snapPointsOffset?.findIndex((snapPointDim) => snapPointDim === dimension) ?? null;
      const $drawerRef = get2(drawerRef);
      const $direction = get2(direction);
      onSnapPointChange(newSnapPointIndex);
      set2($drawerRef, {
        transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`,
        transform: isVertical($direction) ? `translate3d(0, ${dimension}px, 0)` : `translate3d(${dimension}px, 0, 0)`
      });
      const $fadeFromIndex = get2(fadeFromIndex);
      const $overlayRef = get2(overlayRef);
      if (snapPointsOffset && newSnapPointIndex !== $snapPointsOffset.length - 1 && newSnapPointIndex !== $fadeFromIndex) {
        set2($overlayRef, {
          transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`,
          opacity: "0"
        });
      } else {
        set2($overlayRef, {
          transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`,
          opacity: "1"
        });
      }
      activeSnapPoint.update(() => {
        const $snapPoints = get2(snapPoints);
        if (newSnapPointIndex === null || !$snapPoints)
          return null;
        return $snapPoints[newSnapPointIndex];
      });
    });
  }
  __name(snapToPoint, "snapToPoint");
  function onRelease({ draggedDistance, closeDrawer, velocity, dismissible }) {
    const $fadeFromIndex = get2(fadeFromIndex);
    if ($fadeFromIndex === void 0)
      return;
    const $activeSnapPointOffset = get2(activeSnapPointOffset);
    const $activeSnapPointIndex = get2(activeSnapPointIndex);
    const $overlayRef = get2(overlayRef);
    const $snapPointsOffset = get2(snapPointsOffset);
    const $snapPoints = get2(snapPoints);
    const $direction = get2(direction);
    const currentPosition = $direction === "bottom" || $direction === "right" ? ($activeSnapPointOffset ?? 0) - draggedDistance : ($activeSnapPointOffset ?? 0) + draggedDistance;
    const isOverlaySnapPoint = $activeSnapPointIndex === $fadeFromIndex - 1;
    const isFirst = $activeSnapPointIndex === 0;
    const hasDraggedUp = draggedDistance > 0;
    if (isOverlaySnapPoint) {
      set2($overlayRef, {
        transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`
      });
    }
    if (velocity > 2 && !hasDraggedUp) {
      if (dismissible)
        closeDrawer();
      else
        snapToPoint($snapPointsOffset[0]);
      return;
    }
    if (velocity > 2 && hasDraggedUp && $snapPointsOffset && $snapPoints) {
      snapToPoint($snapPointsOffset[$snapPoints.length - 1]);
      return;
    }
    const closestSnapPoint = $snapPointsOffset?.reduce((prev2, curr) => {
      if (typeof prev2 !== "number" || typeof curr !== "number")
        return prev2;
      return Math.abs(curr - currentPosition) < Math.abs(prev2 - currentPosition) ? curr : prev2;
    });
    const dim = isVertical($direction) ? window.innerHeight : window.innerWidth;
    if (velocity > VELOCITY_THRESHOLD && Math.abs(draggedDistance) < dim * 0.4) {
      const dragDirection = hasDraggedUp ? 1 : -1;
      if (dragDirection > 0 && get2(isLastSnapPoint) && $snapPoints) {
        snapToPoint($snapPointsOffset[$snapPoints.length - 1]);
        return;
      }
      if (isFirst && dragDirection < 0 && dismissible) {
        closeDrawer();
      }
      if ($activeSnapPointIndex === null)
        return;
      snapToPoint($snapPointsOffset[$activeSnapPointIndex + dragDirection]);
      return;
    }
    snapToPoint(closestSnapPoint);
  }
  __name(onRelease, "onRelease");
  function onDrag({ draggedDistance }) {
    const $drawerRef = get2(drawerRef);
    const $activeSnapPointOffset = get2(activeSnapPointOffset);
    if ($activeSnapPointOffset === null)
      return;
    const $snapPointsOffset = get2(snapPointsOffset);
    const $direction = get2(direction);
    const newValue = $direction === "bottom" || $direction === "right" ? $activeSnapPointOffset - draggedDistance : $activeSnapPointOffset + draggedDistance;
    const lastSnapPoint = $snapPointsOffset[$snapPointsOffset.length - 1];
    if (isBottomOrRight($direction) && newValue < lastSnapPoint) {
      return;
    }
    if (!isBottomOrRight($direction) && newValue > lastSnapPoint) {
      return;
    }
    set2($drawerRef, {
      transform: isVertical($direction) ? `translate3d(0, ${newValue}px, 0)` : `translate3d(${newValue}px, 0, 0)`
    });
  }
  __name(onDrag, "onDrag");
  function getPercentageDragged(absDraggedDistance, isDraggingDown) {
    const $activeSnapPointIndex = get2(activeSnapPointIndex);
    const $snapPointsOffset = get2(snapPointsOffset);
    const $snapPoints = get2(snapPoints);
    const $fadeFromIndex = get2(fadeFromIndex);
    if (!$snapPoints || typeof $activeSnapPointIndex !== "number" || !$snapPointsOffset || $fadeFromIndex === void 0)
      return null;
    const isOverlaySnapPoint = $activeSnapPointIndex === $fadeFromIndex - 1;
    const isOverlaySnapPointOrHigher = $activeSnapPointIndex >= $fadeFromIndex;
    if (isOverlaySnapPointOrHigher && isDraggingDown) {
      return 0;
    }
    if (isOverlaySnapPoint && !isDraggingDown)
      return 1;
    if (!get2(shouldFade) && !isOverlaySnapPoint)
      return null;
    const targetSnapPointIndex = isOverlaySnapPoint ? $activeSnapPointIndex + 1 : $activeSnapPointIndex - 1;
    const snapPointDistance = isOverlaySnapPoint ? $snapPointsOffset[targetSnapPointIndex] - $snapPointsOffset[targetSnapPointIndex - 1] : $snapPointsOffset[targetSnapPointIndex + 1] - $snapPointsOffset[targetSnapPointIndex];
    const percentageDragged = absDraggedDistance / Math.abs(snapPointDistance);
    if (isOverlaySnapPoint) {
      return 1 - percentageDragged;
    } else {
      return percentageDragged;
    }
  }
  __name(getPercentageDragged, "getPercentageDragged");
  function onSnapPointChange(activeSnapPointIndex2) {
    const $snapPoints = get2(snapPoints);
    const $snapPointsOffset = get2(snapPointsOffset);
    if ($snapPoints && activeSnapPointIndex2 === $snapPointsOffset.length - 1) {
      openTime.set(/* @__PURE__ */ new Date());
    }
  }
  __name(onSnapPointChange, "onSnapPointChange");
  return {
    isLastSnapPoint,
    shouldFade,
    getPercentageDragged,
    activeSnapPointIndex,
    onRelease,
    onDrag,
    snapPointsOffset
  };
}
__name(handleSnapPoints, "handleSnapPoints");
function isMac2() {
  return testPlatform(/^Mac/);
}
__name(isMac2, "isMac2");
function isIPhone() {
  return testPlatform(/^iPhone/);
}
__name(isIPhone, "isIPhone");
function isIPad() {
  return testPlatform(/^iPad/) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  isMac2() && navigator.maxTouchPoints > 1;
}
__name(isIPad, "isIPad");
function isIOS() {
  return isIPhone() || isIPad();
}
__name(isIOS, "isIOS");
function testPlatform(re) {
  return typeof window !== "undefined" && window.navigator != null ? re.test(window.navigator.platform) : void 0;
}
__name(testPlatform, "testPlatform");
function isScrollable(node) {
  const style = window.getComputedStyle(node);
  return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);
}
__name(isScrollable, "isScrollable");
function getScrollParent(node) {
  if (isScrollable(node)) {
    node = node.parentElement;
  }
  while (node && !isScrollable(node)) {
    node = node.parentElement;
  }
  return node || document.scrollingElement || document.documentElement;
}
__name(getScrollParent, "getScrollParent");
function preventScroll() {
  if (typeof document === "undefined")
    return () => {
    };
  preventScrollCount++;
  if (preventScrollCount === 1) {
    if (isIOS()) {
      restore = preventScrollMobileSafari();
    } else {
      restore = preventScrollStandard();
    }
  }
  return () => {
    preventScrollCount--;
    if (preventScrollCount === 0) {
      restore();
    }
  };
}
__name(preventScroll, "preventScroll");
function getPaddingProperty2(documentElement) {
  const documentLeft = documentElement.getBoundingClientRect().left;
  const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;
  return scrollbarX ? "paddingLeft" : "paddingRight";
}
__name(getPaddingProperty2, "getPaddingProperty2");
function setCSSProperty2(el, property, value) {
  if (!el)
    return;
  const previousValue = el.style.getPropertyValue(property);
  el.style.setProperty(property, value);
  return () => {
    if (previousValue) {
      el.style.setProperty(property, previousValue);
    } else {
      el.style.removeProperty(property);
    }
  };
}
__name(setCSSProperty2, "setCSSProperty2");
function preventScrollStandard() {
  if (typeof document === "undefined")
    return () => {
    };
  const win = document.defaultView ?? window;
  const { documentElement, body: body2 } = document;
  const scrollbarWidth = win.innerWidth - documentElement.clientWidth;
  const setScrollbarWidthProperty = /* @__PURE__ */ __name(() => setCSSProperty2(documentElement, "--scrollbar-width", `${scrollbarWidth}px`), "setScrollbarWidthProperty");
  const paddingProperty = getPaddingProperty2(documentElement);
  const scrollbarSidePadding = win.getComputedStyle(body2)[paddingProperty];
  return chain(setScrollbarWidthProperty(), setStyle(body2, paddingProperty, `calc(${scrollbarSidePadding} + ${scrollbarWidth}px)`), setStyle(body2, "overflow", "hidden"));
}
__name(preventScrollStandard, "preventScrollStandard");
function preventScrollMobileSafari() {
  let scrollable;
  let lastY = 0;
  const { documentElement, body: body2, activeElement } = document;
  function onTouchStart(e3) {
    scrollable = getScrollParent(e3.target);
    if (scrollable === documentElement && scrollable === body2)
      return;
    lastY = e3.changedTouches[0].pageY;
  }
  __name(onTouchStart, "onTouchStart");
  function onTouchMove(e3) {
    if (!scrollable || scrollable === documentElement || scrollable === body2) {
      e3.preventDefault();
      return;
    }
    const y2 = e3.changedTouches[0].pageY;
    const scrollTop = scrollable.scrollTop;
    const bottom = scrollable.scrollHeight - scrollable.clientHeight;
    if (bottom === 0)
      return;
    if (scrollTop <= 0 && y2 > lastY || scrollTop >= bottom && y2 < lastY) {
      e3.preventDefault();
    }
    lastY = y2;
  }
  __name(onTouchMove, "onTouchMove");
  function onTouchEnd(e3) {
    const target = e3.target;
    if (!(isInput3(target) && target !== activeElement))
      return;
    e3.preventDefault();
    target.style.transform = "translateY(-2000px)";
    target.focus();
    requestAnimationFrame(() => {
      target.style.transform = "";
    });
  }
  __name(onTouchEnd, "onTouchEnd");
  function onFocus(e3) {
    const target = e3.target;
    if (!isInput3(target))
      return;
    target.style.transform = "translateY(-2000px)";
    requestAnimationFrame(() => {
      target.style.transform = "";
      if (visualViewport) {
        if (visualViewport.height < window.innerHeight) {
          requestAnimationFrame(() => {
            scrollIntoView(target);
          });
        } else {
          visualViewport.addEventListener("resize", () => scrollIntoView(target), { once: true });
        }
      }
    });
  }
  __name(onFocus, "onFocus");
  function onWindowScroll() {
    window.scrollTo(0, 0);
  }
  __name(onWindowScroll, "onWindowScroll");
  const scrollX = window.pageXOffset;
  const scrollY = window.pageYOffset;
  const restoreStyles = chain(
    setStyle(documentElement, "paddingRight", `${window.innerWidth - documentElement.clientWidth}px`),
    setStyle(documentElement, "overflow", "hidden")
    // setStyle(document.body, 'marginTop', `-${scrollY}px`),
  );
  window.scrollTo(0, 0);
  const removeEvents = chain(addEventListener2(document, "touchstart", onTouchStart, { passive: false, capture: true }), addEventListener2(document, "touchmove", onTouchMove, { passive: false, capture: true }), addEventListener2(document, "touchend", onTouchEnd, { passive: false, capture: true }), addEventListener2(document, "focus", onFocus, true), addEventListener2(window, "scroll", onWindowScroll));
  return () => {
    restoreStyles();
    removeEvents();
    window.scrollTo(scrollX, scrollY);
  };
}
__name(preventScrollMobileSafari, "preventScrollMobileSafari");
function setStyle(element2, style, value) {
  const cur = element2.style[style];
  element2.style[style] = value;
  return () => {
    element2.style[style] = cur;
  };
}
__name(setStyle, "setStyle");
function scrollIntoView(target) {
  const { documentElement, body: body2, scrollingElement } = document;
  const root2 = scrollingElement || documentElement;
  while (target && target !== root2) {
    const scrollable = getScrollParent(target);
    if (scrollable !== documentElement && scrollable !== body2 && scrollable !== target) {
      const scrollableTop = scrollable.getBoundingClientRect().top;
      const targetTop = target.getBoundingClientRect().top;
      const targetBottom = target.getBoundingClientRect().bottom;
      const keyboardHeight = scrollable.getBoundingClientRect().bottom;
      if (targetBottom > keyboardHeight) {
        scrollable.scrollTop += targetTop - scrollableTop;
      }
    }
    target = scrollable.parentElement;
  }
}
__name(scrollIntoView, "scrollIntoView");
function handleEscapeKeydown(node, handler) {
  let unsub = noop3;
  function update(handler2) {
    unsub();
    unsub = chain(
      // Handle escape keydowns
      documentEscapeKeyStore2.subscribe((e3) => {
        if (!e3)
          return;
        const target = e3.target;
        if (!isHTMLElement2(target) || target.closest("[data-escapee]") !== node) {
          return;
        }
        e3.preventDefault();
        handler2(e3);
      })
    );
    node.setAttribute("data-escapee", "");
  }
  __name(update, "update");
  update(handler);
  return () => {
    unsub();
    node.removeAttribute("data-escapee");
  };
}
__name(handleEscapeKeydown, "handleEscapeKeydown");
function isHTMLElement2(el) {
  return el instanceof HTMLElement;
}
__name(isHTMLElement2, "isHTMLElement2");
function handlePositionFixed({ isOpen, modal, nested, hasBeenOpened }) {
  const activeUrl = writable(typeof window !== "undefined" ? window.location.href : "");
  let scrollPos = 0;
  function setPositionFixed(open) {
    if (!(previousBodyPosition === null && open))
      return;
    previousBodyPosition = {
      position: document.body.style.position,
      top: document.body.style.top,
      left: document.body.style.left,
      height: document.body.style.height
    };
    const { scrollX, innerHeight } = window;
    document.body.style.setProperty("position", "fixed", "important");
    document.body.style.top = `${-scrollPos}px`;
    document.body.style.left = `${-scrollX}px`;
    document.body.style.right = "0px";
    document.body.style.height = "auto";
    setTimeout(() => requestAnimationFrame(() => {
      const bottomBarHeight = innerHeight - window.innerHeight;
      if (bottomBarHeight && scrollPos >= innerHeight) {
        document.body.style.top = `${-(scrollPos + bottomBarHeight)}px`;
      }
    }), 300);
  }
  __name(setPositionFixed, "setPositionFixed");
  function restorePositionSetting() {
    if (previousBodyPosition === null)
      return;
    const $activeUrl = get2(activeUrl);
    const y2 = -parseInt(document.body.style.top, 10);
    const x2 = -parseInt(document.body.style.left, 10);
    document.body.style.position = previousBodyPosition.position;
    document.body.style.top = previousBodyPosition.top;
    document.body.style.left = previousBodyPosition.left;
    document.body.style.height = previousBodyPosition.height;
    document.body.style.right = "unset";
    requestAnimationFrame(() => {
      if ($activeUrl !== window.location.href) {
        activeUrl.set(window.location.href);
        return;
      }
      window.scrollTo(x2, y2);
    });
    previousBodyPosition = null;
  }
  __name(restorePositionSetting, "restorePositionSetting");
  effect3([isOpen, activeUrl], ([$isOpen, _2]) => {
    if (typeof document === "undefined")
      return;
    if (get2(nested) || !get2(hasBeenOpened))
      return;
    if ($isOpen) {
      setPositionFixed($isOpen);
      if (!get2(modal)) {
        setTimeout(() => {
          restorePositionSetting();
        }, 500);
      }
    } else {
      restorePositionSetting();
    }
  });
  return { restorePositionSetting };
}
__name(handlePositionFixed, "handlePositionFixed");
function createVaul(props) {
  const { snapPoints: snapPointsProp, fadeFromIndex: fadeFromIndexProp = snapPointsProp && snapPointsProp.length - 1, ...withDefaults } = { ...defaultProps, ...removeUndefined2(props) };
  const options2 = toWritableStores2(omit2({
    ...withDefaults,
    snapPoints: snapPointsProp,
    fadeFromIndex: fadeFromIndexProp
  }, ...omittedOptions));
  const triggerRef = writable(void 0);
  const { onDrag: onDragProp, onRelease: onReleaseProp, onClose, onOpenChange } = withDefaults;
  const { snapPoints, fadeFromIndex, fixed, dismissible, modal, nested, shouldScaleBackground, scrollLockTimeout, closeThreshold, direction } = options2;
  const openStore = writable(withDefaults.defaultOpen);
  const isOpen = overridable2(openStore, withDefaults.onOpenChange);
  const hasBeenOpened = writable(false);
  const visible = writable(false);
  const justReleased = writable(false);
  const overlayRef = writable(void 0);
  const openTime = writable(null);
  const keyboardIsOpen = writable(false);
  const drawerRef = writable(void 0);
  const drawerId = writable(void 0);
  let isDragging = false;
  let dragStartTime = null;
  let isClosing = false;
  let pointerStart = 0;
  let dragEndTime = null;
  let lastTimeDragPrevented = null;
  let isAllowedToDrag = false;
  let drawerHeightRef = get2(drawerRef)?.getBoundingClientRect().height || 0;
  let previousDiffFromInitial = 0;
  let initialDrawerHeight = 0;
  let nestedOpenChangeTimer = null;
  const activeSnapPoint = overridable2(writable(withDefaults.defaultActiveSnapPoint), withDefaults.onActiveSnapPointChange);
  const { activeSnapPointIndex, getPercentageDragged: getSnapPointsPercentageDragged, onDrag: onDragSnapPoints, onRelease: onReleaseSnapPoints, shouldFade, snapPointsOffset } = handleSnapPoints({
    snapPoints,
    activeSnapPoint,
    drawerRef,
    fadeFromIndex,
    overlayRef,
    openTime,
    direction
  });
  const getContentStyle = derived([snapPointsOffset], ([$snapPointsOffset]) => {
    return (style = "") => {
      if ($snapPointsOffset && $snapPointsOffset.length > 0) {
        const styleProp = styleToString2({
          "--snap-point-height": `${$snapPointsOffset[0]}px`
        });
        return style + styleProp;
      }
      return style;
    };
  });
  effect3([drawerRef], ([$drawerRef]) => {
    if ($drawerRef) {
      drawerId.set($drawerRef.id);
    }
  });
  effect3([isOpen], ([$open]) => {
    sleep2(100).then(() => {
      const id = get2(drawerId);
      if ($open && id) {
        openDrawerIds.update((prev2) => {
          if (prev2.includes(id)) {
            return prev2;
          }
          prev2.push(id);
          return prev2;
        });
      } else {
        openDrawerIds.update((prev2) => prev2.filter((id2) => id2 !== id2));
      }
    });
  });
  effect3([isOpen], ([$isOpen]) => {
    if (!$isOpen && get2(shouldScaleBackground)) {
      const id = setTimeout(() => {
        reset2(document.body, "background");
      }, 200);
      return () => clearTimeout(id);
    }
  });
  effect3([isOpen], ([$isOpen]) => {
    let unsub = /* @__PURE__ */ __name(() => {
    }, "unsub");
    if ($isOpen) {
      unsub = preventScroll();
    }
    return unsub;
  });
  const { restorePositionSetting } = handlePositionFixed({ isOpen, modal, nested, hasBeenOpened });
  effect3([drawerRef], ([$drawerRef]) => {
    let unsub = noop3;
    if ($drawerRef) {
      unsub = handleEscapeKeydown($drawerRef, () => {
        closeDrawer(true);
      });
    }
    return () => {
      unsub();
    };
  });
  function openDrawer() {
    if (isClosing)
      return;
    hasBeenOpened.set(true);
    isOpen.set(true);
  }
  __name(openDrawer, "openDrawer");
  function onPress(event) {
    const $drawerRef = get2(drawerRef);
    if (!get2(dismissible) && !get2(snapPoints))
      return;
    if ($drawerRef && !$drawerRef.contains(event.target))
      return;
    drawerHeightRef = $drawerRef?.getBoundingClientRect().height || 0;
    isDragging = true;
    dragStartTime = /* @__PURE__ */ new Date();
    if (isIOS()) {
      window.addEventListener("touchend", () => isAllowedToDrag = false, { once: true });
    }
    event.target.setPointerCapture(event.pointerId);
    pointerStart = isVertical(get2(direction)) ? event.screenY : event.screenX;
  }
  __name(onPress, "onPress");
  function shouldDrag(el, isDraggingInDirection) {
    const $drawerRef = get2(drawerRef);
    let element2 = el;
    const highlightedText = window.getSelection()?.toString();
    const $direction = get2(direction);
    const swipeAmount = $drawerRef ? getTranslate($drawerRef, $direction) : null;
    const date = /* @__PURE__ */ new Date();
    if (element2.hasAttribute("data-vaul-no-drag") || element2.closest("[data-vaul-no-drag]")) {
      return false;
    }
    const $openTime = get2(openTime);
    if ($openTime && date.getTime() - $openTime.getTime() < 500) {
      return false;
    }
    if (swipeAmount !== null) {
      if ($direction === "bottom" || $direction === "right" ? swipeAmount > 0 : swipeAmount < 0) {
        return true;
      }
    }
    if (swipeAmount !== null && swipeAmount > 0) {
      return true;
    }
    if (highlightedText && highlightedText.length > 0) {
      return false;
    }
    const $scrollLockTimeout = get2(scrollLockTimeout);
    if (lastTimeDragPrevented && date.getTime() - lastTimeDragPrevented.getTime() < $scrollLockTimeout && swipeAmount === 0) {
      lastTimeDragPrevented = date;
      return false;
    }
    if (isDraggingInDirection) {
      lastTimeDragPrevented = date;
      return false;
    }
    while (element2) {
      if (element2.scrollHeight > element2.clientHeight) {
        if (element2.scrollTop !== 0) {
          lastTimeDragPrevented = /* @__PURE__ */ new Date();
          return false;
        }
        if (element2.getAttribute("role") === "dialog") {
          return true;
        }
      }
      element2 = element2.parentNode;
    }
    return true;
  }
  __name(shouldDrag, "shouldDrag");
  function onDrag(event) {
    const $drawerRef = get2(drawerRef);
    if (!$drawerRef || !isDragging)
      return;
    const $direction = get2(direction);
    const directionMultiplier = getDirectionMultiplier($direction);
    const draggedDistance = getDistanceMoved(pointerStart, $direction, event) * directionMultiplier;
    const isDraggingInDirection = draggedDistance > 0;
    const $activeSnapPointIndex = get2(activeSnapPointIndex);
    const $snapPoints = get2(snapPoints);
    if ($snapPoints && $activeSnapPointIndex === 0 && !get2(dismissible))
      return;
    if (!isAllowedToDrag && !shouldDrag(event.target, isDraggingInDirection)) {
      return;
    }
    $drawerRef.classList.add(DRAG_CLASS);
    isAllowedToDrag = true;
    set2($drawerRef, {
      transition: "none"
    });
    const $overlayRef = get2(overlayRef);
    set2($overlayRef, {
      transition: "none"
    });
    if ($snapPoints) {
      onDragSnapPoints({ draggedDistance });
    }
    if (isDraggingInDirection && !$snapPoints) {
      const dampenedDraggedDistance = dampenValue(draggedDistance);
      const translateValue = Math.min(dampenedDraggedDistance * -1, 0) * directionMultiplier;
      set2($drawerRef, {
        transform: isVertical($direction) ? `translate3d(0, ${translateValue}px, 0)` : `translate3d(${translateValue}px, 0, 0)`
      });
      return;
    }
    const absDraggedDistance = Math.abs(draggedDistance);
    let percentageDragged = absDraggedDistance / drawerHeightRef;
    const snapPointPercentageDragged = getSnapPointsPercentageDragged(absDraggedDistance, isDraggingInDirection);
    if (snapPointPercentageDragged !== null) {
      percentageDragged = snapPointPercentageDragged;
    }
    const opacityValue = 1 - percentageDragged;
    const $fadeFromIndex = get2(fadeFromIndex);
    const $shouldFade = get2(shouldFade);
    if ($shouldFade || $fadeFromIndex && $activeSnapPointIndex === $fadeFromIndex - 1) {
      onDragProp?.(event, percentageDragged);
      set2($overlayRef, {
        opacity: `${opacityValue}`,
        transition: "none"
      }, true);
    }
    const wrapper = document.querySelector("[data-vaul-drawer-wrapper]");
    if (wrapper && $overlayRef && get2(shouldScaleBackground)) {
      const scaleValue = Math.min(getScale() + percentageDragged * (1 - getScale()), 1);
      const borderRadiusValue = 8 - percentageDragged * 8;
      const translateValue = Math.max(0, 14 - percentageDragged * 14);
      set2(wrapper, {
        borderRadius: `${borderRadiusValue}px`,
        transform: isVertical($direction) ? `scale(${scaleValue}) translate3d(0, ${translateValue}px, 0)` : `scale(${scaleValue}) translate3d(${translateValue}px, 0, 0)`,
        transition: "none"
      }, true);
    }
    if (!$snapPoints) {
      const translateValue = absDraggedDistance * directionMultiplier;
      set2($drawerRef, {
        transform: isVertical($direction) ? `translate3d(0, ${translateValue}px, 0)` : `translate3d(${translateValue}px, 0, 0)`
      });
    }
  }
  __name(onDrag, "onDrag");
  function scaleBackground(open, backgroundColor = "black") {
    const wrapper = document.querySelector("[data-vaul-drawer-wrapper]");
    if (!wrapper || !get2(shouldScaleBackground))
      return;
    const $direction = get2(direction);
    if (open) {
      set2(document.body, {
        background: document.body.style.backgroundColor || document.body.style.background
      });
      set2(document.body, {
        background: backgroundColor
      }, true);
      set2(wrapper, {
        borderRadius: `${BORDER_RADIUS}px`,
        overflow: "hidden",
        ...isVertical($direction) ? {
          transform: `scale(${getScale()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,
          transformOrigin: "top"
        } : {
          transform: `scale(${getScale()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,
          transformOrigin: "left"
        },
        transitionProperty: "transform, border-radius",
        transitionDuration: `${TRANSITIONS.DURATION}s`,
        transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(",")})`
      });
    } else {
      reset2(wrapper, "overflow");
      reset2(wrapper, "transform");
      reset2(wrapper, "borderRadius");
      set2(wrapper, {
        transitionProperty: "transform, border-radius",
        transitionDuration: `${TRANSITIONS.DURATION}s`,
        transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(",")})`
      });
    }
  }
  __name(scaleBackground, "scaleBackground");
  effect3([activeSnapPointIndex, snapPoints, snapPointsOffset], ([$activeSnapPointIndex, $snapPoints, $snapPointsOffset]) => {
    function onVisualViewportChange() {
      const $drawerRef = get2(drawerRef);
      if (!$drawerRef)
        return;
      const $keyboardIsOpen = get2(keyboardIsOpen);
      const focusedElement = document.activeElement;
      if (isInput3(focusedElement) || $keyboardIsOpen) {
        const visualViewportHeight = window.visualViewport?.height || 0;
        let diffFromInitial = window.innerHeight - visualViewportHeight;
        const drawerHeight = $drawerRef.getBoundingClientRect().height || 0;
        if (!initialDrawerHeight) {
          initialDrawerHeight = drawerHeight;
        }
        const offsetFromTop = $drawerRef.getBoundingClientRect().top;
        if (Math.abs(previousDiffFromInitial - diffFromInitial) > 60) {
          keyboardIsOpen.set(!$keyboardIsOpen);
        }
        if ($snapPoints && $snapPoints.length > 0 && $snapPointsOffset && $activeSnapPointIndex) {
          const activeSnapPointHeight = $snapPointsOffset[$activeSnapPointIndex] || 0;
          diffFromInitial += activeSnapPointHeight;
        }
        previousDiffFromInitial = diffFromInitial;
        if (drawerHeight > visualViewportHeight || $keyboardIsOpen) {
          const height = $drawerRef.getBoundingClientRect().height;
          let newDrawerHeight = height;
          if (height > visualViewportHeight) {
            newDrawerHeight = visualViewportHeight - WINDOW_TOP_OFFSET;
          }
          if (get2(fixed)) {
            $drawerRef.style.height = `${height - Math.max(diffFromInitial, 0)}px`;
          } else {
            $drawerRef.style.height = `${Math.max(newDrawerHeight, visualViewportHeight - offsetFromTop)}px`;
          }
        } else {
          $drawerRef.style.height = `${initialDrawerHeight}px`;
        }
        if ($snapPoints && $snapPoints.length > 0 && !$keyboardIsOpen) {
          $drawerRef.style.bottom = `0px`;
        } else {
          $drawerRef.style.bottom = `${Math.max(diffFromInitial, 0)}px`;
        }
      }
    }
    __name(onVisualViewportChange, "onVisualViewportChange");
    let removeListener = noop3;
    if (window.visualViewport) {
      removeListener = addEventListener2(window.visualViewport, "resize", onVisualViewportChange);
    }
    return () => {
      removeListener();
    };
  });
  function closeDrawer(withKeyboard = false) {
    if (isClosing)
      return;
    const $drawerRef = get2(drawerRef);
    if (!$drawerRef)
      return;
    const $direction = get2(direction);
    onClose?.();
    set2($drawerRef, {
      transform: isVertical($direction) ? `translate3d(0, ${$direction === "bottom" ? "100%" : "-100%"}, 0)` : `translate3d(${$direction === "right" ? "100%" : "-100%"}, 0, 0)`,
      transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`
    });
    set2(get2(overlayRef), {
      opacity: "0",
      transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`
    });
    scaleBackground(false);
    isClosing = true;
    setTimeout(() => {
      visible.set(false);
      isOpen.set(false);
      isClosing = false;
      if (withKeyboard) {
        get2(triggerRef)?.focus();
      }
    }, 300);
    const $snapPoints = get2(snapPoints);
    setTimeout(() => {
      reset2(document.documentElement, "scrollBehavior");
      if ($snapPoints) {
        activeSnapPoint.set($snapPoints[0]);
      }
    }, TRANSITIONS.DURATION * 1e3);
  }
  __name(closeDrawer, "closeDrawer");
  effect3([isOpen], ([$isOpen]) => {
    if ($isOpen) {
      hasBeenOpened.set(true);
    } else {
      closeDrawer();
    }
  });
  function resetDrawer() {
    const $drawerRef = get2(drawerRef);
    if (!$drawerRef)
      return;
    const $overlayRef = get2(overlayRef);
    const wrapper = document.querySelector("[data-vaul-drawer-wrapper]");
    const $direction = get2(direction);
    const currentSwipeAmount = getTranslate($drawerRef, $direction);
    set2($drawerRef, {
      transform: "translate3d(0, 0, 0)",
      transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`
    });
    set2($overlayRef, {
      transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`,
      opacity: "1"
    });
    const $shouldScaleBackground = get2(shouldScaleBackground);
    const $isOpen = get2(isOpen);
    if ($shouldScaleBackground && currentSwipeAmount && currentSwipeAmount > 0 && $isOpen) {
      set2(wrapper, {
        borderRadius: `${BORDER_RADIUS}px`,
        overflow: "hidden",
        ...isVertical($direction) ? {
          transform: `scale(${getScale()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,
          transformOrigin: "top"
        } : {
          transform: `scale(${getScale()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,
          transformOrigin: "left"
        },
        transitionProperty: "transform, border-radius",
        transitionDuration: `${TRANSITIONS.DURATION}s`,
        transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(",")})`
      }, true);
    }
  }
  __name(resetDrawer, "resetDrawer");
  function onRelease(event) {
    const $drawerRef = get2(drawerRef);
    if (!isDragging || !$drawerRef)
      return;
    if (isAllowedToDrag && isInput3(event.target)) {
      event.target.blur();
    }
    $drawerRef.classList.remove(DRAG_CLASS);
    isAllowedToDrag = false;
    isDragging = false;
    dragEndTime = /* @__PURE__ */ new Date();
    const $direction = get2(direction);
    const swipeAmount = getTranslate($drawerRef, $direction);
    if (event.target && !shouldDrag(event.target, false) || !swipeAmount || Number.isNaN(swipeAmount))
      return;
    if (dragStartTime === null)
      return;
    const timeTaken = dragEndTime.getTime() - dragStartTime.getTime();
    const distMoved = getDistanceMoved(pointerStart, $direction, event);
    const velocity = Math.abs(distMoved) / timeTaken;
    if (velocity > 0.05) {
      justReleased.set(true);
      setTimeout(() => {
        justReleased.set(false);
      }, 200);
    }
    if (get2(snapPoints)) {
      onReleaseSnapPoints({
        draggedDistance: distMoved * getDirectionMultiplier($direction),
        closeDrawer,
        velocity,
        dismissible: get2(dismissible)
      });
      onReleaseProp?.(event, true);
      return;
    }
    if ($direction === "bottom" || $direction === "right" ? distMoved > 0 : distMoved < 0) {
      resetDrawer();
      onReleaseProp?.(event, true);
      return;
    }
    if (velocity > VELOCITY_THRESHOLD) {
      closeDrawer();
      onReleaseProp?.(event, false);
      return;
    }
    const visibleDrawerHeight = Math.min(get2(drawerRef)?.getBoundingClientRect().height ?? 0, window.innerHeight);
    if (swipeAmount >= visibleDrawerHeight * get2(closeThreshold)) {
      closeDrawer();
      onReleaseProp?.(event, false);
      return;
    }
    onReleaseProp?.(event, true);
    resetDrawer();
  }
  __name(onRelease, "onRelease");
  effect3([isOpen], ([$isOpen]) => {
    if (!$isOpen)
      return;
    if (isBrowser2) {
      set2(document.documentElement, {
        scrollBehavior: "auto"
      });
    }
    openTime.set(/* @__PURE__ */ new Date());
    scaleBackground(true, props.backgroundColor);
  });
  effect3([visible], ([$visible]) => {
    if (!$visible)
      return;
    const $drawerRef = get2(drawerRef);
    if (!$drawerRef)
      return;
    const children = $drawerRef.querySelectorAll("*");
    children.forEach((child) => {
      const htmlChild = child;
      if (htmlChild.scrollHeight > htmlChild.clientHeight || htmlChild.scrollWidth > htmlChild.clientWidth) {
        htmlChild.classList.add("vaul-scrollable");
      }
    });
  });
  function onNestedOpenChange(o2) {
    const $drawerRef = get2(drawerRef);
    const scale = o2 ? (window.innerWidth - NESTED_DISPLACEMENT) / window.innerWidth : 1;
    const y2 = o2 ? -NESTED_DISPLACEMENT : 0;
    if (nestedOpenChangeTimer) {
      window.clearTimeout(nestedOpenChangeTimer);
    }
    set2($drawerRef, {
      transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`,
      transform: `scale(${scale}) translate3d(0, ${y2}px, 0)`
    });
    if (!o2 && $drawerRef) {
      nestedOpenChangeTimer = setTimeout(() => {
        const $direction = get2(direction);
        const translateValue = getTranslate($drawerRef, $direction);
        set2($drawerRef, {
          transition: "none",
          transform: isVertical($direction) ? `translate3d(0, ${translateValue}px, 0)` : `translate3d(${translateValue}px, 0, 0)`
        });
      }, 500);
    }
  }
  __name(onNestedOpenChange, "onNestedOpenChange");
  function onNestedDrag(_2, percentageDragged) {
    if (percentageDragged < 0)
      return;
    const initialScale = (window.innerWidth - NESTED_DISPLACEMENT) / window.innerWidth;
    const newScale = initialScale + percentageDragged * (1 - initialScale);
    const newTranslate = -NESTED_DISPLACEMENT + percentageDragged * NESTED_DISPLACEMENT;
    const $direction = get2(direction);
    set2(get2(drawerRef), {
      transform: isVertical($direction) ? `scale(${newScale}) translate3d(0, ${newTranslate}px, 0)` : `scale(${newScale}) translate3d(${newTranslate}px, 0, 0)`,
      transition: "none"
    });
  }
  __name(onNestedDrag, "onNestedDrag");
  function onNestedRelease(_2, o2) {
    const $direction = get2(direction);
    const dim = isVertical($direction) ? window.innerHeight : window.innerWidth;
    const scale = o2 ? (dim - NESTED_DISPLACEMENT) / dim : 1;
    const translate = o2 ? -NESTED_DISPLACEMENT : 0;
    if (o2) {
      set2(get2(drawerRef), {
        transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`,
        transform: isVertical($direction) ? `scale(${scale}) translate3d(0, ${translate}px, 0)` : `scale(${scale}) translate3d(${translate}px, 0, 0)`
      });
    }
  }
  __name(onNestedRelease, "onNestedRelease");
  return {
    states: {
      isOpen,
      hasBeenOpened,
      snapPoints,
      activeSnapPoint,
      snapPointsOffset,
      keyboardIsOpen,
      shouldFade,
      visible,
      drawerId,
      openDrawerIds
    },
    helpers: {
      getContentStyle
    },
    methods: {
      closeDrawer,
      onOpenChange,
      onPress,
      onRelease,
      onDrag,
      scaleBackground,
      onNestedDrag,
      onNestedOpenChange,
      onNestedRelease,
      restorePositionSetting,
      openDrawer
    },
    refs: {
      drawerRef,
      overlayRef,
      triggerRef
    },
    options: options2
  };
}
__name(createVaul, "createVaul");
function dampenValue(v2) {
  return 8 * (Math.log(v2 + 1) - 2);
}
__name(dampenValue, "dampenValue");
function getScale() {
  return (window.innerWidth - WINDOW_TOP_OFFSET) / window.innerWidth;
}
__name(getScale, "getScale");
function getDistanceMoved(pointerStart, direction, event) {
  if (event.type.startsWith("touch")) {
    return getDistanceMovedForTouch(pointerStart, direction, event);
  } else {
    return getDistanceMovedForPointer(pointerStart, direction, event);
  }
}
__name(getDistanceMoved, "getDistanceMoved");
function getDistanceMovedForPointer(pointerStart, direction, event) {
  return pointerStart - (isVertical(direction) ? event.screenY : event.screenX);
}
__name(getDistanceMovedForPointer, "getDistanceMovedForPointer");
function getDistanceMovedForTouch(pointerStart, direction, event) {
  return pointerStart - (isVertical(direction) ? event.changedTouches[0].screenY : event.changedTouches[0].screenX);
}
__name(getDistanceMovedForTouch, "getDistanceMovedForTouch");
function getDirectionMultiplier(direction) {
  return direction === "bottom" || direction === "right" ? 1 : -1;
}
__name(getDirectionMultiplier, "getDirectionMultiplier");
function setCtx2(props = {}) {
  const vaul = createVaul(props);
  const updateOption = getOptionUpdater2(vaul.options);
  setContext(VAUL_ROOT, { ...vaul, updateOption });
  return {
    ...vaul,
    updateOption
  };
}
__name(setCtx2, "setCtx2");
function getCtx2() {
  return getContext(VAUL_ROOT);
}
__name(getCtx2, "getCtx2");
function Root3($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "open",
    "onOpenChange",
    "closeThreshold",
    "scrollLockTimeout",
    "snapPoints",
    "fadeFromIndex",
    "openFocus",
    "onOutsideClick",
    "closeOnOutsideClick",
    "backgroundColor",
    "nested",
    "shouldScaleBackground",
    "activeSnapPoint",
    "onActiveSnapPointChange",
    "onRelease",
    "onDrag",
    "onClose",
    "dismissible",
    "direction"
  ]);
  push();
  var $$store_subs;
  let open = fallback($$props["open"], false);
  let onOpenChange = fallback($$props["onOpenChange"], () => void 0, true);
  let closeThreshold = fallback($$props["closeThreshold"], () => void 0, true);
  let scrollLockTimeout = fallback($$props["scrollLockTimeout"], () => void 0, true);
  let snapPoints = fallback($$props["snapPoints"], () => void 0, true);
  let fadeFromIndex = fallback($$props["fadeFromIndex"], () => void 0, true);
  let openFocus = fallback($$props["openFocus"], () => void 0, true);
  let onOutsideClick = fallback($$props["onOutsideClick"], () => void 0, true);
  let closeOnOutsideClick = fallback($$props["closeOnOutsideClick"], true);
  let backgroundColor = fallback($$props["backgroundColor"], "black");
  let nested = fallback($$props["nested"], false);
  let shouldScaleBackground = fallback($$props["shouldScaleBackground"], false);
  let activeSnapPoint = fallback($$props["activeSnapPoint"], () => void 0, true);
  let onActiveSnapPointChange = fallback($$props["onActiveSnapPointChange"], () => void 0, true);
  let onRelease = fallback($$props["onRelease"], () => void 0, true);
  let onDrag = fallback($$props["onDrag"], () => void 0, true);
  let onClose = fallback($$props["onClose"], () => void 0, true);
  let dismissible = fallback($$props["dismissible"], () => void 0, true);
  let direction = fallback($$props["direction"], "bottom");
  const {
    states: {
      keyboardIsOpen,
      activeSnapPoint: localActiveSnapPoint,
      drawerId,
      openDrawerIds: openDrawerIds2,
      isOpen
    },
    methods: { closeDrawer, openDrawer },
    options: { dismissible: localDismissible },
    updateOption
  } = setCtx2({
    defaultOpen: open,
    defaultActiveSnapPoint: activeSnapPoint,
    onOpenChange: ({ next: next2 }) => {
      if (open !== next2) {
        onOpenChange?.(next2);
        open = next2;
      }
      return next2;
    },
    onActiveSnapPointChange: ({ next: next2 }) => {
      if (next2 === void 0 && snapPoints && activeSnapPoint !== next2) {
        const newNext = snapPoints[0];
        onActiveSnapPointChange?.(newNext);
        activeSnapPoint = newNext;
        return newNext;
      }
      if (activeSnapPoint !== next2) {
        onActiveSnapPointChange?.(next2);
        activeSnapPoint = next2;
      }
      return next2;
    },
    closeThreshold,
    scrollLockTimeout,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    snapPoints,
    fadeFromIndex,
    nested,
    onDrag,
    onClose,
    onRelease,
    shouldScaleBackground,
    backgroundColor,
    dismissible,
    direction
  });
  activeSnapPoint !== void 0 && localActiveSnapPoint.set(activeSnapPoint);
  updateOption("closeThreshold", closeThreshold);
  updateOption("scrollLockTimeout", scrollLockTimeout);
  updateOption("snapPoints", snapPoints);
  updateOption("fadeFromIndex", fadeFromIndex);
  updateOption("openFocus", openFocus);
  updateOption("shouldScaleBackground", shouldScaleBackground);
  updateOption("backgroundColor", backgroundColor);
  updateOption("dismissible", dismissible);
  updateOption("direction", direction);
  open && !store_get($$store_subs ??= {}, "$isOpen", isOpen) && openDrawer();
  !open && store_get($$store_subs ??= {}, "$isOpen", isOpen) && closeDrawer();
  let $$settled = true;
  let $$inner_payload;
  function $$render_inner($$payload2) {
    Dialog($$payload2, spread_props([
      {
        closeOnOutsideClick,
        closeOnEscape: false,
        get open() {
          return open;
        },
        set open($$value) {
          open = $$value;
          $$settled = false;
        },
        preventScroll: false,
        onOpenChange: (o2) => {
          onOpenChange?.(o2);
          if (!o2) {
            closeDrawer();
          } else if (o2) {
            openDrawer();
          }
        },
        onOutsideClick: (e3) => {
          if (!closeOnOutsideClick)
            return;
          onOutsideClick?.(e3);
          if (e3?.defaultPrevented)
            return;
          if (store_get($$store_subs ??= {}, "$keyboardIsOpen", keyboardIsOpen)) {
            keyboardIsOpen.set(false);
          }
          e3.preventDefault();
          if (!store_get($$store_subs ??= {}, "$localDismissible", localDismissible)) {
            return;
          }
          const $openDialogIds = get2(openDrawerIds2);
          const isLast = $openDialogIds[$openDialogIds.length - 1] === get2(drawerId);
          if (isLast) {
            onOpenChange?.(false);
            closeDrawer();
          }
        }
      },
      $$restProps,
      {
        children: ($$payload3) => {
          $$payload3.out += `<!---->`;
          slot($$payload3, $$props, "default", {}, null);
          $$payload3.out += `<!---->`;
        },
        $$slots: { default: true }
      }
    ]));
  }
  __name($$render_inner, "$$render_inner");
  do {
    $$settled = true;
    $$inner_payload = copy_payload($$payload);
    $$render_inner($$inner_payload);
  } while (!$$settled);
  assign_payload($$payload, $$inner_payload);
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, {
    open,
    onOpenChange,
    closeThreshold,
    scrollLockTimeout,
    snapPoints,
    fadeFromIndex,
    openFocus,
    onOutsideClick,
    closeOnOutsideClick,
    backgroundColor,
    nested,
    shouldScaleBackground,
    activeSnapPoint,
    onActiveSnapPointChange,
    onRelease,
    onDrag,
    onClose,
    dismissible,
    direction
  });
  pop();
}
__name(Root3, "Root3");
function Visible($$payload, $$props) {
  push();
  getCtx2();
  pop();
}
__name(Visible, "Visible");
function Content($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["style"]);
  push();
  var $$store_subs;
  const {
    refs: { drawerRef },
    states: { visible },
    helpers: { getContentStyle },
    methods: { onPress, onDrag, onRelease },
    options: { direction }
  } = getCtx2();
  let style = fallback($$props["style"], "");
  let $$settled = true;
  let $$inner_payload;
  function $$render_inner($$payload2) {
    Dialog_content($$payload2, spread_props([
      {
        get el() {
          return store_get($$store_subs ??= {}, "$drawerRef", drawerRef);
        },
        set el($$value) {
          store_set(drawerRef, $$value);
          $$settled = false;
        },
        style: store_get($$store_subs ??= {}, "$getContentStyle", getContentStyle)(style),
        "data-vaul-drawer": "",
        "data-vaul-drawer-direction": store_get($$store_subs ??= {}, "$direction", direction),
        "data-vaul-drawer-visible": store_get($$store_subs ??= {}, "$visible", visible) ? "true" : "false"
      },
      $$restProps,
      {
        children: ($$payload3) => {
          Visible();
          $$payload3.out += `<!----> <!---->`;
          slot($$payload3, $$props, "default", {}, null);
          $$payload3.out += `<!---->`;
        },
        $$slots: { default: true }
      }
    ]));
  }
  __name($$render_inner, "$$render_inner");
  do {
    $$settled = true;
    $$inner_payload = copy_payload($$payload);
    $$render_inner($$inner_payload);
  } while (!$$settled);
  assign_payload($$payload, $$inner_payload);
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { style });
  pop();
}
__name(Content, "Content");
function Overlay($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, []);
  push();
  var $$store_subs;
  let hasSnapPoints;
  const {
    refs: { overlayRef },
    states: { isOpen, visible, snapPoints, shouldFade },
    methods: { onRelease }
  } = getCtx2();
  hasSnapPoints = store_get($$store_subs ??= {}, "$snapPoints", snapPoints) && store_get($$store_subs ??= {}, "$snapPoints", snapPoints).length > 0;
  let $$settled = true;
  let $$inner_payload;
  function $$render_inner($$payload2) {
    Dialog_overlay($$payload2, spread_props([
      {
        get el() {
          return store_get($$store_subs ??= {}, "$overlayRef", overlayRef);
        },
        set el($$value) {
          store_set(overlayRef, $$value);
          $$settled = false;
        },
        "data-vaul-drawer-visible": store_get($$store_subs ??= {}, "$visible", visible) ? "true" : "false",
        "data-vaul-overlay": "",
        "data-vaul-snap-points": store_get($$store_subs ??= {}, "$isOpen", isOpen) && hasSnapPoints ? "true" : "false",
        "data-vaul-snap-points-overlay": store_get($$store_subs ??= {}, "$isOpen", isOpen) && store_get($$store_subs ??= {}, "$shouldFade", shouldFade) ? "true" : "false"
      },
      $$restProps
    ]));
  }
  __name($$render_inner, "$$render_inner");
  do {
    $$settled = true;
    $$inner_payload = copy_payload($$payload);
    $$render_inner($$inner_payload);
  } while (!$$settled);
  assign_payload($$payload, $$inner_payload);
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
__name(Overlay, "Overlay");
function Close_wrapper($$payload, $$props) {
  push();
  let _2, rest;
  let meltBuilder = $$props["meltBuilder"];
  const { methods: { closeDrawer } } = getCtx2();
  const wrappedAction = /* @__PURE__ */ __name((node) => {
    const handleKeydown = /* @__PURE__ */ __name((e3) => {
      if (e3.key === "Enter" || e3.key === " ") {
        e3.preventDefault();
        closeDrawer(true);
      }
    }, "handleKeydown");
    const handleClick = /* @__PURE__ */ __name(() => {
      closeDrawer();
    }, "handleClick");
    node.addEventListener("keydown", handleKeydown);
    node.addEventListener("click", handleClick);
    return () => {
      node.removeEventListener("keydown", handleKeydown);
      node.removeEventListener("click", handleClick);
    };
  }, "wrappedAction");
  ({ _: _2, ...rest } = meltBuilder);
  Object.assign(rest, { action: wrappedAction });
  $$payload.out += `<!---->`;
  slot($$payload, $$props, "default", { newBuilder: rest }, null);
  $$payload.out += `<!---->`;
  bind_props($$props, { meltBuilder });
  pop();
}
__name(Close_wrapper, "Close_wrapper");
function Close$1($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["el", "asChild"]);
  push();
  let el = fallback($$props["el"], () => void 0, true);
  let asChild = fallback($$props["asChild"], false);
  getCtx2();
  let $$settled = true;
  let $$inner_payload;
  function $$render_inner($$payload2) {
    if (asChild) {
      $$payload2.out += "<!--[-->";
      Dialog_close($$payload2, spread_props([
        {
          get el() {
            return el;
          },
          set el($$value) {
            el = $$value;
            $$settled = false;
          }
        },
        $$restProps,
        {
          asChild,
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload3, { builder }) => {
              Close_wrapper($$payload3, {
                meltBuilder: builder,
                children: invalid_default_snippet,
                $$slots: {
                  default: ($$payload4, { newBuilder }) => {
                    $$payload4.out += `<!---->`;
                    slot($$payload4, $$props, "default", { builder: newBuilder }, null);
                    $$payload4.out += `<!---->`;
                  }
                }
              });
            }
          }
        }
      ]));
    } else {
      $$payload2.out += "<!--[!-->";
      Dialog_close($$payload2, spread_props([
        {
          get el() {
            return el;
          },
          set el($$value) {
            el = $$value;
            $$settled = false;
          }
        },
        $$restProps,
        {
          asChild,
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload3, { builder }) => {
              $$payload3.out += `<!---->`;
              slot($$payload3, $$props, "default", { builder }, null);
              $$payload3.out += `<!---->`;
            }
          }
        }
      ]));
    }
    $$payload2.out += `<!--]-->`;
  }
  __name($$render_inner, "$$render_inner");
  do {
    $$settled = true;
    $$inner_payload = copy_payload($$payload);
    $$render_inner($$inner_payload);
  } while (!$$settled);
  assign_payload($$payload, $$inner_payload);
  bind_props($$props, { el, asChild });
  pop();
}
__name(Close$1, "Close$1");
function Trigger_wrapper($$payload, $$props) {
  push();
  let action, rest;
  let meltBuilder = $$props["meltBuilder"];
  const { refs: { triggerRef } } = getCtx2();
  const wrappedAction = /* @__PURE__ */ __name((node) => {
    triggerRef.set(node);
    return action(node);
  }, "wrappedAction");
  ({ action, ...rest } = meltBuilder);
  Object.assign(rest, { action: wrappedAction });
  $$payload.out += `<!---->`;
  slot($$payload, $$props, "default", { newBuilder: rest }, null);
  $$payload.out += `<!---->`;
  bind_props($$props, { meltBuilder });
  pop();
}
__name(Trigger_wrapper, "Trigger_wrapper");
function Trigger$1($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["el", "asChild"]);
  push();
  const { refs: { triggerRef } } = getCtx2();
  let el = fallback($$props["el"], () => void 0, true);
  let asChild = fallback($$props["asChild"], false);
  if (el) {
    triggerRef.set(el);
  }
  let $$settled = true;
  let $$inner_payload;
  function $$render_inner($$payload2) {
    if (asChild) {
      $$payload2.out += "<!--[-->";
      Dialog_trigger($$payload2, spread_props([
        {
          asChild,
          get el() {
            return el;
          },
          set el($$value) {
            el = $$value;
            $$settled = false;
          }
        },
        $$restProps,
        {
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload3, { builder }) => {
              Trigger_wrapper($$payload3, {
                meltBuilder: builder,
                children: invalid_default_snippet,
                $$slots: {
                  default: ($$payload4, { newBuilder }) => {
                    $$payload4.out += `<!---->`;
                    slot($$payload4, $$props, "default", { builder: newBuilder }, null);
                    $$payload4.out += `<!---->`;
                  }
                }
              });
            }
          }
        }
      ]));
    } else {
      $$payload2.out += "<!--[!-->";
      Dialog_trigger($$payload2, spread_props([
        {
          get el() {
            return el;
          },
          set el($$value) {
            el = $$value;
            $$settled = false;
          }
        },
        $$restProps,
        {
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload3, { builder }) => {
              $$payload3.out += `<!---->`;
              slot($$payload3, $$props, "default", { builder }, null);
              $$payload3.out += `<!---->`;
            }
          }
        }
      ]));
    }
    $$payload2.out += `<!--]-->`;
  }
  __name($$render_inner, "$$render_inner");
  do {
    $$settled = true;
    $$inner_payload = copy_payload($$payload);
    $$render_inner($$inner_payload);
  } while (!$$settled);
  assign_payload($$payload, $$inner_payload);
  bind_props($$props, { el, asChild });
  pop();
}
__name(Trigger$1, "Trigger$1");
function Drawer($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "shouldScaleBackground",
    "open",
    "activeSnapPoint"
  ]);
  let shouldScaleBackground = fallback($$props["shouldScaleBackground"], true);
  let open = fallback($$props["open"], false);
  let activeSnapPoint = fallback($$props["activeSnapPoint"], void 0);
  let $$settled = true;
  let $$inner_payload;
  function $$render_inner($$payload2) {
    Root3($$payload2, spread_props([
      {
        shouldScaleBackground,
        get open() {
          return open;
        },
        set open($$value) {
          open = $$value;
          $$settled = false;
        },
        get activeSnapPoint() {
          return activeSnapPoint;
        },
        set activeSnapPoint($$value) {
          activeSnapPoint = $$value;
          $$settled = false;
        }
      },
      $$restProps,
      {
        children: ($$payload3) => {
          $$payload3.out += `<!---->`;
          slot($$payload3, $$props, "default", {}, null);
          $$payload3.out += `<!---->`;
        },
        $$slots: { default: true }
      }
    ]));
  }
  __name($$render_inner, "$$render_inner");
  do {
    $$settled = true;
    $$inner_payload = copy_payload($$payload);
    $$render_inner($$inner_payload);
  } while (!$$settled);
  assign_payload($$payload, $$inner_payload);
  bind_props($$props, { shouldScaleBackground, open, activeSnapPoint });
}
__name(Drawer, "Drawer");
function Drawer_overlay($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["el", "class"]);
  push();
  let el = fallback($$props["el"], void 0);
  let className = fallback($$props["class"], void 0);
  let $$settled = true;
  let $$inner_payload;
  function $$render_inner($$payload2) {
    Overlay($$payload2, spread_props([
      {
        get el() {
          return el;
        },
        set el($$value) {
          el = $$value;
          $$settled = false;
        },
        class: cn("fixed inset-0 z-50 bg-black/80", className)
      },
      $$restProps,
      {
        children: ($$payload3) => {
          $$payload3.out += `<!---->`;
          slot($$payload3, $$props, "default", {}, null);
          $$payload3.out += `<!---->`;
        },
        $$slots: { default: true }
      }
    ]));
  }
  __name($$render_inner, "$$render_inner");
  do {
    $$settled = true;
    $$inner_payload = copy_payload($$payload);
    $$render_inner($$inner_payload);
  } while (!$$settled);
  assign_payload($$payload, $$inner_payload);
  bind_props($$props, { el, class: className });
  pop();
}
__name(Drawer_overlay, "Drawer_overlay");
function Drawer_content($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  let className = fallback($$props["class"], void 0);
  Portal($$payload, {
    children: ($$payload2) => {
      Drawer_overlay($$payload2, {});
      $$payload2.out += `<!----> `;
      Content($$payload2, spread_props([
        {
          class: cn("fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background", className)
        },
        $$restProps,
        {
          children: ($$payload3) => {
            $$payload3.out += `<!---->`;
            slot($$payload3, $$props, "default", {}, null);
            $$payload3.out += `<!---->`;
          },
          $$slots: { default: true }
        }
      ]));
      $$payload2.out += `<!---->`;
    },
    $$slots: { default: true }
  });
  bind_props($$props, { class: className });
  pop();
}
__name(Drawer_content, "Drawer_content");
var name2;
var defaults3;
var dialogIdParts;
var TRANSITIONS;
var VELOCITY_THRESHOLD;
var safeOnDestroy2;
var overridable2;
var cache;
var nonTextInputTypes;
var isBrowser2;
var visualViewport;
var preventScrollCount;
var restore;
var documentEscapeKeyStore2;
var previousBodyPosition;
var CLOSE_THRESHOLD;
var SCROLL_LOCK_TIMEOUT;
var BORDER_RADIUS;
var NESTED_DISPLACEMENT;
var WINDOW_TOP_OFFSET;
var DRAG_CLASS;
var openDrawerIds;
var defaultProps;
var omittedOptions;
var VAUL_ROOT;
var Portal;
var Trigger;
var Close;
var init_index6 = __esm({
  ".svelte-kit/output/server/chunks/index6.js"() {
    init_index2();
    init_Icon();
    init_create();
    init_index4();
    init_utils3();
    init_index_server();
    init_updater();
    init_action();
    init_clsx();
    ({ name: name2 } = createElHelpers("dialog"));
    defaults3 = {
      preventScroll: true,
      closeOnEscape: true,
      closeOnOutsideClick: true,
      role: "dialog",
      defaultOpen: false,
      portal: void 0,
      forceVisible: false,
      openFocus: void 0,
      closeFocus: void 0,
      onOutsideClick: void 0
    };
    dialogIdParts = ["content", "title", "description"];
    TRANSITIONS = {
      DURATION: 0.5,
      EASE: [0.32, 0.72, 0, 1]
    };
    VELOCITY_THRESHOLD = 0.4;
    safeOnDestroy2 = /* @__PURE__ */ __name((fn) => {
      try {
        onDestroy(fn);
      } catch {
        return fn();
      }
    }, "safeOnDestroy2");
    overridable2 = /* @__PURE__ */ __name((store, onChange) => {
      const update = /* @__PURE__ */ __name((updater, sideEffect) => {
        store.update((curr) => {
          const next2 = updater(curr);
          let res = next2;
          if (onChange) {
            res = onChange({ curr, next: next2 });
          }
          sideEffect?.(res);
          return res;
        });
      }, "update");
      const set22 = /* @__PURE__ */ __name((curr) => {
        update(() => curr);
      }, "set22");
      return {
        ...store,
        update,
        set: set22
      };
    }, "overridable2");
    cache = /* @__PURE__ */ new WeakMap();
    nonTextInputTypes = /* @__PURE__ */ new Set([
      "checkbox",
      "radio",
      "range",
      "color",
      "file",
      "image",
      "button",
      "submit",
      "reset"
    ]);
    isBrowser2 = typeof document !== "undefined";
    visualViewport = typeof document !== "undefined" && window.visualViewport;
    preventScrollCount = 0;
    documentEscapeKeyStore2 = readable(void 0, (set22) => {
      function keydown(event) {
        if (event && event.key === "Escape") {
          set22(event);
        }
        set22(void 0);
      }
      __name(keydown, "keydown");
      const unsubscribe = addEventListener2(document, "keydown", keydown, {
        passive: false
      });
      return unsubscribe;
    });
    previousBodyPosition = null;
    CLOSE_THRESHOLD = 0.25;
    SCROLL_LOCK_TIMEOUT = 100;
    BORDER_RADIUS = 8;
    NESTED_DISPLACEMENT = 16;
    WINDOW_TOP_OFFSET = 26;
    DRAG_CLASS = "vaul-dragging";
    openDrawerIds = writable([]);
    defaultProps = {
      closeThreshold: CLOSE_THRESHOLD,
      shouldScaleBackground: true,
      scrollLockTimeout: SCROLL_LOCK_TIMEOUT,
      onDrag: void 0,
      onRelease: void 0,
      snapPoints: void 0,
      fadeFromIndex: void 0,
      defaultActiveSnapPoint: void 0,
      onActiveSnapPointChange: void 0,
      defaultOpen: false,
      onOpenChange: void 0,
      fixed: void 0,
      dismissible: true,
      modal: true,
      nested: false,
      onClose: void 0,
      direction: "bottom"
    };
    omittedOptions = [
      "defaultOpen",
      "onOpenChange",
      "defaultActiveSnapPoint",
      "onActiveSnapPointChange",
      "onDrag",
      "onRelease",
      "onClose"
    ];
    VAUL_ROOT = Symbol("VAUL_ROOT");
    Portal = Dialog_portal;
    Trigger = Trigger$1;
    Close = Close$1;
  }
});
function getAvatarData() {
  const NAME = "avatar";
  const PARTS = ["root", "image", "fallback"];
  return {
    NAME,
    PARTS
  };
}
__name(getAvatarData, "getAvatarData");
function setCtx3(props) {
  const { NAME, PARTS } = getAvatarData();
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  const avatar = { ...createAvatar(removeUndefined(props)), getAttrs: getAttrs2 };
  setContext(NAME, avatar);
  return {
    ...avatar,
    updateOption: getOptionUpdater(avatar.options)
  };
}
__name(setCtx3, "setCtx3");
function getImage(src = "") {
  const { NAME } = getAvatarData();
  const avatar = getContext(NAME);
  if (!src) {
    avatar.options.src.set("");
  } else {
    avatar.options.src.set(src);
  }
  return avatar;
}
__name(getImage, "getImage");
function getCtx3() {
  const { NAME } = getAvatarData();
  return getContext(NAME);
}
__name(getCtx3, "getCtx3");
function Avatar$1($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "delayMs",
    "loadingStatus",
    "onLoadingStatusChange",
    "asChild",
    "el"
  ]);
  push();
  let delayMs = fallback($$props["delayMs"], () => void 0, true);
  let loadingStatus = fallback($$props["loadingStatus"], () => void 0, true);
  let onLoadingStatusChange = fallback($$props["onLoadingStatusChange"], () => void 0, true);
  let asChild = fallback($$props["asChild"], false);
  let el = fallback($$props["el"], () => void 0, true);
  const {
    states: { loadingStatus: localLoadingStatus },
    updateOption,
    getAttrs: getAttrs2
  } = setCtx3({
    src: "",
    delayMs,
    onLoadingStatusChange: ({ next: next2 }) => {
      loadingStatus = next2;
      onLoadingStatusChange?.(next2);
      return next2;
    }
  });
  const attrs = getAttrs2("root");
  loadingStatus !== void 0 && localLoadingStatus.set(loadingStatus);
  updateOption("delayMs", delayMs);
  if (asChild) {
    $$payload.out += "<!--[-->";
    $$payload.out += `<!---->`;
    slot($$payload, $$props, "default", { attrs }, null);
    $$payload.out += `<!---->`;
  } else {
    $$payload.out += "<!--[!-->";
    $$payload.out += `<div${spread_attributes({ ...$$restProps, ...attrs })}><!---->`;
    slot($$payload, $$props, "default", { attrs }, null);
    $$payload.out += `<!----></div>`;
  }
  $$payload.out += `<!--]-->`;
  bind_props($$props, {
    delayMs,
    loadingStatus,
    onLoadingStatusChange,
    asChild,
    el
  });
  pop();
}
__name(Avatar$1, "Avatar$1");
function Avatar_image$1($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["src", "alt", "asChild", "el"]);
  push();
  var $$store_subs;
  let image, builder;
  let src = fallback($$props["src"], () => void 0, true);
  let alt = fallback($$props["alt"], () => void 0, true);
  let asChild = fallback($$props["asChild"], false);
  let el = fallback($$props["el"], () => void 0, true);
  const attrs = { "data-bits-avatar-image": "" };
  image = getImage(src).elements.image;
  builder = store_get($$store_subs ??= {}, "$image", image);
  Object.assign(builder, attrs);
  if (asChild) {
    $$payload.out += "<!--[-->";
    $$payload.out += `<!---->`;
    slot($$payload, $$props, "default", { builder }, null);
    $$payload.out += `<!---->`;
  } else {
    $$payload.out += "<!--[!-->";
    $$payload.out += `<img${spread_attributes({ ...builder, alt, ...$$restProps })} onload="this.__e=event" onerror="this.__e=event">`;
  }
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { src, alt, asChild, el });
  pop();
}
__name(Avatar_image$1, "Avatar_image$1");
function Avatar_fallback$1($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["asChild", "el"]);
  push();
  var $$store_subs;
  let builder;
  let asChild = fallback($$props["asChild"], false);
  let el = fallback($$props["el"], () => void 0, true);
  const { elements: { fallback: fallback$1 }, getAttrs: getAttrs2 } = getCtx3();
  const attrs = getAttrs2("fallback");
  builder = store_get($$store_subs ??= {}, "$fallback", fallback$1);
  Object.assign(builder, attrs);
  if (asChild) {
    $$payload.out += "<!--[-->";
    $$payload.out += `<!---->`;
    slot($$payload, $$props, "default", { builder }, null);
    $$payload.out += `<!---->`;
  } else {
    $$payload.out += "<!--[!-->";
    $$payload.out += `<span${spread_attributes({ ...builder, ...$$restProps })}><!---->`;
    slot($$payload, $$props, "default", { builder }, null);
    $$payload.out += `<!----></span>`;
  }
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { asChild, el });
  pop();
}
__name(Avatar_fallback$1, "Avatar_fallback$1");
function Avatar($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "delayMs"]);
  push();
  let className = fallback($$props["class"], void 0);
  let delayMs = fallback($$props["delayMs"], void 0);
  Avatar$1($$payload, spread_props([
    {
      delayMs,
      class: cn("relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full", className)
    },
    $$restProps,
    {
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
  bind_props($$props, { class: className, delayMs });
  pop();
}
__name(Avatar, "Avatar");
function Avatar_image($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "src", "alt"]);
  push();
  let className = fallback($$props["class"], void 0);
  let src = fallback($$props["src"], void 0);
  let alt = fallback($$props["alt"], void 0);
  Avatar_image$1($$payload, spread_props([
    {
      src,
      alt,
      class: cn("aspect-square h-full w-full", className)
    },
    $$restProps
  ]));
  bind_props($$props, { class: className, src, alt });
  pop();
}
__name(Avatar_image, "Avatar_image");
function Avatar_fallback($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  let className = fallback($$props["class"], void 0);
  Avatar_fallback$1($$payload, spread_props([
    {
      class: cn("flex h-full w-full items-center justify-center rounded-full bg-muted", className)
    },
    $$restProps,
    {
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
  bind_props($$props, { class: className });
  pop();
}
__name(Avatar_fallback, "Avatar_fallback");
var defaults4;
var createAvatar;
var init_avatar_fallback = __esm({
  ".svelte-kit/output/server/chunks/avatar-fallback.js"() {
    init_index2();
    init_create();
    init_utils3();
    init_updater();
    init_index4();
    defaults4 = {
      src: "",
      delayMs: 0,
      onLoadingStatusChange: void 0
    };
    createAvatar = /* @__PURE__ */ __name((props) => {
      const withDefaults = { ...defaults4, ...props };
      const options2 = toWritableStores(omit(withDefaults, "loadingStatus", "onLoadingStatusChange"));
      const { src, delayMs } = options2;
      const loadingStatusWritable = withDefaults.loadingStatus ?? writable("loading");
      const loadingStatus = overridable(loadingStatusWritable, withDefaults?.onLoadingStatusChange);
      effect2([src, delayMs], ([$src, $delayMs]) => {
        if (isBrowser) {
          const image2 = new Image();
          image2.src = $src;
          image2.onload = () => {
            if (delayMs !== void 0) {
              const timerId = window.setTimeout(() => {
                loadingStatus.set("loaded");
              }, $delayMs);
              return () => window.clearTimeout(timerId);
            } else {
              loadingStatus.set("loaded");
            }
          };
          image2.onerror = () => {
            loadingStatus.set("error");
          };
        }
      });
      const image = makeElement("avatar-image", {
        stores: [src, loadingStatus],
        returned: ([$src, $loadingStatus]) => {
          const imageStyles = styleToString({
            display: $loadingStatus === "loaded" ? "block" : "none"
          });
          return {
            src: $src,
            style: imageStyles
          };
        }
      });
      const fallback2 = makeElement("avatar-fallback", {
        stores: [loadingStatus],
        returned: ([$loadingStatus]) => {
          return {
            style: $loadingStatus === "loaded" ? styleToString({
              display: "none"
            }) : void 0,
            hidden: $loadingStatus === "loaded" ? true : void 0
          };
        }
      });
      return {
        elements: {
          image,
          fallback: fallback2
        },
        states: {
          loadingStatus
        },
        options: options2
      };
    }, "createAvatar");
  }
});
function getAttrs(builders) {
  const attrs = {};
  builders.forEach((builder) => {
    Object.keys(builder).forEach((key2) => {
      if (key2 !== "action") {
        attrs[key2] = builder[key2];
      }
    });
  });
  return attrs;
}
__name(getAttrs, "getAttrs");
function Button$1($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["href", "type", "builders", "el"]);
  push();
  let href = fallback($$props["href"], () => void 0, true);
  let type = fallback($$props["type"], () => void 0, true);
  let builders = fallback($$props["builders"], () => [], true);
  let el = fallback($$props["el"], () => void 0, true);
  const attrs = { "data-button-root": "" };
  if (builders && builders.length) {
    $$payload.out += "<!--[-->";
    const $$tag = href ? "a" : "button";
    element(
      $$payload,
      $$tag,
      () => {
        $$payload.out += `${spread_attributes({
          type: href ? void 0 : type,
          href,
          tabindex: "0",
          ...getAttrs(builders),
          ...$$restProps,
          ...attrs
        })}`;
      },
      () => {
        $$payload.out += `<!---->`;
        slot($$payload, $$props, "default", {}, null);
        $$payload.out += `<!---->`;
      }
    );
  } else {
    $$payload.out += "<!--[!-->";
    const $$tag_1 = href ? "a" : "button";
    element(
      $$payload,
      $$tag_1,
      () => {
        $$payload.out += `${spread_attributes({
          type: href ? void 0 : type,
          href,
          tabindex: "0",
          ...$$restProps,
          ...attrs
        })}`;
      },
      () => {
        $$payload.out += `<!---->`;
        slot($$payload, $$props, "default", {}, null);
        $$payload.out += `<!---->`;
      }
    );
  }
  $$payload.out += `<!--]-->`;
  bind_props($$props, { href, type, builders, el });
  pop();
}
__name(Button$1, "Button$1");
function Button($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "variant", "size", "builders"]);
  push();
  let className = fallback($$props["class"], void 0);
  let variant = fallback($$props["variant"], "default");
  let size2 = fallback($$props["size"], "default");
  let builders = fallback($$props["builders"], () => [], true);
  Button$1($$payload, spread_props([
    {
      builders,
      class: cn(buttonVariants({ variant, size: size2, className })),
      type: "button"
    },
    $$restProps,
    {
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
  bind_props($$props, { class: className, variant, size: size2, builders });
  pop();
}
__name(Button, "Button");
var init_button = __esm({
  ".svelte-kit/output/server/chunks/button.js"() {
    init_index2();
    init_create();
    init_index3();
    init_utils3();
  }
});
function Bell($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const iconNode = [
    [
      "path",
      {
        "d": "M6 8a6 6 0 0 1 12 0c0 7 3 9 3 9H3s3-2 3-9"
      }
    ],
    [
      "path",
      { "d": "M10.3 21a1.94 1.94 0 0 0 3.4 0" }
    ]
  ];
  Icon($$payload, spread_props([
    { name: "bell" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
}
__name(Bell, "Bell");
var init_bell = __esm({
  ".svelte-kit/output/server/chunks/bell.js"() {
    init_index2();
    init_Icon();
  }
});
var page_svelte_exports = {};
__export(page_svelte_exports, {
  default: () => _page
});
function Chevron_right($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const iconNode = [["path", { "d": "m9 18 6-6-6-6" }]];
  Icon($$payload, spread_props([
    { name: "chevron-right" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
}
__name(Chevron_right, "Chevron_right");
function ProfileDrawer($$payload, $$props) {
  push();
  var $$store_subs;
  Drawer($$payload, {
    children: ($$payload2) => {
      Trigger($$payload2, {
        children: ($$payload3) => {
          Avatar($$payload3, {
            children: ($$payload4) => {
              Avatar_image($$payload4, {
                src: store_get($$store_subs ??= {}, "$page", page).data.userWithStats.picture,
                alt: "@shadcn"
              });
              $$payload4.out += `<!----> `;
              Avatar_fallback($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->CN`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!---->`;
            },
            $$slots: { default: true }
          });
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!----> `;
      Drawer_content($$payload2, {
        class: " mx-auto max-w-md border-none bg-[#2E2E30] p-6 text-white",
        children: ($$payload3) => {
          const each_array = ensure_array_like(store_get($$store_subs ??= {}, "$page", page).data.userWithStats.stats);
          $$payload3.out += `<div class="flex justify-end">`;
          Close($$payload3, {
            class: "text-gray-400 hover:text-white",
            children: ($$payload4) => {
              X($$payload4, { size: 24 });
            },
            $$slots: { default: true }
          });
          $$payload3.out += `<!----></div> <div class="mb-6 flex flex-col items-center">`;
          Avatar($$payload3, {
            class: "mb-2 h-16 w-16",
            children: ($$payload4) => {
              Avatar_image($$payload4, {
                src: store_get($$store_subs ??= {}, "$page", page).data.userWithStats.picture,
                alt: store_get($$store_subs ??= {}, "$page", page).data.userWithStats.name
              });
              $$payload4.out += `<!----> `;
              Avatar_fallback($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->CN`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!---->`;
            },
            $$slots: { default: true }
          });
          $$payload3.out += `<!----> <h2 class="text-xl font-semibold">${escape_html(store_get($$store_subs ??= {}, "$page", page).data.userWithStats.name)}</h2></div> <div class="space-y-4"><!--[-->`;
          for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
            let stat = each_array[$$index];
            $$payload3.out += `<div><h3 class="mb-2 text-lg font-medium capitalize">${escape_html(stat.game.name)}</h3> <div class="grid grid-cols-4 gap-2 rounded-lg border border-[#6D6D6E] p-3 text-center"><div><p class="font-bold">${escape_html(stat.globalRanking)}</p> <p class="text-xs text-gray-400">Global Ranking</p></div> <div><p class="font-bold">${escape_html(stat.gamesPlayed)}</p> <p class="text-xs text-gray-400">Games Played</p></div> <div><p class="font-bold">${escape_html(stat.gamesWon)}</p> <p class="text-xs text-gray-400">Games Won</p></div> <div><p class="font-bold">${escape_html(stat.gamesLost)}</p> <p class="text-xs text-gray-400">Games Lost</p></div></div></div>`;
          }
          $$payload3.out += `<!--]--></div> `;
          Button($$payload3, {
            variant: "outline",
            class: "mt-6 w-full rounded-full bg-[#2E2E30]",
            children: ($$payload4) => {
              $$payload4.out += `<!---->Share stats`;
            },
            $$slots: { default: true }
          });
          $$payload3.out += `<!----> <p class="mt-4 text-center text-xs font-light">To edit your username, go to "My profile" by clicking on "More".</p>`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!---->`;
    },
    $$slots: { default: true }
  });
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
__name(ProfileDrawer, "ProfileDrawer");
function _page($$payload) {
  $$payload.out += `<div class="flex items-center justify-between"><h1 class="text-2xl font-medium">Home</h1> <div class="flex items-center gap-5"><a href="/notification" class="rounded border border-gray-200 p-1">`;
  Bell($$payload, { class: "h-6 w-6" });
  $$payload.out += `<!----></a> `;
  ProfileDrawer($$payload);
  $$payload.out += `<!----></div></div> <h2 class="py-5 font-medium">Daily Puzzle</h2> <div class="relative"><div class="absolute left-1/2 top-1/2 flex w-[190px] -translate-x-1/2 -translate-y-1/2 flex-col gap-3"><button class="h-[43px] w-full rounded-3xl border border-white bg-[#3574F5] px-5 font-medium text-white">Continue playing</button> <button class="h-[43px] w-full rounded-3xl border border-white bg-[#2E2E30] px-5 font-medium text-white">Play later</button></div> <img src="/chessStatic.svg" class="w-full" alt=""></div> <div class="flex items-center justify-between pb-3 pt-5"><h3 class="text-lg font-medium">Open Tournaments</h3> `;
  Button($$payload, {
    class: "text-white",
    variant: "ghost",
    children: ($$payload2) => {
      $$payload2.out += `<!---->View more `;
      Chevron_right($$payload2, { class: "size-5" });
      $$payload2.out += `<!---->`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!----></div> `;
  Table2($$payload, {
    children: ($$payload2) => {
      Table_header($$payload2, {
        children: ($$payload3) => {
          Table_row($$payload3, {
            class: "text-nowrap text-sm font-medium",
            children: ($$payload4) => {
              Table_head($$payload4, {
                class: " text-[#C6C6C6]",
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Tournament name`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Table_head($$payload4, {
                class: "text-[#C6C6C6]",
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Time left`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Table_head($$payload4, {
                class: "w-fit text-[#C6C6C6]",
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Duration`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Table_head($$payload4, {
                class: "text-[#C6C6C6]",
                children: ($$payload5) => {
                  $$payload5.out += `<!---->No.players`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!---->`;
            },
            $$slots: { default: true }
          });
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!----> `;
      Table_body($$payload2, {
        children: ($$payload3) => {
          const each_array = ensure_array_like({ length: 5 });
          $$payload3.out += `<!--[-->`;
          for (let i2 = 0, $$length = each_array.length; i2 < $$length; i2++) {
            each_array[i2];
            Table_row($$payload3, {
              class: "text-nowrap text-right text-xs text-[#ffffff]",
              children: ($$payload4) => {
                Table_cell($$payload4, {
                  class: " font-semibold ",
                  children: ($$payload5) => {
                    $$payload5.out += `<!---->${escape_html(i2 + 1)} @Grand_Maestro`;
                  },
                  $$slots: { default: true }
                });
                $$payload4.out += `<!----> `;
                Table_cell($$payload4, {
                  class: "",
                  children: ($$payload5) => {
                    $$payload5.out += `<!---->25 minutes`;
                  },
                  $$slots: { default: true }
                });
                $$payload4.out += `<!----> `;
                Table_cell($$payload4, {
                  class: "w-fit  ",
                  children: ($$payload5) => {
                    $$payload5.out += `<!---->2 hours`;
                  },
                  $$slots: { default: true }
                });
                $$payload4.out += `<!----> `;
                Table_cell($$payload4, {
                  class: "text-left",
                  children: ($$payload5) => {
                    $$payload5.out += `<!---->10`;
                  },
                  $$slots: { default: true }
                });
                $$payload4.out += `<!---->`;
              },
              $$slots: { default: true }
            });
          }
          $$payload3.out += `<!--]-->`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!---->`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!----> <div class="mt-5 flex items-center justify-between pb-4"><h3 class="text-lg font-medium">This Week\u2019s Leaderboard</h3></div> `;
  Root2($$payload, {
    value: "chess",
    class: "",
    children: ($$payload2) => {
      Tabs_list($$payload2, {
        children: ($$payload3) => {
          Tabs_trigger($$payload3, {
            value: "chess",
            children: ($$payload4) => {
              $$payload4.out += `<!---->Chess`;
            },
            $$slots: { default: true }
          });
          $$payload3.out += `<!----> `;
          Tabs_trigger($$payload3, {
            value: "checkers",
            children: ($$payload4) => {
              $$payload4.out += `<!---->Checkers`;
            },
            $$slots: { default: true }
          });
          $$payload3.out += `<!---->`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!----> `;
      Tabs_content($$payload2, {
        value: "chess",
        children: ($$payload3) => {
          $$payload3.out += `<div class="flex w-full items-center justify-between py-5"><div class="text-center"><img class="w-full" src="./avatar-big.svg" alt=""> <p class="mt-3 font-medium">@Adebola</p></div> <div class="text-center"><img class="w-full" src="./avatar-big.svg" alt=""> <p class="mt-3 font-medium">@Adebola</p></div> <div class="text-center"><img class="w-full" src="./avatar-big.svg" alt=""> <p class="mt-3 font-medium">@Adebola</p></div></div>`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!----> `;
      Tabs_content($$payload2, {
        value: "checkers",
        children: ($$payload3) => {
          $$payload3.out += `<div class="flex items-center justify-between py-5"><div class="text-center"><img src="./avatar-big.svg" alt=""> <p class="mt-3 font-medium">@Adebola</p></div> <div class="text-center"><img src="./avatar-big.svg" alt=""> <p class="mt-3 font-medium">@Adebola</p></div> <div class="text-center"><img src="./avatar-big.svg" alt=""> <p class="mt-3 font-medium">@Adebola</p></div></div>`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!----> <div class="flex w-full items-center justify-center">`;
      Button($$payload2, {
        class: "mx-auto w-fit rounded-3xl",
        variant: "outline",
        children: ($$payload3) => {
          $$payload3.out += `<!---->View full leaderboard`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!----></div>`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!----> <div class="mt-10 rounded-lg bg-[#A9692F] p-4"><h2 class="mb-2 font-semibold">Fund Your Wallet!</h2> <p class="mb-2 text-sm">Take advantage of this opportunity to fund your wallet and stake more to increase your
		excitement and rewards.</p> <button type="button" class="w-full rounded-full bg-white px-4 py-2 text-sm font-semibold text-[#A9692F]">Fund wallet</button></div> <h2 class="mb-5 mt-10 font-medium">Play Checkers Now</h2> <div class="relative"><div class="absolute left-1/2 top-1/2 flex w-[190px] -translate-x-1/2 -translate-y-1/2 flex-col gap-3"><button class="h-[43px] w-full rounded-3xl border border-white bg-[#3574F5] px-5 font-medium text-white">Continue playing</button> <button class="h-[43px] w-full rounded-3xl border border-white bg-[#2E2E30] px-5 font-medium text-white">Play later</button></div> <img src="/checkers.svg" class="w-full" alt=""></div>`;
}
__name(_page, "_page");
var init_page_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/_page.svelte.js"() {
    init_index2();
    init_create();
    init_clsx();
    init_index3();
    init_table_row();
    init_index5();
    init_index6();
    init_avatar_fallback();
    init_stores();
    init_button();
    init_bell();
    init_Icon();
  }
});
var __exports5 = {};
__export(__exports5, {
  component: () => component5,
  fonts: () => fonts5,
  imports: () => imports5,
  index: () => index5,
  server: () => page_server_ts_exports,
  server_id: () => server_id2,
  stylesheets: () => stylesheets5
});
var index5;
var component_cache5;
var component5;
var server_id2;
var imports5;
var stylesheets5;
var fonts5;
var init__5 = __esm({
  ".svelte-kit/output/server/nodes/4.js"() {
    init_page_server_ts();
    index5 = 4;
    component5 = /* @__PURE__ */ __name(async () => component_cache5 ??= (await Promise.resolve().then(() => (init_page_svelte(), page_svelte_exports))).default, "component5");
    server_id2 = "src/routes/(app)/+page.server.ts";
    imports5 = ["_app/immutable/nodes/4.Dz8OA0tr.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/create.OoZN6NjL.js", "_app/immutable/chunks/index.bE0HzIKx.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/index-client.bJHR976g.js", "_app/immutable/chunks/index.CplayyMK.js", "_app/immutable/chunks/index.Bi_aB5ul.js", "_app/immutable/chunks/bundle-mjs.BNYwEHuQ.js", "_app/immutable/chunks/table-row.DtEc1Xxs.js", "_app/immutable/chunks/slot.BDgc6-mN.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/lifecycle.BX15fcyy.js", "_app/immutable/chunks/props.CdXMhF7y.js", "_app/immutable/chunks/store.CDnLvhlJ.js", "_app/immutable/chunks/utils.B8KE5qsB.js", "_app/immutable/chunks/misc.CXN-D0wo.js", "_app/immutable/chunks/index.59QgRJh5.js", "_app/immutable/chunks/if.DLf01pqE.js", "_app/immutable/chunks/actions.DVNHJCdf.js", "_app/immutable/chunks/this.CD6iIRB7.js", "_app/immutable/chunks/events.CdlZ0Ps4.js", "_app/immutable/chunks/updater.MNDcgVG0.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/index.AmeJI4DA.js", "_app/immutable/chunks/Icon.DWW-WWR4.js", "_app/immutable/chunks/svelte-element.2QoIbCrV.js", "_app/immutable/chunks/transitions.D2VcR92X.js", "_app/immutable/chunks/action._Er3-yw0.js", "_app/immutable/chunks/avatar-fallback.Dt2LaaM8.js", "_app/immutable/chunks/stores.DSH2_rmp.js", "_app/immutable/chunks/entry.Zk5XMwWG.js", "_app/immutable/chunks/button.DQVOpKKk.js", "_app/immutable/chunks/bell.CwWxVUA7.js"];
    stylesheets5 = ["_app/immutable/assets/index.Dr-8sKQJ.css"];
    fonts5 = [];
  }
});
var page_svelte_exports2 = {};
__export(page_svelte_exports2, {
  default: () => _page2
});
function _page2($$payload) {
  const playOptions = [
    {
      icon: "./circleComputer.svg",
      title: "Play with computer",
      subTitle: "Play against our ever smart AI bots now.",
      href: "play-with-computer"
    },
    {
      icon: "./playWithFriends.svg",
      title: "Play with Friend",
      subTitle: "Create and play your favorite game with a friend now.",
      href: "play-with-friend"
    },
    {
      icon: "./schedule.svg",
      title: "Schedule game",
      subTitle: "Schedule and play your favorite game at a later time.",
      href: "schedule-game"
    },
    {
      icon: "./circleTournament.svg",
      title: "Create tournament",
      subTitle: "Create and play your favourite game with a friend now.",
      href: "create-tournament"
    },
    {
      icon: "./dialyChallenge.svg",
      title: "Daily challenge",
      subTitle: "Play your favourite game with our smartest AI bots now.",
      href: "daily-challenge"
    },
    {
      icon: "./instantPlay.svg",
      title: "Instant play",
      subTitle: "Create and play your favourite game at a later time.",
      href: "instant-play"
    }
  ];
  const each_array = ensure_array_like(playOptions);
  const each_array_1 = ensure_array_like({ length: 5 });
  $$payload.out += `<h1 class="mb-10 text-2xl font-medium">Checkers</h1> <div class="grid grid-cols-2 gap-3 sm:gap-5"><!--[-->`;
  for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
    let { icon, subTitle, title, href } = each_array[$$index];
    $$payload.out += `<a${attr("href", `/checkers/${stringify(href)}`)} class="w-full space-y-1 rounded-md border border-[#6D6D6E] px-3 py-[18px]"><img${attr("src", icon)} alt=""> <p class="text-sm font-semibold">${escape_html(title)}</p> <p class="mt-1 text-[10px] font-light">${escape_html(subTitle)}</p></a>`;
  }
  $$payload.out += `<!--]--></div> <div class="mt-10"><p class="mb-4">Quick pairing</p> <div class="space-y-4"><!--[-->`;
  for (let $$index_1 = 0, $$length = each_array_1.length; $$index_1 < $$length; $$index_1++) {
    each_array_1[$$index_1];
    $$payload.out += `<div class="rounded-md border border-[#AFAFAF] p-4"><div class="mb-2 flex justify-between text-sm font-medium"><p>Loser pay</p> <p>(#)Free</p></div> <p class="mb-2 flex items-center gap-5 text-xs text-[#AFAFAF]"><img src="/people.svg" alt=""> <span class="font-medium">2</span></p> <p class="mb-2 flex items-center gap-5 text-xs text-[#AFAFAF]"><img src="/clock.svg" alt=""> <span class="font-medium">5 hours</span></p> <div class="mb-2 flex items-center justify-between text-xs text-[#AFAFAF]"><p class="flex items-center gap-5"><img src="/lock.svg" alt=""> <span class="font-medium">Public</span></p> <p>2 users joined</p></div></div>`;
  }
  $$payload.out += `<!--]--></div></div>`;
}
__name(_page2, "_page2");
var init_page_svelte2 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/checkers/_page.svelte.js"() {
    init_index2();
    init_index3();
  }
});
var __exports6 = {};
__export(__exports6, {
  component: () => component6,
  fonts: () => fonts6,
  imports: () => imports6,
  index: () => index6,
  stylesheets: () => stylesheets6
});
var index6;
var component_cache6;
var component6;
var imports6;
var stylesheets6;
var fonts6;
var init__6 = __esm({
  ".svelte-kit/output/server/nodes/5.js"() {
    index6 = 5;
    component6 = /* @__PURE__ */ __name(async () => component_cache6 ??= (await Promise.resolve().then(() => (init_page_svelte2(), page_svelte_exports2))).default, "component6");
    imports6 = ["_app/immutable/nodes/5.Bq7VKmdd.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js", "_app/immutable/chunks/index.CplayyMK.js", "_app/immutable/chunks/index.Bi_aB5ul.js", "_app/immutable/chunks/bundle-mjs.BNYwEHuQ.js", "_app/immutable/chunks/create.OoZN6NjL.js", "_app/immutable/chunks/index.bE0HzIKx.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/index-client.bJHR976g.js"];
    stylesheets6 = [];
    fonts6 = [];
  }
});
var page_svelte_exports3 = {};
__export(page_svelte_exports3, {
  default: () => _page3
});
function _page3($$payload) {
  let index39 = 1;
  head($$payload, ($$payload2) => {
    $$payload2.out += `<link rel="preload" as="image"${attr("href", `/howToPlay-1.svg`)}> <link rel="preload" as="image"${attr("href", `/howToPlay-2.svg`)}> <link rel="preload" as="image"${attr("href", `/howToPlay-3.svg`)}> <link rel="preload" as="image"${attr("href", `/howToPlay-4.svg`)}> <link rel="preload" as="image"${attr("href", `/howToPlay-5.svg`)}> <link rel="preload" as="image"${attr("href", `/howToPlay-6.svg`)}>`;
  });
  $$payload.out += `<div class="relative"><h1 class="mb-10 text-2xl font-medium">How To Play</h1> <!---->`;
  {
    $$payload.out += `<div><img${attr("src", `/howToPlay-${index39}.svg`)} class="w-full" alt=""></div>`;
  }
  $$payload.out += `<!----> <div class="fixed bottom-0 mx-auto mt-8 flex w-full max-w-md items-center gap-5 border-t border-gray-700 bg-black px-5 py-5">`;
  if (index39 === 6) {
    $$payload.out += "<!--[-->";
    Button($$payload, {
      class: "w-full rounded-full bg-blue-600 py-3 text-white",
      children: ($$payload2) => {
        $$payload2.out += `<!---->Start Uno`;
      },
      $$slots: { default: true }
    });
  } else {
    $$payload.out += "<!--[!-->";
    Button($$payload, {
      class: "w-full rounded-full bg-blue-600 py-3 text-white",
      children: ($$payload2) => {
        $$payload2.out += `<!---->Skip tutorial`;
      },
      $$slots: { default: true }
    });
    $$payload.out += `<!----> `;
    Button($$payload, {
      onclick: () => {
        if (index39 === 6)
          return;
        index39++;
      },
      class: "w-full rounded-full bg-background  py-3 text-white hover:bg-background",
      children: ($$payload2) => {
        $$payload2.out += `<!---->Next`;
      },
      $$slots: { default: true }
    });
    $$payload.out += `<!---->`;
  }
  $$payload.out += `<!--]--></div></div>`;
}
__name(_page3, "_page3");
var init_page_svelte3 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/checkers/how-to-play/_page.svelte.js"() {
    init_index2();
    init_button();
  }
});
var __exports7 = {};
__export(__exports7, {
  component: () => component7,
  fonts: () => fonts7,
  imports: () => imports7,
  index: () => index7,
  stylesheets: () => stylesheets7
});
var index7;
var component_cache7;
var component7;
var imports7;
var stylesheets7;
var fonts7;
var init__7 = __esm({
  ".svelte-kit/output/server/nodes/6.js"() {
    index7 = 6;
    component7 = /* @__PURE__ */ __name(async () => component_cache7 ??= (await Promise.resolve().then(() => (init_page_svelte3(), page_svelte_exports3))).default, "component7");
    imports7 = ["_app/immutable/nodes/6.Jjnd2Y29.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/if.DLf01pqE.js", "_app/immutable/chunks/key.CCikwZWN.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js", "_app/immutable/chunks/transitions.D2VcR92X.js", "_app/immutable/chunks/button.DQVOpKKk.js", "_app/immutable/chunks/slot.BDgc6-mN.js", "_app/immutable/chunks/lifecycle.BX15fcyy.js", "_app/immutable/chunks/misc.CXN-D0wo.js", "_app/immutable/chunks/props.CdXMhF7y.js", "_app/immutable/chunks/store.CDnLvhlJ.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/create.OoZN6NjL.js", "_app/immutable/chunks/index.bE0HzIKx.js", "_app/immutable/chunks/index-client.bJHR976g.js", "_app/immutable/chunks/svelte-element.2QoIbCrV.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/actions.DVNHJCdf.js", "_app/immutable/chunks/this.CD6iIRB7.js", "_app/immutable/chunks/index.CplayyMK.js", "_app/immutable/chunks/index.Bi_aB5ul.js", "_app/immutable/chunks/bundle-mjs.BNYwEHuQ.js", "_app/immutable/chunks/utils.B8KE5qsB.js", "_app/immutable/chunks/index.CwHq6mbt.js"];
    stylesheets7 = [];
    fonts7 = [];
  }
});
var page_svelte_exports4 = {};
__export(page_svelte_exports4, {
  default: () => _page4
});
function Dc($$payload) {
  $$payload.out += `<h1 class="mb-6 text-2xl font-medium">Daily Challenge</h1> <h2 class="mb-6 font-medium">Current Leaderboard</h2> <div>`;
  Table2($$payload, {
    children: ($$payload2) => {
      Table_header($$payload2, {
        children: ($$payload3) => {
          Table_row($$payload3, {
            class: "text-nowrap text-sm font-medium",
            children: ($$payload4) => {
              Table_head($$payload4, {
                class: " text-[#C6C6C6]",
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Rank`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Table_head($$payload4, {
                class: "text-[#C6C6C6]",
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Player`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Table_head($$payload4, {
                class: "w-fit text-[#C6C6C6]",
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Time`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!---->`;
            },
            $$slots: { default: true }
          });
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!----> `;
      Table_body($$payload2, {
        children: ($$payload3) => {
          const each_array = ensure_array_like({ length: 5 });
          $$payload3.out += `<!--[-->`;
          for (let i2 = 0, $$length = each_array.length; i2 < $$length; i2++) {
            each_array[i2];
            Table_row($$payload3, {
              class: "text-nowrap  text-xs text-[#ffffff]",
              children: ($$payload4) => {
                Table_cell($$payload4, {
                  class: " font-semibold ",
                  children: ($$payload5) => {
                    $$payload5.out += `<!---->${escape_html(i2 + 1)}`;
                  },
                  $$slots: { default: true }
                });
                $$payload4.out += `<!----> `;
                Table_cell($$payload4, {
                  class: "flex w-full  items-center gap-1 truncate font-medium",
                  children: ($$payload5) => {
                    $$payload5.out += `<img src="/avatar.png" class="size-10 rounded-full" alt=""> <p class="text-xs font-medium">@Grand_Maestro</p>`;
                  },
                  $$slots: { default: true }
                });
                $$payload4.out += `<!----> `;
                Table_cell($$payload4, {
                  class: "w-fit",
                  children: ($$payload5) => {
                    $$payload5.out += `<!---->03:23`;
                  },
                  $$slots: { default: true }
                });
                $$payload4.out += `<!---->`;
              },
              $$slots: { default: true }
            });
          }
          $$payload3.out += `<!--]-->`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!---->`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!----> <div class="fixed bottom-0 left-0 mt-8 w-full border-t border-gray-700 bg-black px-5 py-5">`;
  Button($$payload, {
    class: "w-full rounded-full bg-blue-600 py-3 text-white",
    children: ($$payload2) => {
      $$payload2.out += `<!---->Play Now`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!----></div></div>`;
}
__name(Dc, "Dc");
function Pwc($$payload) {
  $$payload.out += `<h1 class="mb-6 text-2xl font-medium">Play With Computer</h1> <h2 class="mb-4 font-medium">Select Piece</h2> <div class="space-y-5"><div class="flex items-center gap-5 rounded-md border border-[rgb(109,109,110)] p-6"><div class="size-10 rounded-full bg-red-500"></div> <div><h1 class="text-sm font-semibold">Red</h1> <p class="text-xs text-[#AFAFAF]">Lorem ipsum dolor sit amet consectetur.</p></div></div> <div class="flex items-center gap-5 rounded-md border border-[rgb(109,109,110)] p-6"><div class="size-10 rounded-full border border-white bg-black"></div> <div><h1 class="text-sm font-semibold">Black</h1> <p class="text-xs text-[#AFAFAF]">Lorem ipsum dolor sit amet consectetur.</p></div></div></div>`;
}
__name(Pwc, "Pwc");
function _page4($$payload, $$props) {
  push();
  var $$store_subs;
  if (store_get($$store_subs ??= {}, "$page", page).params.typeOfPlay === "play-with-computer") {
    $$payload.out += "<!--[-->";
    Pwc($$payload);
  } else {
    $$payload.out += "<!--[!-->";
    if (store_get($$store_subs ??= {}, "$page", page).params.typeOfPlay === "daily-challenge") {
      $$payload.out += "<!--[-->";
      Dc($$payload);
    } else {
      $$payload.out += "<!--[!-->";
      $$payload.out += `<p>page not found</p>`;
    }
    $$payload.out += `<!--]-->`;
  }
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
__name(_page4, "_page4");
var init_page_svelte4 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/checkers/_typeOfPlay_/_page.svelte.js"() {
    init_index2();
    init_stores();
    init_button();
    init_table_row();
    init_clsx();
  }
});
var __exports8 = {};
__export(__exports8, {
  component: () => component8,
  fonts: () => fonts8,
  imports: () => imports8,
  index: () => index8,
  stylesheets: () => stylesheets8
});
var index8;
var component_cache8;
var component8;
var imports8;
var stylesheets8;
var fonts8;
var init__8 = __esm({
  ".svelte-kit/output/server/nodes/7.js"() {
    index8 = 7;
    component8 = /* @__PURE__ */ __name(async () => component_cache8 ??= (await Promise.resolve().then(() => (init_page_svelte4(), page_svelte_exports4))).default, "component8");
    imports8 = ["_app/immutable/nodes/7.D2qs7unI.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/if.DLf01pqE.js", "_app/immutable/chunks/lifecycle.BX15fcyy.js", "_app/immutable/chunks/store.CDnLvhlJ.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/stores.DSH2_rmp.js", "_app/immutable/chunks/entry.Zk5XMwWG.js", "_app/immutable/chunks/index-client.bJHR976g.js", "_app/immutable/chunks/index.bE0HzIKx.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/button.DQVOpKKk.js", "_app/immutable/chunks/slot.BDgc6-mN.js", "_app/immutable/chunks/misc.CXN-D0wo.js", "_app/immutable/chunks/props.CdXMhF7y.js", "_app/immutable/chunks/create.OoZN6NjL.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/svelte-element.2QoIbCrV.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/actions.DVNHJCdf.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js", "_app/immutable/chunks/this.CD6iIRB7.js", "_app/immutable/chunks/index.CplayyMK.js", "_app/immutable/chunks/index.Bi_aB5ul.js", "_app/immutable/chunks/bundle-mjs.BNYwEHuQ.js", "_app/immutable/chunks/utils.B8KE5qsB.js", "_app/immutable/chunks/table-row.DtEc1Xxs.js"];
    stylesheets8 = [];
    fonts8 = [];
  }
});
var page_svelte_exports5 = {};
__export(page_svelte_exports5, {
  default: () => _page5
});
function isComplexEqual(current, next2, equalityFn = (current2, next22) => JSON.stringify(current2) === JSON.stringify(next22)) {
  return typeof current === "object" && typeof next2 === "object" && equalityFn(current, next2);
}
__name(isComplexEqual, "isComplexEqual");
function queryParam(name3, { encode: encode2 = DEFAULT_ENCODER_DECODER.encode, decode: decode2 = DEFAULT_ENCODER_DECODER.decode, defaultValue: defaultValue2 } = DEFAULT_ENCODER_DECODER, { debounceHistory = 0, pushHistory = true, sort = true, showDefaults = true, equalityFn } = {}) {
  const override2 = writable(null);
  let currentValue;
  const { subscribe } = derived([page2, override2], ([$page, $override], set3) => {
    if ($override != void 0) {
      if (isComplexEqual(currentValue, $override, equalityFn)) {
        return;
      }
      currentValue = structuredClone($override);
      return set3($override);
    }
    const actualParam = $page?.url?.searchParams?.get?.(name3);
    if (actualParam == void 0 && defaultValue2 != void 0) {
      if (isComplexEqual(currentValue, defaultValue2, equalityFn)) {
        return;
      }
      currentValue = structuredClone(defaultValue2);
      return set3(defaultValue2);
    }
    const retval = decode2(actualParam);
    if (isComplexEqual(currentValue, retval, equalityFn)) {
      return;
    }
    currentValue = structuredClone(retval);
    return set3(retval);
  });
  return {
    set(newValue) {
    },
    subscribe,
    update: (updater) => {
      updater(currentValue);
    }
  };
}
__name(queryParam, "queryParam");
function _page5($$payload, $$props) {
  push();
  const playOptions = [
    {
      icon: "./chessPlayWithComputer.svg",
      title: "Play with computer",
      subTitle: "Create and play your favourite game instantly.",
      href: "play-with-computer"
    },
    {
      icon: "./playWithFriends.svg",
      title: "Play with Friend",
      subTitle: "Create and play your favourite game with a friend now.",
      href: "play-with-friend"
    },
    {
      icon: "./schedule.svg",
      title: "Schedule game",
      subTitle: "Schedule and play your favourite game at a later time.",
      href: "schedule-game"
    },
    {
      icon: "./circleTournament.svg",
      title: "Create tournament",
      subTitle: "Create and enjoy a  chess tournament now.",
      href: "create-tournament"
    },
    {
      icon: "./instantPlay.svg",
      title: "Instant play",
      subTitle: "Create and play your favourite game at a later time.",
      href: "instant-play"
    }
  ];
  const timeControls = [
    {
      name: "Bullet",
      time: "1+0",
      baseTime: 60,
      increment: 0
    },
    {
      name: "Bullet",
      time: "2+1",
      baseTime: 120,
      increment: 1
    },
    {
      name: "Blitz",
      time: "3+0",
      baseTime: 180,
      increment: 0
    },
    {
      name: "Blitz",
      time: "3+2",
      baseTime: 180,
      increment: 2
    },
    {
      name: "Blitz",
      time: "5+0",
      baseTime: 300,
      increment: 0
    },
    {
      name: "Blitz",
      time: "5+3",
      baseTime: 300,
      increment: 3
    },
    {
      name: "Rapid",
      time: "10+2",
      baseTime: 600,
      increment: 2
    },
    {
      name: "Rapid",
      time: "10+5",
      baseTime: 600,
      increment: 5
    },
    {
      name: "Rapid",
      time: "15+10",
      baseTime: 900,
      increment: 10
    },
    {
      name: "Classical",
      time: "30+0",
      baseTime: 1800,
      increment: 0
    },
    {
      name: "Classical",
      time: "30+20",
      baseTime: 1800,
      increment: 20
    },
    {
      name: "",
      time: "Custom",
      baseTime: 0,
      increment: 0
    }
  ];
  queryParam("timeControl");
  const each_array = ensure_array_like(playOptions);
  $$payload.out += `<h1 class="mb-10 text-2xl font-medium">Chess</h1> <div class="grid grid-cols-2 gap-3 sm:gap-5"><!--[-->`;
  for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
    let { icon, subTitle, title, href } = each_array[$$index];
    $$payload.out += `<a${attr("href", `/chess/${stringify(href)}`)} class="w-full space-y-1 rounded-md border border-[#6D6D6E] px-3 py-[18px]"><img${attr("src", icon)} alt=""> <p class="text-sm font-semibold">${escape_html(title)}</p> <p class="mt-1 text-[10px] font-light">${escape_html(subTitle)}</p></a>`;
  }
  $$payload.out += `<!--]--></div> `;
  Root2($$payload, {
    value: "paring",
    class: "mt-10 w-full",
    children: ($$payload2) => {
      Tabs_list($$payload2, {
        children: ($$payload3) => {
          Tabs_trigger($$payload3, {
            value: "paring",
            children: ($$payload4) => {
              $$payload4.out += `<!---->Quick paring`;
            },
            $$slots: { default: true }
          });
          $$payload3.out += `<!----> `;
          Tabs_trigger($$payload3, {
            value: "lobby",
            children: ($$payload4) => {
              $$payload4.out += `<!---->Lobby`;
            },
            $$slots: { default: true }
          });
          $$payload3.out += `<!---->`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!----> `;
      Tabs_content($$payload2, {
        value: "paring",
        children: ($$payload3) => {
          const each_array_1 = ensure_array_like(timeControls);
          $$payload3.out += `<div class="grid grid-cols-4 gap-5"><!--[-->`;
          for (let $$index_1 = 0, $$length = each_array_1.length; $$index_1 < $$length; $$index_1++) {
            let { name: name3, time } = each_array_1[$$index_1];
            $$payload3.out += `<a${attr("href", `/chess/play?timeControl=${stringify(time)}`)} class="flex h-[60px] flex-col items-center justify-center rounded border border-[#6D6D6E] bg-[#2E2E30] hover:bg-[#4d4d4f]"><p class="text-xs font-medium">${escape_html(time)}</p> <p class="text-[10px] font-light">${escape_html(name3)}</p></a>`;
          }
          $$payload3.out += `<!--]--></div>`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!----> `;
      Tabs_content($$payload2, {
        value: "lobby",
        children: ($$payload3) => {
          Table2($$payload3, {
            children: ($$payload4) => {
              Table_header($$payload4, {
                children: ($$payload5) => {
                  Table_row($$payload5, {
                    children: ($$payload6) => {
                      Table_head($$payload6, {
                        class: " text-[#ffffff]",
                        children: ($$payload7) => {
                          $$payload7.out += `<!---->Player`;
                        },
                        $$slots: { default: true }
                      });
                      $$payload6.out += `<!----> `;
                      Table_head($$payload6, {
                        class: "text-[#ffffff]",
                        children: ($$payload7) => {
                          $$payload7.out += `<!---->Rating`;
                        },
                        $$slots: { default: true }
                      });
                      $$payload6.out += `<!----> `;
                      Table_head($$payload6, {
                        class: "text-[#ffffff]",
                        children: ($$payload7) => {
                          $$payload7.out += `<!---->Time`;
                        },
                        $$slots: { default: true }
                      });
                      $$payload6.out += `<!----> `;
                      Table_head($$payload6, {
                        class: "text-[#ffffff]",
                        children: ($$payload7) => {
                          $$payload7.out += `<!---->Mode`;
                        },
                        $$slots: { default: true }
                      });
                      $$payload6.out += `<!---->`;
                    },
                    $$slots: { default: true }
                  });
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Table_body($$payload4, {
                children: ($$payload5) => {
                  const each_array_2 = ensure_array_like({ length: 5 });
                  $$payload5.out += `<!--[-->`;
                  for (let $$index_2 = 0, $$length = each_array_2.length; $$index_2 < $$length; $$index_2++) {
                    each_array_2[$$index_2];
                    Table_row($$payload5, {
                      class: "text-[#C6C6C6]",
                      children: ($$payload6) => {
                        Table_cell($$payload6, {
                          children: ($$payload7) => {
                            $$payload7.out += `<!---->@Grand_Maestro`;
                          },
                          $$slots: { default: true }
                        });
                        $$payload6.out += `<!----> `;
                        Table_cell($$payload6, {
                          children: ($$payload7) => {
                            $$payload7.out += `<!---->3000`;
                          },
                          $$slots: { default: true }
                        });
                        $$payload6.out += `<!----> `;
                        Table_cell($$payload6, {
                          children: ($$payload7) => {
                            $$payload7.out += `<!---->2800`;
                          },
                          $$slots: { default: true }
                        });
                        $$payload6.out += `<!----> `;
                        Table_cell($$payload6, {
                          children: ($$payload7) => {
                            $$payload7.out += `<!---->200`;
                          },
                          $$slots: { default: true }
                        });
                        $$payload6.out += `<!---->`;
                      },
                      $$slots: { default: true }
                    });
                  }
                  $$payload5.out += `<!--]-->`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!---->`;
            },
            $$slots: { default: true }
          });
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!---->`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!----> <h2 class="mb-4 mt-10 text-base font-medium">Leaderboard</h2> `;
  Table2($$payload, {
    children: ($$payload2) => {
      Table_header($$payload2, {
        children: ($$payload3) => {
          Table_row($$payload3, {
            class: "text-[#C6C6C6]",
            children: ($$payload4) => {
              Table_head($$payload4, {
                class: "w-[100px text-[#C6C6C6]",
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Player`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Table_head($$payload4, {
                class: "text-[#C6C6C6]",
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Rating`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Table_head($$payload4, {
                class: "text-[#C6C6C6]",
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Win`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Table_head($$payload4, {
                class: "text-[#C6C6C6]",
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Draw`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Table_head($$payload4, {
                class: "text-[#C6C6C6]",
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Lost`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!---->`;
            },
            $$slots: { default: true }
          });
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!----> `;
      Table_body($$payload2, {
        children: ($$payload3) => {
          const each_array_3 = ensure_array_like({ length: 5 });
          $$payload3.out += `<!--[-->`;
          for (let $$index_3 = 0, $$length = each_array_3.length; $$index_3 < $$length; $$index_3++) {
            each_array_3[$$index_3];
            Table_row($$payload3, {
              children: ($$payload4) => {
                Table_cell($$payload4, {
                  class: "flex w-full  items-center gap-1 truncate font-medium",
                  children: ($$payload5) => {
                    $$payload5.out += `<img src="./avatar.png" class="size-10" alt=""> <p class="text-xs font-medium">@Grand_Maestro</p>`;
                  },
                  $$slots: { default: true }
                });
                $$payload4.out += `<!----> `;
                Table_cell($$payload4, {
                  class: "text-sm font-medium text-white",
                  children: ($$payload5) => {
                    $$payload5.out += `<!---->3000`;
                  },
                  $$slots: { default: true }
                });
                $$payload4.out += `<!----> `;
                Table_cell($$payload4, {
                  class: "text-sm font-medium text-green-500",
                  children: ($$payload5) => {
                    $$payload5.out += `<!---->2800`;
                  },
                  $$slots: { default: true }
                });
                $$payload4.out += `<!----> `;
                Table_cell($$payload4, {
                  class: "text-sm font-medium text-white",
                  children: ($$payload5) => {
                    $$payload5.out += `<!---->200`;
                  },
                  $$slots: { default: true }
                });
                $$payload4.out += `<!----> `;
                Table_cell($$payload4, {
                  class: "text-sm font-medium text-red-500",
                  children: ($$payload5) => {
                    $$payload5.out += `<!---->99`;
                  },
                  $$slots: { default: true }
                });
                $$payload4.out += `<!---->`;
              },
              $$slots: { default: true }
            });
          }
          $$payload3.out += `<!--]-->`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!---->`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!---->`;
  pop();
}
__name(_page5, "_page5");
var page2;
var DEFAULT_ENCODER_DECODER;
var init_page_svelte5 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/chess/_page.svelte.js"() {
    init_index2();
    init_index5();
    init_table_row();
    init_clsx();
    init_environment();
    init_client();
    init_stores();
    init_index4();
    if (building) {
      page2 = readable({
        url: new URL("https://github.com/paoloricciuti/sveltekit-search-params")
      });
    } else {
      page2 = page;
    }
    DEFAULT_ENCODER_DECODER = {
      encode: (value) => value.toString(),
      decode: (value) => value ? value.toString() : null
    };
  }
});
var __exports9 = {};
__export(__exports9, {
  component: () => component9,
  fonts: () => fonts9,
  imports: () => imports9,
  index: () => index9,
  stylesheets: () => stylesheets9
});
var index9;
var component_cache9;
var component9;
var imports9;
var stylesheets9;
var fonts9;
var init__9 = __esm({
  ".svelte-kit/output/server/nodes/8.js"() {
    index9 = 8;
    component9 = /* @__PURE__ */ __name(async () => component_cache9 ??= (await Promise.resolve().then(() => (init_page_svelte5(), page_svelte_exports5))).default, "component9");
    imports9 = ["_app/immutable/nodes/8.COAJQUgJ.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js", "_app/immutable/chunks/lifecycle.BX15fcyy.js", "_app/immutable/chunks/index.59QgRJh5.js", "_app/immutable/chunks/slot.BDgc6-mN.js", "_app/immutable/chunks/props.CdXMhF7y.js", "_app/immutable/chunks/store.CDnLvhlJ.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/create.OoZN6NjL.js", "_app/immutable/chunks/index.bE0HzIKx.js", "_app/immutable/chunks/index-client.bJHR976g.js", "_app/immutable/chunks/if.DLf01pqE.js", "_app/immutable/chunks/actions.DVNHJCdf.js", "_app/immutable/chunks/this.CD6iIRB7.js", "_app/immutable/chunks/utils.B8KE5qsB.js", "_app/immutable/chunks/bundle-mjs.BNYwEHuQ.js", "_app/immutable/chunks/misc.CXN-D0wo.js", "_app/immutable/chunks/events.CdlZ0Ps4.js", "_app/immutable/chunks/updater.MNDcgVG0.js", "_app/immutable/chunks/table-row.DtEc1Xxs.js", "_app/immutable/chunks/entry.Zk5XMwWG.js", "_app/immutable/chunks/stores.DSH2_rmp.js"];
    stylesheets9 = [];
    fonts9 = [];
  }
});
var page_svelte_exports6 = {};
__export(page_svelte_exports6, {
  default: () => _page6
});
function _page6($$payload) {
}
__name(_page6, "_page6");
var init_page_svelte6 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/chess/play/_page.svelte.js"() {
  }
});
var __exports10 = {};
__export(__exports10, {
  component: () => component10,
  fonts: () => fonts10,
  imports: () => imports10,
  index: () => index10,
  stylesheets: () => stylesheets10
});
var index10;
var component_cache10;
var component10;
var imports10;
var stylesheets10;
var fonts10;
var init__10 = __esm({
  ".svelte-kit/output/server/nodes/9.js"() {
    index10 = 9;
    component10 = /* @__PURE__ */ __name(async () => component_cache10 ??= (await Promise.resolve().then(() => (init_page_svelte6(), page_svelte_exports6))).default, "component10");
    imports10 = ["_app/immutable/nodes/9.RBcn971s.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js"];
    stylesheets10 = [];
    fonts10 = [];
  }
});
function setErrorMap(map) {
  overrideErrorMap = map;
}
__name(setErrorMap, "setErrorMap");
function getErrorMap() {
  return overrideErrorMap;
}
__name(getErrorMap, "getErrorMap");
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue);
}
__name(addIssueToContext, "addIssueToContext");
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
__name(__classPrivateFieldGet, "__classPrivateFieldGet");
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
__name(__classPrivateFieldSet, "__classPrivateFieldSet");
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = /* @__PURE__ */ __name((iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  }, "customMap");
  return { errorMap: customMap, description };
}
__name(processCreateParams, "processCreateParams");
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
__name(timeRegexSource, "timeRegexSource");
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
__name(timeRegex, "timeRegex");
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
__name(datetimeRegex, "datetimeRegex");
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
__name(isValidIP, "isValidIP");
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
__name(floatSafeRemainder, "floatSafeRemainder");
function deepPartialify(schema2) {
  if (schema2 instanceof ZodObject) {
    const newShape = {};
    for (const key2 in schema2.shape) {
      const fieldSchema = schema2.shape[key2];
      newShape[key2] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema2._def,
      shape: () => newShape
    });
  } else if (schema2 instanceof ZodArray) {
    return new ZodArray({
      ...schema2._def,
      type: deepPartialify(schema2.element)
    });
  } else if (schema2 instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema2.unwrap()));
  } else if (schema2 instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema2.unwrap()));
  } else if (schema2 instanceof ZodTuple) {
    return ZodTuple.create(schema2.items.map((item) => deepPartialify(item)));
  } else {
    return schema2;
  }
}
__name(deepPartialify, "deepPartialify");
function mergeValues(a2, b) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b);
  if (a2 === b) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a2).filter((key2) => bKeys.indexOf(key2) !== -1);
    const newObj = { ...a2, ...b };
    for (const key2 of sharedKeys) {
      const sharedValue = mergeValues(a2[key2], b[key2]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key2] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index39 = 0; index39 < a2.length; index39++) {
      const itemA = a2[index39];
      const itemB = b[index39];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
__name(mergeValues, "mergeValues");
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
__name(createZodEnum, "createZodEnum");
function custom(check, params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p2 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p2.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        const p22 = typeof p2 === "string" ? { message: p2 } : p2;
        ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
      }
    });
  return ZodAny.create();
}
__name(custom, "custom");
var util;
var objectUtil;
var ZodParsedType;
var getParsedType;
var ZodIssueCode;
var quotelessJson;
var ZodError;
var errorMap;
var overrideErrorMap;
var makeIssue;
var EMPTY_PATH;
var ParseStatus;
var INVALID;
var DIRTY2;
var OK;
var isAborted;
var isDirty;
var isValid;
var isAsync;
var errorUtil;
var _ZodEnum_cache;
var _ZodNativeEnum_cache;
var ParseInputLazyPath;
var handleResult;
var ZodType;
var cuidRegex;
var cuid2Regex;
var ulidRegex;
var uuidRegex;
var nanoidRegex;
var durationRegex;
var emailRegex;
var _emojiRegex;
var emojiRegex;
var ipv4Regex;
var ipv6Regex;
var base64Regex;
var dateRegexSource;
var dateRegex;
var ZodString;
var ZodNumber;
var ZodBigInt;
var ZodBoolean;
var ZodDate;
var ZodSymbol;
var ZodUndefined;
var ZodNull;
var ZodAny;
var ZodUnknown;
var ZodNever;
var ZodVoid;
var ZodArray;
var ZodObject;
var ZodUnion;
var getDiscriminator;
var ZodDiscriminatedUnion;
var ZodIntersection;
var ZodTuple;
var ZodRecord;
var ZodMap;
var ZodSet;
var ZodFunction;
var ZodLazy;
var ZodLiteral;
var ZodEnum;
var ZodNativeEnum;
var ZodPromise;
var ZodEffects;
var ZodOptional;
var ZodNullable;
var ZodDefault;
var ZodCatch;
var ZodNaN;
var BRAND;
var ZodBranded;
var ZodPipeline;
var ZodReadonly;
var late;
var ZodFirstPartyTypeKind;
var instanceOfType;
var stringType;
var numberType;
var nanType;
var bigIntType;
var booleanType;
var dateType;
var symbolType;
var undefinedType;
var nullType;
var anyType;
var unknownType;
var neverType;
var voidType;
var arrayType;
var objectType;
var strictObjectType;
var unionType;
var discriminatedUnionType;
var intersectionType;
var tupleType;
var recordType;
var mapType;
var setType;
var functionType;
var lazyType;
var literalType;
var enumType;
var nativeEnumType;
var promiseType;
var effectsType;
var optionalType;
var nullableType;
var preprocessType;
var pipelineType;
var ostring;
var onumber;
var oboolean;
var coerce;
var NEVER;
var z;
var init_lib = __esm({
  "node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/index.mjs"() {
    (function(util2) {
      util2.assertEqual = (val) => val;
      function assertIs(_arg) {
      }
      __name(assertIs, "assertIs");
      util2.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      __name(assertNever, "assertNever");
      util2.assertNever = assertNever;
      util2.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util2.getValidEnumValues = (obj) => {
        const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
          filtered[k] = obj[k];
        }
        return util2.objectValues(filtered);
      };
      util2.objectValues = (obj) => {
        return util2.objectKeys(obj).map(function(e3) {
          return obj[e3];
        });
      };
      util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
        const keys = [];
        for (const key2 in object) {
          if (Object.prototype.hasOwnProperty.call(object, key2)) {
            keys.push(key2);
          }
        }
        return keys;
      };
      util2.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
      function joinValues(array3, separator = " | ") {
        return array3.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      __name(joinValues, "joinValues");
      util2.joinValues = joinValues;
      util2.jsonStringifyReplacer = (_2, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util || (util = {}));
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil || (objectUtil = {}));
    ZodParsedType = util.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    getParsedType = /* @__PURE__ */ __name((data) => {
      const t2 = typeof data;
      switch (t2) {
        case "undefined":
          return ZodParsedType.undefined;
        case "string":
          return ZodParsedType.string;
        case "number":
          return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
          return ZodParsedType.boolean;
        case "function":
          return ZodParsedType.function;
        case "bigint":
          return ZodParsedType.bigint;
        case "symbol":
          return ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return ZodParsedType.array;
          }
          if (data === null) {
            return ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return ZodParsedType.date;
          }
          return ZodParsedType.object;
        default:
          return ZodParsedType.unknown;
      }
    }, "getParsedType");
    ZodIssueCode = util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    quotelessJson = /* @__PURE__ */ __name((obj) => {
      const json2 = JSON.stringify(obj, null, 2);
      return json2.replace(/"([^"]+)":/g, "$1:");
    }, "quotelessJson");
    ZodError = /* @__PURE__ */ __name(class _ZodError extends Error {
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      get errors() {
        return this.issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue) {
          return issue.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = /* @__PURE__ */ __name((error2) => {
          for (const issue of error2.issues) {
            if (issue.code === "invalid_union") {
              issue.unionErrors.map(processError);
            } else if (issue.code === "invalid_return_type") {
              processError(issue.returnTypeError);
            } else if (issue.code === "invalid_arguments") {
              processError(issue.argumentsError);
            } else if (issue.path.length === 0) {
              fieldErrors._errors.push(mapper(issue));
            } else {
              let curr = fieldErrors;
              let i2 = 0;
              while (i2 < issue.path.length) {
                const el = issue.path[i2];
                const terminal = i2 === issue.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue));
                }
                curr = curr[el];
                i2++;
              }
            }
          }
        }, "processError");
        processError(this);
        return fieldErrors;
      }
      static assert(value) {
        if (!(value instanceof _ZodError)) {
          throw new Error(`Not a ZodError: ${value}`);
        }
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
            fieldErrors[sub.path[0]].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    }, "_ZodError");
    ZodError.create = (issues) => {
      const error2 = new ZodError(issues);
      return error2;
    };
    errorMap = /* @__PURE__ */ __name((issue, _ctx) => {
      let message;
      switch (issue.code) {
        case ZodIssueCode.invalid_type:
          if (issue.received === ZodParsedType.undefined) {
            message = "Required";
          } else {
            message = `Expected ${issue.expected}, received ${issue.received}`;
          }
          break;
        case ZodIssueCode.invalid_literal:
          message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
          break;
        case ZodIssueCode.unrecognized_keys:
          message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
          break;
        case ZodIssueCode.invalid_union:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_union_discriminator:
          message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
          break;
        case ZodIssueCode.invalid_enum_value:
          message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodIssueCode.invalid_arguments:
          message = `Invalid function arguments`;
          break;
        case ZodIssueCode.invalid_return_type:
          message = `Invalid function return type`;
          break;
        case ZodIssueCode.invalid_date:
          message = `Invalid date`;
          break;
        case ZodIssueCode.invalid_string:
          if (typeof issue.validation === "object") {
            if ("includes" in issue.validation) {
              message = `Invalid input: must include "${issue.validation.includes}"`;
              if (typeof issue.validation.position === "number") {
                message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
              }
            } else if ("startsWith" in issue.validation) {
              message = `Invalid input: must start with "${issue.validation.startsWith}"`;
            } else if ("endsWith" in issue.validation) {
              message = `Invalid input: must end with "${issue.validation.endsWith}"`;
            } else {
              util.assertNever(issue.validation);
            }
          } else if (issue.validation !== "regex") {
            message = `Invalid ${issue.validation}`;
          } else {
            message = "Invalid";
          }
          break;
        case ZodIssueCode.too_small:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.too_big:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "bigint")
            message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.custom:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_intersection_types:
          message = `Intersection results could not be merged`;
          break;
        case ZodIssueCode.not_multiple_of:
          message = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodIssueCode.not_finite:
          message = "Number must be finite";
          break;
        default:
          message = _ctx.defaultError;
          util.assertNever(issue);
      }
      return { message };
    }, "errorMap");
    overrideErrorMap = errorMap;
    makeIssue = /* @__PURE__ */ __name((params) => {
      const { data, path, errorMaps, issueData } = params;
      const fullPath = [...path, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      if (issueData.message !== void 0) {
        return {
          ...issueData,
          path: fullPath,
          message: issueData.message
        };
      }
      let errorMessage = "";
      const maps = errorMaps.filter((m) => !!m).slice().reverse();
      for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: errorMessage
      };
    }, "makeIssue");
    EMPTY_PATH = [];
    ParseStatus = /* @__PURE__ */ __name(class _ParseStatus {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s3 of results) {
          if (s3.status === "aborted")
            return INVALID;
          if (s3.status === "dirty")
            status.dirty();
          arrayValue.push(s3.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          const key2 = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key: key2,
            value
          });
        }
        return _ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key: key2, value } = pair;
          if (key2.status === "aborted")
            return INVALID;
          if (value.status === "aborted")
            return INVALID;
          if (key2.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (key2.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
            finalObject[key2.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    }, "_ParseStatus");
    INVALID = Object.freeze({
      status: "aborted"
    });
    DIRTY2 = /* @__PURE__ */ __name((value) => ({ status: "dirty", value }), "DIRTY2");
    OK = /* @__PURE__ */ __name((value) => ({ status: "valid", value }), "OK");
    isAborted = /* @__PURE__ */ __name((x2) => x2.status === "aborted", "isAborted");
    isDirty = /* @__PURE__ */ __name((x2) => x2.status === "dirty", "isDirty");
    isValid = /* @__PURE__ */ __name((x2) => x2.status === "valid", "isValid");
    isAsync = /* @__PURE__ */ __name((x2) => typeof Promise !== "undefined" && x2 instanceof Promise, "isAsync");
    (function(errorUtil2) {
      errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
      errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
    })(errorUtil || (errorUtil = {}));
    ParseInputLazyPath = /* @__PURE__ */ __name(class {
      constructor(parent, value, path, key2) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key2;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (this._key instanceof Array) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    }, "ParseInputLazyPath");
    handleResult = /* @__PURE__ */ __name((ctx, result) => {
      if (isValid(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error2 = new ZodError(ctx.common.issues);
            this._error = error2;
            return this._error;
          }
        };
      }
    }, "handleResult");
    ZodType = /* @__PURE__ */ __name(class {
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
      }
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return getParsedType(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params) {
        var _a;
        const ctx = {
          common: {
            issues: [],
            async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
      }
      async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            async: true
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
      }
      refine(check, message) {
        const getIssueProperties = /* @__PURE__ */ __name((val) => {
          if (typeof message === "string" || typeof message === "undefined") {
            return { message };
          } else if (typeof message === "function") {
            return message(val);
          } else {
            return message;
          }
        }, "getIssueProperties");
        return this._refinement((val, ctx) => {
          const result = check(val);
          const setError = /* @__PURE__ */ __name(() => ctx.addIssue({
            code: ZodIssueCode.custom,
            ...getIssueProperties(val)
          }), "setError");
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      optional() {
        return ZodOptional.create(this, this._def);
      }
      nullable() {
        return ZodNullable.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray.create(this, this._def);
      }
      promise() {
        return ZodPromise.create(this, this._def);
      }
      or(option) {
        return ZodUnion.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
      }
      transform(transform) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        });
      }
      catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline.create(this, target);
      }
      readonly() {
        return ZodReadonly.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    }, "ZodType");
    cuidRegex = /^c[^\s-]{8,}$/i;
    cuid2Regex = /^[0-9a-z]+$/;
    ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
    uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    nanoidRegex = /^[a-z0-9_-]{21}$/i;
    durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
    base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
    dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
    dateRegex = new RegExp(`^${dateRegexSource}$`);
    ZodString = /* @__PURE__ */ __name(class _ZodString extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.string,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.length < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.length > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "length") {
            const tooBig = input.data.length > check.value;
            const tooSmall = input.data.length < check.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              } else if (tooSmall) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              }
              status.dirty();
            }
          } else if (check.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "email",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "emoji") {
            if (!emojiRegex) {
              emojiRegex = new RegExp(_emojiRegex, "u");
            }
            if (!emojiRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "emoji",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "uuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "nanoid") {
            if (!nanoidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "nanoid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid2") {
            if (!cuid2Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid2",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ulid") {
            if (!ulidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ulid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "url") {
            try {
              new URL(input.data);
            } catch (_a) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "url",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "regex") {
            check.regex.lastIndex = 0;
            const testResult = check.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "regex",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "trim") {
            input.data = input.data.trim();
          } else if (check.kind === "includes") {
            if (!input.data.includes(check.value, check.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { includes: check.value, position: check.position },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check.kind === "startsWith") {
            if (!input.data.startsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { startsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "endsWith") {
            if (!input.data.endsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { endsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "datetime") {
            const regex = datetimeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "date") {
            const regex = dateRegex;
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "date",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "time") {
            const regex = timeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "time",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "duration") {
            if (!durationRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "duration",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ip") {
            if (!isValidIP(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ip",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "base64") {
            if (!base64Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "base64",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _regex(regex, validation, message) {
        return this.refinement((data) => regex.test(data), {
          validation,
          code: ZodIssueCode.invalid_string,
          ...errorUtil.errToObj(message)
        });
      }
      _addCheck(check) {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
      }
      url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
      }
      emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
      }
      uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
      }
      nanoid(message) {
        return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
      }
      cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
      }
      cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
      }
      ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
      }
      base64(message) {
        return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
      }
      ip(options2) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options2) });
      }
      datetime(options2) {
        var _a, _b;
        if (typeof options2 === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            local: false,
            message: options2
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof (options2 === null || options2 === void 0 ? void 0 : options2.precision) === "undefined" ? null : options2 === null || options2 === void 0 ? void 0 : options2.precision,
          offset: (_a = options2 === null || options2 === void 0 ? void 0 : options2.offset) !== null && _a !== void 0 ? _a : false,
          local: (_b = options2 === null || options2 === void 0 ? void 0 : options2.local) !== null && _b !== void 0 ? _b : false,
          ...errorUtil.errToObj(options2 === null || options2 === void 0 ? void 0 : options2.message)
        });
      }
      date(message) {
        return this._addCheck({ kind: "date", message });
      }
      time(options2) {
        if (typeof options2 === "string") {
          return this._addCheck({
            kind: "time",
            precision: null,
            message: options2
          });
        }
        return this._addCheck({
          kind: "time",
          precision: typeof (options2 === null || options2 === void 0 ? void 0 : options2.precision) === "undefined" ? null : options2 === null || options2 === void 0 ? void 0 : options2.precision,
          ...errorUtil.errToObj(options2 === null || options2 === void 0 ? void 0 : options2.message)
        });
      }
      duration(message) {
        return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
      }
      regex(regex, message) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil.errToObj(message)
        });
      }
      includes(value, options2) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options2 === null || options2 === void 0 ? void 0 : options2.position,
          ...errorUtil.errToObj(options2 === null || options2 === void 0 ? void 0 : options2.message)
        });
      }
      startsWith(value, message) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      endsWith(value, message) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      min(minLength, message) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil.errToObj(message)
        });
      }
      max(maxLength, message) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil.errToObj(message)
        });
      }
      length(len, message) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil.errToObj(message)
        });
      }
      /**
       * @deprecated Use z.string().min(1) instead.
       * @see {@link ZodString.min}
       */
      nonempty(message) {
        return this.min(1, errorUtil.errToObj(message));
      }
      trim() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
      }
      toLowerCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
      }
      toUpperCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isDate() {
        return !!this._def.checks.find((ch) => ch.kind === "date");
      }
      get isTime() {
        return !!this._def.checks.find((ch) => ch.kind === "time");
      }
      get isDuration() {
        return !!this._def.checks.find((ch) => ch.kind === "duration");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isNANOID() {
        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get isBase64() {
        return !!this._def.checks.find((ch) => ch.kind === "base64");
      }
      get minLength() {
        let min2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min2 === null || ch.value > min2)
              min2 = ch.value;
          }
        }
        return min2;
      }
      get maxLength() {
        let max2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max2 === null || ch.value < max2)
              max2 = ch.value;
          }
        }
        return max2;
      }
    }, "_ZodString");
    ZodString.create = (params) => {
      var _a;
      return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params)
      });
    };
    ZodNumber = /* @__PURE__ */ __name(class _ZodNumber extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.number,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "int") {
            if (!util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (floatSafeRemainder(input.data, check.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_finite,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      int(message) {
        return this._addCheck({
          kind: "int",
          message: errorUtil.toString(message)
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      finite(message) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil.toString(message)
        });
      }
      safe(message) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil.toString(message)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min2 === null || ch.value > min2)
              min2 = ch.value;
          }
        }
        return min2;
      }
      get maxValue() {
        let max2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max2 === null || ch.value < max2)
              max2 = ch.value;
          }
        }
        return max2;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
      }
      get isFinite() {
        let max2 = null, min2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
            return true;
          } else if (ch.kind === "min") {
            if (min2 === null || ch.value > min2)
              min2 = ch.value;
          } else if (ch.kind === "max") {
            if (max2 === null || ch.value < max2)
              max2 = ch.value;
          }
        }
        return Number.isFinite(min2) && Number.isFinite(max2);
      }
    }, "_ZodNumber");
    ZodNumber.create = (params) => {
      return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    ZodBigInt = /* @__PURE__ */ __name(class _ZodBigInt extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = BigInt(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.bigint,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                type: "bigint",
                minimum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                type: "bigint",
                maximum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (input.data % check.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min2 === null || ch.value > min2)
              min2 = ch.value;
          }
        }
        return min2;
      }
      get maxValue() {
        let max2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max2 === null || ch.value < max2)
              max2 = ch.value;
          }
        }
        return max2;
      }
    }, "_ZodBigInt");
    ZodBigInt.create = (params) => {
      var _a;
      return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params)
      });
    };
    ZodBoolean = /* @__PURE__ */ __name(class extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    }, "ZodBoolean");
    ZodBoolean.create = (params) => {
      return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    ZodDate = /* @__PURE__ */ __name(class _ZodDate extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.date,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        if (isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_date
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.getTime() < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                message: check.message,
                inclusive: true,
                exact: false,
                minimum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.getTime() > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                message: check.message,
                inclusive: true,
                exact: false,
                maximum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check) {
        return new _ZodDate({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      min(minDate, message) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      max(maxDate, message) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      get minDate() {
        let min2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min2 === null || ch.value > min2)
              min2 = ch.value;
          }
        }
        return min2 != null ? new Date(min2) : null;
      }
      get maxDate() {
        let max2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max2 === null || ch.value < max2)
              max2 = ch.value;
          }
        }
        return max2 != null ? new Date(max2) : null;
      }
    }, "_ZodDate");
    ZodDate.create = (params) => {
      return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params)
      });
    };
    ZodSymbol = /* @__PURE__ */ __name(class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    }, "ZodSymbol");
    ZodSymbol.create = (params) => {
      return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params)
      });
    };
    ZodUndefined = /* @__PURE__ */ __name(class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    }, "ZodUndefined");
    ZodUndefined.create = (params) => {
      return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params)
      });
    };
    ZodNull = /* @__PURE__ */ __name(class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.null,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    }, "ZodNull");
    ZodNull.create = (params) => {
      return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params)
      });
    };
    ZodAny = /* @__PURE__ */ __name(class extends ZodType {
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    }, "ZodAny");
    ZodAny.create = (params) => {
      return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params)
      });
    };
    ZodUnknown = /* @__PURE__ */ __name(class extends ZodType {
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    }, "ZodUnknown");
    ZodUnknown.create = (params) => {
      return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params)
      });
    };
    ZodNever = /* @__PURE__ */ __name(class extends ZodType {
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.never,
          received: ctx.parsedType
        });
        return INVALID;
      }
    }, "ZodNever");
    ZodNever.create = (params) => {
      return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params)
      });
    };
    ZodVoid = /* @__PURE__ */ __name(class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.void,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    }, "ZodVoid");
    ZodVoid.create = (params) => {
      return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params)
      });
    };
    ZodArray = /* @__PURE__ */ __name(class _ZodArray extends ZodType {
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            addIssueToContext(ctx, {
              code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i2) => {
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
          })).then((result2) => {
            return ParseStatus.mergeArray(status, result2);
          });
        }
        const result = [...ctx.data].map((item, i2) => {
          return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
        });
        return ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message) {
        return new _ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil.toString(message) }
        });
      }
      max(maxLength, message) {
        return new _ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil.toString(message) }
        });
      }
      length(len, message) {
        return new _ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil.toString(message) }
        });
      }
      nonempty(message) {
        return this.min(1, message);
      }
    }, "_ZodArray");
    ZodArray.create = (schema2, params) => {
      return new ZodArray({
        type: schema2,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params)
      });
    };
    ZodObject = /* @__PURE__ */ __name(class _ZodObject extends ZodType {
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        return this._cached = { shape, keys };
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
          for (const key2 in ctx.data) {
            if (!shapeKeys.includes(key2)) {
              extraKeys.push(key2);
            }
          }
        }
        const pairs = [];
        for (const key2 of shapeKeys) {
          const keyValidator = shape[key2];
          const value = ctx.data[key2];
          pairs.push({
            key: { status: "valid", value: key2 },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key2)),
            alwaysSet: key2 in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key2 of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key2 },
                value: { status: "valid", value: ctx.data[key2] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip")
            ;
          else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key2 of extraKeys) {
            const value = ctx.data[key2];
            pairs.push({
              key: { status: "valid", value: key2 },
              value: catchall._parse(
                new ParseInputLazyPath(ctx, value, ctx.path, key2)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key2 in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key2 = await pair.key;
              const value = await pair.value;
              syncPairs.push({
                key: key2,
                value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message) {
        errorUtil.errToObj;
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message !== void 0 ? {
            errorMap: (issue, ctx) => {
              var _a, _b, _c, _d;
              const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}
        });
      }
      strip() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      // const AugmentFactory =
      //   <Def extends ZodObjectDef>(def: Def) =>
      //   <Augmentation extends ZodRawShape>(
      //     augmentation: Augmentation
      //   ): ZodObject<
      //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
      //     Def["unknownKeys"],
      //     Def["catchall"]
      //   > => {
      //     return new ZodObject({
      //       ...def,
      //       shape: () => ({
      //         ...def.shape(),
      //         ...augmentation,
      //       }),
      //     }) as any;
      //   };
      extend(augmentation) {
        return new _ZodObject({
          ...this._def,
          shape: () => ({
            ...this._def.shape(),
            ...augmentation
          })
        });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new _ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: () => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
      }
      // merge<
      //   Incoming extends AnyZodObject,
      //   Augmentation extends Incoming["shape"],
      //   NewOutput extends {
      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
      //       ? Augmentation[k]["_output"]
      //       : k extends keyof Output
      //       ? Output[k]
      //       : never;
      //   },
      //   NewInput extends {
      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
      //       ? Augmentation[k]["_input"]
      //       : k extends keyof Input
      //       ? Input[k]
      //       : never;
      //   }
      // >(
      //   merging: Incoming
      // ): ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"],
      //   NewOutput,
      //   NewInput
      // > {
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      setKey(key2, schema2) {
        return this.augment({ [key2]: schema2 });
      }
      // merge<Incoming extends AnyZodObject>(
      //   merging: Incoming
      // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
      // ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"]
      // > {
      //   // const mergedShape = objectUtil.mergeShapes(
      //   //   this._def.shape(),
      //   //   merging._def.shape()
      //   // );
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      catchall(index39) {
        return new _ZodObject({
          ...this._def,
          catchall: index39
        });
      }
      pick(mask) {
        const shape = {};
        util.objectKeys(mask).forEach((key2) => {
          if (mask[key2] && this.shape[key2]) {
            shape[key2] = this.shape[key2];
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      omit(mask) {
        const shape = {};
        util.objectKeys(this.shape).forEach((key2) => {
          if (!mask[key2]) {
            shape[key2] = this.shape[key2];
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      /**
       * @deprecated
       */
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key2) => {
          const fieldSchema = this.shape[key2];
          if (mask && !mask[key2]) {
            newShape[key2] = fieldSchema;
          } else {
            newShape[key2] = fieldSchema.optional();
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      required(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key2) => {
          if (mask && !mask[key2]) {
            newShape[key2] = this.shape[key2];
          } else {
            const fieldSchema = this.shape[key2];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
              newField = newField._def.innerType;
            }
            newShape[key2] = newField;
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      keyof() {
        return createZodEnum(util.objectKeys(this.shape));
      }
    }, "_ZodObject");
    ZodObject.create = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.strictCreate = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.lazycreate = (shape, params) => {
      return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodUnion = /* @__PURE__ */ __name(class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options2 = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
        __name(handleResults, "handleResults");
        if (ctx.common.async) {
          return Promise.all(options2.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options2) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError(issues2));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    }, "ZodUnion");
    ZodUnion.create = (types, params) => {
      return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params)
      });
    };
    getDiscriminator = /* @__PURE__ */ __name((type) => {
      if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
      } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
      } else if (type instanceof ZodLiteral) {
        return [type.value];
      } else if (type instanceof ZodEnum) {
        return type.options;
      } else if (type instanceof ZodNativeEnum) {
        return util.objectValues(type.enum);
      } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
      } else if (type instanceof ZodUndefined) {
        return [void 0];
      } else if (type instanceof ZodNull) {
        return [null];
      } else if (type instanceof ZodOptional) {
        return [void 0, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodNullable) {
        return [null, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodBranded) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodReadonly) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodCatch) {
        return getDiscriminator(type._def.innerType);
      } else {
        return [];
      }
    }, "getDiscriminator");
    ZodDiscriminatedUnion = /* @__PURE__ */ __name(class _ZodDiscriminatedUnion extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      /**
       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
       * have a different value for each object in the union.
       * @param discriminator the name of the discriminator property
       * @param types an array of object schemas
       * @param params
       */
      static create(discriminator, options2, params) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options2) {
          const discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues.length) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new _ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
          discriminator,
          options: options2,
          optionsMap,
          ...processCreateParams(params)
        });
      }
    }, "_ZodDiscriminatedUnion");
    ZodIntersection = /* @__PURE__ */ __name(class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = /* @__PURE__ */ __name((parsedLeft, parsedRight) => {
          if (isAborted(parsedLeft) || isAborted(parsedRight)) {
            return INVALID;
          }
          const merged = mergeValues(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_intersection_types
            });
            return INVALID;
          }
          if (isDirty(parsedLeft) || isDirty(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        }, "handleParsed");
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    }, "ZodIntersection");
    ZodIntersection.create = (left, right, params) => {
      return new ZodIntersection({
        left,
        right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params)
      });
    };
    ZodTuple = /* @__PURE__ */ __name(class _ZodTuple extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema2 = this._def.items[itemIndex] || this._def.rest;
          if (!schema2)
            return null;
          return schema2._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x2) => !!x2);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return ParseStatus.mergeArray(status, results);
          });
        } else {
          return ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new _ZodTuple({
          ...this._def,
          rest
        });
      }
    }, "_ZodTuple");
    ZodTuple.create = (schemas, params) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
      });
    };
    ZodRecord = /* @__PURE__ */ __name(class _ZodRecord extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key2 in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, key2)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key2], ctx.path, key2)),
            alwaysSet: key2 in ctx.data
          });
        }
        if (ctx.common.async) {
          return ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType) {
          return new _ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
          });
        }
        return new _ZodRecord({
          keyType: ZodString.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(second)
        });
      }
    }, "_ZodRecord");
    ZodMap = /* @__PURE__ */ __name(class extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.map,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key2, value], index39) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, [index39, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index39, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key2 = await pair.key;
              const value = await pair.value;
              if (key2.status === "aborted" || value.status === "aborted") {
                return INVALID;
              }
              if (key2.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key2.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key2 = pair.key;
            const value = pair.value;
            if (key2.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key2.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key2.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    }, "ZodMap");
    ZodMap.create = (keyType, valueType, params) => {
      return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params)
      });
    };
    ZodSet = /* @__PURE__ */ __name(class _ZodSet extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.set,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element2 of elements2) {
            if (element2.status === "aborted")
              return INVALID;
            if (element2.status === "dirty")
              status.dirty();
            parsedSet.add(element2.value);
          }
          return { status: status.value, value: parsedSet };
        }
        __name(finalizeSet, "finalizeSet");
        const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message) {
        return new _ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil.toString(message) }
        });
      }
      max(maxSize, message) {
        return new _ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil.toString(message) }
        });
      }
      size(size2, message) {
        return this.min(size2, message).max(size2, message);
      }
      nonempty(message) {
        return this.min(1, message);
      }
    }, "_ZodSet");
    ZodSet.create = (valueType, params) => {
      return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params)
      });
    };
    ZodFunction = /* @__PURE__ */ __name(class _ZodFunction extends ZodType {
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.function,
            received: ctx.parsedType
          });
          return INVALID;
        }
        function makeArgsIssue(args, error2) {
          return makeIssue({
            data: args,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              getErrorMap(),
              errorMap
            ].filter((x2) => !!x2),
            issueData: {
              code: ZodIssueCode.invalid_arguments,
              argumentsError: error2
            }
          });
        }
        __name(makeArgsIssue, "makeArgsIssue");
        function makeReturnsIssue(returns, error2) {
          return makeIssue({
            data: returns,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              getErrorMap(),
              errorMap
            ].filter((x2) => !!x2),
            issueData: {
              code: ZodIssueCode.invalid_return_type,
              returnTypeError: error2
            }
          });
        }
        __name(makeReturnsIssue, "makeReturnsIssue");
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
          const me = this;
          return OK(async function(...args) {
            const error2 = new ZodError([]);
            const parsedArgs = await me._def.args.parseAsync(args, params).catch((e3) => {
              error2.addIssue(makeArgsIssue(args, e3));
              throw error2;
            });
            const result = await Reflect.apply(fn, this, parsedArgs);
            const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e3) => {
              error2.addIssue(makeReturnsIssue(result, e3));
              throw error2;
            });
            return parsedReturns;
          });
        } else {
          const me = this;
          return OK(function(...args) {
            const parsedArgs = me._def.args.safeParse(args, params);
            if (!parsedArgs.success) {
              throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = Reflect.apply(fn, this, parsedArgs.data);
            const parsedReturns = me._def.returns.safeParse(result, params);
            if (!parsedReturns.success) {
              throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new _ZodFunction({
          ...this._def,
          args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
      }
      returns(returnType) {
        return new _ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params) {
        return new _ZodFunction({
          args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
          returns: returns || ZodUnknown.create(),
          typeName: ZodFirstPartyTypeKind.ZodFunction,
          ...processCreateParams(params)
        });
      }
    }, "_ZodFunction");
    ZodLazy = /* @__PURE__ */ __name(class extends ZodType {
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    }, "ZodLazy");
    ZodLazy.create = (getter, params) => {
      return new ZodLazy({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params)
      });
    };
    ZodLiteral = /* @__PURE__ */ __name(class extends ZodType {
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    }, "ZodLiteral");
    ZodLiteral.create = (value, params) => {
      return new ZodLiteral({
        value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params)
      });
    };
    ZodEnum = /* @__PURE__ */ __name(class _ZodEnum extends ZodType {
      constructor() {
        super(...arguments);
        _ZodEnum_cache.set(this, void 0);
      }
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
          __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
        }
        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values, newDef = this._def) {
        return _ZodEnum.create(values, {
          ...this._def,
          ...newDef
        });
      }
      exclude(values, newDef = this._def) {
        return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
          ...this._def,
          ...newDef
        });
      }
    }, "_ZodEnum");
    _ZodEnum_cache = /* @__PURE__ */ new WeakMap();
    ZodEnum.create = createZodEnum;
    ZodNativeEnum = /* @__PURE__ */ __name(class extends ZodType {
      constructor() {
        super(...arguments);
        _ZodNativeEnum_cache.set(this, void 0);
      }
      _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
          __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
        }
        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get enum() {
        return this._def.values;
      }
    }, "ZodNativeEnum");
    _ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
    ZodNativeEnum.create = (values, params) => {
      return new ZodNativeEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params)
      });
    };
    ZodPromise = /* @__PURE__ */ __name(class extends ZodType {
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.promise,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    }, "ZodPromise");
    ZodPromise.create = (schema2, params) => {
      return new ZodPromise({
        type: schema2,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params)
      });
    };
    ZodEffects = /* @__PURE__ */ __name(class extends ZodType {
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect4 = this._def.effect || null;
        const checkCtx = {
          addIssue: (arg) => {
            addIssueToContext(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          },
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect4.type === "preprocess") {
          const processed = effect4.transform(ctx.data, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(processed).then(async (processed2) => {
              if (status.value === "aborted")
                return INVALID;
              const result = await this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
              if (result.status === "aborted")
                return INVALID;
              if (result.status === "dirty")
                return DIRTY2(result.value);
              if (status.value === "dirty")
                return DIRTY2(result.value);
              return result;
            });
          } else {
            if (status.value === "aborted")
              return INVALID;
            const result = this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY2(result.value);
            if (status.value === "dirty")
              return DIRTY2(result.value);
            return result;
          }
        }
        if (effect4.type === "refinement") {
          const executeRefinement = /* @__PURE__ */ __name((acc) => {
            const result = effect4.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          }, "executeRefinement");
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect4.type === "transform") {
          if (ctx.common.async === false) {
            const base2 = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!isValid(base2))
              return base2;
            const result = effect4.transform(base2.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base2) => {
              if (!isValid(base2))
                return base2;
              return Promise.resolve(effect4.transform(base2.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
            });
          }
        }
        util.assertNever(effect4);
      }
    }, "ZodEffects");
    ZodEffects.create = (schema2, effect4, params) => {
      return new ZodEffects({
        schema: schema2,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: effect4,
        ...processCreateParams(params)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess, schema2, params) => {
      return new ZodEffects({
        schema: schema2,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params)
      });
    };
    ZodOptional = /* @__PURE__ */ __name(class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
          return OK(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    }, "ZodOptional");
    ZodOptional.create = (type, params) => {
      return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params)
      });
    };
    ZodNullable = /* @__PURE__ */ __name(class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
          return OK(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    }, "ZodNullable");
    ZodNullable.create = (type, params) => {
      return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params)
      });
    };
    ZodDefault = /* @__PURE__ */ __name(class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    }, "ZodDefault");
    ZodDefault.create = (type, params) => {
      return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params)
      });
    };
    ZodCatch = /* @__PURE__ */ __name(class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if (isAsync(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    }, "ZodCatch");
    ZodCatch.create = (type, params) => {
      return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params)
      });
    };
    ZodNaN = /* @__PURE__ */ __name(class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.nan,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
    }, "ZodNaN");
    ZodNaN.create = (params) => {
      return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params)
      });
    };
    BRAND = Symbol("zod_brand");
    ZodBranded = /* @__PURE__ */ __name(class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    }, "ZodBranded");
    ZodPipeline = /* @__PURE__ */ __name(class _ZodPipeline extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = /* @__PURE__ */ __name(async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return DIRTY2(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          }, "handleAsync");
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a2, b) {
        return new _ZodPipeline({
          in: a2,
          out: b,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    }, "_ZodPipeline");
    ZodReadonly = /* @__PURE__ */ __name(class extends ZodType {
      _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = /* @__PURE__ */ __name((data) => {
          if (isValid(data)) {
            data.value = Object.freeze(data.value);
          }
          return data;
        }, "freeze");
        return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
      }
      unwrap() {
        return this._def.innerType;
      }
    }, "ZodReadonly");
    ZodReadonly.create = (type, params) => {
      return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params)
      });
    };
    late = {
      object: ZodObject.lazycreate
    };
    (function(ZodFirstPartyTypeKind2) {
      ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
      ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
    instanceOfType = /* @__PURE__ */ __name((cls, params = {
      message: `Input not instance of ${cls.name}`
    }) => custom((data) => data instanceof cls, params), "instanceOfType");
    stringType = ZodString.create;
    numberType = ZodNumber.create;
    nanType = ZodNaN.create;
    bigIntType = ZodBigInt.create;
    booleanType = ZodBoolean.create;
    dateType = ZodDate.create;
    symbolType = ZodSymbol.create;
    undefinedType = ZodUndefined.create;
    nullType = ZodNull.create;
    anyType = ZodAny.create;
    unknownType = ZodUnknown.create;
    neverType = ZodNever.create;
    voidType = ZodVoid.create;
    arrayType = ZodArray.create;
    objectType = ZodObject.create;
    strictObjectType = ZodObject.strictCreate;
    unionType = ZodUnion.create;
    discriminatedUnionType = ZodDiscriminatedUnion.create;
    intersectionType = ZodIntersection.create;
    tupleType = ZodTuple.create;
    recordType = ZodRecord.create;
    mapType = ZodMap.create;
    setType = ZodSet.create;
    functionType = ZodFunction.create;
    lazyType = ZodLazy.create;
    literalType = ZodLiteral.create;
    enumType = ZodEnum.create;
    nativeEnumType = ZodNativeEnum.create;
    promiseType = ZodPromise.create;
    effectsType = ZodEffects.create;
    optionalType = ZodOptional.create;
    nullableType = ZodNullable.create;
    preprocessType = ZodEffects.createWithPreprocess;
    pipelineType = ZodPipeline.create;
    ostring = /* @__PURE__ */ __name(() => stringType().optional(), "ostring");
    onumber = /* @__PURE__ */ __name(() => numberType().optional(), "onumber");
    oboolean = /* @__PURE__ */ __name(() => booleanType().optional(), "oboolean");
    coerce = {
      string: (arg) => ZodString.create({ ...arg, coerce: true }),
      number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
      boolean: (arg) => ZodBoolean.create({
        ...arg,
        coerce: true
      }),
      bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
      date: (arg) => ZodDate.create({ ...arg, coerce: true })
    };
    NEVER = INVALID;
    z = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      defaultErrorMap: errorMap,
      setErrorMap,
      getErrorMap,
      makeIssue,
      EMPTY_PATH,
      addIssueToContext,
      ParseStatus,
      INVALID,
      DIRTY: DIRTY2,
      OK,
      isAborted,
      isDirty,
      isValid,
      isAsync,
      get util() {
        return util;
      },
      get objectUtil() {
        return objectUtil;
      },
      ZodParsedType,
      getParsedType,
      ZodType,
      datetimeRegex,
      ZodString,
      ZodNumber,
      ZodBigInt,
      ZodBoolean,
      ZodDate,
      ZodSymbol,
      ZodUndefined,
      ZodNull,
      ZodAny,
      ZodUnknown,
      ZodNever,
      ZodVoid,
      ZodArray,
      ZodObject,
      ZodUnion,
      ZodDiscriminatedUnion,
      ZodIntersection,
      ZodTuple,
      ZodRecord,
      ZodMap,
      ZodSet,
      ZodFunction,
      ZodLazy,
      ZodLiteral,
      ZodEnum,
      ZodNativeEnum,
      ZodPromise,
      ZodEffects,
      ZodTransformer: ZodEffects,
      ZodOptional,
      ZodNullable,
      ZodDefault,
      ZodCatch,
      ZodNaN,
      BRAND,
      ZodBranded,
      ZodPipeline,
      ZodReadonly,
      custom,
      Schema: ZodType,
      ZodSchema: ZodType,
      late,
      get ZodFirstPartyTypeKind() {
        return ZodFirstPartyTypeKind;
      },
      coerce,
      any: anyType,
      array: arrayType,
      bigint: bigIntType,
      boolean: booleanType,
      date: dateType,
      discriminatedUnion: discriminatedUnionType,
      effect: effectsType,
      "enum": enumType,
      "function": functionType,
      "instanceof": instanceOfType,
      intersection: intersectionType,
      lazy: lazyType,
      literal: literalType,
      map: mapType,
      nan: nanType,
      nativeEnum: nativeEnumType,
      never: neverType,
      "null": nullType,
      nullable: nullableType,
      number: numberType,
      object: objectType,
      oboolean,
      onumber,
      optional: optionalType,
      ostring,
      pipeline: pipelineType,
      preprocess: preprocessType,
      promise: promiseType,
      record: recordType,
      set: setType,
      strictObject: strictObjectType,
      string: stringType,
      symbol: symbolType,
      transformer: effectsType,
      tuple: tupleType,
      "undefined": undefinedType,
      union: unionType,
      unknown: unknownType,
      "void": voidType,
      NEVER,
      ZodIssueCode,
      quotelessJson,
      ZodError
    });
  }
});
var playWithComputerSchema;
var scheduleGameSchema;
var createTournamentSchema;
var instantPlaySchema;
var playWithFriendSchema;
var init_formSchema = __esm({
  ".svelte-kit/output/server/chunks/formSchema.js"() {
    init_lib();
    playWithComputerSchema = z.object({
      variant: z.string().min(1),
      minutes: z.number().int().min(1),
      stakingAmount: z.number().int().min(1)
    });
    scheduleGameSchema = z.object({
      opponentUserName: z.string().min(1)
    });
    createTournamentSchema = z.object({
      timeControl: z.string().min(1)
    });
    instantPlaySchema = z.object({
      arenaName: z.string().min(1)
    });
    playWithFriendSchema = z.object({
      friendUsername: z.string().min(3, "Username must be at least 3 characters long").max(30, "Username must not exceed 30 characters"),
      variant: z.enum(["standard", "blitz", "rapid"], {
        required_error: "Please select a game variant"
      }),
      timeControl: z.enum(["5+0", "10+0", "15+10"], {
        required_error: "Please select a time control"
      }),
      stakingAmount: z.string().min(1, "Staking amount is required").refine((val) => !isNaN(Number(val.replace(/,/g, ""))), "Please enter a valid number").transform((val) => Number(val.replace(/,/g, ""))).refine((val) => val >= 100, "Minimum staking amount is \u20A6100").refine((val) => val <= 1e6, "Maximum staking amount is \u20A61,000,000")
    });
  }
});
function parse2(serialized, revivers) {
  return unflatten(JSON.parse(serialized));
}
__name(parse2, "parse2");
function unflatten(parsed, revivers) {
  if (typeof parsed === "number")
    return hydrate2(parsed, true);
  if (!Array.isArray(parsed) || parsed.length === 0) {
    throw new Error("Invalid input");
  }
  const values = (
    /** @type {any[]} */
    parsed
  );
  const hydrated = Array(values.length);
  function hydrate2(index39, standalone = false) {
    if (index39 === UNDEFINED)
      return void 0;
    if (index39 === NAN)
      return NaN;
    if (index39 === POSITIVE_INFINITY)
      return Infinity;
    if (index39 === NEGATIVE_INFINITY)
      return -Infinity;
    if (index39 === NEGATIVE_ZERO)
      return -0;
    if (standalone)
      throw new Error(`Invalid input`);
    if (index39 in hydrated)
      return hydrated[index39];
    const value = values[index39];
    if (!value || typeof value !== "object") {
      hydrated[index39] = value;
    } else if (Array.isArray(value)) {
      if (typeof value[0] === "string") {
        const type = value[0];
        switch (type) {
          case "Date":
            hydrated[index39] = new Date(value[1]);
            break;
          case "Set":
            const set3 = /* @__PURE__ */ new Set();
            hydrated[index39] = set3;
            for (let i2 = 1; i2 < value.length; i2 += 1) {
              set3.add(hydrate2(value[i2]));
            }
            break;
          case "Map":
            const map = /* @__PURE__ */ new Map();
            hydrated[index39] = map;
            for (let i2 = 1; i2 < value.length; i2 += 2) {
              map.set(hydrate2(value[i2]), hydrate2(value[i2 + 1]));
            }
            break;
          case "RegExp":
            hydrated[index39] = new RegExp(value[1], value[2]);
            break;
          case "Object":
            hydrated[index39] = Object(value[1]);
            break;
          case "BigInt":
            hydrated[index39] = BigInt(value[1]);
            break;
          case "null":
            const obj = /* @__PURE__ */ Object.create(null);
            hydrated[index39] = obj;
            for (let i2 = 1; i2 < value.length; i2 += 2) {
              obj[value[i2]] = hydrate2(value[i2 + 1]);
            }
            break;
          case "Int8Array":
          case "Uint8Array":
          case "Uint8ClampedArray":
          case "Int16Array":
          case "Uint16Array":
          case "Int32Array":
          case "Uint32Array":
          case "Float32Array":
          case "Float64Array":
          case "BigInt64Array":
          case "BigUint64Array": {
            const TypedArrayConstructor = globalThis[type];
            const base642 = value[1];
            const arraybuffer = decode64(base642);
            const typedArray = new TypedArrayConstructor(arraybuffer);
            hydrated[index39] = typedArray;
            break;
          }
          case "ArrayBuffer": {
            const base642 = value[1];
            const arraybuffer = decode64(base642);
            hydrated[index39] = arraybuffer;
            break;
          }
          default:
            throw new Error(`Unknown type ${type}`);
        }
      } else {
        const array3 = new Array(value.length);
        hydrated[index39] = array3;
        for (let i2 = 0; i2 < value.length; i2 += 1) {
          const n2 = value[i2];
          if (n2 === HOLE)
            continue;
          array3[i2] = hydrate2(n2);
        }
      }
    } else {
      const object = {};
      hydrated[index39] = object;
      for (const key2 in value) {
        const n2 = value[key2];
        object[key2] = hydrate2(n2);
      }
    }
    return hydrated[index39];
  }
  __name(hydrate2, "hydrate2");
  return hydrate2(0);
}
__name(unflatten, "unflatten");
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
__name(getDefaultExportFromCjs, "getDefaultExportFromCjs");
function setPath(parent, key2, value) {
  parent[key2] = value;
  return "skip";
}
__name(setPath, "setPath");
function isInvalidPath(originalPath, pathData) {
  return pathData.value !== void 0 && typeof pathData.value !== "object" && pathData.path.length < originalPath.length;
}
__name(isInvalidPath, "isInvalidPath");
function pathExists(obj, path, options2 = {}) {
  if (!options2.modifier) {
    options2.modifier = (pathData) => isInvalidPath(path, pathData) ? void 0 : pathData.value;
  }
  const exists2 = traversePath(obj, path, options2.modifier);
  if (!exists2)
    return void 0;
  if (options2.value === void 0)
    return exists2;
  return options2.value(exists2.value) ? exists2 : void 0;
}
__name(pathExists, "pathExists");
function traversePath(obj, realPath, modifier) {
  if (!realPath.length)
    return void 0;
  const path = [realPath[0]];
  let parent = obj;
  while (parent && path.length < realPath.length) {
    const key22 = path[path.length - 1];
    const value = modifier ? modifier({
      parent,
      key: String(key22),
      value: parent[key22],
      path: path.map((p2) => String(p2)),
      isLeaf: false,
      set: (v2) => setPath(parent, key22, v2)
    }) : parent[key22];
    if (value === void 0)
      return void 0;
    else
      parent = value;
    path.push(realPath[path.length]);
  }
  if (!parent)
    return void 0;
  const key2 = realPath[realPath.length - 1];
  return {
    parent,
    key: String(key2),
    value: parent[key2],
    path: realPath.map((p2) => String(p2)),
    isLeaf: true,
    set: (v2) => setPath(parent, key2, v2)
  };
}
__name(traversePath, "traversePath");
function traversePaths(parent, modifier, path = []) {
  for (const key2 in parent) {
    const value = parent[key2];
    const isLeaf = value === null || typeof value !== "object";
    const pathData = {
      parent,
      key: key2,
      value,
      path: path.concat([key2]),
      // path.map(String).concat([key])
      isLeaf,
      set: (v2) => setPath(parent, key2, v2)
    };
    const status = modifier(pathData);
    if (status === "abort")
      return status;
    else if (status === "skip")
      continue;
    else if (!isLeaf) {
      const status2 = traversePaths(value, modifier, pathData.path);
      if (status2 === "abort")
        return status2;
    }
  }
}
__name(traversePaths, "traversePaths");
function eqSet(xs, ys) {
  return xs === ys || xs.size === ys.size && [...xs].every((x2) => ys.has(x2));
}
__name(eqSet, "eqSet");
function comparePaths(newObj, oldObj) {
  const diffPaths = /* @__PURE__ */ new Map();
  function builtInDiff(one, other) {
    if (one instanceof Date && other instanceof Date && one.getTime() !== other.getTime())
      return true;
    if (one instanceof Set && other instanceof Set && !eqSet(one, other))
      return true;
    if (one instanceof File && other instanceof File && one !== other)
      return true;
    return false;
  }
  __name(builtInDiff, "builtInDiff");
  function isBuiltin(data) {
    return data instanceof Date || data instanceof Set || data instanceof File;
  }
  __name(isBuiltin, "isBuiltin");
  function checkPath(data, compareTo) {
    const otherData = compareTo ? traversePath(compareTo, data.path) : void 0;
    function addDiff() {
      diffPaths.set(data.path.join(" "), data.path);
      return "skip";
    }
    __name(addDiff, "addDiff");
    if (isBuiltin(data.value)) {
      if (!isBuiltin(otherData?.value) || builtInDiff(data.value, otherData.value)) {
        return addDiff();
      }
    }
    if (data.isLeaf) {
      if (!otherData || data.value !== otherData.value) {
        addDiff();
      }
    }
  }
  __name(checkPath, "checkPath");
  traversePaths(newObj, (data) => checkPath(data, oldObj));
  traversePaths(oldObj, (data) => checkPath(data, newObj));
  return Array.from(diffPaths.values());
}
__name(comparePaths, "comparePaths");
function setPaths(obj, paths, value) {
  const isFunction2 = typeof value === "function";
  for (const path of paths) {
    const leaf = traversePath(obj, path, ({ parent, key: key2, value: value2 }) => {
      if (value2 === void 0 || typeof value2 !== "object") {
        parent[key2] = {};
      }
      return parent[key2];
    });
    if (leaf)
      leaf.parent[leaf.key] = isFunction2 ? value(path, leaf) : value;
  }
}
__name(setPaths, "setPaths");
function splitPath(path) {
  return path.toString().split(/[[\].]+/).filter((p2) => p2);
}
__name(splitPath, "splitPath");
function mergePath(path) {
  return path.reduce((acc, next2) => {
    const key2 = String(next2);
    if (typeof next2 === "number" || /^\d+$/.test(key2))
      acc += `[${key2}]`;
    else if (!acc)
      acc += key2;
    else
      acc += `.${key2}`;
    return acc;
  }, "");
}
__name(mergePath, "mergePath");
function clone$2(obj) {
  let result = obj;
  var type = {}.toString.call(obj).slice(8, -1);
  if (type == "Set") {
    return new Set([...obj].map((value) => clone$2(value)));
  }
  if (type == "Map") {
    return new Map([...obj].map((kv) => [clone$2(kv[0]), clone$2(kv[1])]));
  }
  if (type == "Date") {
    return new Date(obj.getTime());
  }
  if (type == "RegExp") {
    return RegExp(obj.source, getRegExpFlags(obj));
  }
  if (type == "Array" || type == "Object") {
    result = Array.isArray(obj) ? [] : {};
    for (var key2 in obj) {
      result[key2] = clone$2(obj[key2]);
    }
  }
  return result;
}
__name(clone$2, "clone$2");
function getRegExpFlags(regExp) {
  if (typeof regExp.source.flags == "string") {
    return regExp.source.flags;
  } else {
    var flags = [];
    regExp.global && flags.push("g");
    regExp.ignoreCase && flags.push("i");
    regExp.multiline && flags.push("m");
    regExp.sticky && flags.push("y");
    regExp.unicode && flags.push("u");
    return flags.join("");
  }
}
__name(getRegExpFlags, "getRegExpFlags");
function clone$1(data) {
  return data && typeof data === "object" ? collectionClone(data) : data;
}
__name(clone$1, "clone$1");
function assertSchema(schema2, path) {
  if (typeof schema2 === "boolean") {
    throw new SchemaError("Schema property cannot be defined as boolean.", path);
  }
}
__name(assertSchema, "assertSchema");
function schemaInfo(schema2, isOptional, path) {
  assertSchema(schema2, path);
  if (schema2.allOf && schema2.allOf.length) {
    return {
      ...merge$1.withOptions({ allowUndefinedOverrides: false }, ...schema2.allOf.map((s3) => schemaInfo(s3, false, []))),
      schema: schema2
    };
  }
  const types = schemaTypes(schema2, path);
  const array3 = schema2.items && types.includes("array") ? (Array.isArray(schema2.items) ? schema2.items : [schema2.items]).filter((s3) => typeof s3 !== "boolean") : void 0;
  const additionalProperties = schema2.additionalProperties && typeof schema2.additionalProperties === "object" && types.includes("object") ? Object.fromEntries(Object.entries(schema2.additionalProperties).filter(([, value]) => typeof value !== "boolean")) : void 0;
  const properties = schema2.properties && types.includes("object") ? Object.fromEntries(Object.entries(schema2.properties).filter(([, value]) => typeof value !== "boolean")) : void 0;
  const union2 = unionInfo(schema2)?.filter((u2) => u2.type !== "null" && u2.const !== null);
  return {
    types: types.filter((s3) => s3 !== "null"),
    isOptional,
    isNullable: types.includes("null"),
    schema: schema2,
    union: union2?.length ? union2 : void 0,
    array: array3,
    properties,
    additionalProperties,
    required: schema2.required
  };
}
__name(schemaInfo, "schemaInfo");
function schemaTypes(schema2, path) {
  assertSchema(schema2, path);
  let types = schema2.const === null ? ["null"] : [];
  if (schema2.type) {
    types = Array.isArray(schema2.type) ? schema2.type : [schema2.type];
  }
  if (schema2.anyOf) {
    types = schema2.anyOf.flatMap((s3) => schemaTypes(s3, path));
  }
  if (types.includes("array") && schema2.uniqueItems) {
    const i2 = types.findIndex((t2) => t2 != "array");
    types[i2] = "set";
  } else if (schema2.format && conversionFormatTypes.includes(schema2.format)) {
    types.unshift(schema2.format);
    if (schema2.format == "unix-time") {
      const i2 = types.findIndex((t2) => t2 == "integer");
      types.splice(i2, 1);
    }
  }
  if (schema2.const && schema2.const !== null && typeof schema2.const !== "function") {
    types.push(typeof schema2.const);
  }
  return Array.from(new Set(types));
}
__name(schemaTypes, "schemaTypes");
function unionInfo(schema2) {
  if (!schema2.anyOf || !schema2.anyOf.length)
    return void 0;
  return schema2.anyOf.filter((s3) => typeof s3 !== "boolean");
}
__name(unionInfo, "unionInfo");
function defaultValues(schema2, isOptional = false, path = []) {
  return _defaultValues(schema2, isOptional, path);
}
__name(defaultValues, "defaultValues");
function _defaultValues(schema2, isOptional, path) {
  if (!schema2) {
    throw new SchemaError("Schema was undefined", path);
  }
  const info = schemaInfo(schema2, isOptional, path);
  if (!info)
    return void 0;
  let objectDefaults = void 0;
  if ("default" in schema2) {
    if (info.types.includes("object") && schema2.default && typeof schema2.default == "object" && !Array.isArray(schema2.default)) {
      objectDefaults = schema2.default;
    } else {
      if (info.types.length > 1) {
        if (info.types.includes("unix-time") && (info.types.includes("integer") || info.types.includes("number")))
          throw new SchemaError("Cannot resolve a default value with a union that includes a date and a number/integer.", path);
      }
      const [type] = info.types;
      return formatDefaultValue(type, schema2.default);
    }
  }
  let _multiType;
  const isMultiTypeUnion = /* @__PURE__ */ __name(() => {
    if (!info.union || info.union.length < 2)
      return false;
    if (info.union.some((i2) => i2.enum))
      return true;
    if (!_multiType) {
      _multiType = new Set(info.types.map((i2) => {
        return ["integer", "unix-time"].includes(i2) ? "number" : i2;
      }));
    }
    return _multiType.size > 1;
  }, "isMultiTypeUnion");
  let output = {};
  if (!objectDefaults && info.union) {
    const singleDefault = info.union.filter((s3) => typeof s3 !== "boolean" && s3.default !== void 0);
    if (singleDefault.length == 1) {
      return _defaultValues(singleDefault[0], isOptional, path);
    } else if (singleDefault.length > 1) {
      throw new SchemaError("Only one default value can exist in a union, or set a default value for the whole union.", path);
    } else {
      if (info.isNullable)
        return null;
      if (info.isOptional)
        return void 0;
      if (isMultiTypeUnion()) {
        throw new SchemaError("Multi-type unions must have a default value, or exactly one of the union types must have.", path);
      }
      if (info.union.length && info.types[0] == "object") {
        output = info.union.length > 1 ? merge$1.withOptions({ allowUndefinedOverrides: true }, ...info.union.map((s3) => _defaultValues(s3, isOptional, path))) : _defaultValues(info.union[0], isOptional, path);
      }
    }
  }
  if (!objectDefaults) {
    if (info.isNullable)
      return null;
    if (info.isOptional)
      return void 0;
  }
  if (info.properties) {
    for (const [key2, objSchema] of Object.entries(info.properties)) {
      assertSchema(objSchema, [...path, key2]);
      const def = objectDefaults && objectDefaults[key2] !== void 0 ? objectDefaults[key2] : _defaultValues(objSchema, !info.required?.includes(key2), [...path, key2]);
      output[key2] = def;
    }
    return output;
  } else if (objectDefaults) {
    return objectDefaults;
  }
  if (schema2.enum) {
    return schema2.enum[0];
  }
  if (isMultiTypeUnion()) {
    throw new SchemaError("Default values cannot have more than one type.", path);
  } else if (info.types.length == 0) {
    return void 0;
  }
  const [formatType] = info.types;
  return defaultValue(formatType, schema2.enum);
}
__name(_defaultValues, "_defaultValues");
function formatDefaultValue(type, value) {
  switch (type) {
    case "set":
      return Array.isArray(value) ? new Set(value) : value;
    case "Date":
    case "date":
    case "unix-time":
      if (typeof value === "string" || typeof value === "number")
        return new Date(value);
      break;
    case "bigint":
      if (typeof value === "string" || typeof value === "number")
        return BigInt(value);
      break;
    case "symbol":
      if (typeof value === "string" || typeof value === "number")
        return Symbol(value);
      break;
  }
  return value;
}
__name(formatDefaultValue, "formatDefaultValue");
function defaultValue(type, enumType2) {
  switch (type) {
    case "string":
      return enumType2 && enumType2.length > 0 ? enumType2[0] : "";
    case "number":
    case "integer":
      return enumType2 && enumType2.length > 0 ? enumType2[0] : 0;
    case "boolean":
      return false;
    case "array":
      return [];
    case "object":
      return {};
    case "null":
      return null;
    case "Date":
    case "date":
    case "unix-time":
      return void 0;
    case "bigint":
      return BigInt(0);
    case "set":
      return /* @__PURE__ */ new Set();
    case "symbol":
      return Symbol();
    case "undefined":
    case "any":
      return void 0;
    default:
      throw new SchemaError("Schema type or format not supported, requires explicit default value: " + type);
  }
}
__name(defaultValue, "defaultValue");
function defaultTypes(schema2, path = []) {
  return _defaultTypes(schema2, false, path);
}
__name(defaultTypes, "defaultTypes");
function _defaultTypes(schema2, isOptional, path) {
  if (!schema2) {
    throw new SchemaError("Schema was undefined", path);
  }
  const info = schemaInfo(schema2, isOptional, path);
  const output = {
    __types: info.types
  };
  if (info.schema.items && typeof info.schema.items == "object" && !Array.isArray(info.schema.items)) {
    output.__items = _defaultTypes(info.schema.items, info.isOptional, path);
  }
  if (info.properties) {
    for (const [key2, value] of Object.entries(info.properties)) {
      assertSchema(value, [...path, key2]);
      output[key2] = _defaultTypes(info.properties[key2], !info.required?.includes(key2), [
        ...path,
        key2
      ]);
    }
  }
  if (info.additionalProperties && info.types.includes("object")) {
    const additionalInfo = schemaInfo(info.additionalProperties, info.isOptional, path);
    if (additionalInfo.properties && additionalInfo.types.includes("object")) {
      for (const [key2] of Object.entries(additionalInfo.properties)) {
        output[key2] = _defaultTypes(additionalInfo.properties[key2], !additionalInfo.required?.includes(key2), [...path, key2]);
      }
    }
  }
  if (info.isNullable && !output.__types.includes("null")) {
    output.__types.push("null");
  }
  if (info.isOptional && !output.__types.includes("undefined")) {
    output.__types.push("undefined");
  }
  return output;
}
__name(_defaultTypes, "_defaultTypes");
function mapErrors(errors, shape) {
  const output = {};
  function addFormLevelError(error2) {
    if (!("_errors" in output))
      output._errors = [];
    if (!Array.isArray(output._errors)) {
      if (typeof output._errors === "string")
        output._errors = [output._errors];
      else
        throw new SuperFormError("Form-level error was not an array.");
    }
    output._errors.push(error2.message);
  }
  __name(addFormLevelError, "addFormLevelError");
  for (const error2 of errors) {
    if (!error2.path || error2.path.length == 1 && !error2.path[0]) {
      addFormLevelError(error2);
      continue;
    }
    const isLastIndexNumeric = /^\d$/.test(String(error2.path[error2.path.length - 1]));
    const objectError = !isLastIndexNumeric && pathExists(shape, error2.path.filter((p2) => /\D/.test(String(p2))))?.value;
    const leaf = traversePath(output, error2.path, ({ value, parent: parent2, key: key22 }) => {
      if (value === void 0)
        parent2[key22] = {};
      return parent2[key22];
    });
    if (!leaf) {
      addFormLevelError(error2);
      continue;
    }
    const { parent, key: key2 } = leaf;
    if (objectError) {
      if (!(key2 in parent))
        parent[key2] = {};
      if (!("_errors" in parent[key2]))
        parent[key2]._errors = [error2.message];
      else
        parent[key2]._errors.push(error2.message);
    } else {
      if (!(key2 in parent))
        parent[key2] = [error2.message];
      else
        parent[key2].push(error2.message);
    }
  }
  return output;
}
__name(mapErrors, "mapErrors");
function updateErrors(New, Previous, force) {
  if (force)
    return New;
  traversePaths(Previous, (errors) => {
    if (!Array.isArray(errors.value))
      return;
    errors.set(void 0);
  });
  traversePaths(New, (error2) => {
    if (!Array.isArray(error2.value) && error2.value !== void 0)
      return;
    setPaths(Previous, [error2.path], error2.value);
  });
  return Previous;
}
__name(updateErrors, "updateErrors");
function flattenErrors(errors) {
  return _flattenErrors(errors, []);
}
__name(flattenErrors, "flattenErrors");
function _flattenErrors(errors, path) {
  const entries = Object.entries(errors);
  return entries.filter(([, value]) => value !== void 0).flatMap(([key2, messages]) => {
    if (Array.isArray(messages) && messages.length > 0) {
      const currPath = path.concat([key2]);
      return { path: mergePath(currPath), messages };
    } else {
      return _flattenErrors(errors[key2], path.concat([key2]));
    }
  });
}
__name(_flattenErrors, "_flattenErrors");
function mergeDefaults(parsedData, defaults6) {
  if (!parsedData)
    return clone$1(defaults6);
  return merge$1.withOptions({ mergeArrays: false }, defaults6, parsedData);
}
__name(mergeDefaults, "mergeDefaults");
function replaceInvalidDefaults(Data, Defaults, _schema, Errors, preprocessed) {
  const defaultType = _schema.additionalProperties && typeof _schema.additionalProperties == "object" ? { __types: schemaInfo(_schema.additionalProperties, false, []).types } : void 0;
  const Types = defaultTypes(_schema);
  function Types_correctValue(dataValue, defValue, type) {
    const types = type.__types;
    if (!types.length || types.every((t2) => t2 == "undefined" || t2 == "null" || t2 == "any")) {
      return dataValue;
    } else if (types.length == 1 && types[0] == "array" && !type.__items) {
      return dataValue;
    }
    const dateTypes = ["unix-time", "Date", "date"];
    for (const schemaType of types) {
      const defaultTypeValue = defaultValue(schemaType, void 0);
      const sameType = typeof dataValue === typeof defaultTypeValue || dateTypes.includes(schemaType) && dataValue instanceof Date;
      const sameExistance = sameType && dataValue === null === (defaultTypeValue === null);
      if (sameType && sameExistance) {
        return dataValue;
      } else if (type.__items) {
        return Types_correctValue(dataValue, defValue, type.__items);
      }
    }
    if (defValue === void 0 && types.includes("null")) {
      return null;
    }
    return defValue;
  }
  __name(Types_correctValue, "Types_correctValue");
  function Data_traverse() {
    traversePaths(Defaults, Defaults_traverseAndReplace);
    Errors_traverseAndReplace();
    return Data;
  }
  __name(Data_traverse, "Data_traverse");
  function Data_setValue(currentPath, newValue) {
    setPaths(Data, [currentPath], newValue);
  }
  __name(Data_setValue, "Data_setValue");
  function Errors_traverseAndReplace() {
    for (const error2 of Errors) {
      if (!error2.path)
        continue;
      Defaults_traverseAndReplace({
        path: error2.path,
        value: pathExists(Defaults, error2.path)?.value
      });
    }
  }
  __name(Errors_traverseAndReplace, "Errors_traverseAndReplace");
  function Defaults_traverseAndReplace(defaultPath) {
    const currentPath = defaultPath.path;
    if (!currentPath || !currentPath[0])
      return;
    if (typeof currentPath[0] === "string" && preprocessed?.includes(currentPath[0]))
      return;
    const dataPath = pathExists(Data, currentPath);
    if (!dataPath && defaultPath.value !== void 0 || dataPath && dataPath.value === void 0) {
      Data_setValue(currentPath, defaultPath.value);
    } else if (dataPath) {
      const defValue = defaultPath.value;
      const dataValue = dataPath.value;
      if (defValue !== void 0 && typeof dataValue === typeof defValue && dataValue === null === (defValue === null)) {
        return;
      }
      const typePath = currentPath.filter((p2) => /\D/.test(String(p2)));
      const pathTypes = traversePath(Types, typePath, (path) => {
        return "__items" in path.value ? path.value.__items : path.value;
      });
      if (!pathTypes) {
        throw new SchemaError("No types found for defaults", currentPath);
      }
      const fieldType = pathTypes.value ?? defaultType;
      if (!fieldType) {
        throw new SchemaError("No default value specified for field (can be undefined, but must be explicit)", currentPath);
      }
      Data_setValue(currentPath, Types_correctValue(dataValue, defValue, fieldType));
    }
  }
  __name(Defaults_traverseAndReplace, "Defaults_traverseAndReplace");
  {
    return Data_traverse();
  }
}
__name(replaceInvalidDefaults, "replaceInvalidDefaults");
function cancelFlash(options2) {
  if (!options2.flashMessage || !browser)
    return;
  if (!shouldSyncFlash(options2))
    return;
  document.cookie = `flash=; Max-Age=0; Path=${options2.flashMessage.cookiePath ?? "/"};`;
}
__name(cancelFlash, "cancelFlash");
function shouldSyncFlash(options2) {
  if (!options2.flashMessage || !browser)
    return false;
  return options2.syncFlashMessage;
}
__name(shouldSyncFlash, "shouldSyncFlash");
function deserialize(result) {
  const parsed = JSON.parse(result);
  if (parsed.data) {
    parsed.data = parse2(parsed.data);
  }
  return parsed;
}
__name(deserialize, "deserialize");
function clone(element2) {
  return (
    /** @type {T} */
    HTMLElement.prototype.cloneNode.call(element2)
  );
}
__name(clone, "clone");
function enhance(form_element, submit = () => {
}) {
  const fallback_callback = /* @__PURE__ */ __name(async ({
    action,
    result,
    reset: reset3 = true,
    invalidateAll: shouldInvalidateAll = true
  }) => {
    if (result.type === "success") {
      if (reset3) {
        HTMLFormElement.prototype.reset.call(form_element);
      }
      if (shouldInvalidateAll) {
        await invalidateAll();
      }
    }
    if (location.origin + location.pathname === action.origin + action.pathname || result.type === "redirect" || result.type === "error") {
      applyAction();
    }
  }, "fallback_callback");
  async function handle_submit(event) {
    const method = event.submitter?.hasAttribute("formmethod") ? (
      /** @type {HTMLButtonElement | HTMLInputElement} */
      event.submitter.formMethod
    ) : clone(form_element).method;
    if (method !== "post")
      return;
    event.preventDefault();
    const action = new URL(
      // We can't do submitter.formAction directly because that property is always set
      event.submitter?.hasAttribute("formaction") ? (
        /** @type {HTMLButtonElement | HTMLInputElement} */
        event.submitter.formAction
      ) : clone(form_element).action
    );
    const enctype = event.submitter?.hasAttribute("formenctype") ? (
      /** @type {HTMLButtonElement | HTMLInputElement} */
      event.submitter.formEnctype
    ) : clone(form_element).enctype;
    const form_data = new FormData(form_element);
    const submitter_name = event.submitter?.getAttribute("name");
    if (submitter_name) {
      form_data.append(submitter_name, event.submitter?.getAttribute("value") ?? "");
    }
    const controller = new AbortController();
    let cancelled = false;
    const cancel = /* @__PURE__ */ __name(() => cancelled = true, "cancel");
    const callback = await submit({
      action,
      cancel,
      controller,
      formData: form_data,
      formElement: form_element,
      submitter: event.submitter
    }) ?? fallback_callback;
    if (cancelled)
      return;
    let result;
    try {
      const headers2 = new Headers({
        accept: "application/json",
        "x-sveltekit-action": "true"
      });
      if (enctype !== "multipart/form-data") {
        headers2.set(
          "Content-Type",
          /^(:?application\/x-www-form-urlencoded|text\/plain)$/.test(enctype) ? enctype : "application/x-www-form-urlencoded"
        );
      }
      const body2 = enctype === "multipart/form-data" ? form_data : new URLSearchParams(form_data);
      const response = await fetch(action, {
        method: "POST",
        headers: headers2,
        cache: "no-store",
        body: body2,
        signal: controller.signal
      });
      result = deserialize(await response.text());
      if (result.type === "error")
        result.status = response.status;
    } catch (error2) {
      if (
        /** @type {any} */
        error2?.name === "AbortError"
      )
        return;
      result = { type: "error", error: error2 };
    }
    callback({
      action,
      formData: form_data,
      formElement: form_element,
      update: (opts) => fallback_callback({
        action,
        result,
        reset: opts?.reset,
        invalidateAll: opts?.invalidateAll
      }),
      // @ts-expect-error generic constraints stuff we don't care about
      result
    });
  }
  __name(handle_submit, "handle_submit");
  HTMLFormElement.prototype.addEventListener.call(form_element, "submit", handle_submit);
  return {
    destroy() {
      HTMLFormElement.prototype.removeEventListener.call(form_element, "submit", handle_submit);
    }
  };
}
__name(enhance, "enhance");
async function updateCustomValidity(validityEl, errors) {
  if ("setCustomValidity" in validityEl) {
    validityEl.setCustomValidity("");
  }
  if (noCustomValidityDataAttribute in validityEl.dataset)
    return;
  setCustomValidity(validityEl, errors);
}
__name(updateCustomValidity, "updateCustomValidity");
function setCustomValidityForm(formElement, errors) {
  for (const el of formElement.querySelectorAll("input,select,textarea,button")) {
    if ("dataset" in el && noCustomValidityDataAttribute in el.dataset || !el.name) {
      continue;
    }
    const path = traversePath(errors, splitPath(el.name));
    const error2 = path && typeof path.value === "object" && "_errors" in path.value ? path.value._errors : path?.value;
    setCustomValidity(el, error2);
    if (error2)
      return;
  }
}
__name(setCustomValidityForm, "setCustomValidityForm");
function setCustomValidity(el, errors) {
  const message = errors && errors.length ? errors.join("\n") : "";
  el.setCustomValidity(message);
  if (message)
    el.reportValidity();
}
__name(setCustomValidity, "setCustomValidity");
function inputInfo(el) {
  const immediate = !!el && (el instanceof HTMLSelectElement || el instanceof HTMLInputElement && immediateInputTypes.includes(el.type));
  const multiple = !!el && el instanceof HTMLSelectElement && el.multiple;
  const file = !!el && el instanceof HTMLInputElement && el.type == "file";
  return { immediate, multiple, file };
}
__name(inputInfo, "inputInfo");
function Form(formElement, timers, options2) {
  let state = FetchStatus.Idle;
  let delayedTimeout, timeoutTimeout;
  const Timers = activeTimers;
  function Timers_start() {
    Timers_clear();
    Timers_setState(state != FetchStatus.Delayed ? FetchStatus.Submitting : FetchStatus.Delayed);
    delayedTimeout = window.setTimeout(() => {
      if (delayedTimeout && state == FetchStatus.Submitting)
        Timers_setState(FetchStatus.Delayed);
    }, options2.delayMs);
    timeoutTimeout = window.setTimeout(() => {
      if (timeoutTimeout && state == FetchStatus.Delayed)
        Timers_setState(FetchStatus.Timeout);
    }, options2.timeoutMs);
    Timers.add(Timers_clear);
  }
  __name(Timers_start, "Timers_start");
  function Timers_clear() {
    clearTimeout(delayedTimeout);
    clearTimeout(timeoutTimeout);
    delayedTimeout = timeoutTimeout = 0;
    Timers.delete(Timers_clear);
    Timers_setState(FetchStatus.Idle);
  }
  __name(Timers_clear, "Timers_clear");
  function Timers_clearAll() {
    Timers.forEach((t2) => t2());
    Timers.clear();
  }
  __name(Timers_clearAll, "Timers_clearAll");
  function Timers_setState(s3) {
    state = s3;
    timers.submitting.set(state >= FetchStatus.Submitting);
    timers.delayed.set(state >= FetchStatus.Delayed);
    timers.timeout.set(state >= FetchStatus.Timeout);
  }
  __name(Timers_setState, "Timers_setState");
  const ErrorTextEvents = formElement;
  function ErrorTextEvents__selectText(e3) {
    const target = e3.target;
    if (options2.selectErrorText)
      target.select();
  }
  __name(ErrorTextEvents__selectText, "ErrorTextEvents__selectText");
  function ErrorTextEvents_addErrorTextListeners() {
    if (!options2.selectErrorText)
      return;
    ErrorTextEvents.querySelectorAll("input").forEach((el) => {
      el.addEventListener("invalid", ErrorTextEvents__selectText);
    });
  }
  __name(ErrorTextEvents_addErrorTextListeners, "ErrorTextEvents_addErrorTextListeners");
  function ErrorTextEvents_removeErrorTextListeners() {
    if (!options2.selectErrorText)
      return;
    ErrorTextEvents.querySelectorAll("input").forEach((el) => el.removeEventListener("invalid", ErrorTextEvents__selectText));
  }
  __name(ErrorTextEvents_removeErrorTextListeners, "ErrorTextEvents_removeErrorTextListeners");
  const Form2 = formElement;
  {
    ErrorTextEvents_addErrorTextListeners();
    const completed = /* @__PURE__ */ __name((opts) => {
      if (!opts.clearAll)
        Timers_clear();
      else
        Timers_clearAll();
      if (!opts.cancelled)
        setTimeout(() => scrollToFirstError(Form2, options2), 1);
    }, "completed");
    onDestroy(() => {
      ErrorTextEvents_removeErrorTextListeners();
      completed({ cancelled: true });
    });
    return {
      submitting() {
        Timers_start();
      },
      completed,
      scrollToFirstError() {
        setTimeout(() => scrollToFirstError(Form2, options2), 1);
      },
      isSubmitting: () => state === FetchStatus.Submitting || state === FetchStatus.Delayed
    };
  }
}
__name(Form, "Form");
function updateProxyField(obj, path, updater) {
  const output = traversePath(obj, path, ({ parent, key: key2, value }) => {
    if (value === void 0)
      parent[key2] = /\D/.test(key2) ? {} : [];
    return parent[key2];
  });
  if (output) {
    const newValue = updater(output.value);
    output.parent[output.key] = newValue;
  }
  return obj;
}
__name(updateProxyField, "updateProxyField");
function superFieldProxy(superForm2, path, baseOptions) {
  const form = superForm2.form;
  const path2 = splitPath(path);
  const proxy = derived(form, ($form) => {
    const data = traversePath($form, path2);
    return data?.value;
  });
  return {
    subscribe(...params) {
      const unsub = proxy.subscribe(...params);
      return () => unsub();
    },
    update(upd, options2) {
      form.update((data) => updateProxyField(data, path2, upd), options2 ?? baseOptions);
    },
    set(value, options2) {
      form.update((data) => updateProxyField(data, path2, () => value), options2 ?? baseOptions);
    }
  };
}
__name(superFieldProxy, "superFieldProxy");
function isSuperForm(form, options2) {
  const isSuperForm2 = "form" in form;
  if (!isSuperForm2 && options2?.taint !== void 0) {
    throw new SuperFormError("If options.taint is set, the whole superForm object must be used as a proxy.");
  }
  return isSuperForm2;
}
__name(isSuperForm, "isSuperForm");
function fieldProxy(form, path, options2) {
  const path2 = splitPath(path);
  if (isSuperForm(form, options2)) {
    return superFieldProxy(form, path, options2);
  }
  const proxy = derived(form, ($form) => {
    const data = traversePath($form, path2);
    return data?.value;
  });
  return {
    subscribe(...params) {
      const unsub = proxy.subscribe(...params);
      return () => unsub();
    },
    update(upd) {
      form.update((data) => updateProxyField(data, path2, upd));
    },
    set(value) {
      form.update((data) => updateProxyField(data, path2, () => value));
    }
  };
}
__name(fieldProxy, "fieldProxy");
function schemaShape(schema2, path = []) {
  const output = _schemaShape(schema2, path);
  if (!output)
    throw new SchemaError("No shape could be created for schema.", path);
  return output;
}
__name(schemaShape, "schemaShape");
function _schemaShape(schema2, path) {
  assertSchema(schema2, path);
  const info = schemaInfo(schema2, false, path);
  if (info.array || info.union) {
    const arr = info.array || [];
    const union2 = info.union || [];
    return arr.concat(union2).reduce((shape, next2) => {
      const nextShape = _schemaShape(next2, path);
      if (nextShape)
        shape = { ...shape ?? {}, ...nextShape };
      return shape;
    }, arr.length ? {} : void 0);
  }
  if (info.properties) {
    const output = {};
    for (const [key2, prop] of Object.entries(info.properties)) {
      const shape = _schemaShape(prop, [...path, key2]);
      if (shape)
        output[key2] = shape;
    }
    return output;
  }
  return info.types.includes("array") || info.types.includes("object") ? {} : void 0;
}
__name(_schemaShape, "_schemaShape");
function shapeFromObject(obj) {
  let output = {};
  const isArray = Array.isArray(obj);
  for (const [key2, value] of Object.entries(obj)) {
    if (!value || typeof value !== "object")
      continue;
    if (isArray)
      output = { ...output, ...shapeFromObject(value) };
    else
      output[key2] = shapeFromObject(value);
  }
  return output;
}
__name(shapeFromObject, "shapeFromObject");
function superForm(form, formOptions) {
  let initialForm;
  let options2 = formOptions ?? {};
  let initialValidator = void 0;
  {
    if (options2.legacy ?? LEGACY_MODE) {
      if (options2.resetForm === void 0)
        options2.resetForm = false;
      if (options2.taintedMessage === void 0)
        options2.taintedMessage = true;
    }
    if (STORYBOOK_MODE) {
      if (options2.applyAction === void 0)
        options2.applyAction = false;
    }
    if (typeof options2.SPA === "string") {
      if (options2.invalidateAll === void 0)
        options2.invalidateAll = false;
      if (options2.applyAction === void 0)
        options2.applyAction = false;
    }
    initialValidator = options2.validators;
    options2 = {
      ...defaultFormOptions,
      ...options2
    };
    if ((options2.SPA === true || typeof options2.SPA === "object") && options2.validators === void 0) {
      console.warn("No validators set for superForm in SPA mode. Add a validation adapter to the validators option, or set it to false to disable this warning.");
    }
    if (!form) {
      throw new SuperFormError("No form data sent to superForm. Make sure the output from superValidate is used (usually data.form) and that it's not null or undefined. Alternatively, an object with default values for the form can also be used, but then constraints won't be available.");
    }
    if (Context_isValidationObject(form) === false) {
      form = {
        id: options2.id ?? Math.random().toString(36).slice(2, 10),
        valid: false,
        posted: false,
        errors: {},
        data: form,
        shape: shapeFromObject(form)
      };
    }
    form = form;
    const _initialFormId = form.id = options2.id ?? form.id;
    const _currentPage = get2(page) ?? (STORYBOOK_MODE ? {} : void 0);
    if (!initialForms.has(form)) {
      initialForms.set(form, form);
    }
    initialForm = initialForms.get(form);
    if (_currentPage.form && typeof _currentPage.form === "object") {
      const postedData = _currentPage.form;
      for (const postedForm of Context_findValidationForms(postedData).reverse()) {
        if (postedForm.id == _initialFormId && !initialForms.has(postedForm)) {
          initialForms.set(postedData, postedData);
          const pageDataForm = form;
          form = postedForm;
          form.constraints = pageDataForm.constraints;
          form.shape = pageDataForm.shape;
          if (form.valid && options2.resetForm && (options2.resetForm === true || options2.resetForm())) {
            form = clone$1(pageDataForm);
            form.message = clone$1(postedForm.message);
          }
          break;
        }
      }
    } else {
      form = clone$1(initialForm);
    }
    onDestroy(() => {
      Unsubscriptions_unsubscribe();
      NextChange_clear();
      EnhancedForm_destroy();
      for (const events of Object.values(formEvents)) {
        events.length = 0;
      }
      formIds.get(_currentPage)?.delete(_initialFormId);
    });
    if (options2.dataType !== "json") {
      const checkForNestedData = /* @__PURE__ */ __name((key2, value) => {
        if (!value || typeof value !== "object")
          return;
        if (Array.isArray(value)) {
          if (value.length > 0)
            checkForNestedData(key2, value[0]);
        } else if (!(value instanceof Date) && !(value instanceof File) && !browser) {
          throw new SuperFormError(`Object found in form field "${key2}". Set the dataType option to "json" and add use:enhance to use nested data structures. More information: https://superforms.rocks/concepts/nested-data`);
        }
      }, "checkForNestedData");
      for (const [key2, value] of Object.entries(form.data)) {
        checkForNestedData(key2, value);
      }
    }
  }
  const __data = {
    formId: form.id,
    form: clone$1(form.data),
    constraints: form.constraints ?? {},
    posted: form.posted,
    errors: clone$1(form.errors),
    message: clone$1(form.message),
    tainted: void 0,
    valid: form.valid,
    submitting: false,
    shape: form.shape
  };
  const Data = __data;
  const FormId = writable(options2.id ?? form.id);
  function Context_findValidationForms(data) {
    const forms = Object.values(data).filter((v2) => Context_isValidationObject(v2) !== false);
    return forms;
  }
  __name(Context_findValidationForms, "Context_findValidationForms");
  function Context_isValidationObject(object) {
    if (!object || typeof object !== "object")
      return false;
    if (!("valid" in object && "errors" in object && typeof object.valid === "boolean")) {
      return false;
    }
    return "id" in object && typeof object.id === "string" ? object.id : false;
  }
  __name(Context_isValidationObject, "Context_isValidationObject");
  const _formData = writable(form.data);
  const Form$1 = {
    subscribe: _formData.subscribe,
    set: (value, options22 = {}) => {
      const newData = clone$1(value);
      Tainted_update(newData, options22.taint ?? true);
      return _formData.set(newData);
    },
    update: (updater, options22 = {}) => {
      return _formData.update((value) => {
        const newData = updater(value);
        Tainted_update(newData, options22.taint ?? true);
        return newData;
      });
    }
  };
  function Form_isSPA() {
    return options2.SPA === true || typeof options2.SPA === "object";
  }
  __name(Form_isSPA, "Form_isSPA");
  function Form_resultStatus(defaultStatus) {
    if (defaultStatus > 400)
      return defaultStatus;
    return (typeof options2.SPA === "boolean" || typeof options2.SPA === "string" ? void 0 : options2.SPA?.failStatus) || defaultStatus;
  }
  __name(Form_resultStatus, "Form_resultStatus");
  async function Form_validate(opts = {}) {
    const dataToValidate = opts.formData ?? Data.form;
    let errors = {};
    let status;
    const validator2 = opts.adapter ?? options2.validators;
    if (typeof validator2 == "object") {
      if (validator2 != initialValidator && !("jsonSchema" in validator2)) {
        throw new SuperFormError('Client validation adapter found in options.validators. A full adapter must be used when changing validators dynamically, for example "zod" instead of "zodClient".');
      }
      status = await /* @__PURE__ */ validator2.validate(dataToValidate);
      if (!status.success) {
        errors = mapErrors(status.issues, validator2.shape ?? Data.shape ?? {});
      } else if (opts.recheckValidData !== false) {
        return Form_validate({ ...opts, recheckValidData: false });
      }
    } else {
      status = { success: true, data: {} };
    }
    const data = { ...Data.form, ...dataToValidate, ...status.success ? status.data : {} };
    return {
      valid: status.success,
      posted: false,
      errors,
      data,
      constraints: Data.constraints,
      message: void 0,
      id: Data.formId,
      shape: Data.shape
    };
  }
  __name(Form_validate, "Form_validate");
  function Form__changeEvent(event) {
    if (!options2.onChange || !event.paths.length || event.type == "blur")
      return;
    let changeEvent;
    const paths = event.paths.map(mergePath);
    if (event.type && event.paths.length == 1 && event.formElement && event.target instanceof Element) {
      changeEvent = {
        path: paths[0],
        paths,
        formElement: event.formElement,
        target: event.target,
        set(path, value, options22) {
          fieldProxy({ form: Form$1 }, path, options22).set(value);
        },
        get(path) {
          return get2(fieldProxy(Form$1, path));
        }
      };
    } else {
      changeEvent = {
        paths,
        target: void 0,
        set(path, value, options22) {
          fieldProxy({ form: Form$1 }, path, options22).set(value);
        },
        get(path) {
          return get2(fieldProxy(Form$1, path));
        }
      };
    }
    options2.onChange(changeEvent);
  }
  __name(Form__changeEvent, "Form__changeEvent");
  async function Form_clientValidation(event, force = false, adapter) {
    if (event) {
      if (options2.validators == "clear") {
        Errors.update(($errors) => {
          setPaths($errors, event.paths, void 0);
          return $errors;
        });
      }
      setTimeout(() => Form__changeEvent(event));
    }
    let skipValidation = false;
    if (!force) {
      if (options2.validationMethod == "onsubmit" || options2.validationMethod == "submit-only") {
        skipValidation = true;
      } else if (options2.validationMethod == "onblur" && event?.type == "input")
        skipValidation = true;
      else if (options2.validationMethod == "oninput" && event?.type == "blur")
        skipValidation = true;
    }
    if (skipValidation || !event || !options2.validators || options2.validators == "clear") {
      if (event?.paths) {
        const formElement = event?.formElement ?? EnhancedForm_get();
        if (formElement)
          Form__clearCustomValidity(formElement);
      }
      return;
    }
    const result = await Form_validate({ adapter });
    if (result.valid && (event.immediate || event.type != "input")) {
      Form$1.set(result.data, { taint: "ignore" });
    }
    await tick();
    Form__displayNewErrors(result.errors, event, force);
    return result;
  }
  __name(Form_clientValidation, "Form_clientValidation");
  function Form__clearCustomValidity(formElement) {
    const validity = /* @__PURE__ */ new Map();
    if (options2.customValidity && formElement) {
      for (const el of formElement.querySelectorAll(`[name]`)) {
        if (typeof el.name !== "string" || !el.name.length)
          continue;
        const message = "validationMessage" in el ? String(el.validationMessage) : "";
        validity.set(el.name, { el, message });
        updateCustomValidity(el, void 0);
      }
    }
    return validity;
  }
  __name(Form__clearCustomValidity, "Form__clearCustomValidity");
  async function Form__displayNewErrors(errors, event, force) {
    const { type, immediate, multiple, paths } = event;
    const previous = Data.errors;
    const output = {};
    let validity = /* @__PURE__ */ new Map();
    const formElement = event.formElement ?? EnhancedForm_get();
    if (formElement)
      validity = Form__clearCustomValidity(formElement);
    traversePaths(errors, (error2) => {
      if (!Array.isArray(error2.value))
        return;
      const currentPath = [...error2.path];
      if (currentPath[currentPath.length - 1] == "_errors") {
        currentPath.pop();
      }
      const joinedPath = currentPath.join(".");
      function addError() {
        setPaths(output, [error2.path], error2.value);
        if (options2.customValidity && isEventError && validity.has(joinedPath)) {
          const { el, message } = validity.get(joinedPath);
          if (message != error2.value) {
            setTimeout(() => updateCustomValidity(el, error2.value));
            validity.clear();
          }
        }
      }
      __name(addError, "addError");
      if (force)
        return addError();
      const lastPath = error2.path[error2.path.length - 1];
      const isObjectError = lastPath == "_errors";
      const isEventError = error2.value && paths.some((path) => {
        return isObjectError ? currentPath && path && currentPath.length > 0 && currentPath[0] == path[0] : joinedPath == path.join(".");
      });
      if (isEventError && options2.validationMethod == "oninput")
        return addError();
      if (immediate && !multiple && isEventError)
        return addError();
      if (multiple) {
        const errorPath = pathExists(get2(Errors), error2.path.slice(0, -1));
        if (errorPath?.value && typeof errorPath?.value == "object") {
          for (const errors2 of Object.values(errorPath.value)) {
            if (Array.isArray(errors2)) {
              return addError();
            }
          }
        }
      }
      const previousError = pathExists(previous, error2.path);
      if (previousError && previousError.key in previousError.parent) {
        return addError();
      }
      if (isObjectError) {
        if (options2.validationMethod == "oninput" || type == "blur" && Tainted_hasBeenTainted(mergePath(error2.path.slice(0, -1)))) {
          return addError();
        }
      } else {
        if (type == "blur" && isEventError) {
          return addError();
        }
      }
    });
    Errors.set(output);
  }
  __name(Form__displayNewErrors, "Form__displayNewErrors");
  function Form_set(data, options22 = {}) {
    if (options22.keepFiles) {
      traversePaths(Data.form, (info) => {
        if (info.value instanceof File || browser) {
          const dataPath = pathExists(data, info.path);
          if (!dataPath || !(dataPath.key in dataPath.parent)) {
            setPaths(data, [info.path], info.value);
          }
        }
      });
    }
    return Form$1.set(data, options22);
  }
  __name(Form_set, "Form_set");
  function Form_shouldReset(validForm, successActionResult) {
    return validForm && successActionResult && options2.resetForm && (options2.resetForm === true || options2.resetForm());
  }
  __name(Form_shouldReset, "Form_shouldReset");
  function Form_capture(removeFilesfromData = true) {
    let data = Data.form;
    let tainted = Data.tainted;
    if (removeFilesfromData) {
      const removed = removeFiles(Data.form);
      data = removed.data;
      const paths = removed.paths;
      if (paths.length) {
        tainted = clone$1(tainted) ?? {};
        setPaths(tainted, paths, false);
      }
    }
    return {
      valid: Data.valid,
      posted: Data.posted,
      errors: Data.errors,
      data,
      constraints: Data.constraints,
      message: Data.message,
      id: Data.formId,
      tainted,
      shape: Data.shape
    };
  }
  __name(Form_capture, "Form_capture");
  async function Form_updateFromValidation(form2, successResult) {
    if (form2.valid && successResult && Form_shouldReset(form2.valid, successResult)) {
      Form_reset({ message: form2.message, posted: true });
    } else {
      rebind({
        form: form2,
        untaint: successResult,
        keepFiles: true,
        // Check if the form data should be used for updating, or if the invalidateAll load function should be used:
        skipFormData: options2.invalidateAll == "force"
      });
    }
    if (formEvents.onUpdated.length) {
      await tick();
    }
    for (const event of formEvents.onUpdated) {
      event({ form: form2 });
    }
  }
  __name(Form_updateFromValidation, "Form_updateFromValidation");
  function Form_reset(opts = {}) {
    if (opts.newState)
      initialForm.data = { ...initialForm.data, ...opts.newState };
    const resetData = clone$1(initialForm);
    resetData.data = { ...resetData.data, ...opts.data };
    if (opts.id !== void 0)
      resetData.id = opts.id;
    rebind({
      form: resetData,
      untaint: true,
      message: opts.message,
      keepFiles: false,
      posted: opts.posted,
      resetted: true
    });
  }
  __name(Form_reset, "Form_reset");
  async function Form_updateFromActionResult(result) {
    if (result.type == "error") {
      throw new SuperFormError(`ActionResult of type "${result.type}" cannot be passed to update function.`);
    }
    if (result.type == "redirect") {
      if (Form_shouldReset(true, true))
        Form_reset({ posted: true });
      return;
    }
    if (typeof result.data !== "object") {
      throw new SuperFormError("Non-object validation data returned from ActionResult.");
    }
    const forms = Context_findValidationForms(result.data);
    if (!forms.length) {
      throw new SuperFormError("No form data returned from ActionResult. Make sure you return { form } in the form actions.");
    }
    for (const newForm of forms) {
      if (newForm.id !== Data.formId)
        continue;
      await Form_updateFromValidation(newForm, result.status >= 200 && result.status < 300);
    }
  }
  __name(Form_updateFromActionResult, "Form_updateFromActionResult");
  const Message = writable(__data.message);
  const Constraints = writable(__data.constraints);
  const Posted = writable(__data.posted);
  const Shape = writable(__data.shape);
  const _errors = writable(form.errors);
  const Errors = {
    subscribe: _errors.subscribe,
    set(value, options22) {
      return _errors.set(updateErrors(value, Data.errors, options22?.force));
    },
    update(updater, options22) {
      return _errors.update((value) => {
        return updateErrors(updater(value), Data.errors, options22?.force);
      });
    },
    /**
     * To work with client-side validation, errors cannot be deleted but must
     * be set to undefined, to know where they existed before (tainted+error check in oninput)
     */
    clear: () => Errors.set({})
  };
  let NextChange = null;
  function NextChange_setHtmlEvent(event) {
    if (NextChange && event && Object.keys(event).length == 1 && event.paths?.length && NextChange.target && NextChange.target instanceof HTMLInputElement && NextChange.target.type.toLowerCase() == "file") {
      NextChange.paths = event.paths;
    } else {
      NextChange = event;
    }
    setTimeout(() => {
      Form_clientValidation(NextChange);
    }, 0);
  }
  __name(NextChange_setHtmlEvent, "NextChange_setHtmlEvent");
  function NextChange_additionalEventInformation(event, immediate, multiple, formElement, target) {
    if (NextChange === null) {
      NextChange = { paths: [] };
    }
    NextChange.type = event;
    NextChange.immediate = immediate;
    NextChange.multiple = multiple;
    NextChange.formElement = formElement;
    NextChange.target = target;
  }
  __name(NextChange_additionalEventInformation, "NextChange_additionalEventInformation");
  function NextChange_paths() {
    return NextChange?.paths ?? [];
  }
  __name(NextChange_paths, "NextChange_paths");
  function NextChange_clear() {
    NextChange = null;
  }
  __name(NextChange_clear, "NextChange_clear");
  const Tainted = {
    defaultMessage: "Leave page? Changes that you made may not be saved.",
    state: writable(),
    message: options2.taintedMessage,
    clean: clone$1(form.data),
    // Important to clone form.data, so it's not comparing the same object,
    forceRedirection: false
  };
  function Tainted_enable() {
    options2.taintedMessage = Tainted.message;
  }
  __name(Tainted_enable, "Tainted_enable");
  function Tainted_currentState() {
    return Tainted.state;
  }
  __name(Tainted_currentState, "Tainted_currentState");
  function Tainted_hasBeenTainted(path) {
    if (!Data.tainted)
      return false;
    if (!path)
      return !!Data.tainted;
    const field = pathExists(Data.tainted, splitPath(path));
    return !!field && field.key in field.parent;
  }
  __name(Tainted_hasBeenTainted, "Tainted_hasBeenTainted");
  function Tainted_isTainted(path) {
    if (!arguments.length)
      return Tainted__isObjectTainted(Data.tainted);
    if (typeof path === "boolean")
      return path;
    if (typeof path === "object")
      return Tainted__isObjectTainted(path);
    if (!Data.tainted || path === void 0)
      return false;
    const field = pathExists(Data.tainted, splitPath(path));
    return Tainted__isObjectTainted(field?.value);
  }
  __name(Tainted_isTainted, "Tainted_isTainted");
  function Tainted__isObjectTainted(obj) {
    if (!obj)
      return false;
    if (typeof obj === "object") {
      for (const obj2 of Object.values(obj)) {
        if (Tainted__isObjectTainted(obj2))
          return true;
      }
    }
    return obj === true;
  }
  __name(Tainted__isObjectTainted, "Tainted__isObjectTainted");
  function Tainted_update(newData, taintOptions) {
    if (taintOptions == "ignore")
      return;
    const paths = comparePaths(newData, Data.form);
    const newTainted = comparePaths(newData, Tainted.clean).map((path) => path.join());
    if (paths.length) {
      if (taintOptions == "untaint-all" || taintOptions == "untaint-form") {
        Tainted.state.set(void 0);
      } else {
        Tainted.state.update((currentlyTainted) => {
          if (!currentlyTainted)
            currentlyTainted = {};
          setPaths(currentlyTainted, paths, (path, data) => {
            if (!newTainted.includes(path.join()))
              return void 0;
            const currentValue = traversePath(newData, path);
            const cleanPath = traversePath(Tainted.clean, path);
            return currentValue && cleanPath && currentValue.value === cleanPath.value ? void 0 : taintOptions === true ? true : taintOptions === "untaint" ? void 0 : data.value;
          });
          return currentlyTainted;
        });
      }
      NextChange_setHtmlEvent({ paths });
    }
  }
  __name(Tainted_update, "Tainted_update");
  function Tainted_set(tainted, newClean) {
    Tainted.state.set(tainted);
    if (newClean)
      Tainted.clean = newClean;
  }
  __name(Tainted_set, "Tainted_set");
  const Submitting = writable(false);
  const Delayed = writable(false);
  const Timeout = writable(false);
  const Unsubscriptions = [
    // eslint-disable-next-line dci-lint/private-role-access
    Tainted.state.subscribe((tainted) => __data.tainted = clone$1(tainted)),
    // eslint-disable-next-line dci-lint/private-role-access
    Form$1.subscribe((form2) => __data.form = clone$1(form2)),
    // eslint-disable-next-line dci-lint/private-role-access
    Errors.subscribe((errors) => __data.errors = clone$1(errors)),
    FormId.subscribe((id) => __data.formId = id),
    Constraints.subscribe((constraints2) => __data.constraints = constraints2),
    Posted.subscribe((posted) => __data.posted = posted),
    Message.subscribe((message) => __data.message = message),
    Submitting.subscribe((submitting) => __data.submitting = submitting),
    Shape.subscribe((shape) => __data.shape = shape)
  ];
  function Unsubscriptions_unsubscribe() {
    Unsubscriptions.forEach((unsub) => unsub());
  }
  __name(Unsubscriptions_unsubscribe, "Unsubscriptions_unsubscribe");
  let EnhancedForm;
  function EnhancedForm_get() {
    return EnhancedForm;
  }
  __name(EnhancedForm_get, "EnhancedForm_get");
  function EnhancedForm_setAction(action) {
    if (EnhancedForm)
      EnhancedForm.action = action;
  }
  __name(EnhancedForm_setAction, "EnhancedForm_setAction");
  function EnhancedForm_destroy() {
    if (EnhancedForm?.parentElement) {
      EnhancedForm.remove();
    }
    EnhancedForm = void 0;
  }
  __name(EnhancedForm_destroy, "EnhancedForm_destroy");
  const AllErrors = derived(Errors, ($errors) => $errors ? flattenErrors($errors) : []);
  options2.taintedMessage = void 0;
  function rebind(opts) {
    const form2 = opts.form;
    const message = opts.message ?? form2.message;
    if (opts.untaint || opts.resetted) {
      Tainted_set(typeof opts.untaint === "boolean" ? void 0 : opts.untaint, form2.data);
    }
    if (opts.skipFormData !== true) {
      Form_set(form2.data, {
        taint: "ignore",
        keepFiles: opts.keepFiles
      });
    }
    Message.set(message);
    if (opts.resetted)
      Errors.update(() => ({}), { force: true });
    else
      Errors.set(form2.errors);
    FormId.set(form2.id);
    Posted.set(opts.posted ?? form2.posted);
    if (form2.constraints)
      Constraints.set(form2.constraints);
    if (form2.shape)
      Shape.set(form2.shape);
    __data.valid = form2.valid;
    if (options2.flashMessage && shouldSyncFlash(options2)) {
      const flash = options2.flashMessage.module.getFlash(page);
      if (message && get2(flash) === void 0) {
        flash.set(message);
      }
    }
  }
  __name(rebind, "rebind");
  const formEvents = {
    onSubmit: options2.onSubmit ? [options2.onSubmit] : [],
    onResult: options2.onResult ? [options2.onResult] : [],
    onUpdate: options2.onUpdate ? [options2.onUpdate] : [],
    onUpdated: options2.onUpdated ? [options2.onUpdated] : [],
    onError: options2.onError ? [options2.onError] : []
  };
  function superFormEnhance(FormElement, events) {
    if (options2.SPA !== void 0 && FormElement.method == "get")
      FormElement.method = "post";
    if (typeof options2.SPA === "string") {
      if (options2.SPA.length && FormElement.action == document.location.href) {
        FormElement.action = options2.SPA;
      }
    } else {
      EnhancedForm = FormElement;
    }
    if (events) {
      if (events.onError) {
        if (options2.onError === "apply") {
          throw new SuperFormError('options.onError is set to "apply", cannot add any onError events.');
        } else if (events.onError === "apply") {
          throw new SuperFormError('Cannot add "apply" as onError event in use:enhance.');
        }
        formEvents.onError.push(events.onError);
      }
      if (events.onResult)
        formEvents.onResult.push(events.onResult);
      if (events.onSubmit)
        formEvents.onSubmit.push(events.onSubmit);
      if (events.onUpdate)
        formEvents.onUpdate.push(events.onUpdate);
      if (events.onUpdated)
        formEvents.onUpdated.push(events.onUpdated);
    }
    Tainted_enable();
    let lastInputChange;
    async function onInput(e3) {
      const info = inputInfo(e3.target);
      if (info.immediate && !info.file)
        await new Promise((r3) => setTimeout(r3, 0));
      lastInputChange = NextChange_paths();
      NextChange_additionalEventInformation("input", info.immediate, info.multiple, FormElement, e3.target ?? void 0);
    }
    __name(onInput, "onInput");
    async function onBlur(e3) {
      if (Data.submitting)
        return;
      if (!lastInputChange || NextChange_paths() != lastInputChange) {
        return;
      }
      const info = inputInfo(e3.target);
      if (info.immediate && !info.file)
        await new Promise((r3) => setTimeout(r3, 0));
      Form_clientValidation({
        paths: lastInputChange,
        immediate: info.multiple,
        multiple: info.multiple,
        type: "blur",
        formElement: FormElement,
        target: e3.target ?? void 0
      });
      lastInputChange = void 0;
    }
    __name(onBlur, "onBlur");
    FormElement.addEventListener("focusout", onBlur);
    FormElement.addEventListener("input", onInput);
    onDestroy(() => {
      FormElement.removeEventListener("focusout", onBlur);
      FormElement.removeEventListener("input", onInput);
    });
    const htmlForm = Form(FormElement, { submitting: Submitting, delayed: Delayed, timeout: Timeout }, options2);
    let currentRequest;
    let customRequest = void 0;
    const enhanced = enhance(FormElement, async (submitParams) => {
      let jsonData = void 0;
      let validationAdapter = options2.validators;
      const submit = {
        ...submitParams,
        jsonData(data) {
          if (options2.dataType !== "json") {
            throw new SuperFormError("options.dataType must be set to 'json' to use jsonData.");
          }
          jsonData = data;
        },
        validators(adapter) {
          validationAdapter = adapter;
        },
        customRequest(request) {
          customRequest = request;
        }
      };
      const _submitCancel = submit.cancel;
      let cancelled = false;
      function clientValidationResult(validation) {
        const validationResult = { ...validation, posted: true };
        const status = validationResult.valid ? 200 : Form_resultStatus(400);
        const data = { form: validationResult };
        const result = validationResult.valid ? { type: "success", status, data } : { type: "failure", status, data };
        setTimeout(() => validationResponse({ result }), 0);
      }
      __name(clientValidationResult, "clientValidationResult");
      function clearOnSubmit() {
        switch (options2.clearOnSubmit) {
          case "errors-and-message":
            Errors.clear();
            Message.set(void 0);
            break;
          case "errors":
            Errors.clear();
            break;
          case "message":
            Message.set(void 0);
            break;
        }
      }
      __name(clearOnSubmit, "clearOnSubmit");
      async function triggerOnError(result, status) {
        result.status = status;
        if (options2.onError !== "apply") {
          const event = { result, message: Message, form };
          for (const onErrorEvent of formEvents.onError) {
            if (onErrorEvent !== "apply" && (onErrorEvent != defaultOnError || !options2.flashMessage?.onError)) {
              await onErrorEvent(event);
            }
          }
        }
        if (options2.flashMessage && options2.flashMessage.onError) {
          await options2.flashMessage.onError({
            result,
            flashMessage: options2.flashMessage.module.getFlash(page)
          });
        }
        if (options2.applyAction) {
          if (options2.onError == "apply") {
            await applyAction();
          } else {
            await applyAction({
              type: "failure",
              status: Form_resultStatus(result.status),
              data: result
            });
          }
        }
      }
      __name(triggerOnError, "triggerOnError");
      function cancel(opts = {
        resetTimers: true
      }) {
        cancelled = true;
        if (opts.resetTimers && htmlForm.isSubmitting()) {
          htmlForm.completed({ cancelled });
        }
        return _submitCancel();
      }
      __name(cancel, "cancel");
      submit.cancel = cancel;
      if (htmlForm.isSubmitting() && options2.multipleSubmits == "prevent") {
        cancel({ resetTimers: false });
      } else {
        if (htmlForm.isSubmitting() && options2.multipleSubmits == "abort") {
          if (currentRequest)
            currentRequest.abort();
        }
        htmlForm.submitting();
        currentRequest = submit.controller;
        for (const event of formEvents.onSubmit) {
          try {
            await event(submit);
          } catch (error2) {
            cancel();
            triggerOnError({ type: "error", error: error2 }, 500);
          }
        }
      }
      if (cancelled && options2.flashMessage)
        cancelFlash(options2);
      if (!cancelled) {
        const noValidate = !Form_isSPA() && (FormElement.noValidate || (submit.submitter instanceof HTMLButtonElement || submit.submitter instanceof HTMLInputElement) && submit.submitter.formNoValidate);
        let validation = void 0;
        const validateForm = /* @__PURE__ */ __name(async () => {
          return await Form_validate({ adapter: validationAdapter });
        }, "validateForm");
        clearOnSubmit();
        if (!noValidate) {
          validation = await validateForm();
          if (!validation.valid) {
            cancel({ resetTimers: false });
            clientValidationResult(validation);
          }
        }
        if (!cancelled) {
          if (options2.flashMessage && (options2.clearOnSubmit == "errors-and-message" || options2.clearOnSubmit == "message") && shouldSyncFlash(options2)) {
            options2.flashMessage.module.getFlash(page).set(void 0);
          }
          const submitData = "formData" in submit ? submit.formData : submit.data;
          lastInputChange = void 0;
          if (Form_isSPA()) {
            if (!validation)
              validation = await validateForm();
            cancel({ resetTimers: false });
            clientValidationResult(validation);
          } else if (options2.dataType === "json") {
            if (!validation)
              validation = await validateForm();
            const postData = clone$1(jsonData ?? validation.data);
            traversePaths(postData, (data) => {
              if (data.value instanceof File) {
                const key2 = "__superform_file_" + mergePath(data.path);
                submitData.append(key2, data.value);
                return data.set(void 0);
              } else if (Array.isArray(data.value) && data.value.length && data.value.every((v2) => v2 instanceof File)) {
                const key2 = "__superform_files_" + mergePath(data.path);
                for (const file of data.value) {
                  submitData.append(key2, file);
                }
                return data.set(void 0);
              }
            });
            Object.keys(postData).forEach((key2) => {
              if (typeof submitData.get(key2) === "string") {
                submitData.delete(key2);
              }
            });
            const chunks = chunkSubstr(stringify2(postData), options2.jsonChunkSize ?? 5e5);
            for (const chunk of chunks) {
              submitData.append("__superform_json", chunk);
            }
          }
          if (!submitData.has("__superform_id")) {
            const id = Data.formId;
            if (id !== void 0)
              submitData.set("__superform_id", id);
          }
          if (typeof options2.SPA === "string") {
            EnhancedForm_setAction(options2.SPA);
          }
        }
      }
      function chunkSubstr(str, size2) {
        const numChunks = Math.ceil(str.length / size2);
        const chunks = new Array(numChunks);
        for (let i2 = 0, o2 = 0; i2 < numChunks; ++i2, o2 += size2) {
          chunks[i2] = str.substring(o2, o2 + size2);
        }
        return chunks;
      }
      __name(chunkSubstr, "chunkSubstr");
      async function validationResponse(event) {
        let cancelled2 = false;
        currentRequest = null;
        let result = "type" in event.result && "status" in event.result ? event.result : {
          type: "error",
          status: Form_resultStatus(parseInt(String(event.result.status)) || 500),
          error: event.result.error instanceof Error ? event.result.error : event.result
        };
        const cancel2 = /* @__PURE__ */ __name(() => cancelled2 = true, "cancel2");
        const data = {
          result,
          formEl: FormElement,
          formElement: FormElement,
          cancel: cancel2
        };
        const unsubCheckforNav = STORYBOOK_MODE || !Form_isSPA() ? () => {
        } : navigating.subscribe(($nav) => {
          if (!$nav || $nav.from?.route.id === $nav.to?.route.id)
            return;
          cancel2();
        });
        function setErrorResult(error2, data2, status) {
          data2.result = {
            type: "error",
            error: error2,
            status: Form_resultStatus(status)
          };
        }
        __name(setErrorResult, "setErrorResult");
        for (const event2 of formEvents.onResult) {
          try {
            await event2(data);
          } catch (error2) {
            setErrorResult(error2, data, Math.max(result.status ?? 500, 400));
          }
        }
        result = data.result;
        if (!cancelled2) {
          if ((result.type === "success" || result.type === "failure") && result.data) {
            const forms = Context_findValidationForms(result.data);
            if (!forms.length) {
              throw new SuperFormError("No form data returned from ActionResult. Make sure you return { form } in the form actions.");
            }
            for (const newForm of forms) {
              if (newForm.id !== Data.formId)
                continue;
              const data2 = {
                form: newForm,
                formEl: FormElement,
                formElement: FormElement,
                cancel: () => cancelled2 = true,
                result
              };
              for (const event2 of formEvents.onUpdate) {
                try {
                  await event2(data2);
                } catch (error2) {
                  setErrorResult(error2, data2, Math.max(result.status ?? 500, 400));
                }
              }
              result = data2.result;
              if (!cancelled2) {
                if (options2.customValidity) {
                  setCustomValidityForm(FormElement, data2.form.errors);
                }
                if (Form_shouldReset(data2.form.valid, result.type == "success")) {
                  data2.formElement.querySelectorAll('input[type="file"]').forEach((e3) => e3.value = "");
                }
              }
            }
          }
          if (!cancelled2) {
            if (result.type !== "error") {
              if (result.type === "success" && options2.invalidateAll) {
                await invalidateAll();
              }
              if (options2.applyAction) {
                await applyAction();
              } else {
                await Form_updateFromActionResult(result);
              }
            } else {
              await triggerOnError(result, Math.max(result.status ?? 500, 400));
            }
          }
        }
        if (cancelled2 && options2.flashMessage) {
          cancelFlash(options2);
        }
        if (cancelled2 || result.type != "redirect") {
          htmlForm.completed({ cancelled: cancelled2 });
        } else if (STORYBOOK_MODE) {
          htmlForm.completed({ cancelled: cancelled2, clearAll: true });
        } else {
          const unsub = navigating.subscribe(($nav) => {
            if ($nav)
              return;
            setTimeout(() => {
              try {
                if (unsub)
                  unsub();
              } catch {
              }
            });
            if (htmlForm.isSubmitting()) {
              htmlForm.completed({ cancelled: cancelled2, clearAll: true });
            }
          });
        }
        unsubCheckforNav();
      }
      __name(validationResponse, "validationResponse");
      if (customRequest) {
        if (!cancelled)
          _submitCancel();
        const response = await customRequest(submitParams);
        let result;
        if (response instanceof Response) {
          result = deserialize(await response.text());
        } else if (response instanceof XMLHttpRequest) {
          result = deserialize(response.responseText);
        } else {
          result = response;
        }
        if (result.type === "error")
          result.status = response.status;
        validationResponse({ result });
      }
      return validationResponse;
    });
    return {
      destroy: () => {
        for (const [name3, events2] of Object.entries(formEvents)) {
          formEvents[name3] = events2.filter((e3) => e3 === options2[name3]);
        }
        enhanced.destroy();
      }
    };
  }
  __name(superFormEnhance, "superFormEnhance");
  function removeFiles(formData) {
    const paths = [];
    traversePaths(formData, (data2) => {
      if (data2.value instanceof File) {
        paths.push(data2.path);
        return "skip";
      } else if (Array.isArray(data2.value) && data2.value.length && data2.value.every((d) => d instanceof File)) {
        paths.push(data2.path);
        return "skip";
      }
    });
    if (!paths.length)
      return { data: formData, paths };
    const data = clone$1(formData);
    setPaths(data, paths, (path) => pathExists(initialForm.data, path)?.value);
    return { data, paths };
  }
  __name(removeFiles, "removeFiles");
  return {
    form: Form$1,
    formId: FormId,
    errors: Errors,
    message: Message,
    constraints: Constraints,
    tainted: Tainted_currentState(),
    submitting: readonly(Submitting),
    delayed: readonly(Delayed),
    timeout: readonly(Timeout),
    options: options2,
    capture: Form_capture,
    restore: (snapshot) => {
      rebind({ form: snapshot, untaint: snapshot.tainted ?? true });
    },
    async validate(path, opts = {}) {
      if (!options2.validators) {
        throw new SuperFormError("options.validators must be set to use the validate method.");
      }
      if (opts.update === void 0)
        opts.update = true;
      if (opts.taint === void 0)
        opts.taint = false;
      if (typeof opts.errors == "string")
        opts.errors = [opts.errors];
      let data;
      const splittedPath = splitPath(path);
      if ("value" in opts) {
        if (opts.update === true || opts.update === "value") {
          Form$1.update(($form) => {
            setPaths($form, [splittedPath], opts.value);
            return $form;
          }, { taint: opts.taint });
          data = Data.form;
        } else {
          data = clone$1(Data.form);
          setPaths(data, [splittedPath], opts.value);
        }
      } else {
        data = Data.form;
      }
      const result = await Form_validate({ formData: data });
      const error2 = pathExists(result.errors, splittedPath);
      if (error2 && error2.value && opts.errors) {
        error2.value = opts.errors;
      }
      if (opts.update === true || opts.update == "errors") {
        Errors.update(($errors) => {
          setPaths($errors, [splittedPath], error2?.value);
          return $errors;
        });
      }
      return error2?.value;
    },
    async validateForm(opts = {}) {
      if (!options2.validators && !opts.schema) {
        throw new SuperFormError("options.validators or the schema option must be set to use the validateForm method.");
      }
      const result = opts.update ? await Form_clientValidation({ paths: [] }, true, opts.schema) : Form_validate({ adapter: opts.schema });
      const enhancedForm = EnhancedForm_get();
      if (opts.update && enhancedForm) {
        setTimeout(() => {
          if (!enhancedForm)
            return;
          scrollToFirstError(enhancedForm, {
            ...options2,
            scrollToError: opts.focusOnError === false ? "off" : options2.scrollToError
          });
        }, 1);
      }
      return result || Form_validate({ adapter: opts.schema });
    },
    allErrors: AllErrors,
    posted: Posted,
    reset(options22) {
      return Form_reset({
        message: options22?.keepMessage ? Data.message : void 0,
        data: options22?.data,
        id: options22?.id,
        newState: options22?.newState
      });
    },
    submit(submitter) {
      const form2 = EnhancedForm_get() ? EnhancedForm_get() : submitter && submitter instanceof HTMLElement ? submitter.closest("form") : void 0;
      if (!form2) {
        throw new SuperFormError("use:enhance must be added to the form to use submit, or pass a HTMLElement inside the form (or the form itself) as an argument.");
      }
      if (!form2.requestSubmit) {
        return form2.submit();
      }
      const isSubmitButton = submitter && (submitter instanceof HTMLButtonElement && submitter.type == "submit" || submitter instanceof HTMLInputElement && ["submit", "image"].includes(submitter.type));
      form2.requestSubmit(isSubmitButton ? submitter : void 0);
    },
    isTainted: Tainted_isTainted,
    enhance: superFormEnhance
  };
}
__name(superForm, "superForm");
function constraints(schema2) {
  return _constraints(schemaInfo(schema2, false, []), []);
}
__name(constraints, "constraints");
function merge(...constraints2) {
  const filtered = constraints2.filter((c2) => !!c2);
  if (!filtered.length)
    return void 0;
  if (filtered.length == 1)
    return filtered[0];
  return merge$1(...filtered);
}
__name(merge, "merge");
function _constraints(info, path) {
  if (!info)
    return void 0;
  let output = void 0;
  if (info.union && info.union.length) {
    const infos = info.union.map((s3) => schemaInfo(s3, info.isOptional, path));
    const merged = infos.map((i2) => _constraints(i2, path));
    output = merge(output, ...merged);
    if (output && (info.isNullable || info.isOptional || infos.some((i2) => i2?.isNullable || i2?.isOptional))) {
      delete output.required;
    }
  }
  if (info.array) {
    output = merge(output, ...info.array.map((i2) => _constraints(schemaInfo(i2, info.isOptional, path), path)));
  }
  if (info.properties) {
    const obj = {};
    for (const [key2, prop] of Object.entries(info.properties)) {
      const propInfo = schemaInfo(prop, !info.required?.includes(key2) || prop.default !== void 0, [key2]);
      const propConstraint = _constraints(propInfo, [...path, key2]);
      if (typeof propConstraint === "object" && Object.values(propConstraint).length > 0) {
        obj[key2] = propConstraint;
      }
    }
    output = merge(output, obj);
  }
  return output ?? constraint(info);
}
__name(_constraints, "_constraints");
function constraint(info) {
  const output = {};
  const schema2 = info.schema;
  const type = schema2.type;
  const format = schema2.format;
  if (type == "integer" && format == "unix-time") {
    const date = schema2;
    if (date.minimum !== void 0)
      output.min = new Date(date.minimum).toISOString();
    if (date.maximum !== void 0)
      output.max = new Date(date.maximum).toISOString();
  } else if (type == "string") {
    const str = schema2;
    const patterns = [
      str.pattern,
      ...str.allOf ? str.allOf.map((s3) => typeof s3 == "boolean" ? void 0 : s3.pattern) : []
    ].filter((s3) => s3 !== void 0);
    if (patterns.length > 0)
      output.pattern = patterns[0];
    if (str.minLength !== void 0)
      output.minlength = str.minLength;
    if (str.maxLength !== void 0)
      output.maxlength = str.maxLength;
  } else if (type == "number" || type == "integer") {
    const num = schema2;
    if (num.minimum !== void 0)
      output.min = num.minimum;
    else if (num.exclusiveMinimum !== void 0)
      output.min = num.exclusiveMinimum + (type == "integer" ? 1 : Number.MIN_VALUE);
    if (num.maximum !== void 0)
      output.max = num.maximum;
    else if (num.exclusiveMaximum !== void 0)
      output.max = num.exclusiveMaximum - (type == "integer" ? 1 : Number.MIN_VALUE);
    if (num.multipleOf !== void 0)
      output.step = num.multipleOf;
  } else if (type == "array") {
    const arr = schema2;
    if (arr.minItems !== void 0)
      output.min = arr.minItems;
    if (arr.maxItems !== void 0)
      output.max = arr.maxItems;
  }
  if (!info.isNullable && !info.isOptional) {
    output.required = true;
  }
  return Object.keys(output).length > 0 ? output : void 0;
}
__name(constraint, "constraint");
function schemaHash(schema2) {
  return hashCode(_schemaHash(schemaInfo(schema2, false, []), 0, []));
}
__name(schemaHash, "schemaHash");
function _schemaHash(info, depth, path) {
  if (!info)
    return "";
  function tab() {
    return "  ".repeat(depth);
  }
  __name(tab, "tab");
  function mapSchemas(schemas) {
    return schemas.map((s3) => _schemaHash(schemaInfo(s3, info?.isOptional ?? false, path), depth + 1, path)).filter((s3) => s3).join("|");
  }
  __name(mapSchemas, "mapSchemas");
  function nullish() {
    const output = [];
    if (info?.isNullable)
      output.push("null");
    if (info?.isOptional)
      output.push("undefined");
    return !output.length ? "" : "|" + output.join("|");
  }
  __name(nullish, "nullish");
  if (info.union) {
    return "Union {\n  " + tab() + mapSchemas(info.union) + "\n" + tab() + "}" + nullish();
  }
  if (info.properties) {
    const output = [];
    for (const [key2, prop] of Object.entries(info.properties)) {
      const propInfo = schemaInfo(prop, !info.required?.includes(key2) || prop.default !== void 0, [key2]);
      output.push(key2 + ": " + _schemaHash(propInfo, depth + 1, path));
    }
    return "Object {\n  " + tab() + output.join(",\n  ") + "\n" + tab() + "}" + nullish();
  }
  if (info.array) {
    return "Array[" + mapSchemas(info.array) + "]" + nullish();
  }
  return info.types.join("|") + nullish();
}
__name(_schemaHash, "_schemaHash");
function hashCode(str) {
  let hash2 = 0;
  for (let i2 = 0, len = str.length; i2 < len; i2++) {
    const chr = str.charCodeAt(i2);
    hash2 = (hash2 << 5) - hash2 + chr;
    hash2 |= 0;
  }
  if (hash2 < 0)
    hash2 = hash2 >>> 0;
  return hash2.toString(36);
}
__name(hashCode, "hashCode");
function createAdapter(adapter, jsonSchema) {
  if (!adapter || !("superFormValidationLibrary" in adapter)) {
    throw new SuperFormError('Superforms v2 requires a validation adapter for the schema. Import one of your choice from "sveltekit-superforms/adapters" and wrap the schema with it.');
  }
  if (!jsonSchema)
    jsonSchema = adapter.jsonSchema;
  return {
    ...adapter,
    constraints: adapter.constraints ?? constraints(jsonSchema),
    defaults: adapter.defaults ?? defaultValues(jsonSchema),
    shape: schemaShape(jsonSchema),
    id: schemaHash(jsonSchema)
  };
}
__name(createAdapter, "createAdapter");
async function parseRequest(data, schemaData, options2) {
  let parsed;
  if (data instanceof FormData) {
    parsed = parseFormData(data, schemaData, options2);
  } else if (data instanceof URL || data instanceof URLSearchParams) {
    parsed = parseSearchParams(data, schemaData, options2);
  } else if (data instanceof Request) {
    parsed = await tryParseFormData(data, schemaData, options2);
  } else if (
    // RequestEvent
    data && typeof data === "object" && "request" in data && data.request instanceof Request
  ) {
    parsed = await tryParseFormData(data.request, schemaData, options2);
  } else {
    parsed = {
      id: void 0,
      data,
      posted: false
    };
  }
  return parsed;
}
__name(parseRequest, "parseRequest");
async function tryParseFormData(request, schemaData, options2) {
  let formData = void 0;
  try {
    formData = await request.formData();
  } catch (e3) {
    if (e3 instanceof TypeError && e3.message.includes("already been consumed")) {
      throw e3;
    }
    return { id: void 0, data: void 0, posted: false };
  }
  return parseFormData(formData, schemaData, options2);
}
__name(tryParseFormData, "tryParseFormData");
function parseSearchParams(data, schemaData, options2) {
  if (data instanceof URL)
    data = data.searchParams;
  const convert = new FormData();
  for (const [key2, value] of data.entries()) {
    convert.append(key2, value);
  }
  const output = parseFormData(convert, schemaData, options2);
  output.posted = false;
  return output;
}
__name(parseSearchParams, "parseSearchParams");
function parseFormData(formData, schemaData, options2) {
  function tryParseSuperJson() {
    if (formData.has("__superform_json")) {
      try {
        const output = parse2(formData.getAll("__superform_json").join("") ?? "");
        if (typeof output === "object") {
          const filePaths = Array.from(formData.keys());
          for (const path of filePaths.filter((path2) => path2.startsWith("__superform_file_"))) {
            const realPath = splitPath(path.substring(17));
            setPaths(output, [realPath], formData.get(path));
          }
          for (const path of filePaths.filter((path2) => path2.startsWith("__superform_files_"))) {
            const realPath = splitPath(path.substring(18));
            const allFiles = formData.getAll(path);
            setPaths(output, [realPath], Array.from(allFiles));
          }
          return output;
        }
      } catch {
      }
    }
    return null;
  }
  __name(tryParseSuperJson, "tryParseSuperJson");
  const data = tryParseSuperJson();
  const id = formData.get("__superform_id")?.toString();
  return data ? { id, data, posted: true } : {
    id,
    data: _parseFormData(formData, schemaData, options2),
    posted: true
  };
}
__name(parseFormData, "parseFormData");
function _parseFormData(formData, schema2, options2) {
  const output = {};
  let schemaKeys;
  if (options2?.strict) {
    schemaKeys = new Set([...formData.keys()].filter((key2) => !key2.startsWith("__superform_")));
  } else {
    let unionKeys = [];
    if (schema2.anyOf) {
      const info = schemaInfo(schema2, false, []);
      if (info.union?.some((s3) => s3.type !== "object")) {
        throw new SchemaError("All form types must be an object if schema is a union.");
      }
      unionKeys = info.union?.flatMap((s3) => Object.keys(s3.properties ?? {})) ?? [];
    }
    schemaKeys = new Set([
      ...unionKeys,
      ...Object.keys(schema2.properties ?? {}),
      ...schema2.additionalProperties ? formData.keys() : []
    ].filter((key2) => !key2.startsWith("__superform_")));
  }
  function parseSingleEntry(key2, entry, info) {
    if (options2?.preprocessed && options2.preprocessed.includes(key2)) {
      return entry;
    }
    if (entry && typeof entry !== "string") {
      const allowFiles = legacyMode ? options2?.allowFiles === true : options2?.allowFiles !== false;
      return !allowFiles ? void 0 : entry.size ? entry : info.isNullable ? null : void 0;
    }
    if (info.types.length > 1) {
      throw new SchemaError(unionError, key2);
    }
    const [type] = info.types;
    return parseFormDataEntry(key2, entry, type ?? "any", info);
  }
  __name(parseSingleEntry, "parseSingleEntry");
  const defaultPropertyType = typeof schema2.additionalProperties == "object" ? schema2.additionalProperties : { type: "string" };
  for (const key2 of schemaKeys) {
    const property = schema2.properties ? schema2.properties[key2] : defaultPropertyType;
    assertSchema(property, key2);
    const info = schemaInfo(property ?? defaultPropertyType, !schema2.required?.includes(key2), [
      key2
    ]);
    if (!info)
      continue;
    if (!info.types.includes("boolean") && !schema2.additionalProperties && !formData.has(key2)) {
      continue;
    }
    const entries = formData.getAll(key2);
    if (info.union && info.union.length > 1) {
      throw new SchemaError(unionError, key2);
    }
    if (info.types.includes("array") || info.types.includes("set")) {
      const items = property.items ?? (info.union?.length == 1 ? info.union[0] : void 0);
      if (!items || typeof items == "boolean" || Array.isArray(items) && items.length != 1) {
        throw new SchemaError('Arrays must have a single "items" property that defines its type.', key2);
      }
      const arrayType2 = Array.isArray(items) ? items[0] : items;
      assertSchema(arrayType2, key2);
      const arrayInfo = schemaInfo(arrayType2, info.isOptional, [key2]);
      if (!arrayInfo)
        continue;
      const isFileArray = entries.length && entries.some((e3) => e3 && typeof e3 !== "string");
      const arrayData = entries.map((e3) => parseSingleEntry(key2, e3, arrayInfo));
      if (isFileArray && arrayData.every((file) => !file))
        arrayData.length = 0;
      output[key2] = info.types.includes("set") ? new Set(arrayData) : arrayData;
    } else {
      output[key2] = parseSingleEntry(key2, entries[entries.length - 1], info);
    }
  }
  return output;
}
__name(_parseFormData, "_parseFormData");
function parseFormDataEntry(key2, value, type, info) {
  if (!value) {
    if (type == "boolean" && info.isOptional && info.schema.default === true) {
      return false;
    }
    const defaultValue2 = defaultValues(info.schema, info.isOptional, [key2]);
    if (info.schema.enum && defaultValue2 !== null && defaultValue2 !== void 0) {
      return value;
    }
    if (defaultValue2 !== void 0)
      return defaultValue2;
    if (info.isNullable)
      return null;
    if (info.isOptional)
      return void 0;
  }
  function typeError() {
    throw new SchemaError(type[0].toUpperCase() + type.slice(1) + ` type found. Set the dataType option to "json" and add use:enhance on the client to use nested data structures. More information: https://superforms.rocks/concepts/nested-data`, key2);
  }
  __name(typeError, "typeError");
  switch (type) {
    case "string":
    case "any":
      return value;
    case "integer":
      return parseInt(value ?? "", 10);
    case "number":
      return parseFloat(value ?? "");
    case "boolean":
      return Boolean(value == "false" ? "" : value).valueOf();
    case "unix-time": {
      const date = new Date(value ?? "");
      return !isNaN(date) ? date : void 0;
    }
    case "bigint":
      return BigInt(value ?? ".");
    case "symbol":
      return Symbol(String(value));
    case "set":
    case "array":
    case "object":
      return typeError();
    default:
      throw new SuperFormError("Unsupported schema type for FormData: " + type);
  }
}
__name(parseFormDataEntry, "parseFormDataEntry");
function isPrimitive(value) {
  return typeof value !== "object" && typeof value !== "function" || value === null;
}
__name(isPrimitive, "isPrimitive");
function MapTree() {
  this.childBranches = /* @__PURE__ */ new WeakMap();
  this.primitiveKeys = /* @__PURE__ */ new Map();
  this.hasValue = false;
  this.value = void 0;
}
__name(MapTree, "MapTree");
function addErrorMessage(res, key2, errorMessage, refs) {
  if (!refs?.errorMessages)
    return;
  if (errorMessage) {
    res.errorMessage = {
      ...res.errorMessage,
      [key2]: errorMessage
    };
  }
}
__name(addErrorMessage, "addErrorMessage");
function setResponseValueAndErrors(res, key2, value, errorMessage, refs) {
  res[key2] = value;
  addErrorMessage(res, key2, errorMessage, refs);
}
__name(setResponseValueAndErrors, "setResponseValueAndErrors");
function parseAnyDef() {
  return {};
}
__name(parseAnyDef, "parseAnyDef");
function parseArrayDef(def, refs) {
  const res = {
    type: "array"
  };
  if (def.type?._def && def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}
__name(parseArrayDef, "parseArrayDef");
function parseBigintDef(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}
__name(parseBigintDef, "parseBigintDef");
function parseBooleanDef() {
  return {
    type: "boolean"
  };
}
__name(parseBooleanDef, "parseBooleanDef");
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}
__name(parseBrandedDef, "parseBrandedDef");
function parseDateDef(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy ?? refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i2) => parseDateDef(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser(def, refs);
  }
}
__name(parseDateDef, "parseDateDef");
function parseDefaultDef(_def, refs) {
  return {
    ...parseDef(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
__name(parseDefaultDef, "parseDefaultDef");
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : {};
}
__name(parseEffectsDef, "parseEffectsDef");
function parseEnumDef(def) {
  return {
    type: "string",
    enum: def.values
  };
}
__name(parseEnumDef, "parseEnumDef");
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x2) => !!x2);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema2) => {
    if (isJsonSchema7AllOfType(schema2)) {
      mergedAllOf.push(...schema2.allOf);
      if (schema2.unevaluatedProperties === void 0) {
        unevaluatedProperties = void 0;
      }
    } else {
      let nestedSchema = schema2;
      if ("additionalProperties" in schema2 && schema2.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema2;
        nestedSchema = rest;
      } else {
        unevaluatedProperties = void 0;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : void 0;
}
__name(parseIntersectionDef, "parseIntersectionDef");
function parseLiteralDef(def, refs) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      enum: [def.value]
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}
__name(parseLiteralDef, "parseLiteralDef");
function parseStringDef(def, refs) {
  const res = {
    type: "string"
  };
  function processPattern(value) {
    return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(value) : value;
  }
  __name(processPattern, "processPattern");
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          break;
        case "max":
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern(res, RegExp(`^${processPattern(check.value)}`), check.message, refs);
          break;
        case "endsWith":
          addPattern(res, RegExp(`${processPattern(check.value)}$`), check.message, refs);
          break;
        case "datetime":
          addFormat(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat(res, "date", check.message, refs);
          break;
        case "time":
          addFormat(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat(res, "duration", check.message, refs);
          break;
        case "length":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "includes": {
          addPattern(res, RegExp(processPattern(check.value)), check.message, refs);
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji, check.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              setResponseValueAndErrors(res, "contentEncoding", "base64", check.message, refs);
              break;
            }
            case "pattern:zod": {
              addPattern(res, zodPatterns.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern(res, zodPatterns.nanoid, check.message, refs);
        }
      }
    }
  }
  return res;
}
__name(parseStringDef, "parseStringDef");
function parseRecordDef(def, refs) {
  if (refs.target === "openApi3" && def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce((acc, key2) => ({
        ...acc,
        [key2]: parseDef(def.valueType._def, {
          ...refs,
          currentPath: [...refs.currentPath, "properties", key2]
        }) ?? {}
      }), {}),
      additionalProperties: false
    };
  }
  const schema2 = {
    type: "object",
    additionalProperties: parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? {}
  };
  if (refs.target === "openApi3") {
    return schema2;
  }
  if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {
    const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
    return {
      ...schema2,
      propertyNames: keyType
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema2,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.type._def.checks?.length) {
    const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);
    return {
      ...schema2,
      propertyNames: keyType
    };
  }
  return schema2;
}
__name(parseRecordDef, "parseRecordDef");
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys = parseDef(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || {};
  const values = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
__name(parseMapDef, "parseMapDef");
function parseNativeEnumDef(def) {
  const object = def.values;
  const actualKeys = Object.keys(def.values).filter((key2) => {
    return typeof object[object[key2]] !== "number";
  });
  const actualValues = actualKeys.map((key2) => object[key2]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
__name(parseNativeEnumDef, "parseNativeEnumDef");
function parseNeverDef() {
  return {
    not: {}
  };
}
__name(parseNeverDef, "parseNeverDef");
function parseNullDef(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}
__name(parseNullDef, "parseNullDef");
function parseUnionDef(def, refs) {
  if (refs.target === "openApi3")
    return asAnyOf(def, refs);
  const options2 = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options2.every((x2) => x2._def.typeName in primitiveMappings && (!x2._def.checks || !x2._def.checks.length))) {
    const types = options2.reduce((types2, x2) => {
      const type = primitiveMappings[x2._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options2.every((x2) => x2._def.typeName === "ZodLiteral" && !x2.description)) {
    const types = options2.reduce((acc, x2) => {
      const type = typeof x2._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x2._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options2.length) {
      const uniqueTypes = types.filter((x2, i2, a2) => a2.indexOf(x2) === i2);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options2.reduce((acc, x2) => {
          return acc.includes(x2._def.value) ? acc : [...acc, x2._def.value];
        }, [])
      };
    }
  } else if (options2.every((x2) => x2._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options2.reduce((acc, x2) => [
        ...acc,
        ...x2._def.values.filter((x22) => !acc.includes(x22))
      ], [])
    };
  }
  return asAnyOf(def, refs);
}
__name(parseUnionDef, "parseUnionDef");
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3") {
      return {
        type: primitiveMappings[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [
        primitiveMappings[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  if (refs.target === "openApi3") {
    const base22 = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base22 && "$ref" in base22)
      return { allOf: [base22], nullable: true };
    return base22 && { ...base22, nullable: true };
  }
  const base2 = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base2 && { anyOf: [base2, { type: "null" }] };
}
__name(parseNullableDef, "parseNullableDef");
function parseNumberDef(def, refs) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage(res, "type", check.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}
__name(parseNumberDef, "parseNumberDef");
function decideAdditionalProperties(def, refs) {
  if (refs.removeAdditionalStrategy === "strict") {
    return def.catchall._def.typeName === "ZodNever" ? def.unknownKeys !== "strict" : parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? true;
  } else {
    return def.catchall._def.typeName === "ZodNever" ? def.unknownKeys === "passthrough" : parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? true;
  }
}
__name(decideAdditionalProperties, "decideAdditionalProperties");
function parseObjectDef(def, refs) {
  const result = {
    type: "object",
    ...Object.entries(def.shape()).reduce((acc, [propName, propDef]) => {
      if (propDef === void 0 || propDef._def === void 0)
        return acc;
      const parsedDef = parseDef(propDef._def, {
        ...refs,
        currentPath: [...refs.currentPath, "properties", propName],
        propertyPath: [...refs.currentPath, "properties", propName]
      });
      if (parsedDef === void 0)
        return acc;
      return {
        properties: { ...acc.properties, [propName]: parsedDef },
        required: propDef.isOptional() ? acc.required : [...acc.required, propName]
      };
    }, { properties: {}, required: [] }),
    additionalProperties: decideAdditionalProperties(def, refs)
  };
  if (!result.required.length)
    delete result.required;
  return result;
}
__name(parseObjectDef, "parseObjectDef");
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}
__name(parsePromiseDef, "parsePromiseDef");
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema2 = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors(schema2, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors(schema2, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema2;
}
__name(parseSetDef, "parseSetDef");
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x2, i2) => parseDef(x2._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i2}`]
      })).reduce((acc, x2) => x2 === void 0 ? acc : [...acc, x2], []),
      additionalItems: parseDef(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x2, i2) => parseDef(x2._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i2}`]
      })).reduce((acc, x2) => x2 === void 0 ? acc : [...acc, x2], [])
    };
  }
}
__name(parseTupleDef, "parseTupleDef");
function parseUndefinedDef() {
  return {
    not: {}
  };
}
__name(parseUndefinedDef, "parseUndefinedDef");
function parseUnknownDef() {
  return {};
}
__name(parseUnknownDef, "parseUnknownDef");
function parseDef(def, refs, forceResolution = false) {
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchema = selectParser(def, def.typeName, refs);
  if (jsonSchema) {
    addMeta(def, refs, jsonSchema);
  }
  newItem.jsonSchema = jsonSchema;
  return jsonSchema;
}
__name(parseDef, "parseDef");
async function validate(schema2, data, errorMap2) {
  const result = await schema2.safeParseAsync(data, { errorMap: errorMap2 });
  if (result.success) {
    return {
      data: result.data,
      success: true
    };
  }
  return {
    issues: result.error.issues.map(({ message, path }) => ({ message, path })),
    success: false
  };
}
__name(validate, "validate");
function _zod(schema2, options2) {
  return /* @__PURE__ */ createAdapter({
    superFormValidationLibrary: "zod",
    validate: async (data) => validate(schema2, data, options2?.errorMap),
    jsonSchema: options2?.jsonSchema ?? /* @__PURE__ */ zodToJSONSchema(schema2, options2?.config),
    defaults: options2?.defaults
  });
}
__name(_zod, "_zod");
function _zodClient(schema2, options2) {
  return {
    superFormValidationLibrary: "zod",
    validate: async (data) => validate(schema2, data, options2?.errorMap)
  };
}
__name(_zodClient, "_zodClient");
var browser;
var collectionClone;
var isObject2;
var merge$1;
var defaultOptions$2;
var conversionFormatTypes;
var SuperFormError;
var SchemaError;
var noCustomValidityDataAttribute;
var isElementInViewport;
var scrollToAndCenter;
var immediateInputTypes;
var FetchStatus;
var activeTimers;
var scrollToFirstError;
var formIds;
var initialForms;
var defaultOnError;
var defaultFormOptions;
var LEGACY_MODE;
var STORYBOOK_MODE;
var legacyMode;
var unionError;
var memoize$1;
var memoizeWeak;
var baseMemoize;
var memoize2;
var ignoreOverride;
var defaultOptions$1;
var getDefaultOptions;
var getRefs;
var parseCatchDef;
var integerDateParser;
var isJsonSchema7AllOfType;
var emojiRegex2;
var zodPatterns;
var escapeNonAlphaNumeric;
var addFormat;
var addPattern;
var processRegExp;
var primitiveMappings;
var asAnyOf;
var parseOptionalDef;
var parsePipelineDef;
var parseReadonlyDef;
var get$ref;
var getRelativePath;
var selectParser;
var addMeta;
var zodToJsonSchema;
var defaultOptions;
var zodToJSONSchema;
var zod;
var zodClient;
var init_zod = __esm({
  ".svelte-kit/output/server/chunks/zod.js"() {
    init_index4();
    init_stores();
    init_index2();
    init_index_server();
    init_client();
    init_stringify();
    init_lib();
    browser = BROWSER;
    collectionClone = clone$2;
    isObject2 = /* @__PURE__ */ __name((obj) => {
      if (typeof obj === "object" && obj !== null) {
        if (typeof Object.getPrototypeOf === "function") {
          const prototype = Object.getPrototypeOf(obj);
          return prototype === Object.prototype || prototype === null;
        }
        return Object.prototype.toString.call(obj) === "[object Object]";
      }
      return false;
    }, "isObject2");
    merge$1 = /* @__PURE__ */ __name((...objects) => objects.reduce((result, current) => {
      if (Array.isArray(current)) {
        throw new TypeError("Arguments provided to ts-deepmerge must be objects, not arrays.");
      }
      Object.keys(current).forEach((key2) => {
        if (["__proto__", "constructor", "prototype"].includes(key2)) {
          return;
        }
        if (Array.isArray(result[key2]) && Array.isArray(current[key2])) {
          result[key2] = merge$1.options.mergeArrays ? merge$1.options.uniqueArrayItems ? Array.from(new Set(result[key2].concat(current[key2]))) : [...result[key2], ...current[key2]] : current[key2];
        } else if (isObject2(result[key2]) && isObject2(current[key2])) {
          result[key2] = merge$1(result[key2], current[key2]);
        } else {
          result[key2] = current[key2] === void 0 ? merge$1.options.allowUndefinedOverrides ? current[key2] : result[key2] : current[key2];
        }
      });
      return result;
    }, {}), "merge$1");
    defaultOptions$2 = {
      allowUndefinedOverrides: true,
      mergeArrays: true,
      uniqueArrayItems: true
    };
    merge$1.options = defaultOptions$2;
    merge$1.withOptions = (options2, ...objects) => {
      merge$1.options = Object.assign(Object.assign({}, defaultOptions$2), options2);
      const result = merge$1(...objects);
      merge$1.options = defaultOptions$2;
      return result;
    };
    conversionFormatTypes = ["unix-time", "bigint", "any", "symbol", "set"];
    SuperFormError = /* @__PURE__ */ __name(class _SuperFormError extends Error {
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, _SuperFormError.prototype);
      }
    }, "_SuperFormError");
    SchemaError = /* @__PURE__ */ __name(class _SchemaError extends SuperFormError {
      path;
      constructor(message, path) {
        super((path && path.length ? `[${Array.isArray(path) ? path.join(".") : path}] ` : "") + message);
        this.path = Array.isArray(path) ? path.join(".") : path;
        Object.setPrototypeOf(this, _SchemaError.prototype);
      }
    }, "_SchemaError");
    noCustomValidityDataAttribute = "noCustomValidity";
    isElementInViewport = /* @__PURE__ */ __name((el, topOffset = 0) => {
      const rect = el.getBoundingClientRect();
      return rect.top >= topOffset && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth);
    }, "isElementInViewport");
    scrollToAndCenter = /* @__PURE__ */ __name((el, offset2 = 1.125, behavior = "smooth") => {
      const elementRect = el.getBoundingClientRect();
      const absoluteElementTop = elementRect.top + window.pageYOffset;
      const top = absoluteElementTop - window.innerHeight / (2 * offset2);
      window.scrollTo({ left: 0, top, behavior });
    }, "scrollToAndCenter");
    immediateInputTypes = ["checkbox", "radio", "range", "file"];
    (function(FetchStatus2) {
      FetchStatus2[FetchStatus2["Idle"] = 0] = "Idle";
      FetchStatus2[FetchStatus2["Submitting"] = 1] = "Submitting";
      FetchStatus2[FetchStatus2["Delayed"] = 2] = "Delayed";
      FetchStatus2[FetchStatus2["Timeout"] = 3] = "Timeout";
    })(FetchStatus || (FetchStatus = {}));
    activeTimers = /* @__PURE__ */ new Set();
    scrollToFirstError = /* @__PURE__ */ __name(async (Form2, options2) => {
      if (options2.scrollToError == "off")
        return;
      const selector2 = options2.errorSelector;
      if (!selector2)
        return;
      await tick();
      let el;
      el = Form2.querySelector(selector2);
      if (!el)
        return;
      el = el.querySelector(selector2) ?? el;
      const nav = options2.stickyNavbar ? document.querySelector(options2.stickyNavbar) : null;
      if (typeof options2.scrollToError != "string") {
        el.scrollIntoView(options2.scrollToError);
      } else if (!isElementInViewport(el, nav?.offsetHeight ?? 0)) {
        scrollToAndCenter(el, void 0, options2.scrollToError);
      }
      function Form_shouldAutoFocus(userAgent) {
        if (typeof options2.autoFocusOnError === "boolean")
          return options2.autoFocusOnError;
        else
          return !/iPhone|iPad|iPod|Android/i.test(userAgent);
      }
      __name(Form_shouldAutoFocus, "Form_shouldAutoFocus");
      if (!Form_shouldAutoFocus("Cloudflare-Workers"))
        return;
      let focusEl;
      focusEl = el;
      if (!["INPUT", "SELECT", "BUTTON", "TEXTAREA"].includes(focusEl.tagName)) {
        focusEl = focusEl.querySelector('input:not([type="hidden"]):not(.flatpickr-input), select, textarea');
      }
      if (focusEl) {
        try {
          focusEl.focus({ preventScroll: true });
          if (options2.selectErrorText && focusEl.tagName == "INPUT") {
            focusEl.select();
          }
        } catch (err) {
        }
      }
    }, "scrollToFirstError");
    formIds = /* @__PURE__ */ new WeakMap();
    initialForms = /* @__PURE__ */ new WeakMap();
    defaultOnError = /* @__PURE__ */ __name((event) => {
      throw event.result.error;
    }, "defaultOnError");
    defaultFormOptions = {
      applyAction: true,
      invalidateAll: true,
      resetForm: true,
      autoFocusOnError: "detect",
      scrollToError: "smooth",
      errorSelector: '[aria-invalid="true"],[data-invalid]',
      selectErrorText: false,
      stickyNavbar: void 0,
      taintedMessage: false,
      onSubmit: void 0,
      onResult: void 0,
      onUpdate: void 0,
      onUpdated: void 0,
      onError: defaultOnError,
      dataType: "form",
      validators: void 0,
      customValidity: false,
      clearOnSubmit: "message",
      delayMs: 500,
      timeoutMs: 8e3,
      multipleSubmits: "prevent",
      SPA: void 0,
      validationMethod: "auto"
    };
    LEGACY_MODE = false;
    try {
      if (SUPERFORMS_LEGACY)
        LEGACY_MODE = true;
    } catch {
    }
    STORYBOOK_MODE = false;
    try {
      if (globalThis.STORIES)
        STORYBOOK_MODE = true;
    } catch {
    }
    legacyMode = false;
    try {
      if (SUPERFORMS_LEGACY)
        legacyMode = true;
    } catch {
    }
    unionError = 'FormData parsing failed: Unions are only supported when the dataType option for superForm is set to "json".';
    MapTree.prototype.has = /* @__PURE__ */ __name(function has(key2) {
      var keyObject = isPrimitive(key2) ? this.primitiveKeys.get(key2) : key2;
      return keyObject ? this.childBranches.has(keyObject) : false;
    }, "has");
    MapTree.prototype.get = /* @__PURE__ */ __name(function get22(key2) {
      var keyObject = isPrimitive(key2) ? this.primitiveKeys.get(key2) : key2;
      return keyObject ? this.childBranches.get(keyObject) : void 0;
    }, "get22");
    MapTree.prototype.resolveBranch = /* @__PURE__ */ __name(function resolveBranch(key2) {
      if (this.has(key2)) {
        return this.get(key2);
      }
      var newBranch = new MapTree();
      var keyObject = this.createKey(key2);
      this.childBranches.set(keyObject, newBranch);
      return newBranch;
    }, "resolveBranch");
    MapTree.prototype.setValue = /* @__PURE__ */ __name(function setValue(value) {
      this.hasValue = true;
      return this.value = value;
    }, "setValue");
    MapTree.prototype.createKey = /* @__PURE__ */ __name(function createKey(key2) {
      if (isPrimitive(key2)) {
        var keyObject = {};
        this.primitiveKeys.set(key2, keyObject);
        return keyObject;
      }
      return key2;
    }, "createKey");
    MapTree.prototype.clear = /* @__PURE__ */ __name(function clear() {
      if (arguments.length === 0) {
        this.childBranches = /* @__PURE__ */ new WeakMap();
        this.primitiveKeys.clear();
        this.hasValue = false;
        this.value = void 0;
      } else if (arguments.length === 1) {
        var key2 = arguments[0];
        if (isPrimitive(key2)) {
          var keyObject = this.primitiveKeys.get(key2);
          if (keyObject) {
            this.childBranches.delete(keyObject);
            this.primitiveKeys.delete(key2);
          }
        } else {
          this.childBranches.delete(key2);
        }
      } else {
        var childKey = arguments[0];
        if (this.has(childKey)) {
          var childBranch = this.get(childKey);
          childBranch.clear.apply(childBranch, Array.prototype.slice.call(arguments, 1));
        }
      }
    }, "clear");
    memoize$1 = /* @__PURE__ */ __name(function memoize(fn) {
      var argsTree = new MapTree();
      function memoized() {
        var args = Array.prototype.slice.call(arguments);
        var argNode = args.reduce(/* @__PURE__ */ __name(function getBranch(parentBranch, arg) {
          return parentBranch.resolveBranch(arg);
        }, "getBranch"), argsTree);
        if (argNode.hasValue) {
          return argNode.value;
        }
        var value = fn.apply(null, args);
        return argNode.setValue(value);
      }
      __name(memoized, "memoized");
      memoized.clear = argsTree.clear.bind(argsTree);
      return memoized;
    }, "memoize");
    memoizeWeak = memoize$1;
    baseMemoize = /* @__PURE__ */ getDefaultExportFromCjs(memoizeWeak);
    memoize2 = baseMemoize;
    ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
    defaultOptions$1 = {
      name: void 0,
      $refStrategy: "root",
      basePath: ["#"],
      effectStrategy: "input",
      pipeStrategy: "all",
      dateStrategy: "format:date-time",
      mapStrategy: "entries",
      removeAdditionalStrategy: "passthrough",
      definitionPath: "definitions",
      target: "jsonSchema7",
      strictUnions: false,
      definitions: {},
      errorMessages: false,
      markdownDescription: false,
      patternStrategy: "escape",
      applyRegexFlags: false,
      emailStrategy: "format:email",
      base64Strategy: "contentEncoding:base64",
      nameStrategy: "ref"
    };
    getDefaultOptions = /* @__PURE__ */ __name((options2) => typeof options2 === "string" ? {
      ...defaultOptions$1,
      name: options2
    } : {
      ...defaultOptions$1,
      ...options2
    }, "getDefaultOptions");
    getRefs = /* @__PURE__ */ __name((options2) => {
      const _options = getDefaultOptions(options2);
      const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
      return {
        ..._options,
        currentPath,
        propertyPath: void 0,
        seen: new Map(Object.entries(_options.definitions).map(([name3, def]) => [
          def._def,
          {
            def: def._def,
            path: [..._options.basePath, _options.definitionPath, name3],
            // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
            jsonSchema: void 0
          }
        ]))
      };
    }, "getRefs");
    parseCatchDef = /* @__PURE__ */ __name((def, refs) => {
      return parseDef(def.innerType._def, refs);
    }, "parseCatchDef");
    integerDateParser = /* @__PURE__ */ __name((def, refs) => {
      const res = {
        type: "integer",
        format: "unix-time"
      };
      if (refs.target === "openApi3") {
        return res;
      }
      for (const check of def.checks) {
        switch (check.kind) {
          case "min":
            setResponseValueAndErrors(
              res,
              "minimum",
              check.value,
              // This is in milliseconds
              check.message,
              refs
            );
            break;
          case "max":
            setResponseValueAndErrors(
              res,
              "maximum",
              check.value,
              // This is in milliseconds
              check.message,
              refs
            );
            break;
        }
      }
      return res;
    }, "integerDateParser");
    isJsonSchema7AllOfType = /* @__PURE__ */ __name((type) => {
      if ("type" in type && type.type === "string")
        return false;
      return "allOf" in type;
    }, "isJsonSchema7AllOfType");
    zodPatterns = {
      /**
       * `c` was changed to `[cC]` to replicate /i flag
       */
      cuid: /^[cC][^\s-]{8,}$/,
      cuid2: /^[0-9a-z]+$/,
      ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
      /**
       * `a-z` was added to replicate /i flag
       */
      email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
      /**
       * Constructed a valid Unicode RegExp
       *
       * Lazily instantiate since this type of regex isn't supported
       * in all envs (e.g. React Native).
       *
       * See:
       * https://github.com/colinhacks/zod/issues/2433
       * Fix in Zod:
       * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
       */
      emoji: () => {
        if (emojiRegex2 === void 0) {
          emojiRegex2 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
        }
        return emojiRegex2;
      },
      /**
       * Unused
       */
      uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
      /**
       * Unused
       */
      ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
      /**
       * Unused
       */
      ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
      base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
      nanoid: /^[a-zA-Z0-9_-]{21}$/
    };
    escapeNonAlphaNumeric = /* @__PURE__ */ __name((value) => Array.from(value).map((c2) => /[a-zA-Z0-9]/.test(c2) ? c2 : `\\${c2}`).join(""), "escapeNonAlphaNumeric");
    addFormat = /* @__PURE__ */ __name((schema2, value, message, refs) => {
      if (schema2.format || schema2.anyOf?.some((x2) => x2.format)) {
        if (!schema2.anyOf) {
          schema2.anyOf = [];
        }
        if (schema2.format) {
          schema2.anyOf.push({
            format: schema2.format,
            ...schema2.errorMessage && refs.errorMessages && {
              errorMessage: { format: schema2.errorMessage.format }
            }
          });
          delete schema2.format;
          if (schema2.errorMessage) {
            delete schema2.errorMessage.format;
            if (Object.keys(schema2.errorMessage).length === 0) {
              delete schema2.errorMessage;
            }
          }
        }
        schema2.anyOf.push({
          format: value,
          ...message && refs.errorMessages && { errorMessage: { format: message } }
        });
      } else {
        setResponseValueAndErrors(schema2, "format", value, message, refs);
      }
    }, "addFormat");
    addPattern = /* @__PURE__ */ __name((schema2, regex, message, refs) => {
      if (schema2.pattern || schema2.allOf?.some((x2) => x2.pattern)) {
        if (!schema2.allOf) {
          schema2.allOf = [];
        }
        if (schema2.pattern) {
          schema2.allOf.push({
            pattern: schema2.pattern,
            ...schema2.errorMessage && refs.errorMessages && {
              errorMessage: { pattern: schema2.errorMessage.pattern }
            }
          });
          delete schema2.pattern;
          if (schema2.errorMessage) {
            delete schema2.errorMessage.pattern;
            if (Object.keys(schema2.errorMessage).length === 0) {
              delete schema2.errorMessage;
            }
          }
        }
        schema2.allOf.push({
          pattern: processRegExp(regex, refs),
          ...message && refs.errorMessages && { errorMessage: { pattern: message } }
        });
      } else {
        setResponseValueAndErrors(schema2, "pattern", processRegExp(regex, refs), message, refs);
      }
    }, "addPattern");
    processRegExp = /* @__PURE__ */ __name((regexOrFunction, refs) => {
      const regex = typeof regexOrFunction === "function" ? regexOrFunction() : regexOrFunction;
      if (!refs.applyRegexFlags || !regex.flags)
        return regex.source;
      const flags = {
        i: regex.flags.includes("i"),
        m: regex.flags.includes("m"),
        s: regex.flags.includes("s")
        // `.` matches newlines
      };
      const source2 = flags.i ? regex.source.toLowerCase() : regex.source;
      let pattern2 = "";
      let isEscaped = false;
      let inCharGroup = false;
      let inCharRange = false;
      for (let i2 = 0; i2 < source2.length; i2++) {
        if (isEscaped) {
          pattern2 += source2[i2];
          isEscaped = false;
          continue;
        }
        if (flags.i) {
          if (inCharGroup) {
            if (source2[i2].match(/[a-z]/)) {
              if (inCharRange) {
                pattern2 += source2[i2];
                pattern2 += `${source2[i2 - 2]}-${source2[i2]}`.toUpperCase();
                inCharRange = false;
              } else if (source2[i2 + 1] === "-" && source2[i2 + 2]?.match(/[a-z]/)) {
                pattern2 += source2[i2];
                inCharRange = true;
              } else {
                pattern2 += `${source2[i2]}${source2[i2].toUpperCase()}`;
              }
              continue;
            }
          } else if (source2[i2].match(/[a-z]/)) {
            pattern2 += `[${source2[i2]}${source2[i2].toUpperCase()}]`;
            continue;
          }
        }
        if (flags.m) {
          if (source2[i2] === "^") {
            pattern2 += `(^|(?<=[\r
]))`;
            continue;
          } else if (source2[i2] === "$") {
            pattern2 += `($|(?=[\r
]))`;
            continue;
          }
        }
        if (flags.s && source2[i2] === ".") {
          pattern2 += inCharGroup ? `${source2[i2]}\r
` : `[${source2[i2]}\r
]`;
          continue;
        }
        pattern2 += source2[i2];
        if (source2[i2] === "\\") {
          isEscaped = true;
        } else if (inCharGroup && source2[i2] === "]") {
          inCharGroup = false;
        } else if (!inCharGroup && source2[i2] === "[") {
          inCharGroup = true;
        }
      }
      try {
        const regexTest = new RegExp(pattern2);
      } catch {
        console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
        return regex.source;
      }
      return pattern2;
    }, "processRegExp");
    primitiveMappings = {
      ZodString: "string",
      ZodNumber: "number",
      ZodBigInt: "integer",
      ZodBoolean: "boolean",
      ZodNull: "null"
    };
    asAnyOf = /* @__PURE__ */ __name((def, refs) => {
      const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x2, i2) => parseDef(x2._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", `${i2}`]
      })).filter((x2) => !!x2 && (!refs.strictUnions || typeof x2 === "object" && Object.keys(x2).length > 0));
      return anyOf.length ? { anyOf } : void 0;
    }, "asAnyOf");
    parseOptionalDef = /* @__PURE__ */ __name((def, refs) => {
      if (refs.currentPath.toString() === refs.propertyPath?.toString()) {
        return parseDef(def.innerType._def, refs);
      }
      const innerSchema = parseDef(def.innerType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", "1"]
      });
      return innerSchema ? {
        anyOf: [
          {
            not: {}
          },
          innerSchema
        ]
      } : {};
    }, "parseOptionalDef");
    parsePipelineDef = /* @__PURE__ */ __name((def, refs) => {
      if (refs.pipeStrategy === "input") {
        return parseDef(def.in._def, refs);
      } else if (refs.pipeStrategy === "output") {
        return parseDef(def.out._def, refs);
      }
      const a2 = parseDef(def.in._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", "0"]
      });
      const b = parseDef(def.out._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", a2 ? "1" : "0"]
      });
      return {
        allOf: [a2, b].filter((x2) => x2 !== void 0)
      };
    }, "parsePipelineDef");
    parseReadonlyDef = /* @__PURE__ */ __name((def, refs) => {
      return parseDef(def.innerType._def, refs);
    }, "parseReadonlyDef");
    get$ref = /* @__PURE__ */ __name((item, refs) => {
      switch (refs.$refStrategy) {
        case "root":
          return { $ref: item.path.join("/") };
        case "relative":
          return { $ref: getRelativePath(refs.currentPath, item.path) };
        case "none":
        case "seen": {
          if (item.path.length < refs.currentPath.length && item.path.every((value, index39) => refs.currentPath[index39] === value)) {
            console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
            return {};
          }
          return refs.$refStrategy === "seen" ? {} : void 0;
        }
      }
    }, "get$ref");
    getRelativePath = /* @__PURE__ */ __name((pathA, pathB) => {
      let i2 = 0;
      for (; i2 < pathA.length && i2 < pathB.length; i2++) {
        if (pathA[i2] !== pathB[i2])
          break;
      }
      return [(pathA.length - i2).toString(), ...pathB.slice(i2)].join("/");
    }, "getRelativePath");
    selectParser = /* @__PURE__ */ __name((def, typeName, refs) => {
      switch (typeName) {
        case ZodFirstPartyTypeKind.ZodString:
          return parseStringDef(def, refs);
        case ZodFirstPartyTypeKind.ZodNumber:
          return parseNumberDef(def, refs);
        case ZodFirstPartyTypeKind.ZodObject:
          return parseObjectDef(def, refs);
        case ZodFirstPartyTypeKind.ZodBigInt:
          return parseBigintDef(def, refs);
        case ZodFirstPartyTypeKind.ZodBoolean:
          return parseBooleanDef();
        case ZodFirstPartyTypeKind.ZodDate:
          return parseDateDef(def, refs);
        case ZodFirstPartyTypeKind.ZodUndefined:
          return parseUndefinedDef();
        case ZodFirstPartyTypeKind.ZodNull:
          return parseNullDef(refs);
        case ZodFirstPartyTypeKind.ZodArray:
          return parseArrayDef(def, refs);
        case ZodFirstPartyTypeKind.ZodUnion:
        case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
          return parseUnionDef(def, refs);
        case ZodFirstPartyTypeKind.ZodIntersection:
          return parseIntersectionDef(def, refs);
        case ZodFirstPartyTypeKind.ZodTuple:
          return parseTupleDef(def, refs);
        case ZodFirstPartyTypeKind.ZodRecord:
          return parseRecordDef(def, refs);
        case ZodFirstPartyTypeKind.ZodLiteral:
          return parseLiteralDef(def, refs);
        case ZodFirstPartyTypeKind.ZodEnum:
          return parseEnumDef(def);
        case ZodFirstPartyTypeKind.ZodNativeEnum:
          return parseNativeEnumDef(def);
        case ZodFirstPartyTypeKind.ZodNullable:
          return parseNullableDef(def, refs);
        case ZodFirstPartyTypeKind.ZodOptional:
          return parseOptionalDef(def, refs);
        case ZodFirstPartyTypeKind.ZodMap:
          return parseMapDef(def, refs);
        case ZodFirstPartyTypeKind.ZodSet:
          return parseSetDef(def, refs);
        case ZodFirstPartyTypeKind.ZodLazy:
          return parseDef(def.getter()._def, refs);
        case ZodFirstPartyTypeKind.ZodPromise:
          return parsePromiseDef(def, refs);
        case ZodFirstPartyTypeKind.ZodNaN:
        case ZodFirstPartyTypeKind.ZodNever:
          return parseNeverDef();
        case ZodFirstPartyTypeKind.ZodEffects:
          return parseEffectsDef(def, refs);
        case ZodFirstPartyTypeKind.ZodAny:
          return parseAnyDef();
        case ZodFirstPartyTypeKind.ZodUnknown:
          return parseUnknownDef();
        case ZodFirstPartyTypeKind.ZodDefault:
          return parseDefaultDef(def, refs);
        case ZodFirstPartyTypeKind.ZodBranded:
          return parseBrandedDef(def, refs);
        case ZodFirstPartyTypeKind.ZodReadonly:
          return parseReadonlyDef(def, refs);
        case ZodFirstPartyTypeKind.ZodCatch:
          return parseCatchDef(def, refs);
        case ZodFirstPartyTypeKind.ZodPipeline:
          return parsePipelineDef(def, refs);
        case ZodFirstPartyTypeKind.ZodFunction:
        case ZodFirstPartyTypeKind.ZodVoid:
        case ZodFirstPartyTypeKind.ZodSymbol:
          return void 0;
        default:
          return /* @__PURE__ */ ((_2) => void 0)();
      }
    }, "selectParser");
    addMeta = /* @__PURE__ */ __name((def, refs, jsonSchema) => {
      if (def.description) {
        jsonSchema.description = def.description;
        if (refs.markdownDescription) {
          jsonSchema.markdownDescription = def.description;
        }
      }
      return jsonSchema;
    }, "addMeta");
    zodToJsonSchema = /* @__PURE__ */ __name((schema2, options2) => {
      const refs = getRefs(options2);
      const definitions = typeof options2 === "object" && options2.definitions ? Object.entries(options2.definitions).reduce((acc, [name22, schema22]) => ({
        ...acc,
        [name22]: parseDef(schema22._def, {
          ...refs,
          currentPath: [...refs.basePath, refs.definitionPath, name22]
        }, true) ?? {}
      }), {}) : void 0;
      const name3 = typeof options2 === "string" ? options2 : options2?.nameStrategy === "title" ? void 0 : options2?.name;
      const main = parseDef(schema2._def, name3 === void 0 ? refs : {
        ...refs,
        currentPath: [...refs.basePath, refs.definitionPath, name3]
      }, false) ?? {};
      const title = typeof options2 === "object" && options2.name !== void 0 && options2.nameStrategy === "title" ? options2.name : void 0;
      if (title !== void 0) {
        main.title = title;
      }
      const combined = name3 === void 0 ? definitions ? {
        ...main,
        [refs.definitionPath]: definitions
      } : main : {
        $ref: [
          ...refs.$refStrategy === "relative" ? [] : refs.basePath,
          refs.definitionPath,
          name3
        ].join("/"),
        [refs.definitionPath]: {
          ...definitions,
          [name3]: main
        }
      };
      if (refs.target === "jsonSchema7") {
        combined.$schema = "http://json-schema.org/draft-07/schema#";
      } else if (refs.target === "jsonSchema2019-09") {
        combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
      }
      return combined;
    }, "zodToJsonSchema");
    defaultOptions = {
      dateStrategy: "integer",
      pipeStrategy: "output",
      $refStrategy: "none"
    };
    zodToJSONSchema = /* @__NO_SIDE_EFFECTS__ */
    /* @__PURE__ */ __name((...params) => {
      params[1] = typeof params[1] == "object" ? { ...defaultOptions, ...params[1] } : defaultOptions;
      return zodToJsonSchema(...params);
    }, "zodToJSONSchema");
    zod = /* @__PURE__ */ memoize2(_zod);
    zodClient = /* @__PURE__ */ memoize2(_zodClient);
  }
});
async function superValidate(data, adapter, options2) {
  if (data && "superFormValidationLibrary" in data) {
    options2 = adapter;
    adapter = data;
    data = void 0;
  }
  const validator2 = adapter;
  const defaults6 = options2?.defaults ?? validator2.defaults;
  const jsonSchema = validator2.jsonSchema;
  const parsed = await parseRequest(data, jsonSchema, options2);
  const addErrors = options2?.errors ?? (options2?.strict ? true : !!parsed.data);
  const parsedData = options2?.strict ? parsed.data ?? {} : mergeDefaults(parsed.data, defaults6);
  let status;
  if (!!parsed.data || addErrors) {
    status = await /* @__PURE__ */ validator2.validate(parsedData);
  } else {
    status = { success: false, issues: [] };
  }
  const valid = status.success;
  const errors = valid || !addErrors ? {} : mapErrors(status.issues, validator2.shape);
  const dataWithDefaults = valid ? status.data : replaceInvalidDefaults(options2?.strict ? mergeDefaults(parsedData, defaults6) : parsedData, defaults6, jsonSchema, status.issues, options2?.preprocessed);
  let outputData;
  if (jsonSchema.additionalProperties === false) {
    outputData = {};
    for (const key2 of Object.keys(jsonSchema.properties ?? {})) {
      if (key2 in dataWithDefaults)
        outputData[key2] = dataWithDefaults[key2];
    }
  } else {
    outputData = dataWithDefaults;
  }
  const output = {
    id: parsed.id ?? options2?.id ?? validator2.id,
    valid,
    posted: parsed.posted,
    errors,
    data: outputData
  };
  if (!parsed.posted) {
    output.constraints = validator2.constraints;
    if (Object.keys(validator2.shape).length) {
      output.shape = validator2.shape;
    }
  }
  return output;
}
__name(superValidate, "superValidate");
var init_superValidate = __esm({
  ".svelte-kit/output/server/chunks/superValidate.js"() {
    init_chunks();
    init_zod();
  }
});
var page_server_ts_exports2 = {};
__export(page_server_ts_exports2, {
  load: () => load2
});
var load2;
var init_page_server_ts2 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/chess/_typeOfPlay_/_page.server.ts.js"() {
    init_formSchema();
    init_client();
    init_zod();
    init_chunks();
    init_superValidate();
    load2 = /* @__PURE__ */ __name(async () => {
      const pwcForm = await superValidate(zod(playWithComputerSchema));
      const pwfForm = await superValidate(zod(playWithFriendSchema));
      const sagForm = await superValidate(zod(scheduleGameSchema));
      const catForm = await superValidate(zod(createTournamentSchema));
      const ipForm = await superValidate(zod(instantPlaySchema));
      return {
        pwcForm,
        pwfForm,
        sagForm,
        catForm,
        ipForm
      };
    }, "load2");
  }
});
function createLabel() {
  const root2 = makeElement("label", {
    action: (node) => {
      const mouseDown = addMeltEventListener(node, "mousedown", (e3) => {
        if (!e3.defaultPrevented && e3.detail > 1) {
          e3.preventDefault();
        }
      });
      return {
        destroy: mouseDown
      };
    }
  });
  return {
    elements: {
      root: root2
    }
  };
}
__name(createLabel, "createLabel");
function getLabelData() {
  const NAME = "label";
  const PARTS = ["root"];
  const getAttrs2 = createBitAttrs(NAME, PARTS);
  return {
    NAME,
    getAttrs: getAttrs2
  };
}
__name(getLabelData, "getLabelData");
function Label$1($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["asChild", "el"]);
  push();
  var $$store_subs;
  let builder;
  let asChild = fallback($$props["asChild"], false);
  let el = fallback($$props["el"], () => void 0, true);
  const { elements: { root: root2 } } = createLabel();
  const { getAttrs: getAttrs2 } = getLabelData();
  const attrs = getAttrs2("root");
  builder = store_get($$store_subs ??= {}, "$root", root2);
  Object.assign(builder, attrs);
  if (asChild) {
    $$payload.out += "<!--[-->";
    $$payload.out += `<!---->`;
    slot($$payload, $$props, "default", { builder }, null);
    $$payload.out += `<!---->`;
  } else {
    $$payload.out += "<!--[!-->";
    $$payload.out += `<label${spread_attributes({ ...builder, ...$$restProps })}><!---->`;
    slot($$payload, $$props, "default", { builder }, null);
    $$payload.out += `<!----></label>`;
  }
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { asChild, el });
  pop();
}
__name(Label$1, "Label$1");
function setFormField(props) {
  setContext(FORM_FIELD, props);
  return props;
}
__name(setFormField, "setFormField");
function getFormField() {
  if (!hasContext(FORM_FIELD)) {
    ctxError("Form.Field");
  }
  return getContext(FORM_FIELD);
}
__name(getFormField, "getFormField");
function setFormControl(props) {
  setContext(FORM_CONTROL, props);
  return props;
}
__name(setFormControl, "setFormControl");
function getFormControl() {
  if (!hasContext(FORM_CONTROL)) {
    ctxError("<Control />");
  }
  return getContext(FORM_CONTROL);
}
__name(getFormControl, "getFormControl");
function ctxError(ctx) {
  throw new Error(`Unable to find \`${ctx}\` context. Did you forget to wrap the component in a \`${ctx}\`?`);
}
__name(ctxError, "ctxError");
function getAriaDescribedBy({ fieldErrorsId = void 0, descriptionId = void 0, errors }) {
  let describedBy = "";
  if (descriptionId) {
    describedBy += descriptionId + " ";
  }
  if (errors.length && fieldErrorsId) {
    describedBy += fieldErrorsId;
  }
  return describedBy ? describedBy.trim() : void 0;
}
__name(getAriaDescribedBy, "getAriaDescribedBy");
function getAriaRequired(constraints2) {
  if (!("required" in constraints2))
    return void 0;
  return constraints2.required ? "true" : void 0;
}
__name(getAriaRequired, "getAriaRequired");
function getAriaInvalid(errors) {
  return errors && errors.length ? "true" : void 0;
}
__name(getAriaInvalid, "getAriaInvalid");
function getDataFsError(errors) {
  return errors && errors.length ? "" : void 0;
}
__name(getDataFsError, "getDataFsError");
function generateId2() {
  return nanoid(5);
}
__name(generateId2, "generateId2");
function extractErrorArray(errors) {
  if (Array.isArray(errors))
    return errors;
  if (typeof errors === "object" && "_errors" in errors) {
    if (errors._errors !== void 0)
      return errors._errors;
  }
  return [];
}
__name(extractErrorArray, "extractErrorArray");
function Description($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["id", "asChild", "el"]);
  push();
  var $$store_subs;
  let descriptionAttrs;
  const { descriptionId, errors } = getFormField();
  let id = fallback($$props["id"], generateId2, true);
  let asChild = fallback($$props["asChild"], false);
  let el = fallback($$props["el"], () => void 0, true);
  descriptionId.set(id);
  descriptionAttrs = {
    id: store_get($$store_subs ??= {}, "$descriptionId", descriptionId),
    "data-fs-error": getDataFsError(store_get($$store_subs ??= {}, "$errors", errors)),
    "data-fs-description": "",
    ...$$restProps
  };
  if (asChild) {
    $$payload.out += "<!--[-->";
    $$payload.out += `<!---->`;
    slot($$payload, $$props, "default", { descriptionAttrs }, null);
    $$payload.out += `<!---->`;
  } else {
    $$payload.out += "<!--[!-->";
    $$payload.out += `<div${spread_attributes({ ...descriptionAttrs })}><!---->`;
    slot($$payload, $$props, "default", { descriptionAttrs }, null);
    $$payload.out += `<!----></div>`;
  }
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { id, asChild, el });
  pop();
}
__name(Description, "Description");
function getValueAtPath(path, obj) {
  const keys = path.split(/[[\].]/).filter(Boolean);
  let value = obj;
  for (const key2 of keys) {
    if (typeof value !== "object" || value === null) {
      return void 0;
    }
    value = value[key2];
  }
  return value;
}
__name(getValueAtPath, "getValueAtPath");
function Field($$payload, $$props) {
  push();
  var $$store_subs;
  let formErrors, formConstraints, formTainted, formData;
  let form = $$props["form"];
  let name3 = $$props["name"];
  const field = {
    name: writable(name3),
    errors: writable([]),
    constraints: writable({}),
    tainted: writable(false),
    fieldErrorsId: writable(),
    descriptionId: writable(),
    form
  };
  const { tainted, errors } = field;
  setFormField(field);
  ({
    errors: formErrors,
    constraints: formConstraints,
    tainted: formTainted,
    form: formData
  } = form);
  field.name.set(name3);
  field.errors.set(extractErrorArray(getValueAtPath(name3, store_get($$store_subs ??= {}, "$formErrors", formErrors))));
  field.constraints.set(getValueAtPath(name3, store_get($$store_subs ??= {}, "$formConstraints", formConstraints)) ?? {});
  field.tainted.set(store_get($$store_subs ??= {}, "$formTainted", formTainted) ? getValueAtPath(name3, store_get($$store_subs ??= {}, "$formTainted", formTainted)) === true : false);
  $$payload.out += `<!---->`;
  slot(
    $$payload,
    $$props,
    "default",
    {
      value: store_get($$store_subs ??= {}, "$formData", formData)[name3],
      errors: store_get($$store_subs ??= {}, "$errors", errors),
      tainted: store_get($$store_subs ??= {}, "$tainted", tainted),
      constraints: store_get($$store_subs ??= {}, "$formConstraints", formConstraints)[name3]
    },
    null
  );
  $$payload.out += `<!---->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { form, name: name3 });
  pop();
}
__name(Field, "Field");
function Control$1($$payload, $$props) {
  push();
  var $$store_subs;
  let errorAttr, attrs, labelAttrs;
  let id = fallback($$props["id"], generateId2, true);
  const {
    name: name3,
    fieldErrorsId,
    descriptionId,
    errors,
    constraints: constraints2
  } = getFormField();
  const controlContext = {
    id: writable(id),
    attrs: writable(),
    labelAttrs: writable()
  };
  const { id: idStore } = controlContext;
  setFormControl(controlContext);
  controlContext.id.set(id);
  errorAttr = getDataFsError(store_get($$store_subs ??= {}, "$errors", errors));
  attrs = {
    name: store_get($$store_subs ??= {}, "$name", name3),
    id: store_get($$store_subs ??= {}, "$idStore", idStore),
    "data-fs-error": errorAttr,
    "aria-describedby": getAriaDescribedBy({
      fieldErrorsId: store_get($$store_subs ??= {}, "$fieldErrorsId", fieldErrorsId),
      descriptionId: store_get($$store_subs ??= {}, "$descriptionId", descriptionId),
      errors: store_get($$store_subs ??= {}, "$errors", errors)
    }),
    "aria-invalid": getAriaInvalid(store_get($$store_subs ??= {}, "$errors", errors)),
    "aria-required": getAriaRequired(store_get($$store_subs ??= {}, "$constraints", constraints2)),
    "data-fs-control": ""
  };
  labelAttrs = {
    for: store_get($$store_subs ??= {}, "$idStore", idStore),
    "data-fs-label": "",
    "data-fs-error": errorAttr
  };
  controlContext.attrs.set(attrs);
  controlContext.labelAttrs.set(labelAttrs);
  $$payload.out += `<!---->`;
  slot($$payload, $$props, "default", { attrs }, null);
  $$payload.out += `<!---->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { id });
  pop();
}
__name(Control$1, "Control$1");
function Field_errors($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["id", "asChild", "el"]);
  push();
  var $$store_subs;
  let errorAttr, fieldErrorsAttrs, errorAttrs;
  const { fieldErrorsId, errors } = getFormField();
  let id = fallback($$props["id"], generateId2, true);
  let asChild = fallback($$props["asChild"], false);
  let el = fallback($$props["el"], () => void 0, true);
  errorAttr = getDataFsError(store_get($$store_subs ??= {}, "$errors", errors));
  fieldErrorsId.set(id);
  fieldErrorsAttrs = {
    id: store_get($$store_subs ??= {}, "$fieldErrorsId", fieldErrorsId),
    "data-fs-error": errorAttr,
    "data-fs-field-errors": "",
    "aria-live": "assertive",
    ...$$restProps
  };
  errorAttrs = {
    "data-fs-field-error": "",
    "data-fs-error": errorAttr
  };
  if (asChild) {
    $$payload.out += "<!--[-->";
    $$payload.out += `<!---->`;
    slot(
      $$payload,
      $$props,
      "default",
      {
        errors: store_get($$store_subs ??= {}, "$errors", errors),
        fieldErrorsAttrs,
        errorAttrs
      },
      null
    );
    $$payload.out += `<!---->`;
  } else {
    $$payload.out += "<!--[!-->";
    $$payload.out += `<div${spread_attributes({ ...fieldErrorsAttrs })}><!---->`;
    slot(
      $$payload,
      $$props,
      "default",
      {
        errors: store_get($$store_subs ??= {}, "$errors", errors),
        fieldErrorsAttrs,
        errorAttrs
      },
      () => {
        const each_array = ensure_array_like(store_get($$store_subs ??= {}, "$errors", errors));
        $$payload.out += `<!--[-->`;
        for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
          let error2 = each_array[$$index];
          $$payload.out += `<div${spread_attributes({ ...errorAttrs })}>${escape_html(error2)}</div>`;
        }
        $$payload.out += `<!--]-->`;
      }
    );
    $$payload.out += `<!----></div>`;
  }
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { id, asChild, el });
  pop();
}
__name(Field_errors, "Field_errors");
function Form_description($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  let className = fallback($$props["class"], void 0);
  Description($$payload, spread_props([
    {
      class: cn("text-sm text-muted-foreground", className)
    },
    $$restProps,
    {
      children: invalid_default_snippet,
      $$slots: {
        default: ($$payload2, { descriptionAttrs }) => {
          $$payload2.out += `<!---->`;
          slot($$payload2, $$props, "default", { descriptionAttrs }, null);
          $$payload2.out += `<!---->`;
        }
      }
    }
  ]));
  bind_props($$props, { class: className });
  pop();
}
__name(Form_description, "Form_description");
function Label($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  let className = fallback($$props["class"], void 0);
  Label$1($$payload, spread_props([
    {
      class: cn("text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70", className)
    },
    $$restProps,
    {
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
  bind_props($$props, { class: className });
  pop();
}
__name(Label, "Label");
function Form_label($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  var $$store_subs;
  let className = fallback($$props["class"], void 0);
  const { labelAttrs } = getFormControl();
  Label($$payload, spread_props([
    store_get($$store_subs ??= {}, "$labelAttrs", labelAttrs),
    {
      class: cn("data-[fs-error]:text-destructive", className)
    },
    $$restProps,
    {
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", { labelAttrs }, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { class: className });
  pop();
}
__name(Form_label, "Form_label");
function Form_field_errors($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "errorClasses"]);
  push();
  let className = fallback($$props["class"], void 0);
  let errorClasses = fallback($$props["errorClasses"], void 0);
  Field_errors($$payload, spread_props([
    {
      class: cn("text-sm font-medium text-destructive", className)
    },
    $$restProps,
    {
      children: invalid_default_snippet,
      $$slots: {
        default: ($$payload2, { errors, fieldErrorsAttrs, errorAttrs }) => {
          $$payload2.out += `<!---->`;
          slot($$payload2, $$props, "default", { errors, fieldErrorsAttrs, errorAttrs }, () => {
            const each_array = ensure_array_like(errors);
            $$payload2.out += `<!--[-->`;
            for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
              let error2 = each_array[$$index];
              $$payload2.out += `<div${spread_attributes({ ...errorAttrs, class: cn(errorClasses) })}>${escape_html(error2)}</div>`;
            }
            $$payload2.out += `<!--]-->`;
          });
          $$payload2.out += `<!---->`;
        }
      }
    }
  ]));
  bind_props($$props, { class: className, errorClasses });
  pop();
}
__name(Form_field_errors, "Form_field_errors");
function Form_field($$payload, $$props) {
  push();
  let form = $$props["form"];
  let name3 = $$props["name"];
  let className = fallback($$props["class"], void 0);
  Field($$payload, {
    form,
    name: name3,
    children: invalid_default_snippet,
    $$slots: {
      default: ($$payload2, { constraints: constraints2, errors, tainted, value }) => {
        $$payload2.out += `<div${attr("class", cn("space-y-2", className))}><!---->`;
        slot($$payload2, $$props, "default", { constraints: constraints2, errors, tainted, value }, null);
        $$payload2.out += `<!----></div>`;
      }
    }
  });
  bind_props($$props, { form, name: name3, class: className });
  pop();
}
__name(Form_field, "Form_field");
function FundWalletAlert($$payload) {
  $$payload.out += `<div class="mt-10 rounded-lg bg-[#A9692F] p-4"><h2 class="mb-2 font-semibold">Fund Your Wallet!</h2> <p class="mb-2 text-sm">Take advantage of this opportunity to fund your wallet and stake more to increase your
		excitement and rewards.</p> <button type="button" class="w-full rounded-full bg-white px-4 py-2 text-sm font-semibold text-[#A9692F]">Fund wallet</button></div>`;
}
__name(FundWalletAlert, "FundWalletAlert");
function TournamentDrawer($$payload) {
  Drawer($$payload, {
    children: ($$payload2) => {
      Trigger($$payload2, {
        children: ($$payload3) => {
          Avatar($$payload3, {
            children: ($$payload4) => {
              Avatar_image($$payload4, {
                src: "https://github.com/shadcn.png",
                alt: "@shadcn"
              });
              $$payload4.out += `<!----> `;
              Avatar_fallback($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->CN`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!---->`;
            },
            $$slots: { default: true }
          });
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!----> `;
      Drawer_content($$payload2, {
        class: " mx-auto max-w-md border-none bg-[#2E2E30] p-6 text-white",
        children: ($$payload3) => {
          $$payload3.out += `<div class="flex justify-end">`;
          Close($$payload3, {
            class: "text-gray-400 hover:text-white",
            children: ($$payload4) => {
              X($$payload4, { size: 24 });
            },
            $$slots: { default: true }
          });
          $$payload3.out += `<!----></div> <div class="space-y-6 text-center"><img src="/verified.svg" class="mx-auto w-fit" alt=""> <p class="font-medium uppercase">PUBLIC TOURNAMENT SUCCESSFUL</p> <p class="pb-10 text-center text-sm">You have successfully created a public tournament. You will be notified how many players are
				interested.</p> <div class="space-y-5"><div class="flex items-center justify-between"><p>Variant</p> <p>Blitz</p></div> <div class="flex items-center justify-between"><p>Minute per side</p> <p>10 minutes</p></div> <div class="flex items-center justify-between"><p>Date</p> <p>28/09/2024</p></div> <div class="flex items-center justify-between"><p>Time</p> <p>12:00pm</p></div> <div class="flex items-center justify-between"><p>Staking amount</p> <p>5,000</p></div></div> `;
          Button($$payload3, {
            variant: "outline",
            class: "mt-6 w-full rounded-full bg-[#3574F5]",
            children: ($$payload4) => {
              $$payload4.out += `<!---->Share link`;
            },
            $$slots: { default: true }
          });
          $$payload3.out += `<!----></div>`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!---->`;
    },
    $$slots: { default: true }
  });
}
__name(TournamentDrawer, "TournamentDrawer");
var FORM_FIELD;
var FORM_CONTROL;
var Control;
var init_TournamentDrawer = __esm({
  ".svelte-kit/output/server/chunks/TournamentDrawer.js"() {
    init_index2();
    init_utils3();
    init_create();
    init_updater();
    init_index4();
    init_action();
    init_clsx();
    init_index3();
    init_index6();
    init_avatar_fallback();
    init_button();
    FORM_FIELD = Symbol("FORM_FIELD_CTX");
    FORM_CONTROL = Symbol("FORM_CONTROL_CTX");
    Control = Control$1;
  }
});
function Input($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "value", "readonly"]);
  push();
  let className = fallback($$props["class"], void 0);
  let value = fallback($$props["value"], void 0);
  let readonly2 = fallback($$props["readonly"], void 0);
  $$payload.out += `<input${spread_attributes({
    class: cn("flex h-[56px] w-full rounded-md border border-input bg-white px-3 py-2 text-sm text-background ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50", className),
    value,
    readonly: readonly2,
    ...$$restProps
  })}>`;
  bind_props($$props, { class: className, value, readonly: readonly2 });
  pop();
}
__name(Input, "Input");
var init_input = __esm({
  ".svelte-kit/output/server/chunks/input.js"() {
    init_index2();
    init_utils3();
  }
});
var page_svelte_exports7 = {};
__export(page_svelte_exports7, {
  default: () => _page7
});
function Form_button($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, []);
  Button($$payload, spread_props([
    { type: "submit" },
    $$restProps,
    {
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
}
__name(Form_button, "Form_button");
function Cat($$payload, $$props) {
  push();
  var $$store_subs;
  let { catForm } = $$props;
  const form = superForm(catForm, {
    validators: zodClient(createTournamentSchema)
  });
  const { enhance: enhance2, delayed, form: formData } = form;
  let $$settled = true;
  let $$inner_payload;
  function $$render_inner($$payload2) {
    $$payload2.out += `<h1 class="mb-10 text-2xl font-medium">Create a Tournament</h1> <form method="POST" class="relative w-full"><!---->`;
    Form_field($$payload2, {
      form,
      name: "timeControl",
      children: ($$payload3) => {
        $$payload3.out += `<!---->`;
        Control($$payload3, {
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload4, { attrs }) => {
              $$payload4.out += `<!---->`;
              Form_label($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Time control`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Input($$payload4, spread_props([
                attrs,
                {
                  get value() {
                    return store_get($$store_subs ??= {}, "$formData", formData).timeControl;
                  },
                  set value($$value) {
                    store_mutate($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).timeControl = $$value);
                    $$settled = false;
                  }
                }
              ]));
              $$payload4.out += `<!---->`;
            }
          }
        });
        $$payload3.out += `<!----> <!---->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!---->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----> <!---->`;
    Form_field($$payload2, {
      form,
      name: "timeControl",
      children: ($$payload3) => {
        $$payload3.out += `<!---->`;
        Control($$payload3, {
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload4, { attrs }) => {
              $$payload4.out += `<!---->`;
              Form_label($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Variant`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Input($$payload4, spread_props([
                attrs,
                {
                  get value() {
                    return store_get($$store_subs ??= {}, "$formData", formData).timeControl;
                  },
                  set value($$value) {
                    store_mutate($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).timeControl = $$value);
                    $$settled = false;
                  }
                }
              ]));
              $$payload4.out += `<!---->`;
            }
          }
        });
        $$payload3.out += `<!----> <!---->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!---->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----> <!---->`;
    Form_field($$payload2, {
      form,
      name: "timeControl",
      children: ($$payload3) => {
        $$payload3.out += `<!---->`;
        Control($$payload3, {
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload4, { attrs }) => {
              $$payload4.out += `<!---->`;
              Form_label($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Increment per seconds`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Input($$payload4, spread_props([
                attrs,
                {
                  get value() {
                    return store_get($$store_subs ??= {}, "$formData", formData).timeControl;
                  },
                  set value($$value) {
                    store_mutate($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).timeControl = $$value);
                    $$settled = false;
                  }
                }
              ]));
              $$payload4.out += `<!---->`;
            }
          }
        });
        $$payload3.out += `<!----> <!---->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!---->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----> <!---->`;
    Form_field($$payload2, {
      form,
      name: "timeControl",
      children: ($$payload3) => {
        $$payload3.out += `<!---->`;
        Control($$payload3, {
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload4, { attrs }) => {
              $$payload4.out += `<!---->`;
              Form_label($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Tournament fee`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Input($$payload4, spread_props([
                attrs,
                {
                  get value() {
                    return store_get($$store_subs ??= {}, "$formData", formData).timeControl;
                  },
                  set value($$value) {
                    store_mutate($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).timeControl = $$value);
                    $$settled = false;
                  }
                }
              ]));
              $$payload4.out += `<!---->`;
            }
          }
        });
        $$payload3.out += `<!----> <!---->`;
        Form_description($$payload3, {
          children: ($$payload4) => {
            $$payload4.out += `<!---->Private tournaments are not free. A fee is compulsory.`;
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!----> <!---->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!---->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----> `;
    FundWalletAlert($$payload2);
    $$payload2.out += `<!----> <div class="sticky bottom-0 left-0 mt-8 w-full border-t border-gray-700 bg-black px-5 py-5">`;
    Button($$payload2, {
      href: "play",
      class: "w-full rounded-full bg-blue-600 py-3 text-white",
      children: ($$payload3) => {
        $$payload3.out += `<!---->Create tournament`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----></div> `;
    TournamentDrawer($$payload2);
    $$payload2.out += `<!----></form>`;
  }
  __name($$render_inner, "$$render_inner");
  do {
    $$settled = true;
    $$inner_payload = copy_payload($$payload);
    $$render_inner($$inner_payload);
  } while (!$$settled);
  assign_payload($$payload, $$inner_payload);
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
__name(Cat, "Cat");
function Ip($$payload, $$props) {
  push();
  var $$store_subs;
  let { ipForm } = $$props;
  const form = superForm(ipForm, { validators: zodClient(instantPlaySchema) });
  const { enhance: enhance2, delayed, form: formData } = form;
  let $$settled = true;
  let $$inner_payload;
  function $$render_inner($$payload2) {
    $$payload2.out += `<h1 class="mb-10 text-2xl font-medium">Instant Play</h1> <form method="POST" class="relative w-full"><!---->`;
    Form_field($$payload2, {
      form,
      name: "arenaName",
      children: ($$payload3) => {
        $$payload3.out += `<!---->`;
        Control($$payload3, {
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload4, { attrs }) => {
              $$payload4.out += `<!---->`;
              Form_label($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Arena name`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Input($$payload4, spread_props([
                attrs,
                {
                  get value() {
                    return store_get($$store_subs ??= {}, "$formData", formData).arenaName;
                  },
                  set value($$value) {
                    store_mutate($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).arenaName = $$value);
                    $$settled = false;
                  }
                }
              ]));
              $$payload4.out += `<!---->`;
            }
          }
        });
        $$payload3.out += `<!----> <!---->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!---->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----> <!---->`;
    Form_field($$payload2, {
      form,
      name: "arenaName",
      children: ($$payload3) => {
        $$payload3.out += `<!---->`;
        Control($$payload3, {
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload4, { attrs }) => {
              $$payload4.out += `<!---->`;
              Form_label($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Variant`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Input($$payload4, spread_props([
                attrs,
                {
                  get value() {
                    return store_get($$store_subs ??= {}, "$formData", formData).arenaName;
                  },
                  set value($$value) {
                    store_mutate($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).arenaName = $$value);
                    $$settled = false;
                  }
                }
              ]));
              $$payload4.out += `<!---->`;
            }
          }
        });
        $$payload3.out += `<!----> <!---->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!---->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----> <!---->`;
    Form_field($$payload2, {
      form,
      name: "arenaName",
      children: ($$payload3) => {
        $$payload3.out += `<!---->`;
        Control($$payload3, {
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload4, { attrs }) => {
              $$payload4.out += `<!---->`;
              Form_label($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Time control`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Input($$payload4, spread_props([
                attrs,
                {
                  get value() {
                    return store_get($$store_subs ??= {}, "$formData", formData).arenaName;
                  },
                  set value($$value) {
                    store_mutate($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).arenaName = $$value);
                    $$settled = false;
                  }
                }
              ]));
              $$payload4.out += `<!---->`;
            }
          }
        });
        $$payload3.out += `<!----> <!---->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!---->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----> <!---->`;
    Form_field($$payload2, {
      form,
      name: "arenaName",
      children: ($$payload3) => {
        $$payload3.out += `<!---->`;
        Control($$payload3, {
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload4, { attrs }) => {
              $$payload4.out += `<!---->`;
              Form_label($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Maximum number of players`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Input($$payload4, spread_props([
                attrs,
                {
                  get value() {
                    return store_get($$store_subs ??= {}, "$formData", formData).arenaName;
                  },
                  set value($$value) {
                    store_mutate($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).arenaName = $$value);
                    $$settled = false;
                  }
                }
              ]));
              $$payload4.out += `<!---->`;
            }
          }
        });
        $$payload3.out += `<!----> <!---->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!---->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----> <!---->`;
    Form_field($$payload2, {
      form,
      name: "arenaName",
      children: ($$payload3) => {
        $$payload3.out += `<!---->`;
        Control($$payload3, {
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload4, { attrs }) => {
              $$payload4.out += `<!---->`;
              Form_label($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Staking amount`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Input($$payload4, spread_props([
                attrs,
                {
                  get value() {
                    return store_get($$store_subs ??= {}, "$formData", formData).arenaName;
                  },
                  set value($$value) {
                    store_mutate($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).arenaName = $$value);
                    $$settled = false;
                  }
                }
              ]));
              $$payload4.out += `<!---->`;
            }
          }
        });
        $$payload3.out += `<!----> <!---->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!---->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----> `;
    FundWalletAlert($$payload2);
    $$payload2.out += `<!----> <div class="sticky bottom-0 left-0 mt-8 w-full border-t border-gray-700 bg-black px-5 py-5">`;
    Button($$payload2, {
      href: "play",
      class: "w-full rounded-full bg-blue-600 py-3 text-white",
      children: ($$payload3) => {
        $$payload3.out += `<!---->Create game`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----></div></form>`;
  }
  __name($$render_inner, "$$render_inner");
  do {
    $$settled = true;
    $$inner_payload = copy_payload($$payload);
    $$render_inner($$inner_payload);
  } while (!$$settled);
  assign_payload($$payload, $$inner_payload);
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
__name(Ip, "Ip");
function Pwc2($$payload, $$props) {
  push();
  var $$store_subs;
  let { pwcForm } = $$props;
  const form = superForm(pwcForm, {
    validators: zodClient(playWithComputerSchema)
  });
  const { enhance: enhance2, delayed, form: formData } = form;
  let $$settled = true;
  let $$inner_payload;
  function $$render_inner($$payload2) {
    $$payload2.out += `<h1 class="mb-10 text-2xl font-medium">Play With Computer</h1> <form method="POST" class="relative w-full"><!---->`;
    Form_field($$payload2, {
      form,
      name: "variant",
      children: ($$payload3) => {
        $$payload3.out += `<!---->`;
        Control($$payload3, {
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload4, { attrs }) => {
              $$payload4.out += `<!---->`;
              Form_label($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Variant`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Input($$payload4, spread_props([
                attrs,
                {
                  get value() {
                    return store_get($$store_subs ??= {}, "$formData", formData).variant;
                  },
                  set value($$value) {
                    store_mutate($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).variant = $$value);
                    $$settled = false;
                  }
                }
              ]));
              $$payload4.out += `<!---->`;
            }
          }
        });
        $$payload3.out += `<!----> <!---->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!---->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----> <!---->`;
    Form_field($$payload2, {
      form,
      name: "minutes",
      children: ($$payload3) => {
        $$payload3.out += `<!---->`;
        Control($$payload3, {
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload4, { attrs }) => {
              $$payload4.out += `<!---->`;
              Form_label($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Minutes per side`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Input($$payload4, spread_props([
                attrs,
                {
                  get value() {
                    return store_get($$store_subs ??= {}, "$formData", formData).minutes;
                  },
                  set value($$value) {
                    store_mutate($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).minutes = $$value);
                    $$settled = false;
                  }
                }
              ]));
              $$payload4.out += `<!---->`;
            }
          }
        });
        $$payload3.out += `<!----> <!---->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!---->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----> <!---->`;
    Form_field($$payload2, {
      form,
      name: "stakingAmount",
      children: ($$payload3) => {
        $$payload3.out += `<!---->`;
        Control($$payload3, {
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload4, { attrs }) => {
              $$payload4.out += `<!---->`;
              Form_label($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Staking amount`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Input($$payload4, spread_props([
                attrs,
                {
                  get value() {
                    return store_get($$store_subs ??= {}, "$formData", formData).stakingAmount;
                  },
                  set value($$value) {
                    store_mutate($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).stakingAmount = $$value);
                    $$settled = false;
                  }
                }
              ]));
              $$payload4.out += `<!---->`;
            }
          }
        });
        $$payload3.out += `<!----> <!---->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!---->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----> <!---->`;
    Form_field($$payload2, {
      form,
      name: "stakingAmount",
      children: ($$payload3) => {
        $$payload3.out += `<!---->`;
        Control($$payload3, {
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload4, { attrs }) => {
              $$payload4.out += `<!---->`;
              Form_label($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Staking amount`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Input($$payload4, spread_props([
                attrs,
                {
                  get value() {
                    return store_get($$store_subs ??= {}, "$formData", formData).stakingAmount;
                  },
                  set value($$value) {
                    store_mutate($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).stakingAmount = $$value);
                    $$settled = false;
                  }
                }
              ]));
              $$payload4.out += `<!---->`;
            }
          }
        });
        $$payload3.out += `<!----> <!---->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!---->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----> <div class="sticky bottom-0 left-0 mt-8 w-full border-t border-gray-700 bg-black px-5 py-5">`;
    Button($$payload2, {
      href: "play",
      class: "w-full rounded-full bg-blue-600 py-3 text-white",
      children: ($$payload3) => {
        $$payload3.out += `<!---->create game now`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----></div></form>`;
  }
  __name($$render_inner, "$$render_inner");
  do {
    $$settled = true;
    $$inner_payload = copy_payload($$payload);
    $$render_inner($$inner_payload);
  } while (!$$settled);
  assign_payload($$payload, $$inner_payload);
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
__name(Pwc2, "Pwc2");
function InviteDrawer($$payload) {
  Drawer($$payload, {
    children: ($$payload2) => {
      Trigger($$payload2, {
        children: ($$payload3) => {
          Avatar($$payload3, {
            children: ($$payload4) => {
              Avatar_image($$payload4, {
                src: "https://github.com/shadcn.png",
                alt: "@shadcn"
              });
              $$payload4.out += `<!----> `;
              Avatar_fallback($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->CN`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!---->`;
            },
            $$slots: { default: true }
          });
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!----> `;
      Drawer_content($$payload2, {
        class: " mx-auto max-w-md border-none bg-[#2E2E30] p-6 text-white",
        children: ($$payload3) => {
          $$payload3.out += `<div class="flex justify-end">`;
          Close($$payload3, {
            class: "text-gray-400 hover:text-white",
            children: ($$payload4) => {
              X($$payload4, { size: 24 });
            },
            $$slots: { default: true }
          });
          $$payload3.out += `<!----></div> <div class="space-y-4 text-center"><img src="/verified.svg" class="mx-auto w-fit" alt=""> <p class="font-medium uppercase">invite link</p> <p class="text-center">Copy the invite link below and share with your opponent.</p> `;
          Input($$payload3, { value: "ertyvubeg7ui3wg7eui", disabled: true });
          $$payload3.out += `<!----> `;
          Button($$payload3, {
            variant: "outline",
            class: "mt-6 w-full rounded-full bg-[#3574F5]",
            children: ($$payload4) => {
              $$payload4.out += `<!---->Copy link`;
            },
            $$slots: { default: true }
          });
          $$payload3.out += `<!----></div>`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!---->`;
    },
    $$slots: { default: true }
  });
}
__name(InviteDrawer, "InviteDrawer");
function Pwf($$payload, $$props) {
  push();
  var $$store_subs;
  let { pwfForm } = $$props;
  const form = superForm(pwfForm, {
    validators: zodClient(playWithFriendSchema)
  });
  const { enhance: enhance2, delayed, form: formData } = form;
  let $$settled = true;
  let $$inner_payload;
  function $$render_inner($$payload2) {
    $$payload2.out += `<div class="mb-10 min-h-screen bg-black text-white"><h1 class="mb-6 text-2xl font-medium">Play With Friend</h1> <form method="POST" class="space-y-4"><!---->`;
    Form_field($$payload2, {
      form,
      name: "friendUsername",
      children: ($$payload3) => {
        $$payload3.out += `<!---->`;
        Control($$payload3, {
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload4, { attrs }) => {
              $$payload4.out += `<!---->`;
              Form_label($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Friend's username`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Input($$payload4, spread_props([
                attrs,
                {
                  get value() {
                    return store_get($$store_subs ??= {}, "$formData", formData).friendUsername;
                  },
                  set value($$value) {
                    store_mutate($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).friendUsername = $$value);
                    $$settled = false;
                  },
                  placeholder: "e.g Beast_Mode"
                }
              ]));
              $$payload4.out += `<!---->`;
            }
          }
        });
        $$payload3.out += `<!----> <!---->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!---->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----> <!---->`;
    Form_field($$payload2, {
      form,
      name: "variant",
      children: ($$payload3) => {
        $$payload3.out += `<!---->`;
        Control($$payload3, {
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload4, { attrs }) => {
              $$payload4.out += `<!---->`;
              Form_label($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Variant`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> <select${spread_attributes({
                ...attrs,
                class: "h-[56px] w-full rounded bg-white p-2 text-black"
              })}><option value="" disabled selected>Choose variant</option><option value="standard">Standard</option><option value="blitz">Blitz</option><option value="rapid">Rapid</option></select>`;
            }
          }
        });
        $$payload3.out += `<!----> <!---->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!---->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----> <!---->`;
    Form_field($$payload2, {
      form,
      name: "timeControl",
      children: ($$payload3) => {
        $$payload3.out += `<!---->`;
        Control($$payload3, {
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload4, { attrs }) => {
              $$payload4.out += `<!---->`;
              Form_label($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Time control`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> <select${spread_attributes({
                ...attrs,
                class: "h-[56px] w-full rounded bg-white p-2 text-black"
              })}><option value="" disabled selected>Select time control</option><option value="5+0">5+0</option><option value="10+0">10+0</option><option value="15+10">15+10</option></select>`;
            }
          }
        });
        $$payload3.out += `<!----> <!---->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!---->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----> <!---->`;
    Form_field($$payload2, {
      form,
      name: "stakingAmount",
      children: ($$payload3) => {
        $$payload3.out += `<!---->`;
        Control($$payload3, {
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload4, { attrs }) => {
              $$payload4.out += `<!---->`;
              Form_label($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Staking amount \u20A6`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Input($$payload4, spread_props([
                attrs,
                {
                  get value() {
                    return store_get($$store_subs ??= {}, "$formData", formData).stakingAmount;
                  },
                  set value($$value) {
                    store_mutate($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).stakingAmount = $$value);
                    $$settled = false;
                  },
                  placeholder: "e.g 1,000"
                }
              ]));
              $$payload4.out += `<!---->`;
            }
          }
        });
        $$payload3.out += `<!----> <!---->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!---->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----> <div class="mt-6 rounded-lg bg-orange-700 p-4"><h2 class="mb-2 font-semibold">Fund Your Wallet!</h2> <p class="mb-2 text-sm">Take advantage of this opportunity to fund your wallet and stake more to increase your
				excitement and rewards.</p> <button type="button" class="rounded-full bg-white px-4 py-2 text-sm font-semibold text-orange-700">Fund wallet</button></div> <div class="sticky bottom-0 left-0 mt-8 w-full border-t border-gray-700 bg-black px-5 py-5"><!---->`;
    Form_button($$payload2, {
      class: "w-full rounded-full bg-blue-600 py-3 text-white",
      children: ($$payload3) => {
        $$payload3.out += `<!---->Send invite`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----></div> `;
    InviteDrawer($$payload2);
    $$payload2.out += `<!----></form></div>`;
  }
  __name($$render_inner, "$$render_inner");
  do {
    $$settled = true;
    $$inner_payload = copy_payload($$payload);
    $$render_inner($$inner_payload);
  } while (!$$settled);
  assign_payload($$payload, $$inner_payload);
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
__name(Pwf, "Pwf");
function ScheduleDrawer($$payload) {
  Drawer($$payload, {
    children: ($$payload2) => {
      Trigger($$payload2, {
        children: ($$payload3) => {
          Avatar($$payload3, {
            children: ($$payload4) => {
              Avatar_image($$payload4, {
                src: "https://github.com/shadcn.png",
                alt: "@shadcn"
              });
              $$payload4.out += `<!----> `;
              Avatar_fallback($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->CN`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!---->`;
            },
            $$slots: { default: true }
          });
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!----> `;
      Drawer_content($$payload2, {
        class: " mx-auto max-w-md border-none bg-[#2E2E30] p-6 text-white",
        children: ($$payload3) => {
          $$payload3.out += `<div class="flex justify-end">`;
          Close($$payload3, {
            class: "text-gray-400 hover:text-white",
            children: ($$payload4) => {
              X($$payload4, { size: 24 });
            },
            $$slots: { default: true }
          });
          $$payload3.out += `<!----></div> <div class="space-y-6 text-center"><img src="/verified.svg" class="mx-auto w-fit" alt=""> <p class="font-medium uppercase">SCHEDULE SUCCESSFUL</p> <p class="text-center">Your game against [opponent\u2019s username] has been scheduled successfully.</p> <div class="flex items-center justify-center gap-3"><p>you</p> <img src="/vs.svg" alt=""> <p>[opponent\u2019s username]</p></div> <div class="space-y-5"><div class="flex items-center justify-between"><p>variant</p> <p>Blitz</p></div> <div class="flex items-center justify-between"><p>Minute per side</p> <p>10 minutes</p></div> <div class="flex items-center justify-between"><p>Date</p> <p>28/09/2024</p></div> <div class="flex items-center justify-between"><p>Time</p> <p>12:00pm</p></div> <div class="flex items-center justify-between"><p>Staking amount</p> <p>5,000</p></div></div></div>`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!---->`;
    },
    $$slots: { default: true }
  });
}
__name(ScheduleDrawer, "ScheduleDrawer");
function Sag($$payload, $$props) {
  push();
  var $$store_subs;
  let { sagForm } = $$props;
  const form = superForm(sagForm, { validators: zodClient(scheduleGameSchema) });
  const { enhance: enhance2, delayed, form: formData } = form;
  let $$settled = true;
  let $$inner_payload;
  function $$render_inner($$payload2) {
    $$payload2.out += `<h1 class="mb-10 text-2xl font-medium">Schedule a Game</h1> <form method="POST" class="relative w-full"><!---->`;
    Form_field($$payload2, {
      form,
      name: "opponentUserName",
      children: ($$payload3) => {
        $$payload3.out += `<!---->`;
        Control($$payload3, {
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload4, { attrs }) => {
              $$payload4.out += `<!---->`;
              Form_label($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Opponent's username`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Input($$payload4, spread_props([
                attrs,
                {
                  get value() {
                    return store_get($$store_subs ??= {}, "$formData", formData).opponentUserName;
                  },
                  set value($$value) {
                    store_mutate($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).opponentUserName = $$value);
                    $$settled = false;
                  }
                }
              ]));
              $$payload4.out += `<!---->`;
            }
          }
        });
        $$payload3.out += `<!----> <!---->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!---->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----> <div class="flex items-center gap-5"><!---->`;
    Form_field($$payload2, {
      form,
      name: "opponentUserName",
      children: ($$payload3) => {
        $$payload3.out += `<!---->`;
        Control($$payload3, {
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload4, { attrs }) => {
              $$payload4.out += `<!---->`;
              Form_label($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Schedule date`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Input($$payload4, spread_props([
                attrs,
                {
                  get value() {
                    return store_get($$store_subs ??= {}, "$formData", formData).opponentUserName;
                  },
                  set value($$value) {
                    store_mutate($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).opponentUserName = $$value);
                    $$settled = false;
                  }
                }
              ]));
              $$payload4.out += `<!---->`;
            }
          }
        });
        $$payload3.out += `<!----> <!---->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!---->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----> <!---->`;
    Form_field($$payload2, {
      form,
      name: "opponentUserName",
      children: ($$payload3) => {
        $$payload3.out += `<!---->`;
        Control($$payload3, {
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload4, { attrs }) => {
              $$payload4.out += `<!---->`;
              Form_label($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Schedule time`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Input($$payload4, spread_props([
                attrs,
                {
                  get value() {
                    return store_get($$store_subs ??= {}, "$formData", formData).opponentUserName;
                  },
                  set value($$value) {
                    store_mutate($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).opponentUserName = $$value);
                    $$settled = false;
                  }
                }
              ]));
              $$payload4.out += `<!---->`;
            }
          }
        });
        $$payload3.out += `<!----> <!---->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!---->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----></div> <!---->`;
    Form_field($$payload2, {
      form,
      name: "opponentUserName",
      children: ($$payload3) => {
        $$payload3.out += `<!---->`;
        Control($$payload3, {
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload4, { attrs }) => {
              $$payload4.out += `<!---->`;
              Form_label($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Variant`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Input($$payload4, spread_props([
                attrs,
                {
                  get value() {
                    return store_get($$store_subs ??= {}, "$formData", formData).opponentUserName;
                  },
                  set value($$value) {
                    store_mutate($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).opponentUserName = $$value);
                    $$settled = false;
                  }
                }
              ]));
              $$payload4.out += `<!---->`;
            }
          }
        });
        $$payload3.out += `<!----> <!---->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!---->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----><!---->`;
    Form_field($$payload2, {
      form,
      name: "opponentUserName",
      children: ($$payload3) => {
        $$payload3.out += `<!---->`;
        Control($$payload3, {
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload4, { attrs }) => {
              $$payload4.out += `<!---->`;
              Form_label($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Time Control`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Input($$payload4, spread_props([
                attrs,
                {
                  get value() {
                    return store_get($$store_subs ??= {}, "$formData", formData).opponentUserName;
                  },
                  set value($$value) {
                    store_mutate($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).opponentUserName = $$value);
                    $$settled = false;
                  }
                }
              ]));
              $$payload4.out += `<!---->`;
            }
          }
        });
        $$payload3.out += `<!----> <!---->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!---->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----><!---->`;
    Form_field($$payload2, {
      form,
      name: "opponentUserName",
      children: ($$payload3) => {
        $$payload3.out += `<!---->`;
        Control($$payload3, {
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload4, { attrs }) => {
              $$payload4.out += `<!---->`;
              Form_label($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Staking amount N`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Input($$payload4, spread_props([
                attrs,
                {
                  get value() {
                    return store_get($$store_subs ??= {}, "$formData", formData).opponentUserName;
                  },
                  set value($$value) {
                    store_mutate($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).opponentUserName = $$value);
                    $$settled = false;
                  }
                }
              ]));
              $$payload4.out += `<!---->`;
            }
          }
        });
        $$payload3.out += `<!----> <!---->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!---->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----> `;
    FundWalletAlert($$payload2);
    $$payload2.out += `<!----> <div class="sticky bottom-0 left-0 mt-8 w-full border-t border-gray-700 bg-black px-5 py-5">`;
    Button($$payload2, {
      href: "play",
      class: "w-full rounded-full bg-blue-600 py-3 text-white",
      children: ($$payload3) => {
        $$payload3.out += `<!---->Schedule game`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----></div> `;
    ScheduleDrawer($$payload2);
    $$payload2.out += `<!----></form>`;
  }
  __name($$render_inner, "$$render_inner");
  do {
    $$settled = true;
    $$inner_payload = copy_payload($$payload);
    $$render_inner($$inner_payload);
  } while (!$$settled);
  assign_payload($$payload, $$inner_payload);
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
__name(Sag, "Sag");
function _page7($$payload, $$props) {
  push();
  var $$store_subs;
  let { data } = $$props;
  if (store_get($$store_subs ??= {}, "$page", page).params.typeOfPlay === "play-with-computer") {
    $$payload.out += "<!--[-->";
    Pwc2($$payload, { pwcForm: data.pwcForm });
  } else {
    $$payload.out += "<!--[!-->";
    if (store_get($$store_subs ??= {}, "$page", page).params.typeOfPlay === "play-with-friend") {
      $$payload.out += "<!--[-->";
      Pwf($$payload, { pwfForm: data.pwfForm });
    } else {
      $$payload.out += "<!--[!-->";
      if (store_get($$store_subs ??= {}, "$page", page).params.typeOfPlay === "schedule-game") {
        $$payload.out += "<!--[-->";
        Sag($$payload, { sagForm: data.sagForm });
      } else {
        $$payload.out += "<!--[!-->";
        if (store_get($$store_subs ??= {}, "$page", page).params.typeOfPlay === "create-tournament") {
          $$payload.out += "<!--[-->";
          Cat($$payload, { catForm: data.catForm });
        } else {
          $$payload.out += "<!--[!-->";
          if (store_get($$store_subs ??= {}, "$page", page).params.typeOfPlay === "instant-play") {
            $$payload.out += "<!--[-->";
            Ip($$payload, { ipForm: data.ipForm });
          } else {
            $$payload.out += "<!--[!-->";
            $$payload.out += `<p>page not found</p>`;
          }
          $$payload.out += `<!--]-->`;
        }
        $$payload.out += `<!--]-->`;
      }
      $$payload.out += `<!--]-->`;
    }
    $$payload.out += `<!--]-->`;
  }
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
__name(_page7, "_page7");
var init_page_svelte7 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/chess/_typeOfPlay_/_page.svelte.js"() {
    init_index2();
    init_stores();
    init_TournamentDrawer();
    init_formSchema();
    init_client();
    init_zod();
    init_chunks();
    init_input();
    init_button();
    init_index6();
    init_avatar_fallback();
    init_index3();
    init_clsx();
  }
});
var __exports11 = {};
__export(__exports11, {
  component: () => component11,
  fonts: () => fonts11,
  imports: () => imports11,
  index: () => index11,
  server: () => page_server_ts_exports2,
  server_id: () => server_id3,
  stylesheets: () => stylesheets11
});
var index11;
var component_cache11;
var component11;
var server_id3;
var imports11;
var stylesheets11;
var fonts11;
var init__11 = __esm({
  ".svelte-kit/output/server/nodes/10.js"() {
    init_page_server_ts2();
    index11 = 10;
    component11 = /* @__PURE__ */ __name(async () => component_cache11 ??= (await Promise.resolve().then(() => (init_page_svelte7(), page_svelte_exports7))).default, "component11");
    server_id3 = "src/routes/(app)/chess/[typeOfPlay]/+page.server.ts";
    imports11 = ["_app/immutable/nodes/10.DKbxaqBw.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/if.DLf01pqE.js", "_app/immutable/chunks/store.CDnLvhlJ.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/stores.DSH2_rmp.js", "_app/immutable/chunks/entry.Zk5XMwWG.js", "_app/immutable/chunks/index-client.bJHR976g.js", "_app/immutable/chunks/index.bE0HzIKx.js", "_app/immutable/chunks/svelte-component.CXtuGKwm.js", "_app/immutable/chunks/actions.DVNHJCdf.js", "_app/immutable/chunks/props.CdXMhF7y.js", "_app/immutable/chunks/TournamentDrawer.lR2hNNEe.js", "_app/immutable/chunks/slot.BDgc6-mN.js", "_app/immutable/chunks/lifecycle.BX15fcyy.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/this.CD6iIRB7.js", "_app/immutable/chunks/utils.B8KE5qsB.js", "_app/immutable/chunks/bundle-mjs.BNYwEHuQ.js", "_app/immutable/chunks/misc.CXN-D0wo.js", "_app/immutable/chunks/create.OoZN6NjL.js", "_app/immutable/chunks/updater.MNDcgVG0.js", "_app/immutable/chunks/events.CdlZ0Ps4.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/class.waVxCJrB.js", "_app/immutable/chunks/action._Er3-yw0.js", "_app/immutable/chunks/index.CplayyMK.js", "_app/immutable/chunks/index.Bi_aB5ul.js", "_app/immutable/chunks/forms.CmnTScIw.js", "_app/immutable/chunks/_commonjsHelpers.CqkleIqs.js", "_app/immutable/chunks/index.AmeJI4DA.js", "_app/immutable/chunks/Icon.DWW-WWR4.js", "_app/immutable/chunks/svelte-element.2QoIbCrV.js", "_app/immutable/chunks/transitions.D2VcR92X.js", "_app/immutable/chunks/avatar-fallback.Dt2LaaM8.js", "_app/immutable/chunks/button.DQVOpKKk.js", "_app/immutable/chunks/input.BuFGoid3.js"];
    stylesheets11 = ["_app/immutable/assets/index.Dr-8sKQJ.css"];
    fonts11 = [];
  }
});
var page_server_ts_exports3 = {};
__export(page_server_ts_exports3, {
  load: () => load3
});
var load3;
var init_page_server_ts3 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/explore/_page.server.ts.js"() {
    load3 = /* @__PURE__ */ __name(async () => {
      return {};
    }, "load3");
  }
});
var page_svelte_exports8 = {};
__export(page_svelte_exports8, {
  default: () => _page8
});
function setEmblaContext(config) {
  setContext(EMBLA_CAROUSEL_CONTEXT, config);
  return config;
}
__name(setEmblaContext, "setEmblaContext");
function getEmblaContext(name3 = "This component") {
  if (!hasContext(EMBLA_CAROUSEL_CONTEXT)) {
    throw new Error(`${name3} must be used within a <Carousel.Root> component`);
  }
  return getContext(EMBLA_CAROUSEL_CONTEXT);
}
__name(getEmblaContext, "getEmblaContext");
function Carousel($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "opts",
    "plugins",
    "api",
    "orientation",
    "class"
  ]);
  push();
  let opts = fallback($$props["opts"], () => ({}), true);
  let plugins = fallback($$props["plugins"], () => [], true);
  let api = fallback($$props["api"], void 0);
  let orientation = fallback($$props["orientation"], "horizontal");
  let className = fallback($$props["class"], void 0);
  const apiStore = writable(void 0);
  const orientationStore = writable(orientation);
  const canScrollPrev = writable(false);
  const canScrollNext = writable(false);
  const optionsStore = writable(opts);
  const pluginStore = writable(plugins);
  const scrollSnapsStore = writable([]);
  const selectedIndexStore = writable(0);
  function scrollPrev() {
    api?.scrollPrev();
  }
  __name(scrollPrev, "scrollPrev");
  function scrollNext() {
    api?.scrollNext();
  }
  __name(scrollNext, "scrollNext");
  function scrollTo(index39, jump) {
    api?.scrollTo(index39, jump);
  }
  __name(scrollTo, "scrollTo");
  function onSelect(api2) {
    if (!api2)
      return;
    canScrollPrev.set(api2.canScrollPrev());
    canScrollNext.set(api2.canScrollNext());
  }
  __name(onSelect, "onSelect");
  function handleKeyDown(e3) {
    if (e3.key === "ArrowLeft") {
      e3.preventDefault();
      scrollPrev();
    } else if (e3.key === "ArrowRight") {
      e3.preventDefault();
      scrollNext();
    }
  }
  __name(handleKeyDown, "handleKeyDown");
  setEmblaContext({
    api: apiStore,
    scrollPrev,
    scrollNext,
    orientation: orientationStore,
    canScrollNext,
    canScrollPrev,
    handleKeyDown,
    options: optionsStore,
    plugins: pluginStore,
    onInit,
    scrollSnaps: scrollSnapsStore,
    selectedIndex: selectedIndexStore,
    scrollTo
  });
  function onInit(event) {
    api = event.detail;
    apiStore.set(api);
    scrollSnapsStore.set(api.scrollSnapList());
  }
  __name(onInit, "onInit");
  onDestroy(() => {
    api?.off("select", onSelect);
  });
  orientationStore.set(orientation);
  pluginStore.set(plugins);
  optionsStore.set(opts);
  if (api) {
    onSelect(api);
    api.on("select", onSelect);
    api.on("reInit", onSelect);
  }
  $$payload.out += `<div${spread_attributes({
    class: cn("relative", className),
    role: "region",
    "aria-roledescription": "carousel",
    ...$$restProps
  })}><!---->`;
  slot($$payload, $$props, "default", {}, null);
  $$payload.out += `<!----></div>`;
  bind_props($$props, {
    opts,
    plugins,
    api,
    orientation,
    class: className
  });
  pop();
}
__name(Carousel, "Carousel");
function Carousel_content($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  var $$store_subs;
  let className = fallback($$props["class"], void 0);
  const { orientation, options: options2, plugins, onInit } = getEmblaContext("<Carousel.Content/>");
  $$payload.out += `<div class="overflow-hidden"><div${spread_attributes({
    class: cn("flex", store_get($$store_subs ??= {}, "$orientation", orientation) === "horizontal" ? "-ml-4" : "-mt-4 flex-col", className),
    "data-embla-container": "",
    ...$$restProps
  })}><!---->`;
  slot($$payload, $$props, "default", {}, null);
  $$payload.out += `<!----></div></div>`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { class: className });
  pop();
}
__name(Carousel_content, "Carousel_content");
function Carousel_item($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class"]);
  push();
  var $$store_subs;
  let className = fallback($$props["class"], void 0);
  const { orientation } = getEmblaContext("<Carousel.Item/>");
  $$payload.out += `<div${spread_attributes({
    role: "group",
    "aria-roledescription": "slide",
    class: cn("min-w-0 shrink-0 grow-0 basis-full", store_get($$store_subs ??= {}, "$orientation", orientation) === "horizontal" ? "pl-4" : "pt-4", className),
    "data-embla-slide": "",
    ...$$restProps
  })}><!---->`;
  slot($$payload, $$props, "default", {}, null);
  $$payload.out += `<!----></div>`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { class: className });
  pop();
}
__name(Carousel_item, "Carousel_item");
function _page8($$payload) {
  const games = [
    {
      href: "/chess",
      imgHead: "/chessCard/chessHeader.svg",
      imgBoard: "/chessCard/chessboard.svg"
    },
    {
      href: "/uno",
      imgHead: "/unoCard/unoHead.png",
      imgBoard: "/unoCard/unoBoard.png"
    },
    {
      href: "/ludo",
      imgHead: "/ludoCard/ludoHead.png",
      imgBoard: "/ludoCard/ludoBoard.png"
    },
    {
      href: "/checkers",
      imgHead: "/checkerCard/checkerHead.png",
      imgBoard: "/checkerCard/checkerBoard.png"
    },
    {
      href: "/rps",
      imgHead: "/rpsCard/rpsHead.png",
      imgBoard: "/rpsCard/rpsBoard.png"
    }
  ];
  $$payload.out += `<div><h1 class="mb-20 text-2xl font-medium">Explore</h1></div> `;
  Carousel($$payload, {
    class: "mb-10 w-full",
    children: ($$payload2) => {
      Carousel_content($$payload2, {
        class: "-ml-6 ",
        children: ($$payload3) => {
          const each_array = ensure_array_like(games);
          $$payload3.out += `<!--[-->`;
          for (let i2 = 0, $$length = each_array.length; i2 < $$length; i2++) {
            let { href, imgBoard, imgHead } = each_array[i2];
            Carousel_item($$payload3, {
              class: " basis-2/3 pl-6 md:basis-1/2 lg:basis-1/2",
              children: ($$payload4) => {
                $$payload4.out += `<div class="relative h-full object-contain"><img${attr("src", imgHead)} alt=""> <img${attr("src", imgBoard)} class="rounded-b-md" alt=""> `;
                Button($$payload4, {
                  href,
                  class: "absolute bottom-5 left-1/2 -translate-x-1/2 bg-black font-bold uppercase ",
                  children: ($$payload5) => {
                    $$payload5.out += `<!---->Tap To Play`;
                  },
                  $$slots: { default: true }
                });
                $$payload4.out += `<!----></div>`;
              },
              $$slots: { default: true }
            });
          }
          $$payload3.out += `<!--]-->`;
        },
        $$slots: { default: true }
      });
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!---->`;
}
__name(_page8, "_page8");
var EMBLA_CAROUSEL_CONTEXT;
var init_page_svelte8 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/explore/_page.svelte.js"() {
    init_index2();
    init_index4();
    init_index_server();
    init_utils3();
    init_clsx();
    init_index3();
    init_button();
    EMBLA_CAROUSEL_CONTEXT = Symbol("EMBLA_CAROUSEL_CONTEXT");
  }
});
var __exports12 = {};
__export(__exports12, {
  component: () => component12,
  fonts: () => fonts12,
  imports: () => imports12,
  index: () => index12,
  server: () => page_server_ts_exports3,
  server_id: () => server_id4,
  stylesheets: () => stylesheets12
});
var index12;
var component_cache12;
var component12;
var server_id4;
var imports12;
var stylesheets12;
var fonts12;
var init__12 = __esm({
  ".svelte-kit/output/server/nodes/11.js"() {
    init_page_server_ts3();
    index12 = 11;
    component12 = /* @__PURE__ */ __name(async () => component_cache12 ??= (await Promise.resolve().then(() => (init_page_svelte8(), page_svelte_exports8))).default, "component12");
    server_id4 = "src/routes/(app)/explore/+page.server.ts";
    imports12 = ["_app/immutable/nodes/11.DujYRnhp.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/slot.BDgc6-mN.js", "_app/immutable/chunks/lifecycle.BX15fcyy.js", "_app/immutable/chunks/misc.CXN-D0wo.js", "_app/immutable/chunks/props.CdXMhF7y.js", "_app/immutable/chunks/store.CDnLvhlJ.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/index-client.bJHR976g.js", "_app/immutable/chunks/index.bE0HzIKx.js", "_app/immutable/chunks/utils.B8KE5qsB.js", "_app/immutable/chunks/bundle-mjs.BNYwEHuQ.js", "_app/immutable/chunks/actions.DVNHJCdf.js", "_app/immutable/chunks/index.CplayyMK.js", "_app/immutable/chunks/index.Bi_aB5ul.js", "_app/immutable/chunks/create.OoZN6NjL.js", "_app/immutable/chunks/button.DQVOpKKk.js", "_app/immutable/chunks/if.DLf01pqE.js", "_app/immutable/chunks/svelte-element.2QoIbCrV.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/this.CD6iIRB7.js"];
    stylesheets12 = [];
    fonts12 = [];
  }
});
var page_svelte_exports9 = {};
__export(page_svelte_exports9, {
  default: () => _page9
});
function _page9($$payload) {
  const playOptions = [
    {
      icon: "./circleComputer.svg",
      title: "Play with computer",
      subTitle: "Play against our ever smart AI bots now.",
      href: "play-with-computer"
    },
    {
      icon: "./playWithFriends.svg",
      title: "Play with Friend",
      subTitle: "Create and play your favorite game with a friend now.",
      href: "play-with-friend"
    },
    {
      icon: "./schedule.svg",
      title: "Schedule game",
      subTitle: "Schedule and play your favorite game at a later time.",
      href: "schedule-game"
    },
    {
      icon: "./circleTournament.svg",
      title: "Create tournament",
      subTitle: "Create and play your favourite game with a friend now.",
      href: "create-tournament"
    },
    {
      icon: "./instantPlay.svg",
      title: "Instant play",
      subTitle: "Create and play your favourite game at a later time.",
      href: "instant-play"
    }
  ];
  const each_array = ensure_array_like(playOptions);
  const each_array_1 = ensure_array_like({ length: 5 });
  $$payload.out += `<h1 class="mb-10 text-2xl font-medium">Ludo</h1> <div class="grid grid-cols-2 gap-3 sm:gap-5"><!--[-->`;
  for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
    let { icon, subTitle, title, href } = each_array[$$index];
    $$payload.out += `<a${attr("href", `/ludo/${stringify(href)}`)} class="w-full space-y-1 rounded-md border border-[#6D6D6E] px-3 py-[18px]"><img${attr("src", icon)} alt=""> <p class="text-sm font-semibold">${escape_html(title)}</p> <p class="mt-1 text-[10px] font-light">${escape_html(subTitle)}</p></a>`;
  }
  $$payload.out += `<!--]--></div> <div class="mt-10"><p class="mb-4">Quick pairing</p> <div class="space-y-4"><!--[-->`;
  for (let $$index_1 = 0, $$length = each_array_1.length; $$index_1 < $$length; $$index_1++) {
    each_array_1[$$index_1];
    $$payload.out += `<div class="rounded-md border border-[#AFAFAF] p-4"><div class="mb-2 flex justify-between text-sm font-medium"><p>Loser pay</p> <p>(#)Free</p></div> <p class="mb-2 flex items-center gap-5 text-xs text-[#AFAFAF]"><img src="/people.svg" alt=""> <span class="font-medium">2</span></p> <p class="mb-2 flex items-center gap-5 text-xs text-[#AFAFAF]"><img src="/clock.svg" alt=""> <span class="font-medium">5 hours</span></p> <div class="mb-2 flex items-center justify-between text-xs text-[#AFAFAF]"><p class="flex items-center gap-5"><img src="/lock.svg" alt=""> <span class="font-medium">Public</span></p> <p>2 users joined</p></div></div>`;
  }
  $$payload.out += `<!--]--></div></div>`;
}
__name(_page9, "_page9");
var init_page_svelte9 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/ludo/_page.svelte.js"() {
    init_index2();
    init_index3();
  }
});
var __exports13 = {};
__export(__exports13, {
  component: () => component13,
  fonts: () => fonts13,
  imports: () => imports13,
  index: () => index13,
  stylesheets: () => stylesheets13
});
var index13;
var component_cache13;
var component13;
var imports13;
var stylesheets13;
var fonts13;
var init__13 = __esm({
  ".svelte-kit/output/server/nodes/12.js"() {
    index13 = 12;
    component13 = /* @__PURE__ */ __name(async () => component_cache13 ??= (await Promise.resolve().then(() => (init_page_svelte9(), page_svelte_exports9))).default, "component13");
    imports13 = ["_app/immutable/nodes/12.CET_qiAT.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js", "_app/immutable/chunks/index.CplayyMK.js", "_app/immutable/chunks/index.Bi_aB5ul.js", "_app/immutable/chunks/bundle-mjs.BNYwEHuQ.js", "_app/immutable/chunks/create.OoZN6NjL.js", "_app/immutable/chunks/index.bE0HzIKx.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/index-client.bJHR976g.js"];
    stylesheets13 = [];
    fonts13 = [];
  }
});
var page_svelte_exports10 = {};
__export(page_svelte_exports10, {
  default: () => _page10
});
function Pwc3($$payload) {
  let colors = ["#3574F5", "#E93223", "#285614", "#F7DF4B"];
  const each_array = ensure_array_like(colors);
  $$payload.out += `<h1 class="mb-10 text-2xl font-medium">Play With Computer</h1> <p class="mb-4 font-medium capitalize">Choose Your Color</p> <div class="mx-auto grid w-full grid-cols-2 gap-5"><!--[-->`;
  for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
    let color = each_array[$$index];
    $$payload.out += `<button class="relative h-fit w-full rounded-md active:border-4 active:border-blue-400"><div class="h-[170px] w-full rounded-md"${attr("style", `background-color:${stringify(color)}`)}></div> <div class="absolute left-[16px] top-[16px] size-[24px] rounded-full border-2 bg-white"></div></button>`;
  }
  $$payload.out += `<!--]--></div>`;
}
__name(Pwc3, "Pwc3");
function _page10($$payload) {
  Pwc3($$payload);
}
__name(_page10, "_page10");
var init_page_svelte10 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/ludo/_typeOfPlay_/_page.svelte.js"() {
    init_index2();
  }
});
var __exports14 = {};
__export(__exports14, {
  component: () => component14,
  fonts: () => fonts14,
  imports: () => imports14,
  index: () => index14,
  stylesheets: () => stylesheets14
});
var index14;
var component_cache14;
var component14;
var imports14;
var stylesheets14;
var fonts14;
var init__14 = __esm({
  ".svelte-kit/output/server/nodes/13.js"() {
    index14 = 13;
    component14 = /* @__PURE__ */ __name(async () => component_cache14 ??= (await Promise.resolve().then(() => (init_page_svelte10(), page_svelte_exports10))).default, "component14");
    imports14 = ["_app/immutable/nodes/13.s93kMlWL.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js", "_app/immutable/chunks/utils.M4KGanEH.js"];
    stylesheets14 = [];
    fonts14 = [];
  }
});
var page_svelte_exports11 = {};
__export(page_svelte_exports11, {
  default: () => _page11
});
function File_text($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const iconNode = [
    [
      "path",
      {
        "d": "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"
      }
    ],
    ["path", { "d": "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { "d": "M10 9H8" }],
    ["path", { "d": "M16 13H8" }],
    ["path", { "d": "M16 17H8" }]
  ];
  Icon($$payload, spread_props([
    { name: "file-text" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
}
__name(File_text, "File_text");
function Headphones($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const iconNode = [
    [
      "path",
      {
        "d": "M3 14h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-7a9 9 0 0 1 18 0v7a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3"
      }
    ]
  ];
  Icon($$payload, spread_props([
    { name: "headphones" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
}
__name(Headphones, "Headphones");
function Heart($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const iconNode = [
    [
      "path",
      {
        "d": "M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z"
      }
    ]
  ];
  Icon($$payload, spread_props([
    { name: "heart" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
}
__name(Heart, "Heart");
function History($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const iconNode = [
    [
      "path",
      {
        "d": "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"
      }
    ],
    ["path", { "d": "M3 3v5h5" }],
    ["path", { "d": "M12 7v5l4 2" }]
  ];
  Icon($$payload, spread_props([
    { name: "history" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
}
__name(History, "History");
function Log_out($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const iconNode = [
    [
      "path",
      { "d": "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4" }
    ],
    [
      "polyline",
      { "points": "16 17 21 12 16 7" }
    ],
    [
      "line",
      {
        "x1": "21",
        "x2": "9",
        "y1": "12",
        "y2": "12"
      }
    ]
  ];
  Icon($$payload, spread_props([
    { name: "log-out" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
}
__name(Log_out, "Log_out");
function Settings($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const iconNode = [
    [
      "path",
      {
        "d": "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"
      }
    ],
    [
      "circle",
      { "cx": "12", "cy": "12", "r": "3" }
    ]
  ];
  Icon($$payload, spread_props([
    { name: "settings" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
}
__name(Settings, "Settings");
function Wallet($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const iconNode = [
    [
      "path",
      {
        "d": "M19 7V4a1 1 0 0 0-1-1H5a2 2 0 0 0 0 4h15a1 1 0 0 1 1 1v4h-3a2 2 0 0 0 0 4h3a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1"
      }
    ],
    [
      "path",
      {
        "d": "M3 5v14a2 2 0 0 0 2 2h15a1 1 0 0 0 1-1v-4"
      }
    ]
  ];
  Icon($$payload, spread_props([
    { name: "wallet" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
}
__name(Wallet, "Wallet");
function _page11($$payload, $$props) {
  push();
  let data = $$props["data"];
  let menuItems = [
    {
      icon: History,
      label: "Game history",
      color: "text-white",
      href: "/more/game-history"
    },
    {
      icon: Settings,
      label: "Settings",
      color: "text-white",
      href: "/more/settings"
    },
    {
      icon: Wallet,
      label: "My wallet",
      color: "text-white",
      href: "/more/wallet"
    },
    {
      icon: Headphones,
      label: "Customer support",
      color: "text-white",
      href: "/more/support"
    },
    {
      icon: Heart,
      label: "Write a review",
      color: "text-white",
      href: "/more/reviews"
    },
    {
      icon: File_text,
      label: "FAQ",
      color: "text-white",
      href: "/more/faq"
    },
    {
      icon: Log_out,
      label: "Logout",
      color: "text-red-500"
    }
  ];
  const each_array = ensure_array_like(menuItems);
  $$payload.out += `<h1 class="mb-10 text-2xl font-medium">More</h1> <div><!--[-->`;
  for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
    let item = each_array[$$index];
    $$payload.out += `<button class="flex w-full items-center justify-between border-b border-gray-700 py-6 pl-2 transition-all last:border-b-0 hover:rounded-md hover:bg-gray-900/70"><div class="flex items-center"><!---->`;
    item.icon?.($$payload, { class: `${item.color} mr-3`, size: 20 });
    $$payload.out += `<!----> <span${attr("class", item.color)}>${escape_html(item.label)}</span></div> <svg class="h-4 w-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg></button>`;
  }
  $$payload.out += `<!--]--></div>`;
  bind_props($$props, { data });
  pop();
}
__name(_page11, "_page11");
var init_page_svelte11 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/more/_page.svelte.js"() {
    init_index2();
    init_client();
    init_Icon();
  }
});
var __exports15 = {};
__export(__exports15, {
  component: () => component15,
  fonts: () => fonts15,
  imports: () => imports15,
  index: () => index15,
  stylesheets: () => stylesheets15
});
var index15;
var component_cache15;
var component15;
var imports15;
var stylesheets15;
var fonts15;
var init__15 = __esm({
  ".svelte-kit/output/server/nodes/14.js"() {
    index15 = 14;
    component15 = /* @__PURE__ */ __name(async () => component_cache15 ??= (await Promise.resolve().then(() => (init_page_svelte11(), page_svelte_exports11))).default, "component15");
    imports15 = ["_app/immutable/nodes/14.DXX3dkFc.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/svelte-component.CXtuGKwm.js", "_app/immutable/chunks/class.waVxCJrB.js", "_app/immutable/chunks/lifecycle.BX15fcyy.js", "_app/immutable/chunks/props.CdXMhF7y.js", "_app/immutable/chunks/store.CDnLvhlJ.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/entry.Zk5XMwWG.js", "_app/immutable/chunks/index-client.bJHR976g.js", "_app/immutable/chunks/index.bE0HzIKx.js", "_app/immutable/chunks/slot.BDgc6-mN.js", "_app/immutable/chunks/Icon.DWW-WWR4.js", "_app/immutable/chunks/svelte-element.2QoIbCrV.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js"];
    stylesheets15 = [];
    fonts15 = [];
  }
});
var page_svelte_exports12 = {};
__export(page_svelte_exports12, {
  default: () => _page12
});
function _page12($$payload) {
  const each_array = ensure_array_like({ length: 5 });
  $$payload.out += `<h1 class="mb-10 text-2xl font-medium capitalize">Frequently Asked Questions</h1> <ul class="space-y-5 px-5"><!--[-->`;
  for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
    each_array[$$index];
    $$payload.out += `<li class="list-decimal"><p class="mb-2 text-lg text-[#C6C6C6]">Frequently Asked Questions</p> <p class="text-sm">Lorem ipsum dolor sit amet consectetur. Congue arcu dictum odio ut. Sit sed at venenatis
				natoque donec. Auctor cursus senectus morbi consectetur interdum mauris.</p></li>`;
  }
  $$payload.out += `<!--]--></ul>`;
}
__name(_page12, "_page12");
var init_page_svelte12 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/more/faq/_page.svelte.js"() {
    init_index2();
  }
});
var __exports16 = {};
__export(__exports16, {
  component: () => component16,
  fonts: () => fonts16,
  imports: () => imports16,
  index: () => index16,
  stylesheets: () => stylesheets16
});
var index16;
var component_cache16;
var component16;
var imports16;
var stylesheets16;
var fonts16;
var init__16 = __esm({
  ".svelte-kit/output/server/nodes/15.js"() {
    index16 = 15;
    component16 = /* @__PURE__ */ __name(async () => component_cache16 ??= (await Promise.resolve().then(() => (init_page_svelte12(), page_svelte_exports12))).default, "component16");
    imports16 = ["_app/immutable/nodes/15.BmK1pNB2.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/each.BsZK1HXx.js"];
    stylesheets16 = [];
    fonts16 = [];
  }
});
var page_server_ts_exports4 = {};
__export(page_server_ts_exports4, {
  load: () => load4
});
var load4;
var init_page_server_ts4 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/more/game-history/_page.server.ts.js"() {
    load4 = /* @__PURE__ */ __name(async () => {
      return {};
    }, "load4");
  }
});
var page_svelte_exports13 = {};
__export(page_svelte_exports13, {
  default: () => _page13
});
function Search($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const iconNode = [
    [
      "circle",
      { "cx": "11", "cy": "11", "r": "8" }
    ],
    ["path", { "d": "m21 21-4.3-4.3" }]
  ];
  Icon($$payload, spread_props([
    { name: "search" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
}
__name(Search, "Search");
function _page13($$payload, $$props) {
  let data = $$props["data"];
  $$payload.out += `<h1 class="mb-10 text-2xl font-medium">Game History</h1> `;
  Root2($$payload, {
    value: "tournaments",
    children: ($$payload2) => {
      Tabs_list($$payload2, {
        children: ($$payload3) => {
          Tabs_trigger($$payload3, {
            value: "tournaments",
            children: ($$payload4) => {
              $$payload4.out += `<!---->Tournaments`;
            },
            $$slots: { default: true }
          });
          $$payload3.out += `<!----> `;
          Tabs_trigger($$payload3, {
            value: "scheduled",
            children: ($$payload4) => {
              $$payload4.out += `<!---->Scheduled games`;
            },
            $$slots: { default: true }
          });
          $$payload3.out += `<!---->`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!----> `;
      Tabs_content($$payload2, {
        value: "tournaments",
        children: ($$payload3) => {
          const each_array = ensure_array_like({ length: 5 });
          $$payload3.out += `<div class="my-5 flex w-full items-center gap-2 rounded-2xl border border-[#AFAFAF] py-3">`;
          Search($$payload3, { class: "ml-4 size-4 text-[#AFAFAF] " });
          $$payload3.out += `<!----> <input type="text" class="w-full flex-1 border-none bg-transparent outline-none" name="" id="" placeholder="Search"></div> <div class="space-y-4"><!--[-->`;
          for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
            each_array[$$index];
            $$payload3.out += `<a href="/tournament/tournament-history" class="block rounded-md border border-[#AFAFAF] p-4"><div class="mb-2 flex justify-between text-sm font-medium"><p>Blitz</p> <p>(#)25,000</p></div> <p class="mb-2 flex items-center gap-5 text-xs text-[#AFAFAF]"><img src="/people.svg" alt=""> <span class="font-medium">2</span></p> <p class="mb-2 flex items-center gap-5 text-xs text-[#AFAFAF]"><img src="/clock.svg" alt=""> <span class="font-medium">5 hours</span></p> <div class="mb-2 flex items-center justify-between text-xs text-[#AFAFAF]"><p class="flex items-center gap-5"><img src="/lock.svg" alt=""> <span class="font-medium">Public</span></p> <p>% users joined</p></div></a>`;
          }
          $$payload3.out += `<!--]--></div>`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!----> `;
      Tabs_content($$payload2, {
        value: "scheduled",
        children: ($$payload3) => {
          $$payload3.out += `<!---->Change your password here.`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!---->`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!---->`;
  bind_props($$props, { data });
}
__name(_page13, "_page13");
var init_page_svelte13 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/more/game-history/_page.svelte.js"() {
    init_index2();
    init_index5();
    init_Icon();
  }
});
var __exports17 = {};
__export(__exports17, {
  component: () => component17,
  fonts: () => fonts17,
  imports: () => imports17,
  index: () => index17,
  server: () => page_server_ts_exports4,
  server_id: () => server_id5,
  stylesheets: () => stylesheets17
});
var index17;
var component_cache17;
var component17;
var server_id5;
var imports17;
var stylesheets17;
var fonts17;
var init__17 = __esm({
  ".svelte-kit/output/server/nodes/16.js"() {
    init_page_server_ts4();
    index17 = 16;
    component17 = /* @__PURE__ */ __name(async () => component_cache17 ??= (await Promise.resolve().then(() => (init_page_svelte13(), page_svelte_exports13))).default, "component17");
    server_id5 = "src/routes/(app)/more/game-history/+page.server.ts";
    imports17 = ["_app/immutable/nodes/16.j0yxbBCJ.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/props.CdXMhF7y.js", "_app/immutable/chunks/store.CDnLvhlJ.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/index.59QgRJh5.js", "_app/immutable/chunks/slot.BDgc6-mN.js", "_app/immutable/chunks/lifecycle.BX15fcyy.js", "_app/immutable/chunks/create.OoZN6NjL.js", "_app/immutable/chunks/index.bE0HzIKx.js", "_app/immutable/chunks/index-client.bJHR976g.js", "_app/immutable/chunks/if.DLf01pqE.js", "_app/immutable/chunks/actions.DVNHJCdf.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/this.CD6iIRB7.js", "_app/immutable/chunks/utils.B8KE5qsB.js", "_app/immutable/chunks/bundle-mjs.BNYwEHuQ.js", "_app/immutable/chunks/misc.CXN-D0wo.js", "_app/immutable/chunks/events.CdlZ0Ps4.js", "_app/immutable/chunks/updater.MNDcgVG0.js", "_app/immutable/chunks/Icon.DWW-WWR4.js", "_app/immutable/chunks/svelte-element.2QoIbCrV.js", "_app/immutable/chunks/render.RIqL4_R6.js"];
    stylesheets17 = [];
    fonts17 = [];
  }
});
var page_svelte_exports14 = {};
__export(page_svelte_exports14, {
  default: () => _page14
});
function Star($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const iconNode = [
    [
      "polygon",
      {
        "points": "12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"
      }
    ]
  ];
  Icon($$payload, spread_props([
    { name: "star" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
}
__name(Star, "Star");
function _page14($$payload) {
  const each_array = ensure_array_like({ length: 5 });
  const each_array_1 = ensure_array_like({ length: 5 });
  $$payload.out += `<h1 class="mb-10 text-2xl font-medium capitalize">Write a review</h1> <div class="grid h-[134px] place-items-center border-y"><div class="flex items-center gap-5"><h2 class="text-xl font-semibold">5.0</h2> <div class="space-y-1"><div class="flex items-center gap-1"><!--[-->`;
  for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
    each_array[$$index];
    Star($$payload, {});
  }
  $$payload.out += `<!--]--> <p class="text-lg font-semibold">(1M+)</p></div> <p>average rating</p></div></div></div> <div class="space-y-5"><!--[-->`;
  for (let $$index_2 = 0, $$length = each_array_1.length; $$index_2 < $$length; $$index_2++) {
    each_array_1[$$index_2];
    const each_array_2 = ensure_array_like({ length: 5 });
    $$payload.out += `<div class="mt-5 space-x-2"><div class="flex items-center gap-1"><!--[-->`;
    for (let $$index_1 = 0, $$length2 = each_array_2.length; $$index_1 < $$length2; $$index_1++) {
      each_array_2[$$index_1];
      Star($$payload, {});
    }
    $$payload.out += `<!--]--></div> <p class="text-lg">Toni Franey</p> <p class="text-sm">Lorem ipsum dolor sit amet consectetur. Congue arcu dictum odio ut. Sit sed at venenatis
				natoque donec. Auctor cursus senectus morbi consectetur interdum mauris.</p></div>`;
  }
  $$payload.out += `<!--]--></div>`;
}
__name(_page14, "_page14");
var init_page_svelte14 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/more/reviews/_page.svelte.js"() {
    init_index2();
    init_index3();
    init_Icon();
  }
});
var __exports18 = {};
__export(__exports18, {
  component: () => component18,
  fonts: () => fonts18,
  imports: () => imports18,
  index: () => index18,
  stylesheets: () => stylesheets18
});
var index18;
var component_cache18;
var component18;
var imports18;
var stylesheets18;
var fonts18;
var init__18 = __esm({
  ".svelte-kit/output/server/nodes/17.js"() {
    index18 = 17;
    component18 = /* @__PURE__ */ __name(async () => component_cache18 ??= (await Promise.resolve().then(() => (init_page_svelte14(), page_svelte_exports14))).default, "component18");
    imports18 = ["_app/immutable/nodes/17.BgkQIP9x.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/index.CplayyMK.js", "_app/immutable/chunks/index.Bi_aB5ul.js", "_app/immutable/chunks/bundle-mjs.BNYwEHuQ.js", "_app/immutable/chunks/create.OoZN6NjL.js", "_app/immutable/chunks/index.bE0HzIKx.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/index-client.bJHR976g.js", "_app/immutable/chunks/slot.BDgc6-mN.js", "_app/immutable/chunks/props.CdXMhF7y.js", "_app/immutable/chunks/store.CDnLvhlJ.js", "_app/immutable/chunks/Icon.DWW-WWR4.js", "_app/immutable/chunks/svelte-element.2QoIbCrV.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js", "_app/immutable/chunks/lifecycle.BX15fcyy.js"];
    stylesheets18 = [];
    fonts18 = [];
  }
});
var page_svelte_exports15 = {};
__export(page_svelte_exports15, {
  default: () => _page15
});
function User_round($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const iconNode = [
    [
      "circle",
      { "cx": "12", "cy": "8", "r": "5" }
    ],
    ["path", { "d": "M20 21a8 8 0 0 0-16 0" }]
  ];
  Icon($$payload, spread_props([
    { name: "user-round" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
}
__name(User_round, "User_round");
function _page15($$payload, $$props) {
  push();
  let menuItems = [
    {
      label: "Mange profile",
      icon: User_round,
      href: "/more/settings/manage-profile"
    },
    {
      label: "Notifications",
      icon: Bell,
      href: "/more/settings/notification"
    }
  ];
  const each_array = ensure_array_like(menuItems);
  $$payload.out += `<h1 class="mb-10 text-2xl font-medium">Settings</h1> <div><!--[-->`;
  for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
    let item = each_array[$$index];
    $$payload.out += `<button class="flex w-full items-center justify-between border-b border-gray-700 py-6 pl-2 transition-all last:border-b-0 hover:rounded-md hover:bg-gray-900/70"><div class="flex items-center"><!---->`;
    item.icon?.($$payload, { class: "mr-3", size: 20 });
    $$payload.out += `<!----> <span>${escape_html(item.label)}</span></div> <svg class="h-4 w-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg></button>`;
  }
  $$payload.out += `<!--]--></div>`;
  pop();
}
__name(_page15, "_page15");
var init_page_svelte15 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/more/settings/_page.svelte.js"() {
    init_index2();
    init_client();
    init_Icon();
    init_bell();
  }
});
var __exports19 = {};
__export(__exports19, {
  component: () => component19,
  fonts: () => fonts19,
  imports: () => imports19,
  index: () => index19,
  stylesheets: () => stylesheets19
});
var index19;
var component_cache19;
var component19;
var imports19;
var stylesheets19;
var fonts19;
var init__19 = __esm({
  ".svelte-kit/output/server/nodes/18.js"() {
    index19 = 18;
    component19 = /* @__PURE__ */ __name(async () => component_cache19 ??= (await Promise.resolve().then(() => (init_page_svelte15(), page_svelte_exports15))).default, "component19");
    imports19 = ["_app/immutable/nodes/18.D6UVQ6qs.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/svelte-component.CXtuGKwm.js", "_app/immutable/chunks/lifecycle.BX15fcyy.js", "_app/immutable/chunks/entry.Zk5XMwWG.js", "_app/immutable/chunks/index-client.bJHR976g.js", "_app/immutable/chunks/index.bE0HzIKx.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/slot.BDgc6-mN.js", "_app/immutable/chunks/props.CdXMhF7y.js", "_app/immutable/chunks/store.CDnLvhlJ.js", "_app/immutable/chunks/Icon.DWW-WWR4.js", "_app/immutable/chunks/svelte-element.2QoIbCrV.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js", "_app/immutable/chunks/bell.CwWxVUA7.js"];
    stylesheets19 = [];
    fonts19 = [];
  }
});
var page_server_ts_exports5 = {};
__export(page_server_ts_exports5, {
  actions: () => actions,
  load: () => load5
});
var load5;
var actions;
var init_page_server_ts5 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/more/settings/manage-profile/_page.server.ts.js"() {
    init_schema();
    init_chunks();
    init_drizzle_orm();
    load5 = /* @__PURE__ */ __name(async ({ locals: { user } }) => {
      console.log("\u{1F680} ~ load ~ user:", user);
      if (!user) {
        redirect(308, "/login");
      }
      return {
        user
      };
    }, "load5");
    actions = {
      default: async ({ locals: { user, db: db2 }, request }) => {
        if (!user)
          redirect(308, "/login");
        const form = await request.formData();
        const platform2 = form.get("platform");
        const handle2 = form.get("handle");
        switch (platform2) {
          case "twitter":
            await db2.update(usersTable).set({
              xHandle: handle2
            }).where(eq(usersTable.id, user.id));
            console.log("\u{1F680} ~ default: ~ platform:", platform2);
            return { handle: handle2 };
          case "facebook":
            await db2.update(usersTable).set({
              facebookHandle: handle2
            }).where(eq(usersTable.id, user.id));
            break;
          case "instagram":
            await db2.update(usersTable).set({
              instagramHandle: handle2
            }).where(eq(usersTable.id, user.id));
            break;
        }
      }
    };
  }
});
var page_svelte_exports16 = {};
__export(page_svelte_exports16, {
  default: () => _page16
});
function At_sign($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const iconNode = [
    [
      "circle",
      { "cx": "12", "cy": "12", "r": "4" }
    ],
    [
      "path",
      {
        "d": "M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-4 8"
      }
    ]
  ];
  Icon($$payload, spread_props([
    { name: "at-sign" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
}
__name(At_sign, "At_sign");
function Facebook($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const iconNode = [
    [
      "path",
      {
        "d": "M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"
      }
    ]
  ];
  Icon($$payload, spread_props([
    { name: "facebook" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
}
__name(Facebook, "Facebook");
function Instagram($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const iconNode = [
    [
      "rect",
      {
        "width": "20",
        "height": "20",
        "x": "2",
        "y": "2",
        "rx": "5",
        "ry": "5"
      }
    ],
    [
      "path",
      {
        "d": "M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"
      }
    ],
    [
      "line",
      {
        "x1": "17.5",
        "x2": "17.51",
        "y1": "6.5",
        "y2": "6.5"
      }
    ]
  ];
  Icon($$payload, spread_props([
    { name: "instagram" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
}
__name(Instagram, "Instagram");
function Pencil($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const iconNode = [
    [
      "path",
      {
        "d": "M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z"
      }
    ],
    ["path", { "d": "m15 5 4 4" }]
  ];
  Icon($$payload, spread_props([
    { name: "pencil" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
}
__name(Pencil, "Pencil");
function Twitter($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const iconNode = [
    [
      "path",
      {
        "d": "M22 4s-.7 2.1-2 3.4c1.6 10-9.4 17.3-18 11.6 2.2.1 4.4-.6 6-2C3 15.5.5 9.6 3 5c2.2 2.6 5.6 4.1 9 4-.9-4.2 4-6.6 7-3.8 1.1 0 3-1.2 3-1.2z"
      }
    ]
  ];
  Icon($$payload, spread_props([
    { name: "twitter" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
}
__name(Twitter, "Twitter");
function _page16($$payload, $$props) {
  push();
  let { data, form } = $$props;
  data.user;
  console.log("\u{1F680} ~ data:", data);
  let menuItems = [
    {
      label: "email",
      subLabel: data.user.email,
      icon: At_sign
    },
    {
      label: "twitter",
      subLabel: data.user.xHandle,
      icon: Twitter
    },
    {
      label: "instagram",
      subLabel: data.user.instagramHandle,
      icon: Instagram
    },
    {
      label: "facebook",
      subLabel: data.user.facebookHandle,
      icon: Facebook
    }
  ];
  console.log("\u{1F680} ~ menuItems:", menuItems);
  let editingStates = menuItems.map(() => false);
  const each_array = ensure_array_like(menuItems);
  $$payload.out += `<h1 class="mb-10 text-2xl font-medium">Manage Profile</h1> <div class="mx-auto mb-8 w-fit text-center"><!---->`;
  Avatar($$payload, {
    class: "mx-auto size-24",
    children: ($$payload2) => {
      $$payload2.out += `<!---->`;
      Avatar_image($$payload2, { src: data.user.picture, alt: "@shadcn" });
      $$payload2.out += `<!----> <!---->`;
      Avatar_fallback($$payload2, {
        children: ($$payload3) => {
          $$payload3.out += `<!---->${escape_html(data.user.name)}`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!---->`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!----> <h2 class="text-3xl font-bold">@${escape_html(data.user.name)}</h2></div> <div><!--[-->`;
  for (let index39 = 0, $$length = each_array.length; index39 < $$length; index39++) {
    let item = each_array[index39];
    $$payload.out += `<div class="flex w-full items-center justify-between border-b border-gray-700 py-6 pl-2 transition-all last:border-b-0 hover:rounded-md hover:bg-gray-900/70"><div class="flex items-center gap-3"><!---->`;
    item.icon?.($$payload, { class: "mr-3", size: 20 });
    $$payload.out += `<!----> <div class="text-left"><div class="text-xs capitalize">${escape_html(item.label)}</div> <form method="POST" class="font-medium capitalize">`;
    if (editingStates[index39]) {
      $$payload.out += "<!--[-->";
      $$payload.out += `<input name="handle" class="bg-background" type="text"> <input name="platform"${attr("value", item.label)} hidden class="bg-background" type="text">`;
    } else {
      $$payload.out += "<!--[!-->";
      if (item.subLabel) {
        $$payload.out += "<!--[-->";
        $$payload.out += `${escape_html(item.subLabel)}`;
      } else {
        $$payload.out += "<!--[!-->";
        $$payload.out += `Not Added Yet`;
      }
      $$payload.out += `<!--]-->`;
    }
    $$payload.out += `<!--]--> <button></button></form></div></div> `;
    if (item.label !== "email") {
      $$payload.out += "<!--[-->";
      $$payload.out += `<button class="flex size-7 items-center justify-center rounded-full bg-[#F1F1F1] text-black">`;
      Pencil($$payload, { class: "size-4 text-black" });
      $$payload.out += `<!----></button>`;
    } else {
      $$payload.out += "<!--[!-->";
    }
    $$payload.out += `<!--]--></div>`;
  }
  $$payload.out += `<!--]--></div>`;
  pop();
}
__name(_page16, "_page16");
var init_page_svelte16 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/more/settings/manage-profile/_page.svelte.js"() {
    init_index2();
    init_avatar_fallback();
    init_clsx();
    init_client();
    init_Icon();
  }
});
var __exports20 = {};
__export(__exports20, {
  component: () => component20,
  fonts: () => fonts20,
  imports: () => imports20,
  index: () => index20,
  server: () => page_server_ts_exports5,
  server_id: () => server_id6,
  stylesheets: () => stylesheets20
});
var index20;
var component_cache20;
var component20;
var server_id6;
var imports20;
var stylesheets20;
var fonts20;
var init__20 = __esm({
  ".svelte-kit/output/server/nodes/19.js"() {
    init_page_server_ts5();
    index20 = 19;
    component20 = /* @__PURE__ */ __name(async () => component_cache20 ??= (await Promise.resolve().then(() => (init_page_svelte16(), page_svelte_exports16))).default, "component20");
    server_id6 = "src/routes/(app)/more/settings/manage-profile/+page.server.ts";
    imports20 = ["_app/immutable/nodes/19.D6SqDK1_.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/if.DLf01pqE.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/svelte-component.CXtuGKwm.js", "_app/immutable/chunks/actions.DVNHJCdf.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js", "_app/immutable/chunks/props.CdXMhF7y.js", "_app/immutable/chunks/store.CDnLvhlJ.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/avatar-fallback.Dt2LaaM8.js", "_app/immutable/chunks/slot.BDgc6-mN.js", "_app/immutable/chunks/lifecycle.BX15fcyy.js", "_app/immutable/chunks/create.OoZN6NjL.js", "_app/immutable/chunks/index.bE0HzIKx.js", "_app/immutable/chunks/index-client.bJHR976g.js", "_app/immutable/chunks/this.CD6iIRB7.js", "_app/immutable/chunks/utils.B8KE5qsB.js", "_app/immutable/chunks/bundle-mjs.BNYwEHuQ.js", "_app/immutable/chunks/updater.MNDcgVG0.js", "_app/immutable/chunks/forms.CmnTScIw.js", "_app/immutable/chunks/entry.Zk5XMwWG.js", "_app/immutable/chunks/Icon.DWW-WWR4.js", "_app/immutable/chunks/svelte-element.2QoIbCrV.js"];
    stylesheets20 = [];
    fonts20 = [];
  }
});
var page_svelte_exports17 = {};
__export(page_svelte_exports17, {
  default: () => _page17
});
function _page17($$payload) {
  $$payload.out += `<h1 class="mb-10 text-2xl font-medium">Notification</h1> <div class="mb-10 space-y-6"><div class="flex items-center justify-between"><div><h2 class="text-base font-medium">Enable notification</h2></div> <div class="size-5 bg-blue-500"></div></div> <div class="flex items-center justify-between"><div><h2 class="mb-1 text-base font-medium">Discoverable nearby</h2> <p class="text-xs font-light">Enable this feature to find nearby people playing BroadRoom.</p></div> <div class="size-5 bg-blue-500"></div></div> <div class="flex items-center justify-between"><div><h2 class="mb-1 text-base font-medium">Tournament mode</h2> <p class="text-xs font-light">Get notified when tournaments are about to begin.</p></div> <div class="size-5 bg-blue-500"></div></div></div> <div><h3 class="mb-4 font-medium text-[#AFAFAF]">Report a foul play</h3> <div class="space-y-4">`;
  Input($$payload, {});
  $$payload.out += `<!----> `;
  Input($$payload, {});
  $$payload.out += `<!----></div></div>`;
}
__name(_page17, "_page17");
var init_page_svelte17 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/more/settings/notification/_page.svelte.js"() {
    init_input();
  }
});
var __exports21 = {};
__export(__exports21, {
  component: () => component21,
  fonts: () => fonts21,
  imports: () => imports21,
  index: () => index21,
  stylesheets: () => stylesheets21
});
var index21;
var component_cache21;
var component21;
var imports21;
var stylesheets21;
var fonts21;
var init__21 = __esm({
  ".svelte-kit/output/server/nodes/20.js"() {
    index21 = 20;
    component21 = /* @__PURE__ */ __name(async () => component_cache21 ??= (await Promise.resolve().then(() => (init_page_svelte17(), page_svelte_exports17))).default, "component21");
    imports21 = ["_app/immutable/nodes/20.CZXIzpWO.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/input.BuFGoid3.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js", "_app/immutable/chunks/lifecycle.BX15fcyy.js", "_app/immutable/chunks/misc.CXN-D0wo.js", "_app/immutable/chunks/props.CdXMhF7y.js", "_app/immutable/chunks/store.CDnLvhlJ.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/utils.B8KE5qsB.js", "_app/immutable/chunks/bundle-mjs.BNYwEHuQ.js"];
    stylesheets21 = [];
    fonts21 = [];
  }
});
var page_server_ts_exports6 = {};
__export(page_server_ts_exports6, {
  load: () => load6
});
var load6;
var init_page_server_ts6 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/more/support/_page.server.ts.js"() {
    load6 = /* @__PURE__ */ __name(async () => {
      return {};
    }, "load6");
  }
});
var page_svelte_exports18 = {};
__export(page_svelte_exports18, {
  default: () => _page18
});
function _page18($$payload) {
  $$payload.out += `<h1 class="mb-10 text-2xl font-medium">Customer Support</h1> <div class="px-5"><h2 class="mb-2 text-center font-semibold">We\u2019re here to help you!</h2> <p class="mb-2 text-center text-xs font-normal">Lorem ipsum dolor sit amet consectetur. Congue arcu dictum odio ut. Sit sed at venenatis natoque
		donec. Auctor cursus senectus morbi consectetur interdum mauris.</p> <p class="mb-2 text-center text-xs font-normal">Lorem ipsum dolor sit amet consectetur. Congue arcu dictum odio ut. Sit sed at venenatis natoque
		donec. Auctor cursus senectus morbi consectetur interdum mauris.</p> <div class="mb-4 space-y-3">`;
  Button($$payload, {
    class: "w-full  rounded-full border border-white bg-black",
    children: ($$payload2) => {
      $$payload2.out += `<!---->Call us`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!----> `;
  Button($$payload, {
    class: "w-full rounded-full border border-white bg-blue-600 py-3 text-white",
    children: ($$payload2) => {
      $$payload2.out += `<!---->Chat with us`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!----></div> <p class="text-center text-xs">Unable to reach us? <a href="/more/faq" class="text-blue-600">Visit our FAQ page</a></p></div>`;
}
__name(_page18, "_page18");
var init_page_svelte18 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/more/support/_page.svelte.js"() {
    init_index3();
    init_button();
  }
});
var __exports22 = {};
__export(__exports22, {
  component: () => component22,
  fonts: () => fonts22,
  imports: () => imports22,
  index: () => index22,
  server: () => page_server_ts_exports6,
  server_id: () => server_id7,
  stylesheets: () => stylesheets22
});
var index22;
var component_cache22;
var component22;
var server_id7;
var imports22;
var stylesheets22;
var fonts22;
var init__22 = __esm({
  ".svelte-kit/output/server/nodes/21.js"() {
    init_page_server_ts6();
    index22 = 21;
    component22 = /* @__PURE__ */ __name(async () => component_cache22 ??= (await Promise.resolve().then(() => (init_page_svelte18(), page_svelte_exports18))).default, "component22");
    server_id7 = "src/routes/(app)/more/support/+page.server.ts";
    imports22 = ["_app/immutable/nodes/21.6bYrdRWb.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/index.CplayyMK.js", "_app/immutable/chunks/index.Bi_aB5ul.js", "_app/immutable/chunks/bundle-mjs.BNYwEHuQ.js", "_app/immutable/chunks/create.OoZN6NjL.js", "_app/immutable/chunks/index.bE0HzIKx.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/index-client.bJHR976g.js", "_app/immutable/chunks/button.DQVOpKKk.js", "_app/immutable/chunks/slot.BDgc6-mN.js", "_app/immutable/chunks/lifecycle.BX15fcyy.js", "_app/immutable/chunks/misc.CXN-D0wo.js", "_app/immutable/chunks/props.CdXMhF7y.js", "_app/immutable/chunks/store.CDnLvhlJ.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/if.DLf01pqE.js", "_app/immutable/chunks/svelte-element.2QoIbCrV.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/actions.DVNHJCdf.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js", "_app/immutable/chunks/this.CD6iIRB7.js", "_app/immutable/chunks/utils.B8KE5qsB.js"];
    stylesheets22 = [];
    fonts22 = [];
  }
});
var page_server_ts_exports7 = {};
__export(page_server_ts_exports7, {
  load: () => load7
});
var load7;
var init_page_server_ts7 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/more/wallet/_page.server.ts.js"() {
    load7 = /* @__PURE__ */ __name(async () => {
      return {};
    }, "load7");
  }
});
var page_svelte_exports19 = {};
__export(page_svelte_exports19, {
  default: () => _page19
});
function _page19($$payload) {
  $$payload.out += `<h1 class="mb-10 text-2xl font-medium">Wallet</h1> <div class="mb-6 text-center"><p class="capitalize text-[#C6C6C6]">Total Balance</p> <p class="text-2xl font-bold">0.00</p></div> <div class="flex items-center justify-between gap-5">`;
  Button($$payload, {
    class: "w-full  rounded-full border border-white bg-black",
    children: ($$payload2) => {
      $$payload2.out += `<!---->Withdraw`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!----> `;
  Button($$payload, {
    class: "w-full rounded-full border border-white bg-blue-600 py-3 text-white",
    children: ($$payload2) => {
      $$payload2.out += `<!---->Fund Wallet`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!----></div>`;
}
__name(_page19, "_page19");
var init_page_svelte19 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/more/wallet/_page.svelte.js"() {
    init_index3();
    init_button();
  }
});
var __exports23 = {};
__export(__exports23, {
  component: () => component23,
  fonts: () => fonts23,
  imports: () => imports23,
  index: () => index23,
  server: () => page_server_ts_exports7,
  server_id: () => server_id8,
  stylesheets: () => stylesheets23
});
var index23;
var component_cache23;
var component23;
var server_id8;
var imports23;
var stylesheets23;
var fonts23;
var init__23 = __esm({
  ".svelte-kit/output/server/nodes/22.js"() {
    init_page_server_ts7();
    index23 = 22;
    component23 = /* @__PURE__ */ __name(async () => component_cache23 ??= (await Promise.resolve().then(() => (init_page_svelte19(), page_svelte_exports19))).default, "component23");
    server_id8 = "src/routes/(app)/more/wallet/+page.server.ts";
    imports23 = ["_app/immutable/nodes/22.DCQmE-xC.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/index.CplayyMK.js", "_app/immutable/chunks/index.Bi_aB5ul.js", "_app/immutable/chunks/bundle-mjs.BNYwEHuQ.js", "_app/immutable/chunks/create.OoZN6NjL.js", "_app/immutable/chunks/index.bE0HzIKx.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/index-client.bJHR976g.js", "_app/immutable/chunks/button.DQVOpKKk.js", "_app/immutable/chunks/slot.BDgc6-mN.js", "_app/immutable/chunks/lifecycle.BX15fcyy.js", "_app/immutable/chunks/misc.CXN-D0wo.js", "_app/immutable/chunks/props.CdXMhF7y.js", "_app/immutable/chunks/store.CDnLvhlJ.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/if.DLf01pqE.js", "_app/immutable/chunks/svelte-element.2QoIbCrV.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/actions.DVNHJCdf.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js", "_app/immutable/chunks/this.CD6iIRB7.js", "_app/immutable/chunks/utils.B8KE5qsB.js"];
    stylesheets23 = [];
    fonts23 = [];
  }
});
var page_svelte_exports20 = {};
__export(page_svelte_exports20, {
  default: () => _page20
});
function _page20($$payload) {
  $$payload.out += `<h1 class="mb-[100px] text-2xl font-medium">Notifications</h1> <div class="text-center"><img src="/notification.svg" class="mx-auto mb-4 w-fit" alt=""> <p class="mb-1 text-base font-medium">You don\u2019t have any notifications right <br> now!</p> <p class="text-xs font-normal">We will notify you as soon as we have something to share with you.</p></div>`;
}
__name(_page20, "_page20");
var init_page_svelte20 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/notification/_page.svelte.js"() {
  }
});
var __exports24 = {};
__export(__exports24, {
  component: () => component24,
  fonts: () => fonts24,
  imports: () => imports24,
  index: () => index24,
  stylesheets: () => stylesheets24
});
var index24;
var component_cache24;
var component24;
var imports24;
var stylesheets24;
var fonts24;
var init__24 = __esm({
  ".svelte-kit/output/server/nodes/23.js"() {
    index24 = 23;
    component24 = /* @__PURE__ */ __name(async () => component_cache24 ??= (await Promise.resolve().then(() => (init_page_svelte20(), page_svelte_exports20))).default, "component24");
    imports24 = ["_app/immutable/nodes/23.DsxU65FR.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/template.DAPeAxUe.js"];
    stylesheets24 = [];
    fonts24 = [];
  }
});
var page_svelte_exports21 = {};
__export(page_svelte_exports21, {
  default: () => _page21
});
function CardImage($$payload, $$props) {
  push();
  let src, clipPath, altText, imageStyle;
  let card = $$props["card"];
  let faceDown = fallback($$props["faceDown"], false);
  let gridWidth = fallback($$props["gridWidth"], 14);
  let gridHeight = fallback($$props["gridHeight"], 8);
  let cardWidth = 240;
  let cardHeight = 360;
  src = faceDown ? "/uno.svg" : "/deck.svg";
  clipPath = faceDown ? "none" : `inset(${card.row * cardHeight}px ${(gridWidth - 1 - card.column) * cardWidth}px ${(gridHeight - 1 - card.row) * cardHeight}px ${card.column * cardWidth}px)`;
  altText = faceDown ? "Face-down UNO card" : `UNO card: ${"card.name"}`;
  imageStyle = faceDown ? `background-image: url(${src}); background-size: cover;` : `object-fit: none; object-position: -${card.column * cardWidth}px -${card.row * cardHeight}px;`;
  if (card.row < 0 || card.row >= gridHeight || card.column < 0 || card.column >= gridWidth) {
    console.error("Invalid card position:", card);
  }
  $$payload.out += `<div class="card svelte-1xkc5tv"${attr("style", `clip-path: ${stringify(clipPath)};`)}>`;
  if (faceDown) {
    $$payload.out += "<!--[-->";
    $$payload.out += `<div class="card-face svelte-1xkc5tv"${attr("style", imageStyle)} role="img"${attr("aria-label", altText)}></div>`;
  } else {
    $$payload.out += "<!--[!-->";
    $$payload.out += `<img${attr("src", src)}${attr("alt", altText)}${attr("style", imageStyle)} class="svelte-1xkc5tv">`;
  }
  $$payload.out += `<!--]--></div>`;
  bind_props($$props, { card, faceDown, gridWidth, gridHeight });
  pop();
}
__name(CardImage, "CardImage");
function PlayerHand($$payload, $$props) {
  push();
  let cards = $$props["cards"];
  console.log("\u{1F680} ~ cards:", cards);
  const each_array = ensure_array_like(cards);
  $$payload.out += `<div class="player-hand svelte-z1wv5k"><!--[-->`;
  for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
    let card = each_array[$$index];
    $$payload.out += `<button class="card-container svelte-z1wv5k">`;
    CardImage($$payload, { card });
    $$payload.out += `<!----></button>`;
  }
  $$payload.out += `<!--]--></div>`;
  bind_props($$props, { cards });
  pop();
}
__name(PlayerHand, "PlayerHand");
function ComputerHand($$payload, $$props) {
  let cards = $$props["cards"];
  const each_array = ensure_array_like(cards);
  $$payload.out += `<div class="computer-hand svelte-h6sx7o"><!--[-->`;
  for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
    each_array[$$index];
    CardImage($$payload, { card: {}, faceDown: true });
  }
  $$payload.out += `<!--]--></div>`;
  bind_props($$props, { cards });
}
__name(ComputerHand, "ComputerHand");
function Deck($$payload, $$props) {
  push();
  let deck = $$props["deck"];
  $$payload.out += `<div class="deck svelte-ovd1v2">`;
  CardImage($$payload, { card: {}, faceDown: true });
  $$payload.out += `<!----> <span class="card-count svelte-ovd1v2">${escape_html(deck.length)}</span></div>`;
  bind_props($$props, { deck });
  pop();
}
__name(Deck, "Deck");
function DiscardPile($$payload, $$props) {
  push();
  let cards = $$props["cards"];
  $$payload.out += `<div class="discard-pile svelte-w21m29">`;
  if (cards.length > 0) {
    $$payload.out += "<!--[-->";
    CardImage($$payload, { card: cards[0] });
  } else {
    $$payload.out += "<!--[!-->";
  }
  $$payload.out += `<!--]--></div>`;
  bind_props($$props, { cards });
  pop();
}
__name(DiscardPile, "DiscardPile");
function _page21($$payload, $$props) {
  push();
  let deck = [];
  let playerHand = [];
  let computerHand = [];
  let discardPile = [];
  let currentPlayer = "player";
  $$payload.out += `<main><h1>UNO Game</h1> <button>New Game</button> <div class="game-board svelte-g5a3t">`;
  ComputerHand($$payload, { cards: computerHand });
  $$payload.out += `<!----> <div class="middle-section svelte-g5a3t">`;
  Deck($$payload, { deck });
  $$payload.out += `<!----> `;
  DiscardPile($$payload, { cards: discardPile });
  $$payload.out += `<!----></div> `;
  PlayerHand($$payload, { cards: playerHand });
  $$payload.out += `<!----></div> <p>Current player: ${escape_html(currentPlayer)}</p></main>`;
  pop();
}
__name(_page21, "_page21");
var init_page_svelte21 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/play/_page.svelte.js"() {
    init_index2();
  }
});
var __exports25 = {};
__export(__exports25, {
  component: () => component25,
  fonts: () => fonts25,
  imports: () => imports25,
  index: () => index25,
  stylesheets: () => stylesheets25
});
var index25;
var component_cache25;
var component25;
var imports25;
var stylesheets25;
var fonts25;
var init__25 = __esm({
  ".svelte-kit/output/server/nodes/24.js"() {
    index25 = 24;
    component25 = /* @__PURE__ */ __name(async () => component_cache25 ??= (await Promise.resolve().then(() => (init_page_svelte21(), page_svelte_exports21))).default, "component25");
    imports25 = ["_app/immutable/nodes/24.D8YMl8oA.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/lifecycle.BX15fcyy.js", "_app/immutable/chunks/index-client.bJHR976g.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/props.CdXMhF7y.js", "_app/immutable/chunks/store.CDnLvhlJ.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/if.DLf01pqE.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js"];
    stylesheets25 = ["_app/immutable/assets/24.DuCj01H3.css"];
    fonts25 = [];
  }
});
var page_server_ts_exports8 = {};
var init_page_server_ts8 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/realtime/_page.server.ts.js"() {
  }
});
var QUEEN;
var KING;
var BITS;
var Ox88;
var SIDES;
var ROOKS;
var init_chess = __esm({
  "node_modules/.pnpm/chess.js@1.0.0-beta.8/node_modules/chess.js/dist/esm/chess.js"() {
    QUEEN = "q";
    KING = "k";
    BITS = {
      NORMAL: 1,
      CAPTURE: 2,
      BIG_PAWN: 4,
      EP_CAPTURE: 8,
      PROMOTION: 16,
      KSIDE_CASTLE: 32,
      QSIDE_CASTLE: 64
    };
    Ox88 = {
      a8: 0,
      b8: 1,
      c8: 2,
      d8: 3,
      e8: 4,
      f8: 5,
      g8: 6,
      h8: 7,
      a7: 16,
      b7: 17,
      c7: 18,
      d7: 19,
      e7: 20,
      f7: 21,
      g7: 22,
      h7: 23,
      a6: 32,
      b6: 33,
      c6: 34,
      d6: 35,
      e6: 36,
      f6: 37,
      g6: 38,
      h6: 39,
      a5: 48,
      b5: 49,
      c5: 50,
      d5: 51,
      e5: 52,
      f5: 53,
      g5: 54,
      h5: 55,
      a4: 64,
      b4: 65,
      c4: 66,
      d4: 67,
      e4: 68,
      f4: 69,
      g4: 70,
      h4: 71,
      a3: 80,
      b3: 81,
      c3: 82,
      d3: 83,
      e3: 84,
      f3: 85,
      g3: 86,
      h3: 87,
      a2: 96,
      b2: 97,
      c2: 98,
      d2: 99,
      e2: 100,
      f2: 101,
      g2: 102,
      h2: 103,
      a1: 112,
      b1: 113,
      c1: 114,
      d1: 115,
      e1: 116,
      f1: 117,
      g1: 118,
      h1: 119
    };
    SIDES = {
      [KING]: BITS.KSIDE_CASTLE,
      [QUEEN]: BITS.QSIDE_CASTLE
    };
    ROOKS = {
      w: [
        { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },
        { square: Ox88.h1, flag: BITS.KSIDE_CASTLE }
      ],
      b: [
        { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },
        { square: Ox88.h8, flag: BITS.KSIDE_CASTLE }
      ]
    };
  }
});
var require_pusher = __commonJS({
  "node_modules/.pnpm/pusher-js@8.4.0-rc2/node_modules/pusher-js/dist/web/pusher.js"(exports, module) {
    (/* @__PURE__ */ __name(function webpackUniversalModuleDefinition(root2, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["Pusher"] = factory();
      else
        root2["Pusher"] = factory();
    }, "webpackUniversalModuleDefinition"))(window, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module2 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.l = true;
            return module2.exports;
          }
          __name(__webpack_require__, "__webpack_require__");
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.d = function(exports2, name3, getter) {
            if (!__webpack_require__.o(exports2, name3)) {
              Object.defineProperty(exports2, name3, { enumerable: true, get: getter });
            }
          };
          __webpack_require__.r = function(exports2) {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
              Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
            }
            Object.defineProperty(exports2, "__esModule", { value: true });
          };
          __webpack_require__.t = function(value, mode) {
            if (mode & 1)
              value = __webpack_require__(value);
            if (mode & 8)
              return value;
            if (mode & 4 && typeof value === "object" && value && value.__esModule)
              return value;
            var ns = /* @__PURE__ */ Object.create(null);
            __webpack_require__.r(ns);
            Object.defineProperty(ns, "default", { enumerable: true, value });
            if (mode & 2 && typeof value != "string")
              for (var key2 in value)
                __webpack_require__.d(ns, key2, function(key3) {
                  return value[key3];
                }.bind(null, key2));
            return ns;
          };
          __webpack_require__.n = function(module2) {
            var getter = module2 && module2.__esModule ? (
              /******/
              /* @__PURE__ */ __name(function getDefault() {
                return module2["default"];
              }, "getDefault")
            ) : (
              /******/
              /* @__PURE__ */ __name(function getModuleExports() {
                return module2;
              }, "getModuleExports")
            );
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = 2);
        }([
          /* 0 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var __extends = this && this.__extends || /* @__PURE__ */ function() {
              var extendStatics = /* @__PURE__ */ __name(function(d, b) {
                extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                  d2.__proto__ = b2;
                } || function(d2, b2) {
                  for (var p2 in b2)
                    if (b2.hasOwnProperty(p2))
                      d2[p2] = b2[p2];
                };
                return extendStatics(d, b);
              }, "extendStatics");
              return function(d, b) {
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                __name(__, "__");
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            Object.defineProperty(exports2, "__esModule", { value: true });
            var INVALID_BYTE = 256;
            var Coder = (
              /** @class */
              function() {
                function Coder2(_paddingCharacter) {
                  if (_paddingCharacter === void 0) {
                    _paddingCharacter = "=";
                  }
                  this._paddingCharacter = _paddingCharacter;
                }
                __name(Coder2, "Coder2");
                Coder2.prototype.encodedLength = function(length) {
                  if (!this._paddingCharacter) {
                    return (length * 8 + 5) / 6 | 0;
                  }
                  return (length + 2) / 3 * 4 | 0;
                };
                Coder2.prototype.encode = function(data) {
                  var out = "";
                  var i2 = 0;
                  for (; i2 < data.length - 2; i2 += 3) {
                    var c2 = data[i2] << 16 | data[i2 + 1] << 8 | data[i2 + 2];
                    out += this._encodeByte(c2 >>> 3 * 6 & 63);
                    out += this._encodeByte(c2 >>> 2 * 6 & 63);
                    out += this._encodeByte(c2 >>> 1 * 6 & 63);
                    out += this._encodeByte(c2 >>> 0 * 6 & 63);
                  }
                  var left = data.length - i2;
                  if (left > 0) {
                    var c2 = data[i2] << 16 | (left === 2 ? data[i2 + 1] << 8 : 0);
                    out += this._encodeByte(c2 >>> 3 * 6 & 63);
                    out += this._encodeByte(c2 >>> 2 * 6 & 63);
                    if (left === 2) {
                      out += this._encodeByte(c2 >>> 1 * 6 & 63);
                    } else {
                      out += this._paddingCharacter || "";
                    }
                    out += this._paddingCharacter || "";
                  }
                  return out;
                };
                Coder2.prototype.maxDecodedLength = function(length) {
                  if (!this._paddingCharacter) {
                    return (length * 6 + 7) / 8 | 0;
                  }
                  return length / 4 * 3 | 0;
                };
                Coder2.prototype.decodedLength = function(s3) {
                  return this.maxDecodedLength(s3.length - this._getPaddingLength(s3));
                };
                Coder2.prototype.decode = function(s3) {
                  if (s3.length === 0) {
                    return new Uint8Array(0);
                  }
                  var paddingLength = this._getPaddingLength(s3);
                  var length = s3.length - paddingLength;
                  var out = new Uint8Array(this.maxDecodedLength(length));
                  var op = 0;
                  var i2 = 0;
                  var haveBad = 0;
                  var v0 = 0, v1 = 0, v2 = 0, v3 = 0;
                  for (; i2 < length - 4; i2 += 4) {
                    v0 = this._decodeChar(s3.charCodeAt(i2 + 0));
                    v1 = this._decodeChar(s3.charCodeAt(i2 + 1));
                    v2 = this._decodeChar(s3.charCodeAt(i2 + 2));
                    v3 = this._decodeChar(s3.charCodeAt(i2 + 3));
                    out[op++] = v0 << 2 | v1 >>> 4;
                    out[op++] = v1 << 4 | v2 >>> 2;
                    out[op++] = v2 << 6 | v3;
                    haveBad |= v0 & INVALID_BYTE;
                    haveBad |= v1 & INVALID_BYTE;
                    haveBad |= v2 & INVALID_BYTE;
                    haveBad |= v3 & INVALID_BYTE;
                  }
                  if (i2 < length - 1) {
                    v0 = this._decodeChar(s3.charCodeAt(i2));
                    v1 = this._decodeChar(s3.charCodeAt(i2 + 1));
                    out[op++] = v0 << 2 | v1 >>> 4;
                    haveBad |= v0 & INVALID_BYTE;
                    haveBad |= v1 & INVALID_BYTE;
                  }
                  if (i2 < length - 2) {
                    v2 = this._decodeChar(s3.charCodeAt(i2 + 2));
                    out[op++] = v1 << 4 | v2 >>> 2;
                    haveBad |= v2 & INVALID_BYTE;
                  }
                  if (i2 < length - 3) {
                    v3 = this._decodeChar(s3.charCodeAt(i2 + 3));
                    out[op++] = v2 << 6 | v3;
                    haveBad |= v3 & INVALID_BYTE;
                  }
                  if (haveBad !== 0) {
                    throw new Error("Base64Coder: incorrect characters for decoding");
                  }
                  return out;
                };
                Coder2.prototype._encodeByte = function(b) {
                  var result = b;
                  result += 65;
                  result += 25 - b >>> 8 & 0 - 65 - 26 + 97;
                  result += 51 - b >>> 8 & 26 - 97 - 52 + 48;
                  result += 61 - b >>> 8 & 52 - 48 - 62 + 43;
                  result += 62 - b >>> 8 & 62 - 43 - 63 + 47;
                  return String.fromCharCode(result);
                };
                Coder2.prototype._decodeChar = function(c2) {
                  var result = INVALID_BYTE;
                  result += (42 - c2 & c2 - 44) >>> 8 & -INVALID_BYTE + c2 - 43 + 62;
                  result += (46 - c2 & c2 - 48) >>> 8 & -INVALID_BYTE + c2 - 47 + 63;
                  result += (47 - c2 & c2 - 58) >>> 8 & -INVALID_BYTE + c2 - 48 + 52;
                  result += (64 - c2 & c2 - 91) >>> 8 & -INVALID_BYTE + c2 - 65 + 0;
                  result += (96 - c2 & c2 - 123) >>> 8 & -INVALID_BYTE + c2 - 97 + 26;
                  return result;
                };
                Coder2.prototype._getPaddingLength = function(s3) {
                  var paddingLength = 0;
                  if (this._paddingCharacter) {
                    for (var i2 = s3.length - 1; i2 >= 0; i2--) {
                      if (s3[i2] !== this._paddingCharacter) {
                        break;
                      }
                      paddingLength++;
                    }
                    if (s3.length < 4 || paddingLength > 2) {
                      throw new Error("Base64Coder: incorrect padding");
                    }
                  }
                  return paddingLength;
                };
                return Coder2;
              }()
            );
            exports2.Coder = Coder;
            var stdCoder = new Coder();
            function encode2(data) {
              return stdCoder.encode(data);
            }
            __name(encode2, "encode2");
            exports2.encode = encode2;
            function decode2(s3) {
              return stdCoder.decode(s3);
            }
            __name(decode2, "decode2");
            exports2.decode = decode2;
            var URLSafeCoder = (
              /** @class */
              function(_super) {
                __extends(URLSafeCoder2, _super);
                function URLSafeCoder2() {
                  return _super !== null && _super.apply(this, arguments) || this;
                }
                __name(URLSafeCoder2, "URLSafeCoder2");
                URLSafeCoder2.prototype._encodeByte = function(b) {
                  var result = b;
                  result += 65;
                  result += 25 - b >>> 8 & 0 - 65 - 26 + 97;
                  result += 51 - b >>> 8 & 26 - 97 - 52 + 48;
                  result += 61 - b >>> 8 & 52 - 48 - 62 + 45;
                  result += 62 - b >>> 8 & 62 - 45 - 63 + 95;
                  return String.fromCharCode(result);
                };
                URLSafeCoder2.prototype._decodeChar = function(c2) {
                  var result = INVALID_BYTE;
                  result += (44 - c2 & c2 - 46) >>> 8 & -INVALID_BYTE + c2 - 45 + 62;
                  result += (94 - c2 & c2 - 96) >>> 8 & -INVALID_BYTE + c2 - 95 + 63;
                  result += (47 - c2 & c2 - 58) >>> 8 & -INVALID_BYTE + c2 - 48 + 52;
                  result += (64 - c2 & c2 - 91) >>> 8 & -INVALID_BYTE + c2 - 65 + 0;
                  result += (96 - c2 & c2 - 123) >>> 8 & -INVALID_BYTE + c2 - 97 + 26;
                  return result;
                };
                return URLSafeCoder2;
              }(Coder)
            );
            exports2.URLSafeCoder = URLSafeCoder;
            var urlSafeCoder = new URLSafeCoder();
            function encodeURLSafe(data) {
              return urlSafeCoder.encode(data);
            }
            __name(encodeURLSafe, "encodeURLSafe");
            exports2.encodeURLSafe = encodeURLSafe;
            function decodeURLSafe(s3) {
              return urlSafeCoder.decode(s3);
            }
            __name(decodeURLSafe, "decodeURLSafe");
            exports2.decodeURLSafe = decodeURLSafe;
            exports2.encodedLength = function(length) {
              return stdCoder.encodedLength(length);
            };
            exports2.maxDecodedLength = function(length) {
              return stdCoder.maxDecodedLength(length);
            };
            exports2.decodedLength = function(s3) {
              return stdCoder.decodedLength(s3);
            };
          },
          /* 1 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            var INVALID_UTF16 = "utf8: invalid string";
            var INVALID_UTF8 = "utf8: invalid source encoding";
            function encode2(s3) {
              var arr = new Uint8Array(encodedLength(s3));
              var pos = 0;
              for (var i2 = 0; i2 < s3.length; i2++) {
                var c2 = s3.charCodeAt(i2);
                if (c2 < 128) {
                  arr[pos++] = c2;
                } else if (c2 < 2048) {
                  arr[pos++] = 192 | c2 >> 6;
                  arr[pos++] = 128 | c2 & 63;
                } else if (c2 < 55296) {
                  arr[pos++] = 224 | c2 >> 12;
                  arr[pos++] = 128 | c2 >> 6 & 63;
                  arr[pos++] = 128 | c2 & 63;
                } else {
                  i2++;
                  c2 = (c2 & 1023) << 10;
                  c2 |= s3.charCodeAt(i2) & 1023;
                  c2 += 65536;
                  arr[pos++] = 240 | c2 >> 18;
                  arr[pos++] = 128 | c2 >> 12 & 63;
                  arr[pos++] = 128 | c2 >> 6 & 63;
                  arr[pos++] = 128 | c2 & 63;
                }
              }
              return arr;
            }
            __name(encode2, "encode2");
            exports2.encode = encode2;
            function encodedLength(s3) {
              var result = 0;
              for (var i2 = 0; i2 < s3.length; i2++) {
                var c2 = s3.charCodeAt(i2);
                if (c2 < 128) {
                  result += 1;
                } else if (c2 < 2048) {
                  result += 2;
                } else if (c2 < 55296) {
                  result += 3;
                } else if (c2 <= 57343) {
                  if (i2 >= s3.length - 1) {
                    throw new Error(INVALID_UTF16);
                  }
                  i2++;
                  result += 4;
                } else {
                  throw new Error(INVALID_UTF16);
                }
              }
              return result;
            }
            __name(encodedLength, "encodedLength");
            exports2.encodedLength = encodedLength;
            function decode2(arr) {
              var chars2 = [];
              for (var i2 = 0; i2 < arr.length; i2++) {
                var b = arr[i2];
                if (b & 128) {
                  var min2 = void 0;
                  if (b < 224) {
                    if (i2 >= arr.length) {
                      throw new Error(INVALID_UTF8);
                    }
                    var n1 = arr[++i2];
                    if ((n1 & 192) !== 128) {
                      throw new Error(INVALID_UTF8);
                    }
                    b = (b & 31) << 6 | n1 & 63;
                    min2 = 128;
                  } else if (b < 240) {
                    if (i2 >= arr.length - 1) {
                      throw new Error(INVALID_UTF8);
                    }
                    var n1 = arr[++i2];
                    var n2 = arr[++i2];
                    if ((n1 & 192) !== 128 || (n2 & 192) !== 128) {
                      throw new Error(INVALID_UTF8);
                    }
                    b = (b & 15) << 12 | (n1 & 63) << 6 | n2 & 63;
                    min2 = 2048;
                  } else if (b < 248) {
                    if (i2 >= arr.length - 2) {
                      throw new Error(INVALID_UTF8);
                    }
                    var n1 = arr[++i2];
                    var n2 = arr[++i2];
                    var n3 = arr[++i2];
                    if ((n1 & 192) !== 128 || (n2 & 192) !== 128 || (n3 & 192) !== 128) {
                      throw new Error(INVALID_UTF8);
                    }
                    b = (b & 15) << 18 | (n1 & 63) << 12 | (n2 & 63) << 6 | n3 & 63;
                    min2 = 65536;
                  } else {
                    throw new Error(INVALID_UTF8);
                  }
                  if (b < min2 || b >= 55296 && b <= 57343) {
                    throw new Error(INVALID_UTF8);
                  }
                  if (b >= 65536) {
                    if (b > 1114111) {
                      throw new Error(INVALID_UTF8);
                    }
                    b -= 65536;
                    chars2.push(String.fromCharCode(55296 | b >> 10));
                    b = 56320 | b & 1023;
                  }
                }
                chars2.push(String.fromCharCode(b));
              }
              return chars2.join("");
            }
            __name(decode2, "decode2");
            exports2.decode = decode2;
          },
          /* 2 */
          /***/
          function(module2, exports2, __webpack_require__) {
            module2.exports = __webpack_require__(3).default;
          },
          /* 3 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            class ScriptReceiverFactory {
              constructor(prefix2, name3) {
                this.lastId = 0;
                this.prefix = prefix2;
                this.name = name3;
              }
              create(callback) {
                this.lastId++;
                var number = this.lastId;
                var id = this.prefix + number;
                var name3 = this.name + "[" + number + "]";
                var called = false;
                var callbackWrapper = /* @__PURE__ */ __name(function() {
                  if (!called) {
                    callback.apply(null, arguments);
                    called = true;
                  }
                }, "callbackWrapper");
                this[number] = callbackWrapper;
                return { number, id, name: name3, callback: callbackWrapper };
              }
              remove(receiver) {
                delete this[receiver.number];
              }
            }
            __name(ScriptReceiverFactory, "ScriptReceiverFactory");
            var ScriptReceivers = new ScriptReceiverFactory("_pusher_script_", "Pusher.ScriptReceivers");
            var Defaults = {
              VERSION: "8.4.0-rc2",
              PROTOCOL: 7,
              wsPort: 80,
              wssPort: 443,
              wsPath: "",
              httpHost: "sockjs.pusher.com",
              httpPort: 80,
              httpsPort: 443,
              httpPath: "/pusher",
              stats_host: "stats.pusher.com",
              authEndpoint: "/pusher/auth",
              authTransport: "ajax",
              activityTimeout: 12e4,
              pongTimeout: 3e4,
              unavailableTimeout: 1e4,
              userAuthentication: {
                endpoint: "/pusher/user-auth",
                transport: "ajax"
              },
              channelAuthorization: {
                endpoint: "/pusher/auth",
                transport: "ajax"
              },
              cdn_http: "http://js.pusher.com",
              cdn_https: "https://js.pusher.com",
              dependency_suffix: ""
            };
            var defaults6 = Defaults;
            class dependency_loader_DependencyLoader {
              constructor(options2) {
                this.options = options2;
                this.receivers = options2.receivers || ScriptReceivers;
                this.loading = {};
              }
              load(name3, options2, callback) {
                var self = this;
                if (self.loading[name3] && self.loading[name3].length > 0) {
                  self.loading[name3].push(callback);
                } else {
                  self.loading[name3] = [callback];
                  var request = runtime.createScriptRequest(self.getPath(name3, options2));
                  var receiver = self.receivers.create(function(error2) {
                    self.receivers.remove(receiver);
                    if (self.loading[name3]) {
                      var callbacks = self.loading[name3];
                      delete self.loading[name3];
                      var successCallback = /* @__PURE__ */ __name(function(wasSuccessful) {
                        if (!wasSuccessful) {
                          request.cleanup();
                        }
                      }, "successCallback");
                      for (var i2 = 0; i2 < callbacks.length; i2++) {
                        callbacks[i2](error2, successCallback);
                      }
                    }
                  });
                  request.send(receiver);
                }
              }
              getRoot(options2) {
                var cdn;
                var protocol = runtime.getDocument().location.protocol;
                if (options2 && options2.useTLS || protocol === "https:") {
                  cdn = this.options.cdn_https;
                } else {
                  cdn = this.options.cdn_http;
                }
                return cdn.replace(/\/*$/, "") + "/" + this.options.version;
              }
              getPath(name3, options2) {
                return this.getRoot(options2) + "/" + name3 + this.options.suffix + ".js";
              }
            }
            __name(dependency_loader_DependencyLoader, "dependency_loader_DependencyLoader");
            var DependenciesReceivers = new ScriptReceiverFactory("_pusher_dependencies", "Pusher.DependenciesReceivers");
            var Dependencies = new dependency_loader_DependencyLoader({
              cdn_http: defaults6.cdn_http,
              cdn_https: defaults6.cdn_https,
              version: defaults6.VERSION,
              suffix: defaults6.dependency_suffix,
              receivers: DependenciesReceivers
            });
            const urlStore = {
              baseUrl: "https://pusher.com",
              urls: {
                authenticationEndpoint: {
                  path: "/docs/channels/server_api/authenticating_users"
                },
                authorizationEndpoint: {
                  path: "/docs/channels/server_api/authorizing-users/"
                },
                javascriptQuickStart: {
                  path: "/docs/javascript_quick_start"
                },
                triggeringClientEvents: {
                  path: "/docs/client_api_guide/client_events#trigger-events"
                },
                encryptedChannelSupport: {
                  fullUrl: "https://github.com/pusher/pusher-js/tree/cc491015371a4bde5743d1c87a0fbac0feb53195#encrypted-channel-support"
                }
              }
            };
            const buildLogSuffix = /* @__PURE__ */ __name(function(key2) {
              const urlPrefix = "See:";
              const urlObj = urlStore.urls[key2];
              if (!urlObj)
                return "";
              let url;
              if (urlObj.fullUrl) {
                url = urlObj.fullUrl;
              } else if (urlObj.path) {
                url = urlStore.baseUrl + urlObj.path;
              }
              if (!url)
                return "";
              return `${urlPrefix} ${url}`;
            }, "buildLogSuffix");
            var url_store = { buildLogSuffix };
            var AuthRequestType;
            (function(AuthRequestType2) {
              AuthRequestType2["UserAuthentication"] = "user-authentication";
              AuthRequestType2["ChannelAuthorization"] = "channel-authorization";
            })(AuthRequestType || (AuthRequestType = {}));
            class BadEventName extends Error {
              constructor(msg) {
                super(msg);
                Object.setPrototypeOf(this, new.target.prototype);
              }
            }
            __name(BadEventName, "BadEventName");
            class BadChannelName extends Error {
              constructor(msg) {
                super(msg);
                Object.setPrototypeOf(this, new.target.prototype);
              }
            }
            __name(BadChannelName, "BadChannelName");
            class RequestTimedOut extends Error {
              constructor(msg) {
                super(msg);
                Object.setPrototypeOf(this, new.target.prototype);
              }
            }
            __name(RequestTimedOut, "RequestTimedOut");
            class TransportPriorityTooLow extends Error {
              constructor(msg) {
                super(msg);
                Object.setPrototypeOf(this, new.target.prototype);
              }
            }
            __name(TransportPriorityTooLow, "TransportPriorityTooLow");
            class TransportClosed extends Error {
              constructor(msg) {
                super(msg);
                Object.setPrototypeOf(this, new.target.prototype);
              }
            }
            __name(TransportClosed, "TransportClosed");
            class UnsupportedFeature extends Error {
              constructor(msg) {
                super(msg);
                Object.setPrototypeOf(this, new.target.prototype);
              }
            }
            __name(UnsupportedFeature, "UnsupportedFeature");
            class UnsupportedTransport extends Error {
              constructor(msg) {
                super(msg);
                Object.setPrototypeOf(this, new.target.prototype);
              }
            }
            __name(UnsupportedTransport, "UnsupportedTransport");
            class UnsupportedStrategy extends Error {
              constructor(msg) {
                super(msg);
                Object.setPrototypeOf(this, new.target.prototype);
              }
            }
            __name(UnsupportedStrategy, "UnsupportedStrategy");
            class HTTPAuthError extends Error {
              constructor(status, msg) {
                super(msg);
                this.status = status;
                Object.setPrototypeOf(this, new.target.prototype);
              }
            }
            __name(HTTPAuthError, "HTTPAuthError");
            const ajax = /* @__PURE__ */ __name(function(context, query, authOptions, authRequestType, callback) {
              const xhr = runtime.createXHR();
              xhr.open("POST", authOptions.endpoint, true);
              xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
              for (var headerName in authOptions.headers) {
                xhr.setRequestHeader(headerName, authOptions.headers[headerName]);
              }
              if (authOptions.headersProvider != null) {
                let dynamicHeaders = authOptions.headersProvider();
                for (var headerName in dynamicHeaders) {
                  xhr.setRequestHeader(headerName, dynamicHeaders[headerName]);
                }
              }
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  if (xhr.status === 200) {
                    let data;
                    let parsed = false;
                    try {
                      data = JSON.parse(xhr.responseText);
                      parsed = true;
                    } catch (e3) {
                      callback(new HTTPAuthError(200, `JSON returned from ${authRequestType.toString()} endpoint was invalid, yet status code was 200. Data was: ${xhr.responseText}`), null);
                    }
                    if (parsed) {
                      callback(null, data);
                    }
                  } else {
                    let suffix = "";
                    switch (authRequestType) {
                      case AuthRequestType.UserAuthentication:
                        suffix = url_store.buildLogSuffix("authenticationEndpoint");
                        break;
                      case AuthRequestType.ChannelAuthorization:
                        suffix = `Clients must be authorized to join private or presence channels. ${url_store.buildLogSuffix("authorizationEndpoint")}`;
                        break;
                    }
                    callback(new HTTPAuthError(xhr.status, `Unable to retrieve auth string from ${authRequestType.toString()} endpoint - received status: ${xhr.status} from ${authOptions.endpoint}. ${suffix}`), null);
                  }
                }
              };
              xhr.send(query);
              return xhr;
            }, "ajax");
            var xhr_auth = ajax;
            function encode2(s3) {
              return btoa2(utob(s3));
            }
            __name(encode2, "encode2");
            var fromCharCode = String.fromCharCode;
            var b64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            var b64tab = {};
            for (var base64_i = 0, l2 = b64chars.length; base64_i < l2; base64_i++) {
              b64tab[b64chars.charAt(base64_i)] = base64_i;
            }
            var cb_utob = /* @__PURE__ */ __name(function(c2) {
              var cc = c2.charCodeAt(0);
              return cc < 128 ? c2 : cc < 2048 ? fromCharCode(192 | cc >>> 6) + fromCharCode(128 | cc & 63) : fromCharCode(224 | cc >>> 12 & 15) + fromCharCode(128 | cc >>> 6 & 63) + fromCharCode(128 | cc & 63);
            }, "cb_utob");
            var utob = /* @__PURE__ */ __name(function(u2) {
              return u2.replace(/[^\x00-\x7F]/g, cb_utob);
            }, "utob");
            var cb_encode = /* @__PURE__ */ __name(function(ccc) {
              var padlen = [0, 2, 1][ccc.length % 3];
              var ord = ccc.charCodeAt(0) << 16 | (ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8 | (ccc.length > 2 ? ccc.charCodeAt(2) : 0);
              var chars2 = [
                b64chars.charAt(ord >>> 18),
                b64chars.charAt(ord >>> 12 & 63),
                padlen >= 2 ? "=" : b64chars.charAt(ord >>> 6 & 63),
                padlen >= 1 ? "=" : b64chars.charAt(ord & 63)
              ];
              return chars2.join("");
            }, "cb_encode");
            var btoa2 = window.btoa || function(b) {
              return b.replace(/[\s\S]{1,3}/g, cb_encode);
            };
            class Timer2 {
              constructor(set3, clear2, delay3, callback) {
                this.clear = clear2;
                this.timer = set3(() => {
                  if (this.timer) {
                    this.timer = callback(this.timer);
                  }
                }, delay3);
              }
              isRunning() {
                return this.timer !== null;
              }
              ensureAborted() {
                if (this.timer) {
                  this.clear(this.timer);
                  this.timer = null;
                }
              }
            }
            __name(Timer2, "Timer2");
            var abstract_timer = Timer2;
            function timers_clearTimeout(timer) {
              window.clearTimeout(timer);
            }
            __name(timers_clearTimeout, "timers_clearTimeout");
            function timers_clearInterval(timer) {
              window.clearInterval(timer);
            }
            __name(timers_clearInterval, "timers_clearInterval");
            class timers_OneOffTimer extends abstract_timer {
              constructor(delay3, callback) {
                super(setTimeout, timers_clearTimeout, delay3, function(timer) {
                  callback();
                  return null;
                });
              }
            }
            __name(timers_OneOffTimer, "timers_OneOffTimer");
            class timers_PeriodicTimer extends abstract_timer {
              constructor(delay3, callback) {
                super(setInterval, timers_clearInterval, delay3, function(timer) {
                  callback();
                  return timer;
                });
              }
            }
            __name(timers_PeriodicTimer, "timers_PeriodicTimer");
            var Util = {
              now() {
                if (Date.now) {
                  return Date.now();
                } else {
                  return (/* @__PURE__ */ new Date()).valueOf();
                }
              },
              defer(callback) {
                return new timers_OneOffTimer(0, callback);
              },
              method(name3, ...args) {
                var boundArguments = Array.prototype.slice.call(arguments, 1);
                return function(object) {
                  return object[name3].apply(object, boundArguments.concat(arguments));
                };
              }
            };
            var util2 = Util;
            function extend(target, ...sources) {
              for (var i2 = 0; i2 < sources.length; i2++) {
                var extensions = sources[i2];
                for (var property in extensions) {
                  if (extensions[property] && extensions[property].constructor && extensions[property].constructor === Object) {
                    target[property] = extend(target[property] || {}, extensions[property]);
                  } else {
                    target[property] = extensions[property];
                  }
                }
              }
              return target;
            }
            __name(extend, "extend");
            function stringify3() {
              var m = ["Pusher"];
              for (var i2 = 0; i2 < arguments.length; i2++) {
                if (typeof arguments[i2] === "string") {
                  m.push(arguments[i2]);
                } else {
                  m.push(safeJSONStringify(arguments[i2]));
                }
              }
              return m.join(" : ");
            }
            __name(stringify3, "stringify3");
            function arrayIndexOf(array3, item) {
              var nativeIndexOf = Array.prototype.indexOf;
              if (array3 === null) {
                return -1;
              }
              if (nativeIndexOf && array3.indexOf === nativeIndexOf) {
                return array3.indexOf(item);
              }
              for (var i2 = 0, l3 = array3.length; i2 < l3; i2++) {
                if (array3[i2] === item) {
                  return i2;
                }
              }
              return -1;
            }
            __name(arrayIndexOf, "arrayIndexOf");
            function objectApply(object, f) {
              for (var key2 in object) {
                if (Object.prototype.hasOwnProperty.call(object, key2)) {
                  f(object[key2], key2, object);
                }
              }
            }
            __name(objectApply, "objectApply");
            function keys(object) {
              var keys2 = [];
              objectApply(object, function(_2, key2) {
                keys2.push(key2);
              });
              return keys2;
            }
            __name(keys, "keys");
            function values(object) {
              var values2 = [];
              objectApply(object, function(value) {
                values2.push(value);
              });
              return values2;
            }
            __name(values, "values");
            function apply(array3, f, context) {
              for (var i2 = 0; i2 < array3.length; i2++) {
                f.call(context || window, array3[i2], i2, array3);
              }
            }
            __name(apply, "apply");
            function map(array3, f) {
              var result = [];
              for (var i2 = 0; i2 < array3.length; i2++) {
                result.push(f(array3[i2], i2, array3, result));
              }
              return result;
            }
            __name(map, "map");
            function mapObject(object, f) {
              var result = {};
              objectApply(object, function(value, key2) {
                result[key2] = f(value);
              });
              return result;
            }
            __name(mapObject, "mapObject");
            function filter(array3, test) {
              test = test || function(value) {
                return !!value;
              };
              var result = [];
              for (var i2 = 0; i2 < array3.length; i2++) {
                if (test(array3[i2], i2, array3, result)) {
                  result.push(array3[i2]);
                }
              }
              return result;
            }
            __name(filter, "filter");
            function filterObject(object, test) {
              var result = {};
              objectApply(object, function(value, key2) {
                if (test && test(value, key2, object, result) || Boolean(value)) {
                  result[key2] = value;
                }
              });
              return result;
            }
            __name(filterObject, "filterObject");
            function flatten(object) {
              var result = [];
              objectApply(object, function(value, key2) {
                result.push([key2, value]);
              });
              return result;
            }
            __name(flatten, "flatten");
            function any(array3, test) {
              for (var i2 = 0; i2 < array3.length; i2++) {
                if (test(array3[i2], i2, array3)) {
                  return true;
                }
              }
              return false;
            }
            __name(any, "any");
            function collections_all(array3, test) {
              for (var i2 = 0; i2 < array3.length; i2++) {
                if (!test(array3[i2], i2, array3)) {
                  return false;
                }
              }
              return true;
            }
            __name(collections_all, "collections_all");
            function encodeParamsObject(data) {
              return mapObject(data, function(value) {
                if (typeof value === "object") {
                  value = safeJSONStringify(value);
                }
                return encodeURIComponent(encode2(value.toString()));
              });
            }
            __name(encodeParamsObject, "encodeParamsObject");
            function buildQueryString(data) {
              var params = filterObject(data, function(value) {
                return value !== void 0;
              });
              var query = map(flatten(encodeParamsObject(params)), util2.method("join", "=")).join("&");
              return query;
            }
            __name(buildQueryString, "buildQueryString");
            function decycleObject(object) {
              var objects = [], paths = [];
              return (/* @__PURE__ */ __name(function derez(value, path) {
                var i2, name3, nu;
                switch (typeof value) {
                  case "object":
                    if (!value) {
                      return null;
                    }
                    for (i2 = 0; i2 < objects.length; i2 += 1) {
                      if (objects[i2] === value) {
                        return { $ref: paths[i2] };
                      }
                    }
                    objects.push(value);
                    paths.push(path);
                    if (Object.prototype.toString.apply(value) === "[object Array]") {
                      nu = [];
                      for (i2 = 0; i2 < value.length; i2 += 1) {
                        nu[i2] = derez(value[i2], path + "[" + i2 + "]");
                      }
                    } else {
                      nu = {};
                      for (name3 in value) {
                        if (Object.prototype.hasOwnProperty.call(value, name3)) {
                          nu[name3] = derez(value[name3], path + "[" + JSON.stringify(name3) + "]");
                        }
                      }
                    }
                    return nu;
                  case "number":
                  case "string":
                  case "boolean":
                    return value;
                }
              }, "derez"))(object, "$");
            }
            __name(decycleObject, "decycleObject");
            function safeJSONStringify(source2) {
              try {
                return JSON.stringify(source2);
              } catch (e3) {
                return JSON.stringify(decycleObject(source2));
              }
            }
            __name(safeJSONStringify, "safeJSONStringify");
            class logger_Logger {
              constructor() {
                this.globalLog = (message) => {
                  if (window.console && window.console.log) {
                    window.console.log(message);
                  }
                };
              }
              debug(...args) {
                this.log(this.globalLog, args);
              }
              warn(...args) {
                this.log(this.globalLogWarn, args);
              }
              error(...args) {
                this.log(this.globalLogError, args);
              }
              globalLogWarn(message) {
                if (window.console && window.console.warn) {
                  window.console.warn(message);
                } else {
                  this.globalLog(message);
                }
              }
              globalLogError(message) {
                if (window.console && window.console.error) {
                  window.console.error(message);
                } else {
                  this.globalLogWarn(message);
                }
              }
              log(defaultLoggingFunction, ...args) {
                var message = stringify3.apply(this, arguments);
                if (core_pusher.log) {
                  core_pusher.log(message);
                } else if (core_pusher.logToConsole) {
                  const log = defaultLoggingFunction.bind(this);
                  log(message);
                }
              }
            }
            __name(logger_Logger, "logger_Logger");
            var logger = new logger_Logger();
            var jsonp = /* @__PURE__ */ __name(function(context, query, authOptions, authRequestType, callback) {
              if (authOptions.headers !== void 0 || authOptions.headersProvider != null) {
                logger.warn(`To send headers with the ${authRequestType.toString()} request, you must use AJAX, rather than JSONP.`);
              }
              var callbackName = context.nextAuthCallbackID.toString();
              context.nextAuthCallbackID++;
              var document2 = context.getDocument();
              var script = document2.createElement("script");
              context.auth_callbacks[callbackName] = function(data) {
                callback(null, data);
              };
              var callback_name = "Pusher.auth_callbacks['" + callbackName + "']";
              script.src = authOptions.endpoint + "?callback=" + encodeURIComponent(callback_name) + "&" + query;
              var head2 = document2.getElementsByTagName("head")[0] || document2.documentElement;
              head2.insertBefore(script, head2.firstChild);
            }, "jsonp");
            var jsonp_auth = jsonp;
            class ScriptRequest {
              constructor(src) {
                this.src = src;
              }
              send(receiver) {
                var self = this;
                var errorString = "Error loading " + self.src;
                self.script = document.createElement("script");
                self.script.id = receiver.id;
                self.script.src = self.src;
                self.script.type = "text/javascript";
                self.script.charset = "UTF-8";
                if (self.script.addEventListener) {
                  self.script.onerror = function() {
                    receiver.callback(errorString);
                  };
                  self.script.onload = function() {
                    receiver.callback(null);
                  };
                } else {
                  self.script.onreadystatechange = function() {
                    if (self.script.readyState === "loaded" || self.script.readyState === "complete") {
                      receiver.callback(null);
                    }
                  };
                }
                if (self.script.async === void 0 && document.attachEvent && /opera/i.test("Cloudflare-Workers")) {
                  self.errorScript = document.createElement("script");
                  self.errorScript.id = receiver.id + "_error";
                  self.errorScript.text = receiver.name + "('" + errorString + "');";
                  self.script.async = self.errorScript.async = false;
                } else {
                  self.script.async = true;
                }
                var head2 = document.getElementsByTagName("head")[0];
                head2.insertBefore(self.script, head2.firstChild);
                if (self.errorScript) {
                  head2.insertBefore(self.errorScript, self.script.nextSibling);
                }
              }
              cleanup() {
                if (this.script) {
                  this.script.onload = this.script.onerror = null;
                  this.script.onreadystatechange = null;
                }
                if (this.script && this.script.parentNode) {
                  this.script.parentNode.removeChild(this.script);
                }
                if (this.errorScript && this.errorScript.parentNode) {
                  this.errorScript.parentNode.removeChild(this.errorScript);
                }
                this.script = null;
                this.errorScript = null;
              }
            }
            __name(ScriptRequest, "ScriptRequest");
            class jsonp_request_JSONPRequest {
              constructor(url, data) {
                this.url = url;
                this.data = data;
              }
              send(receiver) {
                if (this.request) {
                  return;
                }
                var query = buildQueryString(this.data);
                var url = this.url + "/" + receiver.number + "?" + query;
                this.request = runtime.createScriptRequest(url);
                this.request.send(receiver);
              }
              cleanup() {
                if (this.request) {
                  this.request.cleanup();
                }
              }
            }
            __name(jsonp_request_JSONPRequest, "jsonp_request_JSONPRequest");
            var getAgent = /* @__PURE__ */ __name(function(sender, useTLS) {
              return function(data, callback) {
                var scheme = "http" + (useTLS ? "s" : "") + "://";
                var url = scheme + (sender.host || sender.options.host) + sender.options.path;
                var request = runtime.createJSONPRequest(url, data);
                var receiver = runtime.ScriptReceivers.create(function(error2, result) {
                  ScriptReceivers.remove(receiver);
                  request.cleanup();
                  if (result && result.host) {
                    sender.host = result.host;
                  }
                  if (callback) {
                    callback(error2, result);
                  }
                });
                request.send(receiver);
              };
            }, "getAgent");
            var jsonp_timeline_jsonp = {
              name: "jsonp",
              getAgent
            };
            var jsonp_timeline = jsonp_timeline_jsonp;
            function getGenericURL(baseScheme, params, path) {
              var scheme = baseScheme + (params.useTLS ? "s" : "");
              var host = params.useTLS ? params.hostTLS : params.hostNonTLS;
              return scheme + "://" + host + path;
            }
            __name(getGenericURL, "getGenericURL");
            function getGenericPath(key2, queryString) {
              var path = "/app/" + key2;
              var query = "?protocol=" + defaults6.PROTOCOL + "&client=js&version=" + defaults6.VERSION + (queryString ? "&" + queryString : "");
              return path + query;
            }
            __name(getGenericPath, "getGenericPath");
            var ws = {
              getInitial: function(key2, params) {
                var path = (params.httpPath || "") + getGenericPath(key2, "flash=false");
                return getGenericURL("ws", params, path);
              }
            };
            var http = {
              getInitial: function(key2, params) {
                var path = (params.httpPath || "/pusher") + getGenericPath(key2);
                return getGenericURL("http", params, path);
              }
            };
            var sockjs = {
              getInitial: function(key2, params) {
                return getGenericURL("http", params, params.httpPath || "/pusher");
              },
              getPath: function(key2, params) {
                return getGenericPath(key2);
              }
            };
            class callback_registry_CallbackRegistry {
              constructor() {
                this._callbacks = {};
              }
              get(name3) {
                return this._callbacks[prefix(name3)];
              }
              add(name3, callback, context) {
                var prefixedEventName = prefix(name3);
                this._callbacks[prefixedEventName] = this._callbacks[prefixedEventName] || [];
                this._callbacks[prefixedEventName].push({
                  fn: callback,
                  context
                });
              }
              remove(name3, callback, context) {
                if (!name3 && !callback && !context) {
                  this._callbacks = {};
                  return;
                }
                var names = name3 ? [prefix(name3)] : keys(this._callbacks);
                if (callback || context) {
                  this.removeCallback(names, callback, context);
                } else {
                  this.removeAllCallbacks(names);
                }
              }
              removeCallback(names, callback, context) {
                apply(names, function(name3) {
                  this._callbacks[name3] = filter(this._callbacks[name3] || [], function(binding) {
                    return callback && callback !== binding.fn || context && context !== binding.context;
                  });
                  if (this._callbacks[name3].length === 0) {
                    delete this._callbacks[name3];
                  }
                }, this);
              }
              removeAllCallbacks(names) {
                apply(names, function(name3) {
                  delete this._callbacks[name3];
                }, this);
              }
            }
            __name(callback_registry_CallbackRegistry, "callback_registry_CallbackRegistry");
            function prefix(name3) {
              return "_" + name3;
            }
            __name(prefix, "prefix");
            class dispatcher_Dispatcher {
              constructor(failThrough) {
                this.callbacks = new callback_registry_CallbackRegistry();
                this.global_callbacks = [];
                this.failThrough = failThrough;
              }
              bind(eventName, callback, context) {
                this.callbacks.add(eventName, callback, context);
                return this;
              }
              bind_global(callback) {
                this.global_callbacks.push(callback);
                return this;
              }
              unbind(eventName, callback, context) {
                this.callbacks.remove(eventName, callback, context);
                return this;
              }
              unbind_global(callback) {
                if (!callback) {
                  this.global_callbacks = [];
                  return this;
                }
                this.global_callbacks = filter(this.global_callbacks || [], (c2) => c2 !== callback);
                return this;
              }
              unbind_all() {
                this.unbind();
                this.unbind_global();
                return this;
              }
              emit(eventName, data, metadata) {
                for (var i2 = 0; i2 < this.global_callbacks.length; i2++) {
                  this.global_callbacks[i2](eventName, data);
                }
                var callbacks = this.callbacks.get(eventName);
                var args = [];
                if (metadata) {
                  args.push(data, metadata);
                } else if (data) {
                  args.push(data);
                }
                if (callbacks && callbacks.length > 0) {
                  for (var i2 = 0; i2 < callbacks.length; i2++) {
                    callbacks[i2].fn.apply(callbacks[i2].context || window, args);
                  }
                } else if (this.failThrough) {
                  this.failThrough(eventName, data);
                }
                return this;
              }
            }
            __name(dispatcher_Dispatcher, "dispatcher_Dispatcher");
            class transport_connection_TransportConnection extends dispatcher_Dispatcher {
              constructor(hooks, name3, priority, key2, options2) {
                super();
                this.initialize = runtime.transportConnectionInitializer;
                this.hooks = hooks;
                this.name = name3;
                this.priority = priority;
                this.key = key2;
                this.options = options2;
                this.state = "new";
                this.timeline = options2.timeline;
                this.activityTimeout = options2.activityTimeout;
                this.id = this.timeline.generateUniqueID();
              }
              handlesActivityChecks() {
                return Boolean(this.hooks.handlesActivityChecks);
              }
              supportsPing() {
                return Boolean(this.hooks.supportsPing);
              }
              connect() {
                if (this.socket || this.state !== "initialized") {
                  return false;
                }
                var url = this.hooks.urls.getInitial(this.key, this.options);
                try {
                  this.socket = this.hooks.getSocket(url, this.options);
                } catch (e3) {
                  util2.defer(() => {
                    this.onError(e3);
                    this.changeState("closed");
                  });
                  return false;
                }
                this.bindListeners();
                logger.debug("Connecting", { transport: this.name, url });
                this.changeState("connecting");
                return true;
              }
              close() {
                if (this.socket) {
                  this.socket.close();
                  return true;
                } else {
                  return false;
                }
              }
              send(data) {
                if (this.state === "open") {
                  util2.defer(() => {
                    if (this.socket) {
                      this.socket.send(data);
                    }
                  });
                  return true;
                } else {
                  return false;
                }
              }
              ping() {
                if (this.state === "open" && this.supportsPing()) {
                  this.socket.ping();
                }
              }
              onOpen() {
                if (this.hooks.beforeOpen) {
                  this.hooks.beforeOpen(this.socket, this.hooks.urls.getPath(this.key, this.options));
                }
                this.changeState("open");
                this.socket.onopen = void 0;
              }
              onError(error2) {
                this.emit("error", { type: "WebSocketError", error: error2 });
                this.timeline.error(this.buildTimelineMessage({ error: error2.toString() }));
              }
              onClose(closeEvent) {
                if (closeEvent) {
                  this.changeState("closed", {
                    code: closeEvent.code,
                    reason: closeEvent.reason,
                    wasClean: closeEvent.wasClean
                  });
                } else {
                  this.changeState("closed");
                }
                this.unbindListeners();
                this.socket = void 0;
              }
              onMessage(message) {
                this.emit("message", message);
              }
              onActivity() {
                this.emit("activity");
              }
              bindListeners() {
                this.socket.onopen = () => {
                  this.onOpen();
                };
                this.socket.onerror = (error2) => {
                  this.onError(error2);
                };
                this.socket.onclose = (closeEvent) => {
                  this.onClose(closeEvent);
                };
                this.socket.onmessage = (message) => {
                  this.onMessage(message);
                };
                if (this.supportsPing()) {
                  this.socket.onactivity = () => {
                    this.onActivity();
                  };
                }
              }
              unbindListeners() {
                if (this.socket) {
                  this.socket.onopen = void 0;
                  this.socket.onerror = void 0;
                  this.socket.onclose = void 0;
                  this.socket.onmessage = void 0;
                  if (this.supportsPing()) {
                    this.socket.onactivity = void 0;
                  }
                }
              }
              changeState(state2, params) {
                this.state = state2;
                this.timeline.info(this.buildTimelineMessage({
                  state: state2,
                  params
                }));
                this.emit(state2, params);
              }
              buildTimelineMessage(message) {
                return extend({ cid: this.id }, message);
              }
            }
            __name(transport_connection_TransportConnection, "transport_connection_TransportConnection");
            class transport_Transport {
              constructor(hooks) {
                this.hooks = hooks;
              }
              isSupported(environment) {
                return this.hooks.isSupported(environment);
              }
              createConnection(name3, priority, key2, options2) {
                return new transport_connection_TransportConnection(this.hooks, name3, priority, key2, options2);
              }
            }
            __name(transport_Transport, "transport_Transport");
            var WSTransport = new transport_Transport({
              urls: ws,
              handlesActivityChecks: false,
              supportsPing: false,
              isInitialized: function() {
                return Boolean(runtime.getWebSocketAPI());
              },
              isSupported: function() {
                return Boolean(runtime.getWebSocketAPI());
              },
              getSocket: function(url) {
                return runtime.createWebSocket(url);
              }
            });
            var httpConfiguration = {
              urls: http,
              handlesActivityChecks: false,
              supportsPing: true,
              isInitialized: function() {
                return true;
              }
            };
            var streamingConfiguration = extend({
              getSocket: function(url) {
                return runtime.HTTPFactory.createStreamingSocket(url);
              }
            }, httpConfiguration);
            var pollingConfiguration = extend({
              getSocket: function(url) {
                return runtime.HTTPFactory.createPollingSocket(url);
              }
            }, httpConfiguration);
            var xhrConfiguration = {
              isSupported: function() {
                return runtime.isXHRSupported();
              }
            };
            var XHRStreamingTransport = new transport_Transport(extend({}, streamingConfiguration, xhrConfiguration));
            var XHRPollingTransport = new transport_Transport(extend({}, pollingConfiguration, xhrConfiguration));
            var Transports = {
              ws: WSTransport,
              xhr_streaming: XHRStreamingTransport,
              xhr_polling: XHRPollingTransport
            };
            var transports = Transports;
            var SockJSTransport = new transport_Transport({
              file: "sockjs",
              urls: sockjs,
              handlesActivityChecks: true,
              supportsPing: false,
              isSupported: function() {
                return true;
              },
              isInitialized: function() {
                return window.SockJS !== void 0;
              },
              getSocket: function(url, options2) {
                return new window.SockJS(url, null, {
                  js_path: Dependencies.getPath("sockjs", {
                    useTLS: options2.useTLS
                  }),
                  ignore_null_origin: options2.ignoreNullOrigin
                });
              },
              beforeOpen: function(socket, path) {
                socket.send(JSON.stringify({
                  path
                }));
              }
            });
            var xdrConfiguration = {
              isSupported: function(environment) {
                var yes = runtime.isXDRSupported(environment.useTLS);
                return yes;
              }
            };
            var XDRStreamingTransport = new transport_Transport(extend({}, streamingConfiguration, xdrConfiguration));
            var XDRPollingTransport = new transport_Transport(extend({}, pollingConfiguration, xdrConfiguration));
            transports.xdr_streaming = XDRStreamingTransport;
            transports.xdr_polling = XDRPollingTransport;
            transports.sockjs = SockJSTransport;
            var transports_transports = transports;
            class net_info_NetInfo extends dispatcher_Dispatcher {
              constructor() {
                super();
                var self = this;
                if (window.addEventListener !== void 0) {
                  window.addEventListener("online", function() {
                    self.emit("online");
                  }, false);
                  window.addEventListener("offline", function() {
                    self.emit("offline");
                  }, false);
                }
              }
              isOnline() {
                if (window.navigator.onLine === void 0) {
                  return true;
                } else {
                  return window.navigator.onLine;
                }
              }
            }
            __name(net_info_NetInfo, "net_info_NetInfo");
            var net_info_Network = new net_info_NetInfo();
            class assistant_to_the_transport_manager_AssistantToTheTransportManager {
              constructor(manager, transport, options2) {
                this.manager = manager;
                this.transport = transport;
                this.minPingDelay = options2.minPingDelay;
                this.maxPingDelay = options2.maxPingDelay;
                this.pingDelay = void 0;
              }
              createConnection(name3, priority, key2, options2) {
                options2 = extend({}, options2, {
                  activityTimeout: this.pingDelay
                });
                var connection = this.transport.createConnection(name3, priority, key2, options2);
                var openTimestamp = null;
                var onOpen = /* @__PURE__ */ __name(function() {
                  connection.unbind("open", onOpen);
                  connection.bind("closed", onClosed);
                  openTimestamp = util2.now();
                }, "onOpen");
                var onClosed = /* @__PURE__ */ __name((closeEvent) => {
                  connection.unbind("closed", onClosed);
                  if (closeEvent.code === 1002 || closeEvent.code === 1003) {
                    this.manager.reportDeath();
                  } else if (!closeEvent.wasClean && openTimestamp) {
                    var lifespan = util2.now() - openTimestamp;
                    if (lifespan < 2 * this.maxPingDelay) {
                      this.manager.reportDeath();
                      this.pingDelay = Math.max(lifespan / 2, this.minPingDelay);
                    }
                  }
                }, "onClosed");
                connection.bind("open", onOpen);
                return connection;
              }
              isSupported(environment) {
                return this.manager.isAlive() && this.transport.isSupported(environment);
              }
            }
            __name(assistant_to_the_transport_manager_AssistantToTheTransportManager, "assistant_to_the_transport_manager_AssistantToTheTransportManager");
            const Protocol = {
              decodeMessage: function(messageEvent) {
                try {
                  var messageData = JSON.parse(messageEvent.data);
                  var pusherEventData = messageData.data;
                  if (typeof pusherEventData === "string") {
                    try {
                      pusherEventData = JSON.parse(messageData.data);
                    } catch (e3) {
                    }
                  }
                  var pusherEvent = {
                    event: messageData.event,
                    channel: messageData.channel,
                    data: pusherEventData
                  };
                  if (messageData.user_id) {
                    pusherEvent.user_id = messageData.user_id;
                  }
                  return pusherEvent;
                } catch (e3) {
                  throw { type: "MessageParseError", error: e3, data: messageEvent.data };
                }
              },
              encodeMessage: function(event) {
                return JSON.stringify(event);
              },
              processHandshake: function(messageEvent) {
                var message = Protocol.decodeMessage(messageEvent);
                if (message.event === "pusher:connection_established") {
                  if (!message.data.activity_timeout) {
                    throw "No activity timeout specified in handshake";
                  }
                  return {
                    action: "connected",
                    id: message.data.socket_id,
                    activityTimeout: message.data.activity_timeout * 1e3
                  };
                } else if (message.event === "pusher:error") {
                  return {
                    action: this.getCloseAction(message.data),
                    error: this.getCloseError(message.data)
                  };
                } else {
                  throw "Invalid handshake";
                }
              },
              getCloseAction: function(closeEvent) {
                if (closeEvent.code < 4e3) {
                  if (closeEvent.code >= 1002 && closeEvent.code <= 1004) {
                    return "backoff";
                  } else {
                    return null;
                  }
                } else if (closeEvent.code === 4e3) {
                  return "tls_only";
                } else if (closeEvent.code < 4100) {
                  return "refused";
                } else if (closeEvent.code < 4200) {
                  return "backoff";
                } else if (closeEvent.code < 4300) {
                  return "retry";
                } else {
                  return "refused";
                }
              },
              getCloseError: function(closeEvent) {
                if (closeEvent.code !== 1e3 && closeEvent.code !== 1001) {
                  return {
                    type: "PusherError",
                    data: {
                      code: closeEvent.code,
                      message: closeEvent.reason || closeEvent.message
                    }
                  };
                } else {
                  return null;
                }
              }
            };
            var protocol_protocol = Protocol;
            class connection_Connection extends dispatcher_Dispatcher {
              constructor(id, transport) {
                super();
                this.id = id;
                this.transport = transport;
                this.activityTimeout = transport.activityTimeout;
                this.bindListeners();
              }
              handlesActivityChecks() {
                return this.transport.handlesActivityChecks();
              }
              send(data) {
                return this.transport.send(data);
              }
              send_event(name3, data, channel) {
                var event = { event: name3, data };
                if (channel) {
                  event.channel = channel;
                }
                logger.debug("Event sent", event);
                return this.send(protocol_protocol.encodeMessage(event));
              }
              ping() {
                if (this.transport.supportsPing()) {
                  this.transport.ping();
                } else {
                  this.send_event("pusher:ping", {});
                }
              }
              close() {
                this.transport.close();
              }
              bindListeners() {
                var listeners = {
                  message: (messageEvent) => {
                    var pusherEvent;
                    try {
                      pusherEvent = protocol_protocol.decodeMessage(messageEvent);
                    } catch (e3) {
                      this.emit("error", {
                        type: "MessageParseError",
                        error: e3,
                        data: messageEvent.data
                      });
                    }
                    if (pusherEvent !== void 0) {
                      logger.debug("Event recd", pusherEvent);
                      switch (pusherEvent.event) {
                        case "pusher:error":
                          this.emit("error", {
                            type: "PusherError",
                            data: pusherEvent.data
                          });
                          break;
                        case "pusher:ping":
                          this.emit("ping");
                          break;
                        case "pusher:pong":
                          this.emit("pong");
                          break;
                      }
                      this.emit("message", pusherEvent);
                    }
                  },
                  activity: () => {
                    this.emit("activity");
                  },
                  error: (error2) => {
                    this.emit("error", error2);
                  },
                  closed: (closeEvent) => {
                    unbindListeners();
                    if (closeEvent && closeEvent.code) {
                      this.handleCloseEvent(closeEvent);
                    }
                    this.transport = null;
                    this.emit("closed");
                  }
                };
                var unbindListeners = /* @__PURE__ */ __name(() => {
                  objectApply(listeners, (listener, event) => {
                    this.transport.unbind(event, listener);
                  });
                }, "unbindListeners");
                objectApply(listeners, (listener, event) => {
                  this.transport.bind(event, listener);
                });
              }
              handleCloseEvent(closeEvent) {
                var action = protocol_protocol.getCloseAction(closeEvent);
                var error2 = protocol_protocol.getCloseError(closeEvent);
                if (error2) {
                  this.emit("error", error2);
                }
                if (action) {
                  this.emit(action, { action, error: error2 });
                }
              }
            }
            __name(connection_Connection, "connection_Connection");
            class handshake_Handshake {
              constructor(transport, callback) {
                this.transport = transport;
                this.callback = callback;
                this.bindListeners();
              }
              close() {
                this.unbindListeners();
                this.transport.close();
              }
              bindListeners() {
                this.onMessage = (m) => {
                  this.unbindListeners();
                  var result;
                  try {
                    result = protocol_protocol.processHandshake(m);
                  } catch (e3) {
                    this.finish("error", { error: e3 });
                    this.transport.close();
                    return;
                  }
                  if (result.action === "connected") {
                    this.finish("connected", {
                      connection: new connection_Connection(result.id, this.transport),
                      activityTimeout: result.activityTimeout
                    });
                  } else {
                    this.finish(result.action, { error: result.error });
                    this.transport.close();
                  }
                };
                this.onClosed = (closeEvent) => {
                  this.unbindListeners();
                  var action = protocol_protocol.getCloseAction(closeEvent) || "backoff";
                  var error2 = protocol_protocol.getCloseError(closeEvent);
                  this.finish(action, { error: error2 });
                };
                this.transport.bind("message", this.onMessage);
                this.transport.bind("closed", this.onClosed);
              }
              unbindListeners() {
                this.transport.unbind("message", this.onMessage);
                this.transport.unbind("closed", this.onClosed);
              }
              finish(action, params) {
                this.callback(extend({ transport: this.transport, action }, params));
              }
            }
            __name(handshake_Handshake, "handshake_Handshake");
            class timeline_sender_TimelineSender {
              constructor(timeline, options2) {
                this.timeline = timeline;
                this.options = options2 || {};
              }
              send(useTLS, callback) {
                if (this.timeline.isEmpty()) {
                  return;
                }
                this.timeline.send(runtime.TimelineTransport.getAgent(this, useTLS), callback);
              }
            }
            __name(timeline_sender_TimelineSender, "timeline_sender_TimelineSender");
            class channel_Channel extends dispatcher_Dispatcher {
              constructor(name3, pusher) {
                super(function(event, data) {
                  logger.debug("No callbacks on " + name3 + " for " + event);
                });
                this.name = name3;
                this.pusher = pusher;
                this.subscribed = false;
                this.subscriptionPending = false;
                this.subscriptionCancelled = false;
              }
              authorize(socketId, callback) {
                return callback(null, { auth: "" });
              }
              trigger(event, data) {
                if (event.indexOf("client-") !== 0) {
                  throw new BadEventName("Event '" + event + "' does not start with 'client-'");
                }
                if (!this.subscribed) {
                  var suffix = url_store.buildLogSuffix("triggeringClientEvents");
                  logger.warn(`Client event triggered before channel 'subscription_succeeded' event . ${suffix}`);
                }
                return this.pusher.send_event(event, data, this.name);
              }
              disconnect() {
                this.subscribed = false;
                this.subscriptionPending = false;
              }
              handleEvent(event) {
                var eventName = event.event;
                var data = event.data;
                if (eventName === "pusher_internal:subscription_succeeded") {
                  this.handleSubscriptionSucceededEvent(event);
                } else if (eventName === "pusher_internal:subscription_count") {
                  this.handleSubscriptionCountEvent(event);
                } else if (eventName.indexOf("pusher_internal:") !== 0) {
                  var metadata = {};
                  this.emit(eventName, data, metadata);
                }
              }
              handleSubscriptionSucceededEvent(event) {
                this.subscriptionPending = false;
                this.subscribed = true;
                if (this.subscriptionCancelled) {
                  this.pusher.unsubscribe(this.name);
                } else {
                  this.emit("pusher:subscription_succeeded", event.data);
                }
              }
              handleSubscriptionCountEvent(event) {
                if (event.data.subscription_count) {
                  this.subscriptionCount = event.data.subscription_count;
                }
                this.emit("pusher:subscription_count", event.data);
              }
              subscribe() {
                if (this.subscribed) {
                  return;
                }
                this.subscriptionPending = true;
                this.subscriptionCancelled = false;
                this.authorize(this.pusher.connection.socket_id, (error2, data) => {
                  if (error2) {
                    this.subscriptionPending = false;
                    logger.error(error2.toString());
                    this.emit("pusher:subscription_error", Object.assign({}, {
                      type: "AuthError",
                      error: error2.message
                    }, error2 instanceof HTTPAuthError ? { status: error2.status } : {}));
                  } else {
                    this.pusher.send_event("pusher:subscribe", {
                      auth: data.auth,
                      channel_data: data.channel_data,
                      channel: this.name
                    });
                  }
                });
              }
              unsubscribe() {
                this.subscribed = false;
                this.pusher.send_event("pusher:unsubscribe", {
                  channel: this.name
                });
              }
              cancelSubscription() {
                this.subscriptionCancelled = true;
              }
              reinstateSubscription() {
                this.subscriptionCancelled = false;
              }
            }
            __name(channel_Channel, "channel_Channel");
            class private_channel_PrivateChannel extends channel_Channel {
              authorize(socketId, callback) {
                return this.pusher.config.channelAuthorizer({
                  channelName: this.name,
                  socketId
                }, callback);
              }
            }
            __name(private_channel_PrivateChannel, "private_channel_PrivateChannel");
            class members_Members {
              constructor() {
                this.reset();
              }
              get(id) {
                if (Object.prototype.hasOwnProperty.call(this.members, id)) {
                  return {
                    id,
                    info: this.members[id]
                  };
                } else {
                  return null;
                }
              }
              each(callback) {
                objectApply(this.members, (member, id) => {
                  callback(this.get(id));
                });
              }
              setMyID(id) {
                this.myID = id;
              }
              onSubscription(subscriptionData) {
                this.members = subscriptionData.presence.hash;
                this.count = subscriptionData.presence.count;
                this.me = this.get(this.myID);
              }
              addMember(memberData) {
                if (this.get(memberData.user_id) === null) {
                  this.count++;
                }
                this.members[memberData.user_id] = memberData.user_info;
                return this.get(memberData.user_id);
              }
              removeMember(memberData) {
                var member = this.get(memberData.user_id);
                if (member) {
                  delete this.members[memberData.user_id];
                  this.count--;
                }
                return member;
              }
              reset() {
                this.members = {};
                this.count = 0;
                this.myID = null;
                this.me = null;
              }
            }
            __name(members_Members, "members_Members");
            var __awaiter = /* @__PURE__ */ __name(function(thisArg, _arguments, P, generator) {
              function adopt(value) {
                return value instanceof P ? value : new P(function(resolve2) {
                  resolve2(value);
                });
              }
              __name(adopt, "adopt");
              return new (P || (P = Promise))(function(resolve2, reject) {
                function fulfilled(value) {
                  try {
                    step(generator.next(value));
                  } catch (e3) {
                    reject(e3);
                  }
                }
                __name(fulfilled, "fulfilled");
                function rejected(value) {
                  try {
                    step(generator["throw"](value));
                  } catch (e3) {
                    reject(e3);
                  }
                }
                __name(rejected, "rejected");
                function step(result) {
                  result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                __name(step, "step");
                step((generator = generator.apply(thisArg, _arguments || [])).next());
              });
            }, "__awaiter");
            class presence_channel_PresenceChannel extends private_channel_PrivateChannel {
              constructor(name3, pusher) {
                super(name3, pusher);
                this.members = new members_Members();
              }
              authorize(socketId, callback) {
                super.authorize(socketId, (error2, authData) => __awaiter(this, void 0, void 0, function* () {
                  if (!error2) {
                    authData = authData;
                    if (authData.channel_data != null) {
                      var channelData = JSON.parse(authData.channel_data);
                      this.members.setMyID(channelData.user_id);
                    } else {
                      yield this.pusher.user.signinDonePromise;
                      if (this.pusher.user.user_data != null) {
                        this.members.setMyID(this.pusher.user.user_data.id);
                      } else {
                        let suffix = url_store.buildLogSuffix("authorizationEndpoint");
                        logger.error(`Invalid auth response for channel '${this.name}', expected 'channel_data' field. ${suffix}, or the user should be signed in.`);
                        callback("Invalid auth response");
                        return;
                      }
                    }
                  }
                  callback(error2, authData);
                }));
              }
              handleEvent(event) {
                var eventName = event.event;
                if (eventName.indexOf("pusher_internal:") === 0) {
                  this.handleInternalEvent(event);
                } else {
                  var data = event.data;
                  var metadata = {};
                  if (event.user_id) {
                    metadata.user_id = event.user_id;
                  }
                  this.emit(eventName, data, metadata);
                }
              }
              handleInternalEvent(event) {
                var eventName = event.event;
                var data = event.data;
                switch (eventName) {
                  case "pusher_internal:subscription_succeeded":
                    this.handleSubscriptionSucceededEvent(event);
                    break;
                  case "pusher_internal:subscription_count":
                    this.handleSubscriptionCountEvent(event);
                    break;
                  case "pusher_internal:member_added":
                    var addedMember = this.members.addMember(data);
                    this.emit("pusher:member_added", addedMember);
                    break;
                  case "pusher_internal:member_removed":
                    var removedMember = this.members.removeMember(data);
                    if (removedMember) {
                      this.emit("pusher:member_removed", removedMember);
                    }
                    break;
                }
              }
              handleSubscriptionSucceededEvent(event) {
                this.subscriptionPending = false;
                this.subscribed = true;
                if (this.subscriptionCancelled) {
                  this.pusher.unsubscribe(this.name);
                } else {
                  this.members.onSubscription(event.data);
                  this.emit("pusher:subscription_succeeded", this.members);
                }
              }
              disconnect() {
                this.members.reset();
                super.disconnect();
              }
            }
            __name(presence_channel_PresenceChannel, "presence_channel_PresenceChannel");
            var utf8 = __webpack_require__(1);
            var base642 = __webpack_require__(0);
            class encrypted_channel_EncryptedChannel extends private_channel_PrivateChannel {
              constructor(name3, pusher, nacl) {
                super(name3, pusher);
                this.key = null;
                this.nacl = nacl;
              }
              authorize(socketId, callback) {
                super.authorize(socketId, (error2, authData) => {
                  if (error2) {
                    callback(error2, authData);
                    return;
                  }
                  let sharedSecret = authData["shared_secret"];
                  if (!sharedSecret) {
                    callback(new Error(`No shared_secret key in auth payload for encrypted channel: ${this.name}`), null);
                    return;
                  }
                  this.key = Object(base642["decode"])(sharedSecret);
                  delete authData["shared_secret"];
                  callback(null, authData);
                });
              }
              trigger(event, data) {
                throw new UnsupportedFeature("Client events are not currently supported for encrypted channels");
              }
              handleEvent(event) {
                var eventName = event.event;
                var data = event.data;
                if (eventName.indexOf("pusher_internal:") === 0 || eventName.indexOf("pusher:") === 0) {
                  super.handleEvent(event);
                  return;
                }
                this.handleEncryptedEvent(eventName, data);
              }
              handleEncryptedEvent(event, data) {
                if (!this.key) {
                  logger.debug("Received encrypted event before key has been retrieved from the authEndpoint");
                  return;
                }
                if (!data.ciphertext || !data.nonce) {
                  logger.error("Unexpected format for encrypted event, expected object with `ciphertext` and `nonce` fields, got: " + data);
                  return;
                }
                let cipherText = Object(base642["decode"])(data.ciphertext);
                if (cipherText.length < this.nacl.secretbox.overheadLength) {
                  logger.error(`Expected encrypted event ciphertext length to be ${this.nacl.secretbox.overheadLength}, got: ${cipherText.length}`);
                  return;
                }
                let nonce = Object(base642["decode"])(data.nonce);
                if (nonce.length < this.nacl.secretbox.nonceLength) {
                  logger.error(`Expected encrypted event nonce length to be ${this.nacl.secretbox.nonceLength}, got: ${nonce.length}`);
                  return;
                }
                let bytes = this.nacl.secretbox.open(cipherText, nonce, this.key);
                if (bytes === null) {
                  logger.debug("Failed to decrypt an event, probably because it was encrypted with a different key. Fetching a new key from the authEndpoint...");
                  this.authorize(this.pusher.connection.socket_id, (error2, authData) => {
                    if (error2) {
                      logger.error(`Failed to make a request to the authEndpoint: ${authData}. Unable to fetch new key, so dropping encrypted event`);
                      return;
                    }
                    bytes = this.nacl.secretbox.open(cipherText, nonce, this.key);
                    if (bytes === null) {
                      logger.error(`Failed to decrypt event with new key. Dropping encrypted event`);
                      return;
                    }
                    this.emit(event, this.getDataToEmit(bytes));
                    return;
                  });
                  return;
                }
                this.emit(event, this.getDataToEmit(bytes));
              }
              getDataToEmit(bytes) {
                let raw = Object(utf8["decode"])(bytes);
                try {
                  return JSON.parse(raw);
                } catch (_a) {
                  return raw;
                }
              }
            }
            __name(encrypted_channel_EncryptedChannel, "encrypted_channel_EncryptedChannel");
            class connection_manager_ConnectionManager extends dispatcher_Dispatcher {
              constructor(key2, options2) {
                super();
                this.state = "initialized";
                this.connection = null;
                this.key = key2;
                this.options = options2;
                this.timeline = this.options.timeline;
                this.usingTLS = this.options.useTLS;
                this.errorCallbacks = this.buildErrorCallbacks();
                this.connectionCallbacks = this.buildConnectionCallbacks(this.errorCallbacks);
                this.handshakeCallbacks = this.buildHandshakeCallbacks(this.errorCallbacks);
                var Network = runtime.getNetwork();
                Network.bind("online", () => {
                  this.timeline.info({ netinfo: "online" });
                  if (this.state === "connecting" || this.state === "unavailable") {
                    this.retryIn(0);
                  }
                });
                Network.bind("offline", () => {
                  this.timeline.info({ netinfo: "offline" });
                  if (this.connection) {
                    this.sendActivityCheck();
                  }
                });
                this.updateStrategy();
              }
              switchCluster(key2) {
                this.key = key2;
                this.updateStrategy();
                this.retryIn(0);
              }
              connect() {
                if (this.connection || this.runner) {
                  return;
                }
                if (!this.strategy.isSupported()) {
                  this.updateState("failed");
                  return;
                }
                this.updateState("connecting");
                this.startConnecting();
                this.setUnavailableTimer();
              }
              send(data) {
                if (this.connection) {
                  return this.connection.send(data);
                } else {
                  return false;
                }
              }
              send_event(name3, data, channel) {
                if (this.connection) {
                  return this.connection.send_event(name3, data, channel);
                } else {
                  return false;
                }
              }
              disconnect() {
                this.disconnectInternally();
                this.updateState("disconnected");
              }
              isUsingTLS() {
                return this.usingTLS;
              }
              startConnecting() {
                var callback = /* @__PURE__ */ __name((error2, handshake) => {
                  if (error2) {
                    this.runner = this.strategy.connect(0, callback);
                  } else {
                    if (handshake.action === "error") {
                      this.emit("error", {
                        type: "HandshakeError",
                        error: handshake.error
                      });
                      this.timeline.error({ handshakeError: handshake.error });
                    } else {
                      this.abortConnecting();
                      this.handshakeCallbacks[handshake.action](handshake);
                    }
                  }
                }, "callback");
                this.runner = this.strategy.connect(0, callback);
              }
              abortConnecting() {
                if (this.runner) {
                  this.runner.abort();
                  this.runner = null;
                }
              }
              disconnectInternally() {
                this.abortConnecting();
                this.clearRetryTimer();
                this.clearUnavailableTimer();
                if (this.connection) {
                  var connection = this.abandonConnection();
                  connection.close();
                }
              }
              updateStrategy() {
                this.strategy = this.options.getStrategy({
                  key: this.key,
                  timeline: this.timeline,
                  useTLS: this.usingTLS
                });
              }
              retryIn(delay3) {
                this.timeline.info({ action: "retry", delay: delay3 });
                if (delay3 > 0) {
                  this.emit("connecting_in", Math.round(delay3 / 1e3));
                }
                this.retryTimer = new timers_OneOffTimer(delay3 || 0, () => {
                  this.disconnectInternally();
                  this.connect();
                });
              }
              clearRetryTimer() {
                if (this.retryTimer) {
                  this.retryTimer.ensureAborted();
                  this.retryTimer = null;
                }
              }
              setUnavailableTimer() {
                this.unavailableTimer = new timers_OneOffTimer(this.options.unavailableTimeout, () => {
                  this.updateState("unavailable");
                });
              }
              clearUnavailableTimer() {
                if (this.unavailableTimer) {
                  this.unavailableTimer.ensureAborted();
                }
              }
              sendActivityCheck() {
                this.stopActivityCheck();
                this.connection.ping();
                this.activityTimer = new timers_OneOffTimer(this.options.pongTimeout, () => {
                  this.timeline.error({ pong_timed_out: this.options.pongTimeout });
                  this.retryIn(0);
                });
              }
              resetActivityCheck() {
                this.stopActivityCheck();
                if (this.connection && !this.connection.handlesActivityChecks()) {
                  this.activityTimer = new timers_OneOffTimer(this.activityTimeout, () => {
                    this.sendActivityCheck();
                  });
                }
              }
              stopActivityCheck() {
                if (this.activityTimer) {
                  this.activityTimer.ensureAborted();
                }
              }
              buildConnectionCallbacks(errorCallbacks) {
                return extend({}, errorCallbacks, {
                  message: (message) => {
                    this.resetActivityCheck();
                    this.emit("message", message);
                  },
                  ping: () => {
                    this.send_event("pusher:pong", {});
                  },
                  activity: () => {
                    this.resetActivityCheck();
                  },
                  error: (error2) => {
                    this.emit("error", error2);
                  },
                  closed: () => {
                    this.abandonConnection();
                    if (this.shouldRetry()) {
                      this.retryIn(1e3);
                    }
                  }
                });
              }
              buildHandshakeCallbacks(errorCallbacks) {
                return extend({}, errorCallbacks, {
                  connected: (handshake) => {
                    this.activityTimeout = Math.min(this.options.activityTimeout, handshake.activityTimeout, handshake.connection.activityTimeout || Infinity);
                    this.clearUnavailableTimer();
                    this.setConnection(handshake.connection);
                    this.socket_id = this.connection.id;
                    this.updateState("connected", { socket_id: this.socket_id });
                  }
                });
              }
              buildErrorCallbacks() {
                let withErrorEmitted = /* @__PURE__ */ __name((callback) => {
                  return (result) => {
                    if (result.error) {
                      this.emit("error", { type: "WebSocketError", error: result.error });
                    }
                    callback(result);
                  };
                }, "withErrorEmitted");
                return {
                  tls_only: withErrorEmitted(() => {
                    this.usingTLS = true;
                    this.updateStrategy();
                    this.retryIn(0);
                  }),
                  refused: withErrorEmitted(() => {
                    this.disconnect();
                  }),
                  backoff: withErrorEmitted(() => {
                    this.retryIn(1e3);
                  }),
                  retry: withErrorEmitted(() => {
                    this.retryIn(0);
                  })
                };
              }
              setConnection(connection) {
                this.connection = connection;
                for (var event in this.connectionCallbacks) {
                  this.connection.bind(event, this.connectionCallbacks[event]);
                }
                this.resetActivityCheck();
              }
              abandonConnection() {
                if (!this.connection) {
                  return;
                }
                this.stopActivityCheck();
                for (var event in this.connectionCallbacks) {
                  this.connection.unbind(event, this.connectionCallbacks[event]);
                }
                var connection = this.connection;
                this.connection = null;
                return connection;
              }
              updateState(newState, data) {
                var previousState = this.state;
                this.state = newState;
                if (previousState !== newState) {
                  var newStateDescription = newState;
                  if (newStateDescription === "connected") {
                    newStateDescription += " with new socket ID " + data.socket_id;
                  }
                  logger.debug("State changed", previousState + " -> " + newStateDescription);
                  this.timeline.info({ state: newState, params: data });
                  this.emit("state_change", { previous: previousState, current: newState });
                  this.emit(newState, data);
                }
              }
              shouldRetry() {
                return this.state === "connecting" || this.state === "connected";
              }
            }
            __name(connection_manager_ConnectionManager, "connection_manager_ConnectionManager");
            class channels_Channels {
              constructor() {
                this.channels = {};
              }
              add(name3, pusher) {
                if (!this.channels[name3]) {
                  this.channels[name3] = createChannel(name3, pusher);
                }
                return this.channels[name3];
              }
              all() {
                return values(this.channels);
              }
              find(name3) {
                return this.channels[name3];
              }
              remove(name3) {
                var channel = this.channels[name3];
                delete this.channels[name3];
                return channel;
              }
              disconnect() {
                objectApply(this.channels, function(channel) {
                  channel.disconnect();
                });
              }
            }
            __name(channels_Channels, "channels_Channels");
            function createChannel(name3, pusher) {
              if (name3.indexOf("private-encrypted-") === 0) {
                if (pusher.config.nacl) {
                  return factory.createEncryptedChannel(name3, pusher, pusher.config.nacl);
                }
                let errMsg = "Tried to subscribe to a private-encrypted- channel but no nacl implementation available";
                let suffix = url_store.buildLogSuffix("encryptedChannelSupport");
                throw new UnsupportedFeature(`${errMsg}. ${suffix}`);
              } else if (name3.indexOf("private-") === 0) {
                return factory.createPrivateChannel(name3, pusher);
              } else if (name3.indexOf("presence-") === 0) {
                return factory.createPresenceChannel(name3, pusher);
              } else if (name3.indexOf("#") === 0) {
                throw new BadChannelName('Cannot create a channel with name "' + name3 + '".');
              } else {
                return factory.createChannel(name3, pusher);
              }
            }
            __name(createChannel, "createChannel");
            var Factory = {
              createChannels() {
                return new channels_Channels();
              },
              createConnectionManager(key2, options2) {
                return new connection_manager_ConnectionManager(key2, options2);
              },
              createChannel(name3, pusher) {
                return new channel_Channel(name3, pusher);
              },
              createPrivateChannel(name3, pusher) {
                return new private_channel_PrivateChannel(name3, pusher);
              },
              createPresenceChannel(name3, pusher) {
                return new presence_channel_PresenceChannel(name3, pusher);
              },
              createEncryptedChannel(name3, pusher, nacl) {
                return new encrypted_channel_EncryptedChannel(name3, pusher, nacl);
              },
              createTimelineSender(timeline, options2) {
                return new timeline_sender_TimelineSender(timeline, options2);
              },
              createHandshake(transport, callback) {
                return new handshake_Handshake(transport, callback);
              },
              createAssistantToTheTransportManager(manager, transport, options2) {
                return new assistant_to_the_transport_manager_AssistantToTheTransportManager(manager, transport, options2);
              }
            };
            var factory = Factory;
            class transport_manager_TransportManager {
              constructor(options2) {
                this.options = options2 || {};
                this.livesLeft = this.options.lives || Infinity;
              }
              getAssistant(transport) {
                return factory.createAssistantToTheTransportManager(this, transport, {
                  minPingDelay: this.options.minPingDelay,
                  maxPingDelay: this.options.maxPingDelay
                });
              }
              isAlive() {
                return this.livesLeft > 0;
              }
              reportDeath() {
                this.livesLeft -= 1;
              }
            }
            __name(transport_manager_TransportManager, "transport_manager_TransportManager");
            class sequential_strategy_SequentialStrategy {
              constructor(strategies, options2) {
                this.strategies = strategies;
                this.loop = Boolean(options2.loop);
                this.failFast = Boolean(options2.failFast);
                this.timeout = options2.timeout;
                this.timeoutLimit = options2.timeoutLimit;
              }
              isSupported() {
                return any(this.strategies, util2.method("isSupported"));
              }
              connect(minPriority, callback) {
                var strategies = this.strategies;
                var current = 0;
                var timeout = this.timeout;
                var runner = null;
                var tryNextStrategy = /* @__PURE__ */ __name((error2, handshake) => {
                  if (handshake) {
                    callback(null, handshake);
                  } else {
                    current = current + 1;
                    if (this.loop) {
                      current = current % strategies.length;
                    }
                    if (current < strategies.length) {
                      if (timeout) {
                        timeout = timeout * 2;
                        if (this.timeoutLimit) {
                          timeout = Math.min(timeout, this.timeoutLimit);
                        }
                      }
                      runner = this.tryStrategy(strategies[current], minPriority, { timeout, failFast: this.failFast }, tryNextStrategy);
                    } else {
                      callback(true);
                    }
                  }
                }, "tryNextStrategy");
                runner = this.tryStrategy(strategies[current], minPriority, { timeout, failFast: this.failFast }, tryNextStrategy);
                return {
                  abort: function() {
                    runner.abort();
                  },
                  forceMinPriority: function(p2) {
                    minPriority = p2;
                    if (runner) {
                      runner.forceMinPriority(p2);
                    }
                  }
                };
              }
              tryStrategy(strategy, minPriority, options2, callback) {
                var timer = null;
                var runner = null;
                if (options2.timeout > 0) {
                  timer = new timers_OneOffTimer(options2.timeout, function() {
                    runner.abort();
                    callback(true);
                  });
                }
                runner = strategy.connect(minPriority, function(error2, handshake) {
                  if (error2 && timer && timer.isRunning() && !options2.failFast) {
                    return;
                  }
                  if (timer) {
                    timer.ensureAborted();
                  }
                  callback(error2, handshake);
                });
                return {
                  abort: function() {
                    if (timer) {
                      timer.ensureAborted();
                    }
                    runner.abort();
                  },
                  forceMinPriority: function(p2) {
                    runner.forceMinPriority(p2);
                  }
                };
              }
            }
            __name(sequential_strategy_SequentialStrategy, "sequential_strategy_SequentialStrategy");
            class best_connected_ever_strategy_BestConnectedEverStrategy {
              constructor(strategies) {
                this.strategies = strategies;
              }
              isSupported() {
                return any(this.strategies, util2.method("isSupported"));
              }
              connect(minPriority, callback) {
                return connect(this.strategies, minPriority, function(i2, runners) {
                  return function(error2, handshake) {
                    runners[i2].error = error2;
                    if (error2) {
                      if (allRunnersFailed(runners)) {
                        callback(true);
                      }
                      return;
                    }
                    apply(runners, function(runner) {
                      runner.forceMinPriority(handshake.transport.priority);
                    });
                    callback(null, handshake);
                  };
                });
              }
            }
            __name(best_connected_ever_strategy_BestConnectedEverStrategy, "best_connected_ever_strategy_BestConnectedEverStrategy");
            function connect(strategies, minPriority, callbackBuilder) {
              var runners = map(strategies, function(strategy, i2, _2, rs) {
                return strategy.connect(minPriority, callbackBuilder(i2, rs));
              });
              return {
                abort: function() {
                  apply(runners, abortRunner);
                },
                forceMinPriority: function(p2) {
                  apply(runners, function(runner) {
                    runner.forceMinPriority(p2);
                  });
                }
              };
            }
            __name(connect, "connect");
            function allRunnersFailed(runners) {
              return collections_all(runners, function(runner) {
                return Boolean(runner.error);
              });
            }
            __name(allRunnersFailed, "allRunnersFailed");
            function abortRunner(runner) {
              if (!runner.error && !runner.aborted) {
                runner.abort();
                runner.aborted = true;
              }
            }
            __name(abortRunner, "abortRunner");
            class websocket_prioritized_cached_strategy_WebSocketPrioritizedCachedStrategy {
              constructor(strategy, transports2, options2) {
                this.strategy = strategy;
                this.transports = transports2;
                this.ttl = options2.ttl || 1800 * 1e3;
                this.usingTLS = options2.useTLS;
                this.timeline = options2.timeline;
              }
              isSupported() {
                return this.strategy.isSupported();
              }
              connect(minPriority, callback) {
                var usingTLS = this.usingTLS;
                var info = fetchTransportCache(usingTLS);
                var cacheSkipCount = info && info.cacheSkipCount ? info.cacheSkipCount : 0;
                var strategies = [this.strategy];
                if (info && info.timestamp + this.ttl >= util2.now()) {
                  var transport = this.transports[info.transport];
                  if (transport) {
                    if (["ws", "wss"].includes(info.transport) || cacheSkipCount > 3) {
                      this.timeline.info({
                        cached: true,
                        transport: info.transport,
                        latency: info.latency
                      });
                      strategies.push(new sequential_strategy_SequentialStrategy([transport], {
                        timeout: info.latency * 2 + 1e3,
                        failFast: true
                      }));
                    } else {
                      cacheSkipCount++;
                    }
                  }
                }
                var startTimestamp = util2.now();
                var runner = strategies.pop().connect(minPriority, /* @__PURE__ */ __name(function cb(error2, handshake) {
                  if (error2) {
                    flushTransportCache(usingTLS);
                    if (strategies.length > 0) {
                      startTimestamp = util2.now();
                      runner = strategies.pop().connect(minPriority, cb);
                    } else {
                      callback(error2);
                    }
                  } else {
                    storeTransportCache(usingTLS, handshake.transport.name, util2.now() - startTimestamp, cacheSkipCount);
                    callback(null, handshake);
                  }
                }, "cb"));
                return {
                  abort: function() {
                    runner.abort();
                  },
                  forceMinPriority: function(p2) {
                    minPriority = p2;
                    if (runner) {
                      runner.forceMinPriority(p2);
                    }
                  }
                };
              }
            }
            __name(websocket_prioritized_cached_strategy_WebSocketPrioritizedCachedStrategy, "websocket_prioritized_cached_strategy_WebSocketPrioritizedCachedStrategy");
            function getTransportCacheKey(usingTLS) {
              return "pusherTransport" + (usingTLS ? "TLS" : "NonTLS");
            }
            __name(getTransportCacheKey, "getTransportCacheKey");
            function fetchTransportCache(usingTLS) {
              var storage = runtime.getLocalStorage();
              if (storage) {
                try {
                  var serializedCache = storage[getTransportCacheKey(usingTLS)];
                  if (serializedCache) {
                    return JSON.parse(serializedCache);
                  }
                } catch (e3) {
                  flushTransportCache(usingTLS);
                }
              }
              return null;
            }
            __name(fetchTransportCache, "fetchTransportCache");
            function storeTransportCache(usingTLS, transport, latency, cacheSkipCount) {
              var storage = runtime.getLocalStorage();
              if (storage) {
                try {
                  storage[getTransportCacheKey(usingTLS)] = safeJSONStringify({
                    timestamp: util2.now(),
                    transport,
                    latency,
                    cacheSkipCount
                  });
                } catch (e3) {
                }
              }
            }
            __name(storeTransportCache, "storeTransportCache");
            function flushTransportCache(usingTLS) {
              var storage = runtime.getLocalStorage();
              if (storage) {
                try {
                  delete storage[getTransportCacheKey(usingTLS)];
                } catch (e3) {
                }
              }
            }
            __name(flushTransportCache, "flushTransportCache");
            class delayed_strategy_DelayedStrategy {
              constructor(strategy, { delay: number }) {
                this.strategy = strategy;
                this.options = { delay: number };
              }
              isSupported() {
                return this.strategy.isSupported();
              }
              connect(minPriority, callback) {
                var strategy = this.strategy;
                var runner;
                var timer = new timers_OneOffTimer(this.options.delay, function() {
                  runner = strategy.connect(minPriority, callback);
                });
                return {
                  abort: function() {
                    timer.ensureAborted();
                    if (runner) {
                      runner.abort();
                    }
                  },
                  forceMinPriority: function(p2) {
                    minPriority = p2;
                    if (runner) {
                      runner.forceMinPriority(p2);
                    }
                  }
                };
              }
            }
            __name(delayed_strategy_DelayedStrategy, "delayed_strategy_DelayedStrategy");
            class IfStrategy {
              constructor(test, trueBranch, falseBranch) {
                this.test = test;
                this.trueBranch = trueBranch;
                this.falseBranch = falseBranch;
              }
              isSupported() {
                var branch2 = this.test() ? this.trueBranch : this.falseBranch;
                return branch2.isSupported();
              }
              connect(minPriority, callback) {
                var branch2 = this.test() ? this.trueBranch : this.falseBranch;
                return branch2.connect(minPriority, callback);
              }
            }
            __name(IfStrategy, "IfStrategy");
            class FirstConnectedStrategy {
              constructor(strategy) {
                this.strategy = strategy;
              }
              isSupported() {
                return this.strategy.isSupported();
              }
              connect(minPriority, callback) {
                var runner = this.strategy.connect(minPriority, function(error2, handshake) {
                  if (handshake) {
                    runner.abort();
                  }
                  callback(error2, handshake);
                });
                return runner;
              }
            }
            __name(FirstConnectedStrategy, "FirstConnectedStrategy");
            function testSupportsStrategy(strategy) {
              return function() {
                return strategy.isSupported();
              };
            }
            __name(testSupportsStrategy, "testSupportsStrategy");
            var getDefaultStrategy = /* @__PURE__ */ __name(function(config, baseOptions, defineTransport) {
              var definedTransports = {};
              function defineTransportStrategy(name3, type, priority, options2, manager) {
                var transport = defineTransport(config, name3, type, priority, options2, manager);
                definedTransports[name3] = transport;
                return transport;
              }
              __name(defineTransportStrategy, "defineTransportStrategy");
              var ws_options = Object.assign({}, baseOptions, {
                hostNonTLS: config.wsHost + ":" + config.wsPort,
                hostTLS: config.wsHost + ":" + config.wssPort,
                httpPath: config.wsPath
              });
              var wss_options = Object.assign({}, ws_options, {
                useTLS: true
              });
              var sockjs_options = Object.assign({}, baseOptions, {
                hostNonTLS: config.httpHost + ":" + config.httpPort,
                hostTLS: config.httpHost + ":" + config.httpsPort,
                httpPath: config.httpPath
              });
              var timeouts = {
                loop: true,
                timeout: 15e3,
                timeoutLimit: 6e4
              };
              var ws_manager = new transport_manager_TransportManager({
                minPingDelay: 1e4,
                maxPingDelay: config.activityTimeout
              });
              var streaming_manager = new transport_manager_TransportManager({
                lives: 2,
                minPingDelay: 1e4,
                maxPingDelay: config.activityTimeout
              });
              var ws_transport = defineTransportStrategy("ws", "ws", 3, ws_options, ws_manager);
              var wss_transport = defineTransportStrategy("wss", "ws", 3, wss_options, ws_manager);
              var sockjs_transport = defineTransportStrategy("sockjs", "sockjs", 1, sockjs_options);
              var xhr_streaming_transport = defineTransportStrategy("xhr_streaming", "xhr_streaming", 1, sockjs_options, streaming_manager);
              var xdr_streaming_transport = defineTransportStrategy("xdr_streaming", "xdr_streaming", 1, sockjs_options, streaming_manager);
              var xhr_polling_transport = defineTransportStrategy("xhr_polling", "xhr_polling", 1, sockjs_options);
              var xdr_polling_transport = defineTransportStrategy("xdr_polling", "xdr_polling", 1, sockjs_options);
              var ws_loop = new sequential_strategy_SequentialStrategy([ws_transport], timeouts);
              var wss_loop = new sequential_strategy_SequentialStrategy([wss_transport], timeouts);
              var sockjs_loop = new sequential_strategy_SequentialStrategy([sockjs_transport], timeouts);
              var streaming_loop = new sequential_strategy_SequentialStrategy([
                new IfStrategy(testSupportsStrategy(xhr_streaming_transport), xhr_streaming_transport, xdr_streaming_transport)
              ], timeouts);
              var polling_loop = new sequential_strategy_SequentialStrategy([
                new IfStrategy(testSupportsStrategy(xhr_polling_transport), xhr_polling_transport, xdr_polling_transport)
              ], timeouts);
              var http_loop = new sequential_strategy_SequentialStrategy([
                new IfStrategy(testSupportsStrategy(streaming_loop), new best_connected_ever_strategy_BestConnectedEverStrategy([
                  streaming_loop,
                  new delayed_strategy_DelayedStrategy(polling_loop, { delay: 4e3 })
                ]), polling_loop)
              ], timeouts);
              var http_fallback_loop = new IfStrategy(testSupportsStrategy(http_loop), http_loop, sockjs_loop);
              var wsStrategy;
              if (baseOptions.useTLS) {
                wsStrategy = new best_connected_ever_strategy_BestConnectedEverStrategy([
                  ws_loop,
                  new delayed_strategy_DelayedStrategy(http_fallback_loop, { delay: 2e3 })
                ]);
              } else {
                wsStrategy = new best_connected_ever_strategy_BestConnectedEverStrategy([
                  ws_loop,
                  new delayed_strategy_DelayedStrategy(wss_loop, { delay: 2e3 }),
                  new delayed_strategy_DelayedStrategy(http_fallback_loop, { delay: 5e3 })
                ]);
              }
              return new websocket_prioritized_cached_strategy_WebSocketPrioritizedCachedStrategy(new FirstConnectedStrategy(new IfStrategy(testSupportsStrategy(ws_transport), wsStrategy, http_fallback_loop)), definedTransports, {
                ttl: 18e5,
                timeline: baseOptions.timeline,
                useTLS: baseOptions.useTLS
              });
            }, "getDefaultStrategy");
            var default_strategy = getDefaultStrategy;
            var transport_connection_initializer = /* @__PURE__ */ __name(function() {
              var self = this;
              self.timeline.info(self.buildTimelineMessage({
                transport: self.name + (self.options.useTLS ? "s" : "")
              }));
              if (self.hooks.isInitialized()) {
                self.changeState("initialized");
              } else if (self.hooks.file) {
                self.changeState("initializing");
                Dependencies.load(self.hooks.file, { useTLS: self.options.useTLS }, function(error2, callback) {
                  if (self.hooks.isInitialized()) {
                    self.changeState("initialized");
                    callback(true);
                  } else {
                    if (error2) {
                      self.onError(error2);
                    }
                    self.onClose();
                    callback(false);
                  }
                });
              } else {
                self.onClose();
              }
            }, "transport_connection_initializer");
            var http_xdomain_request_hooks = {
              getRequest: function(socket) {
                var xdr = new window.XDomainRequest();
                xdr.ontimeout = function() {
                  socket.emit("error", new RequestTimedOut());
                  socket.close();
                };
                xdr.onerror = function(e3) {
                  socket.emit("error", e3);
                  socket.close();
                };
                xdr.onprogress = function() {
                  if (xdr.responseText && xdr.responseText.length > 0) {
                    socket.onChunk(200, xdr.responseText);
                  }
                };
                xdr.onload = function() {
                  if (xdr.responseText && xdr.responseText.length > 0) {
                    socket.onChunk(200, xdr.responseText);
                  }
                  socket.emit("finished", 200);
                  socket.close();
                };
                return xdr;
              },
              abortRequest: function(xdr) {
                xdr.ontimeout = xdr.onerror = xdr.onprogress = xdr.onload = null;
                xdr.abort();
              }
            };
            var http_xdomain_request = http_xdomain_request_hooks;
            const MAX_BUFFER_LENGTH = 256 * 1024;
            class http_request_HTTPRequest extends dispatcher_Dispatcher {
              constructor(hooks, method, url) {
                super();
                this.hooks = hooks;
                this.method = method;
                this.url = url;
              }
              start(payload) {
                this.position = 0;
                this.xhr = this.hooks.getRequest(this);
                this.unloader = () => {
                  this.close();
                };
                runtime.addUnloadListener(this.unloader);
                this.xhr.open(this.method, this.url, true);
                if (this.xhr.setRequestHeader) {
                  this.xhr.setRequestHeader("Content-Type", "application/json");
                }
                this.xhr.send(payload);
              }
              close() {
                if (this.unloader) {
                  runtime.removeUnloadListener(this.unloader);
                  this.unloader = null;
                }
                if (this.xhr) {
                  this.hooks.abortRequest(this.xhr);
                  this.xhr = null;
                }
              }
              onChunk(status, data) {
                while (true) {
                  var chunk = this.advanceBuffer(data);
                  if (chunk) {
                    this.emit("chunk", { status, data: chunk });
                  } else {
                    break;
                  }
                }
                if (this.isBufferTooLong(data)) {
                  this.emit("buffer_too_long");
                }
              }
              advanceBuffer(buffer) {
                var unreadData = buffer.slice(this.position);
                var endOfLinePosition = unreadData.indexOf("\n");
                if (endOfLinePosition !== -1) {
                  this.position += endOfLinePosition + 1;
                  return unreadData.slice(0, endOfLinePosition);
                } else {
                  return null;
                }
              }
              isBufferTooLong(buffer) {
                return this.position === buffer.length && buffer.length > MAX_BUFFER_LENGTH;
              }
            }
            __name(http_request_HTTPRequest, "http_request_HTTPRequest");
            var State2;
            (function(State3) {
              State3[State3["CONNECTING"] = 0] = "CONNECTING";
              State3[State3["OPEN"] = 1] = "OPEN";
              State3[State3["CLOSED"] = 3] = "CLOSED";
            })(State2 || (State2 = {}));
            var state = State2;
            var autoIncrement = 1;
            class http_socket_HTTPSocket {
              constructor(hooks, url) {
                this.hooks = hooks;
                this.session = randomNumber(1e3) + "/" + randomString(8);
                this.location = getLocation(url);
                this.readyState = state.CONNECTING;
                this.openStream();
              }
              send(payload) {
                return this.sendRaw(JSON.stringify([payload]));
              }
              ping() {
                this.hooks.sendHeartbeat(this);
              }
              close(code, reason) {
                this.onClose(code, reason, true);
              }
              sendRaw(payload) {
                if (this.readyState === state.OPEN) {
                  try {
                    runtime.createSocketRequest("POST", getUniqueURL(getSendURL(this.location, this.session))).start(payload);
                    return true;
                  } catch (e3) {
                    return false;
                  }
                } else {
                  return false;
                }
              }
              reconnect() {
                this.closeStream();
                this.openStream();
              }
              onClose(code, reason, wasClean) {
                this.closeStream();
                this.readyState = state.CLOSED;
                if (this.onclose) {
                  this.onclose({
                    code,
                    reason,
                    wasClean
                  });
                }
              }
              onChunk(chunk) {
                if (chunk.status !== 200) {
                  return;
                }
                if (this.readyState === state.OPEN) {
                  this.onActivity();
                }
                var payload;
                var type = chunk.data.slice(0, 1);
                switch (type) {
                  case "o":
                    payload = JSON.parse(chunk.data.slice(1) || "{}");
                    this.onOpen(payload);
                    break;
                  case "a":
                    payload = JSON.parse(chunk.data.slice(1) || "[]");
                    for (var i2 = 0; i2 < payload.length; i2++) {
                      this.onEvent(payload[i2]);
                    }
                    break;
                  case "m":
                    payload = JSON.parse(chunk.data.slice(1) || "null");
                    this.onEvent(payload);
                    break;
                  case "h":
                    this.hooks.onHeartbeat(this);
                    break;
                  case "c":
                    payload = JSON.parse(chunk.data.slice(1) || "[]");
                    this.onClose(payload[0], payload[1], true);
                    break;
                }
              }
              onOpen(options2) {
                if (this.readyState === state.CONNECTING) {
                  if (options2 && options2.hostname) {
                    this.location.base = replaceHost(this.location.base, options2.hostname);
                  }
                  this.readyState = state.OPEN;
                  if (this.onopen) {
                    this.onopen();
                  }
                } else {
                  this.onClose(1006, "Server lost session", true);
                }
              }
              onEvent(event) {
                if (this.readyState === state.OPEN && this.onmessage) {
                  this.onmessage({ data: event });
                }
              }
              onActivity() {
                if (this.onactivity) {
                  this.onactivity();
                }
              }
              onError(error2) {
                if (this.onerror) {
                  this.onerror(error2);
                }
              }
              openStream() {
                this.stream = runtime.createSocketRequest("POST", getUniqueURL(this.hooks.getReceiveURL(this.location, this.session)));
                this.stream.bind("chunk", (chunk) => {
                  this.onChunk(chunk);
                });
                this.stream.bind("finished", (status) => {
                  this.hooks.onFinished(this, status);
                });
                this.stream.bind("buffer_too_long", () => {
                  this.reconnect();
                });
                try {
                  this.stream.start();
                } catch (error2) {
                  util2.defer(() => {
                    this.onError(error2);
                    this.onClose(1006, "Could not start streaming", false);
                  });
                }
              }
              closeStream() {
                if (this.stream) {
                  this.stream.unbind_all();
                  this.stream.close();
                  this.stream = null;
                }
              }
            }
            __name(http_socket_HTTPSocket, "http_socket_HTTPSocket");
            function getLocation(url) {
              var parts = /([^\?]*)\/*(\??.*)/.exec(url);
              return {
                base: parts[1],
                queryString: parts[2]
              };
            }
            __name(getLocation, "getLocation");
            function getSendURL(url, session) {
              return url.base + "/" + session + "/xhr_send";
            }
            __name(getSendURL, "getSendURL");
            function getUniqueURL(url) {
              var separator = url.indexOf("?") === -1 ? "?" : "&";
              return url + separator + "t=" + +/* @__PURE__ */ new Date() + "&n=" + autoIncrement++;
            }
            __name(getUniqueURL, "getUniqueURL");
            function replaceHost(url, hostname) {
              var urlParts = /(https?:\/\/)([^\/:]+)((\/|:)?.*)/.exec(url);
              return urlParts[1] + hostname + urlParts[3];
            }
            __name(replaceHost, "replaceHost");
            function randomNumber(max2) {
              return runtime.randomInt(max2);
            }
            __name(randomNumber, "randomNumber");
            function randomString(length) {
              var result = [];
              for (var i2 = 0; i2 < length; i2++) {
                result.push(randomNumber(32).toString(32));
              }
              return result.join("");
            }
            __name(randomString, "randomString");
            var http_socket = http_socket_HTTPSocket;
            var http_streaming_socket_hooks = {
              getReceiveURL: function(url, session) {
                return url.base + "/" + session + "/xhr_streaming" + url.queryString;
              },
              onHeartbeat: function(socket) {
                socket.sendRaw("[]");
              },
              sendHeartbeat: function(socket) {
                socket.sendRaw("[]");
              },
              onFinished: function(socket, status) {
                socket.onClose(1006, "Connection interrupted (" + status + ")", false);
              }
            };
            var http_streaming_socket = http_streaming_socket_hooks;
            var http_polling_socket_hooks = {
              getReceiveURL: function(url, session) {
                return url.base + "/" + session + "/xhr" + url.queryString;
              },
              onHeartbeat: function() {
              },
              sendHeartbeat: function(socket) {
                socket.sendRaw("[]");
              },
              onFinished: function(socket, status) {
                if (status === 200) {
                  socket.reconnect();
                } else {
                  socket.onClose(1006, "Connection interrupted (" + status + ")", false);
                }
              }
            };
            var http_polling_socket = http_polling_socket_hooks;
            var http_xhr_request_hooks = {
              getRequest: function(socket) {
                var Constructor = runtime.getXHRAPI();
                var xhr = new Constructor();
                xhr.onreadystatechange = xhr.onprogress = function() {
                  switch (xhr.readyState) {
                    case 3:
                      if (xhr.responseText && xhr.responseText.length > 0) {
                        socket.onChunk(xhr.status, xhr.responseText);
                      }
                      break;
                    case 4:
                      if (xhr.responseText && xhr.responseText.length > 0) {
                        socket.onChunk(xhr.status, xhr.responseText);
                      }
                      socket.emit("finished", xhr.status);
                      socket.close();
                      break;
                  }
                };
                return xhr;
              },
              abortRequest: function(xhr) {
                xhr.onreadystatechange = null;
                xhr.abort();
              }
            };
            var http_xhr_request = http_xhr_request_hooks;
            var HTTP = {
              createStreamingSocket(url) {
                return this.createSocket(http_streaming_socket, url);
              },
              createPollingSocket(url) {
                return this.createSocket(http_polling_socket, url);
              },
              createSocket(hooks, url) {
                return new http_socket(hooks, url);
              },
              createXHR(method, url) {
                return this.createRequest(http_xhr_request, method, url);
              },
              createRequest(hooks, method, url) {
                return new http_request_HTTPRequest(hooks, method, url);
              }
            };
            var http_http = HTTP;
            http_http.createXDR = function(method, url) {
              return this.createRequest(http_xdomain_request, method, url);
            };
            var web_http_http = http_http;
            var Runtime = {
              nextAuthCallbackID: 1,
              auth_callbacks: {},
              ScriptReceivers,
              DependenciesReceivers,
              getDefaultStrategy: default_strategy,
              Transports: transports_transports,
              transportConnectionInitializer: transport_connection_initializer,
              HTTPFactory: web_http_http,
              TimelineTransport: jsonp_timeline,
              getXHRAPI() {
                return window.XMLHttpRequest;
              },
              getWebSocketAPI() {
                return window.WebSocket || window.MozWebSocket;
              },
              setup(PusherClass) {
                window.Pusher = PusherClass;
                var initializeOnDocumentBody = /* @__PURE__ */ __name(() => {
                  this.onDocumentBody(PusherClass.ready);
                }, "initializeOnDocumentBody");
                if (!window.JSON) {
                  Dependencies.load("json2", {}, initializeOnDocumentBody);
                } else {
                  initializeOnDocumentBody();
                }
              },
              getDocument() {
                return document;
              },
              getProtocol() {
                return this.getDocument().location.protocol;
              },
              getAuthorizers() {
                return { ajax: xhr_auth, jsonp: jsonp_auth };
              },
              onDocumentBody(callback) {
                if (document.body) {
                  callback();
                } else {
                  setTimeout(() => {
                    this.onDocumentBody(callback);
                  }, 0);
                }
              },
              createJSONPRequest(url, data) {
                return new jsonp_request_JSONPRequest(url, data);
              },
              createScriptRequest(src) {
                return new ScriptRequest(src);
              },
              getLocalStorage() {
                try {
                  return window.localStorage;
                } catch (e3) {
                  return void 0;
                }
              },
              createXHR() {
                if (this.getXHRAPI()) {
                  return this.createXMLHttpRequest();
                } else {
                  return this.createMicrosoftXHR();
                }
              },
              createXMLHttpRequest() {
                var Constructor = this.getXHRAPI();
                return new Constructor();
              },
              createMicrosoftXHR() {
                return new ActiveXObject("Microsoft.XMLHTTP");
              },
              getNetwork() {
                return net_info_Network;
              },
              createWebSocket(url) {
                var Constructor = this.getWebSocketAPI();
                return new Constructor(url);
              },
              createSocketRequest(method, url) {
                if (this.isXHRSupported()) {
                  return this.HTTPFactory.createXHR(method, url);
                } else if (this.isXDRSupported(url.indexOf("https:") === 0)) {
                  return this.HTTPFactory.createXDR(method, url);
                } else {
                  throw "Cross-origin HTTP requests are not supported";
                }
              },
              isXHRSupported() {
                var Constructor = this.getXHRAPI();
                return Boolean(Constructor) && new Constructor().withCredentials !== void 0;
              },
              isXDRSupported(useTLS) {
                var protocol = useTLS ? "https:" : "http:";
                var documentProtocol = this.getProtocol();
                return Boolean(window["XDomainRequest"]) && documentProtocol === protocol;
              },
              addUnloadListener(listener) {
                if (window.addEventListener !== void 0) {
                  window.addEventListener("unload", listener, false);
                } else if (window.attachEvent !== void 0) {
                  window.attachEvent("onunload", listener);
                }
              },
              removeUnloadListener(listener) {
                if (window.addEventListener !== void 0) {
                  window.removeEventListener("unload", listener, false);
                } else if (window.detachEvent !== void 0) {
                  window.detachEvent("onunload", listener);
                }
              },
              randomInt(max2) {
                const random = /* @__PURE__ */ __name(function() {
                  const crypto2 = window.crypto || window["msCrypto"];
                  const random2 = crypto2.getRandomValues(new Uint32Array(1))[0];
                  return random2 / Math.pow(2, 32);
                }, "random");
                return Math.floor(random() * max2);
              }
            };
            var runtime = Runtime;
            var TimelineLevel;
            (function(TimelineLevel2) {
              TimelineLevel2[TimelineLevel2["ERROR"] = 3] = "ERROR";
              TimelineLevel2[TimelineLevel2["INFO"] = 6] = "INFO";
              TimelineLevel2[TimelineLevel2["DEBUG"] = 7] = "DEBUG";
            })(TimelineLevel || (TimelineLevel = {}));
            var timeline_level = TimelineLevel;
            class timeline_Timeline {
              constructor(key2, session, options2) {
                this.key = key2;
                this.session = session;
                this.events = [];
                this.options = options2 || {};
                this.sent = 0;
                this.uniqueID = 0;
              }
              log(level, event) {
                if (level <= this.options.level) {
                  this.events.push(extend({}, event, { timestamp: util2.now() }));
                  if (this.options.limit && this.events.length > this.options.limit) {
                    this.events.shift();
                  }
                }
              }
              error(event) {
                this.log(timeline_level.ERROR, event);
              }
              info(event) {
                this.log(timeline_level.INFO, event);
              }
              debug(event) {
                this.log(timeline_level.DEBUG, event);
              }
              isEmpty() {
                return this.events.length === 0;
              }
              send(sendfn, callback) {
                var data = extend({
                  session: this.session,
                  bundle: this.sent + 1,
                  key: this.key,
                  lib: "js",
                  version: this.options.version,
                  cluster: this.options.cluster,
                  features: this.options.features,
                  timeline: this.events
                }, this.options.params);
                this.events = [];
                sendfn(data, (error2, result) => {
                  if (!error2) {
                    this.sent++;
                  }
                  if (callback) {
                    callback(error2, result);
                  }
                });
                return true;
              }
              generateUniqueID() {
                this.uniqueID++;
                return this.uniqueID;
              }
            }
            __name(timeline_Timeline, "timeline_Timeline");
            class transport_strategy_TransportStrategy {
              constructor(name3, priority, transport, options2) {
                this.name = name3;
                this.priority = priority;
                this.transport = transport;
                this.options = options2 || {};
              }
              isSupported() {
                return this.transport.isSupported({
                  useTLS: this.options.useTLS
                });
              }
              connect(minPriority, callback) {
                if (!this.isSupported()) {
                  return failAttempt(new UnsupportedStrategy(), callback);
                } else if (this.priority < minPriority) {
                  return failAttempt(new TransportPriorityTooLow(), callback);
                }
                var connected = false;
                var transport = this.transport.createConnection(this.name, this.priority, this.options.key, this.options);
                var handshake = null;
                var onInitialized = /* @__PURE__ */ __name(function() {
                  transport.unbind("initialized", onInitialized);
                  transport.connect();
                }, "onInitialized");
                var onOpen = /* @__PURE__ */ __name(function() {
                  handshake = factory.createHandshake(transport, function(result) {
                    connected = true;
                    unbindListeners();
                    callback(null, result);
                  });
                }, "onOpen");
                var onError = /* @__PURE__ */ __name(function(error2) {
                  unbindListeners();
                  callback(error2);
                }, "onError");
                var onClosed = /* @__PURE__ */ __name(function() {
                  unbindListeners();
                  var serializedTransport;
                  serializedTransport = safeJSONStringify(transport);
                  callback(new TransportClosed(serializedTransport));
                }, "onClosed");
                var unbindListeners = /* @__PURE__ */ __name(function() {
                  transport.unbind("initialized", onInitialized);
                  transport.unbind("open", onOpen);
                  transport.unbind("error", onError);
                  transport.unbind("closed", onClosed);
                }, "unbindListeners");
                transport.bind("initialized", onInitialized);
                transport.bind("open", onOpen);
                transport.bind("error", onError);
                transport.bind("closed", onClosed);
                transport.initialize();
                return {
                  abort: () => {
                    if (connected) {
                      return;
                    }
                    unbindListeners();
                    if (handshake) {
                      handshake.close();
                    } else {
                      transport.close();
                    }
                  },
                  forceMinPriority: (p2) => {
                    if (connected) {
                      return;
                    }
                    if (this.priority < p2) {
                      if (handshake) {
                        handshake.close();
                      } else {
                        transport.close();
                      }
                    }
                  }
                };
              }
            }
            __name(transport_strategy_TransportStrategy, "transport_strategy_TransportStrategy");
            function failAttempt(error2, callback) {
              util2.defer(function() {
                callback(error2);
              });
              return {
                abort: function() {
                },
                forceMinPriority: function() {
                }
              };
            }
            __name(failAttempt, "failAttempt");
            const { Transports: strategy_builder_Transports } = runtime;
            var strategy_builder_defineTransport = /* @__PURE__ */ __name(function(config, name3, type, priority, options2, manager) {
              var transportClass = strategy_builder_Transports[type];
              if (!transportClass) {
                throw new UnsupportedTransport(type);
              }
              var enabled = (!config.enabledTransports || arrayIndexOf(config.enabledTransports, name3) !== -1) && (!config.disabledTransports || arrayIndexOf(config.disabledTransports, name3) === -1);
              var transport;
              if (enabled) {
                options2 = Object.assign({ ignoreNullOrigin: config.ignoreNullOrigin }, options2);
                transport = new transport_strategy_TransportStrategy(name3, priority, manager ? manager.getAssistant(transportClass) : transportClass, options2);
              } else {
                transport = strategy_builder_UnsupportedStrategy;
              }
              return transport;
            }, "strategy_builder_defineTransport");
            var strategy_builder_UnsupportedStrategy = {
              isSupported: function() {
                return false;
              },
              connect: function(_2, callback) {
                var deferred = util2.defer(function() {
                  callback(new UnsupportedStrategy());
                });
                return {
                  abort: function() {
                    deferred.ensureAborted();
                  },
                  forceMinPriority: function() {
                  }
                };
              }
            };
            function validateOptions(options2) {
              if (options2 == null) {
                throw "You must pass an options object";
              }
              if (options2.cluster == null) {
                throw "Options object must provide a cluster";
              }
              if ("disableStats" in options2) {
                logger.warn("The disableStats option is deprecated in favor of enableStats");
              }
            }
            __name(validateOptions, "validateOptions");
            const composeChannelQuery = /* @__PURE__ */ __name((params, authOptions) => {
              var query = "socket_id=" + encodeURIComponent(params.socketId);
              for (var key2 in authOptions.params) {
                query += "&" + encodeURIComponent(key2) + "=" + encodeURIComponent(authOptions.params[key2]);
              }
              if (authOptions.paramsProvider != null) {
                let dynamicParams = authOptions.paramsProvider();
                for (var key2 in dynamicParams) {
                  query += "&" + encodeURIComponent(key2) + "=" + encodeURIComponent(dynamicParams[key2]);
                }
              }
              return query;
            }, "composeChannelQuery");
            const UserAuthenticator = /* @__PURE__ */ __name((authOptions) => {
              if (typeof runtime.getAuthorizers()[authOptions.transport] === "undefined") {
                throw `'${authOptions.transport}' is not a recognized auth transport`;
              }
              return (params, callback) => {
                const query = composeChannelQuery(params, authOptions);
                runtime.getAuthorizers()[authOptions.transport](runtime, query, authOptions, AuthRequestType.UserAuthentication, callback);
              };
            }, "UserAuthenticator");
            var user_authenticator = UserAuthenticator;
            const channel_authorizer_composeChannelQuery = /* @__PURE__ */ __name((params, authOptions) => {
              var query = "socket_id=" + encodeURIComponent(params.socketId);
              query += "&channel_name=" + encodeURIComponent(params.channelName);
              for (var key2 in authOptions.params) {
                query += "&" + encodeURIComponent(key2) + "=" + encodeURIComponent(authOptions.params[key2]);
              }
              if (authOptions.paramsProvider != null) {
                let dynamicParams = authOptions.paramsProvider();
                for (var key2 in dynamicParams) {
                  query += "&" + encodeURIComponent(key2) + "=" + encodeURIComponent(dynamicParams[key2]);
                }
              }
              return query;
            }, "channel_authorizer_composeChannelQuery");
            const ChannelAuthorizer = /* @__PURE__ */ __name((authOptions) => {
              if (typeof runtime.getAuthorizers()[authOptions.transport] === "undefined") {
                throw `'${authOptions.transport}' is not a recognized auth transport`;
              }
              return (params, callback) => {
                const query = channel_authorizer_composeChannelQuery(params, authOptions);
                runtime.getAuthorizers()[authOptions.transport](runtime, query, authOptions, AuthRequestType.ChannelAuthorization, callback);
              };
            }, "ChannelAuthorizer");
            var channel_authorizer = ChannelAuthorizer;
            const ChannelAuthorizerProxy = /* @__PURE__ */ __name((pusher, authOptions, channelAuthorizerGenerator) => {
              const deprecatedAuthorizerOptions = {
                authTransport: authOptions.transport,
                authEndpoint: authOptions.endpoint,
                auth: {
                  params: authOptions.params,
                  headers: authOptions.headers
                }
              };
              return (params, callback) => {
                const channel = pusher.channel(params.channelName);
                const channelAuthorizer = channelAuthorizerGenerator(channel, deprecatedAuthorizerOptions);
                channelAuthorizer.authorize(params.socketId, callback);
              };
            }, "ChannelAuthorizerProxy");
            function getConfig(opts, pusher) {
              let config = {
                activityTimeout: opts.activityTimeout || defaults6.activityTimeout,
                cluster: opts.cluster,
                httpPath: opts.httpPath || defaults6.httpPath,
                httpPort: opts.httpPort || defaults6.httpPort,
                httpsPort: opts.httpsPort || defaults6.httpsPort,
                pongTimeout: opts.pongTimeout || defaults6.pongTimeout,
                statsHost: opts.statsHost || defaults6.stats_host,
                unavailableTimeout: opts.unavailableTimeout || defaults6.unavailableTimeout,
                wsPath: opts.wsPath || defaults6.wsPath,
                wsPort: opts.wsPort || defaults6.wsPort,
                wssPort: opts.wssPort || defaults6.wssPort,
                enableStats: getEnableStatsConfig(opts),
                httpHost: getHttpHost(opts),
                useTLS: shouldUseTLS(opts),
                wsHost: getWebsocketHost(opts),
                userAuthenticator: buildUserAuthenticator(opts),
                channelAuthorizer: buildChannelAuthorizer(opts, pusher)
              };
              if ("disabledTransports" in opts)
                config.disabledTransports = opts.disabledTransports;
              if ("enabledTransports" in opts)
                config.enabledTransports = opts.enabledTransports;
              if ("ignoreNullOrigin" in opts)
                config.ignoreNullOrigin = opts.ignoreNullOrigin;
              if ("timelineParams" in opts)
                config.timelineParams = opts.timelineParams;
              if ("nacl" in opts) {
                config.nacl = opts.nacl;
              }
              return config;
            }
            __name(getConfig, "getConfig");
            function getHttpHost(opts) {
              if (opts.httpHost) {
                return opts.httpHost;
              }
              if (opts.cluster) {
                return `sockjs-${opts.cluster}.pusher.com`;
              }
              return defaults6.httpHost;
            }
            __name(getHttpHost, "getHttpHost");
            function getWebsocketHost(opts) {
              if (opts.wsHost) {
                return opts.wsHost;
              }
              return getWebsocketHostFromCluster(opts.cluster);
            }
            __name(getWebsocketHost, "getWebsocketHost");
            function getWebsocketHostFromCluster(cluster) {
              return `ws-${cluster}.pusher.com`;
            }
            __name(getWebsocketHostFromCluster, "getWebsocketHostFromCluster");
            function shouldUseTLS(opts) {
              if (runtime.getProtocol() === "https:") {
                return true;
              } else if (opts.forceTLS === false) {
                return false;
              }
              return true;
            }
            __name(shouldUseTLS, "shouldUseTLS");
            function getEnableStatsConfig(opts) {
              if ("enableStats" in opts) {
                return opts.enableStats;
              }
              if ("disableStats" in opts) {
                return !opts.disableStats;
              }
              return false;
            }
            __name(getEnableStatsConfig, "getEnableStatsConfig");
            const hasCustomHandler = /* @__PURE__ */ __name((auth) => {
              return "customHandler" in auth && auth["customHandler"] != null;
            }, "hasCustomHandler");
            function buildUserAuthenticator(opts) {
              const userAuthentication = Object.assign(Object.assign({}, defaults6.userAuthentication), opts.userAuthentication);
              if (hasCustomHandler(userAuthentication)) {
                return userAuthentication["customHandler"];
              }
              return user_authenticator(userAuthentication);
            }
            __name(buildUserAuthenticator, "buildUserAuthenticator");
            function buildChannelAuth(opts, pusher) {
              let channelAuthorization;
              if ("channelAuthorization" in opts) {
                channelAuthorization = Object.assign(Object.assign({}, defaults6.channelAuthorization), opts.channelAuthorization);
              } else {
                channelAuthorization = {
                  transport: opts.authTransport || defaults6.authTransport,
                  endpoint: opts.authEndpoint || defaults6.authEndpoint
                };
                if ("auth" in opts) {
                  if ("params" in opts.auth)
                    channelAuthorization.params = opts.auth.params;
                  if ("headers" in opts.auth)
                    channelAuthorization.headers = opts.auth.headers;
                }
                if ("authorizer" in opts) {
                  return {
                    customHandler: ChannelAuthorizerProxy(pusher, channelAuthorization, opts.authorizer)
                  };
                }
              }
              return channelAuthorization;
            }
            __name(buildChannelAuth, "buildChannelAuth");
            function buildChannelAuthorizer(opts, pusher) {
              const channelAuthorization = buildChannelAuth(opts, pusher);
              if (hasCustomHandler(channelAuthorization)) {
                return channelAuthorization["customHandler"];
              }
              return channel_authorizer(channelAuthorization);
            }
            __name(buildChannelAuthorizer, "buildChannelAuthorizer");
            class watchlist_WatchlistFacade extends dispatcher_Dispatcher {
              constructor(pusher) {
                super(function(eventName, data) {
                  logger.debug(`No callbacks on watchlist events for ${eventName}`);
                });
                this.pusher = pusher;
                this.bindWatchlistInternalEvent();
              }
              handleEvent(pusherEvent) {
                pusherEvent.data.events.forEach((watchlistEvent) => {
                  this.emit(watchlistEvent.name, watchlistEvent);
                });
              }
              bindWatchlistInternalEvent() {
                this.pusher.connection.bind("message", (pusherEvent) => {
                  var eventName = pusherEvent.event;
                  if (eventName === "pusher_internal:watchlist_events") {
                    this.handleEvent(pusherEvent);
                  }
                });
              }
            }
            __name(watchlist_WatchlistFacade, "watchlist_WatchlistFacade");
            function flatPromise() {
              let resolve2, reject;
              const promise = new Promise((res, rej) => {
                resolve2 = res;
                reject = rej;
              });
              return { promise, resolve: resolve2, reject };
            }
            __name(flatPromise, "flatPromise");
            var flat_promise = flatPromise;
            class user_UserFacade extends dispatcher_Dispatcher {
              constructor(pusher) {
                super(function(eventName, data) {
                  logger.debug("No callbacks on user for " + eventName);
                });
                this.signin_requested = false;
                this.user_data = null;
                this.serverToUserChannel = null;
                this.signinDonePromise = null;
                this._signinDoneResolve = null;
                this._onAuthorize = (err, authData) => {
                  if (err) {
                    logger.warn(`Error during signin: ${err}`);
                    this._cleanup();
                    return;
                  }
                  this.pusher.send_event("pusher:signin", {
                    auth: authData.auth,
                    user_data: authData.user_data
                  });
                };
                this.pusher = pusher;
                this.pusher.connection.bind("state_change", ({ previous, current }) => {
                  if (previous !== "connected" && current === "connected") {
                    this._signin();
                  }
                  if (previous === "connected" && current !== "connected") {
                    this._cleanup();
                    this._newSigninPromiseIfNeeded();
                  }
                });
                this.watchlist = new watchlist_WatchlistFacade(pusher);
                this.pusher.connection.bind("message", (event) => {
                  var eventName = event.event;
                  if (eventName === "pusher:signin_success") {
                    this._onSigninSuccess(event.data);
                  }
                  if (this.serverToUserChannel && this.serverToUserChannel.name === event.channel) {
                    this.serverToUserChannel.handleEvent(event);
                  }
                });
              }
              signin() {
                if (this.signin_requested) {
                  return;
                }
                this.signin_requested = true;
                this._signin();
              }
              _signin() {
                if (!this.signin_requested) {
                  return;
                }
                this._newSigninPromiseIfNeeded();
                if (this.pusher.connection.state !== "connected") {
                  return;
                }
                this.pusher.config.userAuthenticator({
                  socketId: this.pusher.connection.socket_id
                }, this._onAuthorize);
              }
              _onSigninSuccess(data) {
                try {
                  this.user_data = JSON.parse(data.user_data);
                } catch (e3) {
                  logger.error(`Failed parsing user data after signin: ${data.user_data}`);
                  this._cleanup();
                  return;
                }
                if (typeof this.user_data.id !== "string" || this.user_data.id === "") {
                  logger.error(`user_data doesn't contain an id. user_data: ${this.user_data}`);
                  this._cleanup();
                  return;
                }
                this._signinDoneResolve();
                this._subscribeChannels();
              }
              _subscribeChannels() {
                const ensure_subscribed = /* @__PURE__ */ __name((channel) => {
                  if (channel.subscriptionPending && channel.subscriptionCancelled) {
                    channel.reinstateSubscription();
                  } else if (!channel.subscriptionPending && this.pusher.connection.state === "connected") {
                    channel.subscribe();
                  }
                }, "ensure_subscribed");
                this.serverToUserChannel = new channel_Channel(`#server-to-user-${this.user_data.id}`, this.pusher);
                this.serverToUserChannel.bind_global((eventName, data) => {
                  if (eventName.indexOf("pusher_internal:") === 0 || eventName.indexOf("pusher:") === 0) {
                    return;
                  }
                  this.emit(eventName, data);
                });
                ensure_subscribed(this.serverToUserChannel);
              }
              _cleanup() {
                this.user_data = null;
                if (this.serverToUserChannel) {
                  this.serverToUserChannel.unbind_all();
                  this.serverToUserChannel.disconnect();
                  this.serverToUserChannel = null;
                }
                if (this.signin_requested) {
                  this._signinDoneResolve();
                }
              }
              _newSigninPromiseIfNeeded() {
                if (!this.signin_requested) {
                  return;
                }
                if (this.signinDonePromise && !this.signinDonePromise.done) {
                  return;
                }
                const { promise, resolve: resolve2, reject: _2 } = flat_promise();
                promise.done = false;
                const setDone = /* @__PURE__ */ __name(() => {
                  promise.done = true;
                }, "setDone");
                promise.then(setDone).catch(setDone);
                this.signinDonePromise = promise;
                this._signinDoneResolve = resolve2;
              }
            }
            __name(user_UserFacade, "user_UserFacade");
            class pusher_Pusher {
              static ready() {
                pusher_Pusher.isReady = true;
                for (var i2 = 0, l3 = pusher_Pusher.instances.length; i2 < l3; i2++) {
                  pusher_Pusher.instances[i2].connect();
                }
              }
              static getClientFeatures() {
                return keys(filterObject({ ws: runtime.Transports.ws }, function(t2) {
                  return t2.isSupported({});
                }));
              }
              constructor(app_key, options2) {
                checkAppKey(app_key);
                validateOptions(options2);
                this.key = app_key;
                this.options = options2;
                this.config = getConfig(this.options, this);
                this.channels = factory.createChannels();
                this.global_emitter = new dispatcher_Dispatcher();
                this.sessionID = runtime.randomInt(1e9);
                this.timeline = new timeline_Timeline(this.key, this.sessionID, {
                  cluster: this.config.cluster,
                  features: pusher_Pusher.getClientFeatures(),
                  params: this.config.timelineParams || {},
                  limit: 50,
                  level: timeline_level.INFO,
                  version: defaults6.VERSION
                });
                if (this.config.enableStats) {
                  this.timelineSender = factory.createTimelineSender(this.timeline, {
                    host: this.config.statsHost,
                    path: "/timeline/v2/" + runtime.TimelineTransport.name
                  });
                }
                var getStrategy = /* @__PURE__ */ __name((options3) => {
                  return runtime.getDefaultStrategy(this.config, options3, strategy_builder_defineTransport);
                }, "getStrategy");
                this.connection = factory.createConnectionManager(this.key, {
                  getStrategy,
                  timeline: this.timeline,
                  activityTimeout: this.config.activityTimeout,
                  pongTimeout: this.config.pongTimeout,
                  unavailableTimeout: this.config.unavailableTimeout,
                  useTLS: Boolean(this.config.useTLS)
                });
                this.connection.bind("connected", () => {
                  this.subscribeAll();
                  if (this.timelineSender) {
                    this.timelineSender.send(this.connection.isUsingTLS());
                  }
                });
                this.connection.bind("message", (event) => {
                  var eventName = event.event;
                  var internal2 = eventName.indexOf("pusher_internal:") === 0;
                  if (event.channel) {
                    var channel = this.channel(event.channel);
                    if (channel) {
                      channel.handleEvent(event);
                    }
                  }
                  if (!internal2) {
                    this.global_emitter.emit(event.event, event.data);
                  }
                });
                this.connection.bind("connecting", () => {
                  this.channels.disconnect();
                });
                this.connection.bind("disconnected", () => {
                  this.channels.disconnect();
                });
                this.connection.bind("error", (err) => {
                  logger.warn(err);
                });
                pusher_Pusher.instances.push(this);
                this.timeline.info({ instances: pusher_Pusher.instances.length });
                this.user = new user_UserFacade(this);
                if (pusher_Pusher.isReady) {
                  this.connect();
                }
              }
              switchCluster(options2) {
                const { appKey, cluster } = options2;
                this.key = appKey;
                this.options = Object.assign(Object.assign({}, this.options), { cluster });
                this.config = getConfig(this.options, this);
                this.connection.switchCluster(this.key);
              }
              channel(name3) {
                return this.channels.find(name3);
              }
              allChannels() {
                return this.channels.all();
              }
              connect() {
                this.connection.connect();
                if (this.timelineSender) {
                  if (!this.timelineSenderTimer) {
                    var usingTLS = this.connection.isUsingTLS();
                    var timelineSender = this.timelineSender;
                    this.timelineSenderTimer = new timers_PeriodicTimer(6e4, function() {
                      timelineSender.send(usingTLS);
                    });
                  }
                }
              }
              disconnect() {
                this.connection.disconnect();
                if (this.timelineSenderTimer) {
                  this.timelineSenderTimer.ensureAborted();
                  this.timelineSenderTimer = null;
                }
              }
              bind(event_name, callback, context) {
                this.global_emitter.bind(event_name, callback, context);
                return this;
              }
              unbind(event_name, callback, context) {
                this.global_emitter.unbind(event_name, callback, context);
                return this;
              }
              bind_global(callback) {
                this.global_emitter.bind_global(callback);
                return this;
              }
              unbind_global(callback) {
                this.global_emitter.unbind_global(callback);
                return this;
              }
              unbind_all(callback) {
                this.global_emitter.unbind_all();
                return this;
              }
              subscribeAll() {
                var channelName;
                for (channelName in this.channels.channels) {
                  if (this.channels.channels.hasOwnProperty(channelName)) {
                    this.subscribe(channelName);
                  }
                }
              }
              subscribe(channel_name) {
                var channel = this.channels.add(channel_name, this);
                if (channel.subscriptionPending && channel.subscriptionCancelled) {
                  channel.reinstateSubscription();
                } else if (!channel.subscriptionPending && this.connection.state === "connected") {
                  channel.subscribe();
                }
                return channel;
              }
              unsubscribe(channel_name) {
                var channel = this.channels.find(channel_name);
                if (channel && channel.subscriptionPending) {
                  channel.cancelSubscription();
                } else {
                  channel = this.channels.remove(channel_name);
                  if (channel && channel.subscribed) {
                    channel.unsubscribe();
                  }
                }
              }
              send_event(event_name, data, channel) {
                return this.connection.send_event(event_name, data, channel);
              }
              shouldUseTLS() {
                return this.config.useTLS;
              }
              signin() {
                this.user.signin();
              }
            }
            __name(pusher_Pusher, "pusher_Pusher");
            pusher_Pusher.instances = [];
            pusher_Pusher.isReady = false;
            pusher_Pusher.logToConsole = false;
            pusher_Pusher.Runtime = runtime;
            pusher_Pusher.ScriptReceivers = runtime.ScriptReceivers;
            pusher_Pusher.DependenciesReceivers = runtime.DependenciesReceivers;
            pusher_Pusher.auth_callbacks = runtime.auth_callbacks;
            var core_pusher = __webpack_exports__["default"] = pusher_Pusher;
            function checkAppKey(key2) {
              if (key2 === null || key2 === void 0) {
                throw "You must pass your app key when you instantiate Pusher.";
              }
            }
            __name(checkAppKey, "checkAppKey");
            runtime.setup(pusher_Pusher);
          }
          /******/
        ])
      );
    });
  }
});
var page_svelte_exports22 = {};
__export(page_svelte_exports22, {
  default: () => _page22
});
function Chessground_1($$payload, $$props) {
  push();
  let className = fallback($$props["class"], "cg-default-style");
  let fen = fallback($$props["fen"], void 0);
  let orientation = fallback($$props["orientation"], void 0);
  let turnColor = fallback($$props["turnColor"], void 0);
  let check = fallback($$props["check"], void 0);
  let lastMove = fallback($$props["lastMove"], void 0);
  let selected = fallback($$props["selected"], void 0);
  let coordinates = fallback($$props["coordinates"], void 0);
  let autoCastle = fallback($$props["autoCastle"], void 0);
  let viewOnly = fallback($$props["viewOnly"], void 0);
  let disableContextMenu = fallback($$props["disableContextMenu"], void 0);
  let addPieceZIndex = fallback($$props["addPieceZIndex"], void 0);
  let addDimensionsCssVarsTo = fallback($$props["addDimensionsCssVarsTo"], void 0);
  let blockTouchScroll = fallback($$props["blockTouchScroll"], void 0);
  let config = fallback($$props["config"], () => ({}), true);
  let chessground;
  function set3(config2) {
    chessground.set(config2);
  }
  __name(set3, "set3");
  function getState() {
    return chessground.state;
  }
  __name(getState, "getState");
  function getFen() {
    return chessground.getFen();
  }
  __name(getFen, "getFen");
  function toggleOrientation() {
    return chessground.toggleOrientation();
  }
  __name(toggleOrientation, "toggleOrientation");
  function move(orig, dest) {
    return chessground.move(orig, dest);
  }
  __name(move, "move");
  function setPieces(pieces) {
    return chessground.setPieces(pieces);
  }
  __name(setPieces, "setPieces");
  function selectSquare(key2, force) {
    return chessground.selectSquare(key2, force);
  }
  __name(selectSquare, "selectSquare");
  function newPiece(piece, key2) {
    return chessground.newPiece(piece, key2);
  }
  __name(newPiece, "newPiece");
  function playPremove() {
    return chessground.playPremove();
  }
  __name(playPremove, "playPremove");
  function cancelPremove() {
    chessground.cancelPremove();
  }
  __name(cancelPremove, "cancelPremove");
  function playPredrop(validate2) {
    return chessground.playPredrop(validate2);
  }
  __name(playPredrop, "playPredrop");
  function cancelPredrop() {
    chessground.cancelPredrop();
  }
  __name(cancelPredrop, "cancelPredrop");
  function cancelMove() {
    chessground.cancelMove();
  }
  __name(cancelMove, "cancelMove");
  function stop() {
    chessground.stop();
  }
  __name(stop, "stop");
  function explode(keys) {
    chessground.explode(keys);
  }
  __name(explode, "explode");
  function setShapes(shapes) {
    chessground.setShapes(shapes);
  }
  __name(setShapes, "setShapes");
  function setAutoShapes(shapes) {
    chessground.setAutoShapes(shapes);
  }
  __name(setAutoShapes, "setAutoShapes");
  function redrawAll() {
    return chessground.redrawAll();
  }
  __name(redrawAll, "redrawAll");
  function dragNewPiece(piece, event, force) {
    chessground.dragNewPiece(piece, event, force);
  }
  __name(dragNewPiece, "dragNewPiece");
  function destroy() {
    return chessground.destroy();
  }
  __name(destroy, "destroy");
  $$payload.out += `<div${attr("class", `cg-wrap ${stringify(className)} svelte-125qdes`)}></div>`;
  bind_props($$props, {
    class: className,
    fen,
    orientation,
    turnColor,
    check,
    lastMove,
    selected,
    coordinates,
    autoCastle,
    viewOnly,
    disableContextMenu,
    addPieceZIndex,
    addDimensionsCssVarsTo,
    blockTouchScroll,
    config,
    set: set3,
    getState,
    getFen,
    toggleOrientation,
    move,
    setPieces,
    selectSquare,
    newPiece,
    playPremove,
    cancelPremove,
    playPredrop,
    cancelPredrop,
    cancelMove,
    stop,
    explode,
    setShapes,
    setAutoShapes,
    redrawAll,
    dragNewPiece,
    destroy
  });
  pop();
}
__name(Chessground_1, "Chessground_1");
function Chess($$payload, $$props) {
  push();
  let moveNumber = fallback($$props["moveNumber"], 0);
  let turn = fallback($$props["turn"], "w");
  let inCheck = fallback($$props["inCheck"], false);
  let history = fallback($$props["history"], () => [], true);
  let isGameOver = fallback($$props["isGameOver"], false);
  let fen = fallback($$props["fen"], "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
  let orientation = fallback($$props["orientation"], "w");
  let engine = fallback($$props["engine"], () => void 0, true);
  let className = fallback($$props["class"], () => void 0, true);
  function load11(newFen) {
    throw new Error("component not mounted yet");
  }
  __name(load11, "load11");
  function move(moveSan) {
    throw new Error("component not mounted yet");
  }
  __name(move, "move");
  function getHistory({ verbose = false } = {}) {
    throw new Error("component not mounted yet");
  }
  __name(getHistory, "getHistory");
  function getBoard() {
    throw new Error("component not mounted yet");
  }
  __name(getBoard, "getBoard");
  function undo() {
    throw new Error("component not mounted yet");
  }
  __name(undo, "undo");
  function reset3() {
    throw new Error("component not mounted yet");
  }
  __name(reset3, "reset3");
  function toggleOrientation() {
    throw new Error("component not mounted yet");
  }
  __name(toggleOrientation, "toggleOrientation");
  async function playEngineMove() {
    throw new Error("component not mounted yet");
  }
  __name(playEngineMove, "playEngineMove");
  $$payload.out += `<div style="position:relative;">`;
  Chessground_1($$payload, { class: className });
  $$payload.out += `<!----></div>`;
  bind_props($$props, {
    moveNumber,
    turn,
    inCheck,
    history,
    isGameOver,
    fen,
    orientation,
    engine,
    class: className,
    load: load11,
    move,
    getHistory,
    getBoard,
    undo,
    reset: reset3,
    toggleOrientation,
    playEngineMove
  });
  pop();
}
__name(Chess, "Chess");
function Timer($$payload, $$props) {
  push();
  let {
    seconds = 0,
    classes = "",
    paused = false,
    onExpired
  } = $$props;
  function formatTime(totalSeconds) {
    const minutes = Math.floor(totalSeconds / 60);
    const remainingSeconds = totalSeconds % 60;
    return `${minutes.toString().padStart(2, "0")}:${remainingSeconds.toString().padStart(2, "0")}`;
  }
  __name(formatTime, "formatTime");
  $$payload.out += `<div${attr("class", classes)}>${escape_html(formatTime(seconds))}</div>`;
  bind_props($$props, { seconds, paused });
  pop();
}
__name(Timer, "Timer");
function _page22($$payload, $$props) {
  push();
  let TimeRanOut = false;
  let chess;
  let whiteTime = 300;
  let blackTime = 300;
  let increment = 0;
  let playerColor = "w";
  function formatTime(seconds) {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes.toString().padStart(2, "0")}:${remainingSeconds.toString().padStart(2, "0")}`;
  }
  __name(formatTime, "formatTime");
  function handleTimerExpired(color) {
    if (TimeRanOut)
      return;
    TimeRanOut = true;
    chess.reset();
    console.log(`${color}'s time has expired`);
  }
  __name(handleTimerExpired, "handleTimerExpired");
  let $$settled = true;
  let $$inner_payload;
  function $$render_inner($$payload2) {
    $$payload2.out += `<form action="/realtime" method="post">`;
    Button($$payload2, {
      type: "submit",
      children: ($$payload3) => {
        $$payload3.out += `<!---->click`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----></form> <div class="mb-5 flex items-center gap-5"><h1 class="text-lg font-medium">Time Control</h1> <p class="text-2xl">${escape_html(formatTime(whiteTime))} + ${escape_html(increment)}</p></div> <div><div class="flex items-center gap-2 pl-2">`;
    Avatar($$payload2, {
      children: ($$payload3) => {
        Avatar_image($$payload3, {
          src: "https://github.com/shadcn.png",
          alt: "@shadcn"
        });
        $$payload3.out += `<!----> `;
        Avatar_fallback($$payload3, {
          children: ($$payload4) => {
            $$payload4.out += `<!---->W`;
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!---->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----> <p>White</p> `;
    Timer($$payload2, {
      get seconds() {
        return whiteTime;
      },
      set seconds($$value) {
        whiteTime = $$value;
        $$settled = false;
      },
      classes: "",
      paused: playerColor === "b",
      onExpired: () => handleTimerExpired("white")
    });
    $$payload2.out += `<!----></div> <div class="my-2">`;
    Chess($$payload2, { orientation: playerColor });
    $$payload2.out += `<!----></div> <div class="flex items-center gap-2 pl-2">`;
    Avatar($$payload2, {
      children: ($$payload3) => {
        Avatar_image($$payload3, {
          src: "https://github.com/shadcn.png",
          alt: "@shadcn"
        });
        $$payload3.out += `<!----> `;
        Avatar_fallback($$payload3, {
          children: ($$payload4) => {
            $$payload4.out += `<!---->B`;
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!---->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----> <p>Black</p> `;
    Timer($$payload2, {
      get seconds() {
        return blackTime;
      },
      set seconds($$value) {
        blackTime = $$value;
        $$settled = false;
      },
      classes: "",
      paused: playerColor === "w",
      onExpired: () => handleTimerExpired("black")
    });
    $$payload2.out += `<!----></div> <div class="fixed bottom-0 left-0 z-50 w-full border-t bg-background px-5 py-5">`;
    {
      $$payload2.out += "<!--[-->";
      Button($$payload2, {
        class: "w-full rounded-full",
        children: ($$payload3) => {
          $$payload3.out += `<!---->Create New Game`;
        },
        $$slots: { default: true }
      });
    }
    $$payload2.out += `<!--]--></div></div>`;
  }
  __name($$render_inner, "$$render_inner");
  do {
    $$settled = true;
    $$inner_payload = copy_payload($$payload);
    $$render_inner($$inner_payload);
  } while (!$$settled);
  assign_payload($$payload, $$inner_payload);
  pop();
}
__name(_page22, "_page22");
var import_pusher_js;
var files;
var ranks;
var allKeys;
var key2pos;
var State;
var init_page_svelte22 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/realtime/_page.svelte.js"() {
    init_index2();
    init_chess();
    init_avatar_fallback();
    init_button();
    init_client();
    import_pusher_js = __toESM(require_pusher(), 1);
    files = ["a", "b", "c", "d", "e", "f", "g", "h"];
    ranks = ["1", "2", "3", "4", "5", "6", "7", "8"];
    allKeys = Array.prototype.concat(...files.map((c2) => ranks.map((r3) => c2 + r3)));
    key2pos = /* @__PURE__ */ __name((k) => [k.charCodeAt(0) - 97, k.charCodeAt(1) - 49], "key2pos");
    allKeys.map(key2pos);
    (function(State2) {
      State2["Uninitialised"] = "uninitialised";
      State2["Initialising"] = "initialising";
      State2["Waiting"] = "waiting";
      State2["Searching"] = "searching";
    })(State || (State = {}));
  }
});
var __exports26 = {};
__export(__exports26, {
  component: () => component26,
  fonts: () => fonts26,
  imports: () => imports26,
  index: () => index26,
  server: () => page_server_ts_exports8,
  server_id: () => server_id9,
  stylesheets: () => stylesheets26
});
var index26;
var component_cache26;
var component26;
var server_id9;
var imports26;
var stylesheets26;
var fonts26;
var init__26 = __esm({
  ".svelte-kit/output/server/nodes/25.js"() {
    init_page_server_ts8();
    index26 = 25;
    component26 = /* @__PURE__ */ __name(async () => component_cache26 ??= (await Promise.resolve().then(() => (init_page_svelte22(), page_svelte_exports22))).default, "component26");
    server_id9 = "src/routes/(app)/realtime/+page.server.ts";
    imports26 = ["_app/immutable/nodes/25.fnw3WQI9.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/if.DLf01pqE.js", "_app/immutable/chunks/actions.DVNHJCdf.js", "_app/immutable/chunks/this.CD6iIRB7.js", "_app/immutable/chunks/lifecycle.BX15fcyy.js", "_app/immutable/chunks/index-client.bJHR976g.js", "_app/immutable/chunks/props.CdXMhF7y.js", "_app/immutable/chunks/store.CDnLvhlJ.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/class.waVxCJrB.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js", "_app/immutable/chunks/avatar-fallback.Dt2LaaM8.js", "_app/immutable/chunks/slot.BDgc6-mN.js", "_app/immutable/chunks/create.OoZN6NjL.js", "_app/immutable/chunks/index.bE0HzIKx.js", "_app/immutable/chunks/utils.B8KE5qsB.js", "_app/immutable/chunks/bundle-mjs.BNYwEHuQ.js", "_app/immutable/chunks/updater.MNDcgVG0.js", "_app/immutable/chunks/button.DQVOpKKk.js", "_app/immutable/chunks/misc.CXN-D0wo.js", "_app/immutable/chunks/svelte-element.2QoIbCrV.js", "_app/immutable/chunks/index.CplayyMK.js", "_app/immutable/chunks/index.Bi_aB5ul.js", "_app/immutable/chunks/entry.Zk5XMwWG.js", "_app/immutable/chunks/_commonjsHelpers.CqkleIqs.js", "_app/immutable/chunks/forms.CmnTScIw.js"];
    stylesheets26 = ["_app/immutable/assets/25.BaIYnifA.css"];
    fonts26 = [];
  }
});
var page_server_ts_exports9 = {};
__export(page_server_ts_exports9, {
  actions: () => actions2
});
var actions2;
var init_page_server_ts9 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/rps/_page.server.ts.js"() {
    init_schema();
    init_chunks();
    actions2 = {
      startGame: async ({ locals: { db, user }, request }) => {
        if (!user)
          return;
        const form = await request.formData();
        const href = form.get("href");
        const ghc = await db.insert(gameHistoryTable).values({
          gameId: 4,
          playerOneId: user?.id,
          isComputerOpponent: true
        }).returning().get().catch(() => {
          error(500, "Something went wrong");
        });
        redirect(303, `${href}?gh=${ghc.id}`);
      }
    };
  }
});
var page_svelte_exports23 = {};
__export(page_svelte_exports23, {
  default: () => _page23
});
function _page23($$payload) {
  const playOptions = [
    {
      icon: "./circleComputer.svg",
      title: "Play with computer",
      subTitle: "Play against our ever smart AI bots now.",
      href: "play-with-computer"
    },
    {
      icon: "./playWithFriends.svg",
      title: "Play with Friend",
      subTitle: "Create and play your favorite game with a friend now.",
      href: "play-with-friend"
    },
    {
      icon: "./schedule.svg",
      title: "Schedule game",
      subTitle: "Schedule and play your favorite game at a later time.",
      href: "schedule-game"
    },
    {
      icon: "./circleTournament.svg",
      title: "Create tournament",
      subTitle: "Create and play your favourite game with a friend now.",
      href: "create-tournament"
    },
    {
      icon: "./instantPlay.svg",
      title: "Instant play",
      subTitle: "Create and play your favourite game at a later time.",
      href: "instant-play"
    }
  ];
  const each_array = ensure_array_like(playOptions);
  const each_array_1 = ensure_array_like({ length: 5 });
  $$payload.out += `<h1 class="mb-10 text-2xl font-medium">Rock, Paper, Scissors</h1> <form method="POST" class="grid grid-cols-2 gap-3 sm:gap-5"><!--[-->`;
  for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
    let { icon, subTitle, title, href } = each_array[$$index];
    $$payload.out += `<input hidden name="href"${attr("value", "rps/" + href)}> <button formaction="?/startGame" class="inline-block w-full space-y-1 rounded-md border border-[#6D6D6E] px-3 py-[18px] text-left"><img${attr("src", icon)} alt=""> <p class="text-sm font-semibold">${escape_html(title)}</p> <p class="mt-1 text-[10px] font-light">${escape_html(subTitle)}</p></button>`;
  }
  $$payload.out += `<!--]--></form> <div class="mt-10"><p class="mb-4">Quick pairing</p> <div class="space-y-4"><!--[-->`;
  for (let $$index_1 = 0, $$length = each_array_1.length; $$index_1 < $$length; $$index_1++) {
    each_array_1[$$index_1];
    $$payload.out += `<div class="rounded-md border border-[#AFAFAF] p-4"><div class="mb-2 flex justify-between text-sm font-medium"><p>Loser pay</p> <p>(#)Free</p></div> <p class="mb-2 flex items-center gap-5 text-xs text-[#AFAFAF]"><img src="/people.svg" alt=""> <span class="font-medium">2</span></p> <p class="mb-2 flex items-center gap-5 text-xs text-[#AFAFAF]"><img src="/clock.svg" alt=""> <span class="font-medium">5 hours</span></p> <div class="mb-2 flex items-center justify-between text-xs text-[#AFAFAF]"><p class="flex items-center gap-5"><img src="/lock.svg" alt=""> <span class="font-medium">Public</span></p> <p>2 users joined</p></div></div>`;
  }
  $$payload.out += `<!--]--></div></div>`;
}
__name(_page23, "_page23");
var init_page_svelte23 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/rps/_page.svelte.js"() {
    init_index2();
    init_client();
    init_index3();
  }
});
var __exports27 = {};
__export(__exports27, {
  component: () => component27,
  fonts: () => fonts27,
  imports: () => imports27,
  index: () => index27,
  server: () => page_server_ts_exports9,
  server_id: () => server_id10,
  stylesheets: () => stylesheets27
});
var index27;
var component_cache27;
var component27;
var server_id10;
var imports27;
var stylesheets27;
var fonts27;
var init__27 = __esm({
  ".svelte-kit/output/server/nodes/26.js"() {
    init_page_server_ts9();
    index27 = 26;
    component27 = /* @__PURE__ */ __name(async () => component_cache27 ??= (await Promise.resolve().then(() => (init_page_svelte23(), page_svelte_exports23))).default, "component27");
    server_id10 = "src/routes/(app)/rps/+page.server.ts";
    imports27 = ["_app/immutable/nodes/26.COzTEYhz.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/actions.DVNHJCdf.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js", "_app/immutable/chunks/forms.CmnTScIw.js", "_app/immutable/chunks/entry.Zk5XMwWG.js", "_app/immutable/chunks/index-client.bJHR976g.js", "_app/immutable/chunks/index.bE0HzIKx.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/index.CplayyMK.js", "_app/immutable/chunks/index.Bi_aB5ul.js", "_app/immutable/chunks/bundle-mjs.BNYwEHuQ.js", "_app/immutable/chunks/create.OoZN6NjL.js"];
    stylesheets27 = [];
    fonts27 = [];
  }
});
var page_svelte_exports24 = {};
__export(page_svelte_exports24, {
  default: () => _page24
});
function _page24($$payload) {
  let index39 = 1;
  head($$payload, ($$payload2) => {
    $$payload2.out += `<link rel="preload" as="image"${attr("href", `/howToPlay-1.svg`)}> <link rel="preload" as="image"${attr("href", `/howToPlay-2.svg`)}> <link rel="preload" as="image"${attr("href", `/howToPlay-3.svg`)}> <link rel="preload" as="image"${attr("href", `/howToPlay-4.svg`)}> <link rel="preload" as="image"${attr("href", `/howToPlay-5.svg`)}> <link rel="preload" as="image"${attr("href", `/howToPlay-6.svg`)}>`;
  });
  $$payload.out += `<div class="relative"><h1 class="mb-10 text-2xl font-medium">How To Play</h1> <!---->`;
  {
    $$payload.out += `<div><img${attr("src", `/howToPlay-${index39}.svg`)} class="w-full" alt=""></div>`;
  }
  $$payload.out += `<!----> <div class="fixed bottom-0 mx-auto mt-8 flex w-full max-w-md items-center gap-5 border-t border-gray-700 bg-black px-5 py-5">`;
  if (index39 === 6) {
    $$payload.out += "<!--[-->";
    Button($$payload, {
      class: "w-full rounded-full bg-blue-600 py-3 text-white",
      children: ($$payload2) => {
        $$payload2.out += `<!---->Start Uno`;
      },
      $$slots: { default: true }
    });
  } else {
    $$payload.out += "<!--[!-->";
    Button($$payload, {
      class: "w-full rounded-full bg-blue-600 py-3 text-white",
      children: ($$payload2) => {
        $$payload2.out += `<!---->Skip tutorial`;
      },
      $$slots: { default: true }
    });
    $$payload.out += `<!----> `;
    Button($$payload, {
      onclick: () => {
        if (index39 === 6)
          return;
        index39++;
      },
      class: "w-full rounded-full bg-background  py-3 text-white hover:bg-background",
      children: ($$payload2) => {
        $$payload2.out += `<!---->Next`;
      },
      $$slots: { default: true }
    });
    $$payload.out += `<!---->`;
  }
  $$payload.out += `<!--]--></div></div>`;
}
__name(_page24, "_page24");
var init_page_svelte24 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/rps/how-to-play/_page.svelte.js"() {
    init_index2();
    init_button();
  }
});
var __exports28 = {};
__export(__exports28, {
  component: () => component28,
  fonts: () => fonts28,
  imports: () => imports28,
  index: () => index28,
  stylesheets: () => stylesheets28
});
var index28;
var component_cache28;
var component28;
var imports28;
var stylesheets28;
var fonts28;
var init__28 = __esm({
  ".svelte-kit/output/server/nodes/27.js"() {
    index28 = 27;
    component28 = /* @__PURE__ */ __name(async () => component_cache28 ??= (await Promise.resolve().then(() => (init_page_svelte24(), page_svelte_exports24))).default, "component28");
    imports28 = ["_app/immutable/nodes/27.Jjnd2Y29.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/if.DLf01pqE.js", "_app/immutable/chunks/key.CCikwZWN.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js", "_app/immutable/chunks/transitions.D2VcR92X.js", "_app/immutable/chunks/button.DQVOpKKk.js", "_app/immutable/chunks/slot.BDgc6-mN.js", "_app/immutable/chunks/lifecycle.BX15fcyy.js", "_app/immutable/chunks/misc.CXN-D0wo.js", "_app/immutable/chunks/props.CdXMhF7y.js", "_app/immutable/chunks/store.CDnLvhlJ.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/create.OoZN6NjL.js", "_app/immutable/chunks/index.bE0HzIKx.js", "_app/immutable/chunks/index-client.bJHR976g.js", "_app/immutable/chunks/svelte-element.2QoIbCrV.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/actions.DVNHJCdf.js", "_app/immutable/chunks/this.CD6iIRB7.js", "_app/immutable/chunks/index.CplayyMK.js", "_app/immutable/chunks/index.Bi_aB5ul.js", "_app/immutable/chunks/bundle-mjs.BNYwEHuQ.js", "_app/immutable/chunks/utils.B8KE5qsB.js", "_app/immutable/chunks/index.CwHq6mbt.js"];
    stylesheets28 = [];
    fonts28 = [];
  }
});
var page_server_ts_exports10 = {};
__export(page_server_ts_exports10, {
  actions: () => actions3,
  load: () => load8
});
var load8;
var actions3;
var init_page_server_ts10 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/rps/_typeOfPlay_/_page.server.ts.js"() {
    init_schema();
    init_chunks();
    init_drizzle_orm();
    load8 = /* @__PURE__ */ __name(async ({ url }) => {
      console.log("\u{1F680} ~ load ~ url:", url);
    }, "load8");
    actions3 = {
      abortGame: async ({ locals: { db, user }, request }) => {
        const form = await request.formData();
        const gameHistoryId = Number(form.get("gh"));
        if (!user)
          error(401, "Unauthorized");
        if (!gameHistoryId)
          error(400, "error");
        try {
          const game = await db.query.gameHistoryTable.findFirst({
            where: and(
              eq(gameHistoryTable.id, gameHistoryId),
              eq(gameHistoryTable.status, "IN_PROGRESS")
            )
          });
          if (!game) {
            error(400, "Game not found or already finished");
          }
          if (game.playerOneId !== user.id && game.playerTwoId !== user.id) {
            error(400, "User not part of this game");
          }
          const winner = game.isComputerOpponent ? null : user.id === game.playerOneId ? game.playerTwoId : game.playerOneId;
          await db.update(gameHistoryTable).set({
            status: "ABORTED",
            winner
          }).where(eq(gameHistoryTable.id, game.id));
          await db.insert(statsTable).values({
            gameId: 4,
            globalRanking: 1e3,
            userId: user.id,
            gamesPlayed: 1,
            gamesLost: 1
          }).onConflictDoUpdate({
            target: [statsTable.userId, statsTable.gameId],
            set: {
              gamesPlayed: sql`games_played + 1`,
              gamesLost: sql`games_lost + 1`,
              globalRanking: sql`global_ranking + 10`
            }
          });
        } catch (err) {
          console.log("\u{1F680} ~ abortGame: ~ error:", err);
        }
        redirect(303, "/rps");
      }
    };
  }
});
var page_svelte_exports25 = {};
__export(page_svelte_exports25, {
  default: () => _page25
});
function Pwc4($$payload, $$props) {
  push();
  var $$store_subs;
  let won = 0;
  let lost = 0;
  let draw = 0;
  let animate = false;
  let $$settled = true;
  let $$inner_payload;
  function $$render_inner($$payload2) {
    {
      $$payload2.out += "<!--[!-->";
      $$payload2.out += `<div class="svelte-f8xamw"><div class="flex w-full items-center justify-between svelte-f8xamw"><div class="text-center text-lg font-semibold svelte-f8xamw"><p class="text-[#8C8C8C] svelte-f8xamw">WON</p> <p class="text-[25px] svelte-f8xamw">${escape_html(won)}</p></div> <div class="text-center text-lg font-semibold svelte-f8xamw"><p class="text-[#8C8C8C] svelte-f8xamw">LOST</p> <p class="text-[25px] svelte-f8xamw">${escape_html(lost)}</p></div> <div class="text-center text-lg font-semibold svelte-f8xamw"><p class="text-[#8C8C8C] svelte-f8xamw">DRAW</p> <p class="text-[25px] svelte-f8xamw">${escape_html(draw)}</p></div></div> <img src="/robot.svg" class="mx-auto my-[60px] w-fit rounded-full svelte-f8xamw" alt=""> <p class="mb-[60px] text-center text-3xl font-bold svelte-f8xamw">VS</p> <div${attr("class", `${stringify(cn("flex  items-center justify-between", { "animate-bounce": animate }))} svelte-f8xamw`)}><button class="svelte-f8xamw"><img src="/rock.svg" class="mx-auto w-fit rounded-full svelte-f8xamw" alt=""> <p class="mt-2 text-center text-sm font-medium uppercase svelte-f8xamw">Rock</p></button> <button class="svelte-f8xamw"><img src="/paper.svg" class="mx-auto w-fit rounded-full svelte-f8xamw" alt=""> <p class="mt-2 text-center text-sm font-medium uppercase svelte-f8xamw">Paper</p></button> <button class="svelte-f8xamw"><img src="/scissors.svg" class="mx-auto w-fit rounded-full svelte-f8xamw" alt=""> <p class="mt-2 text-center text-sm font-medium uppercase svelte-f8xamw">SCISSORS</p></button></div> <p class="my-5 text-center text-xs font-medium svelte-f8xamw">Tap on either the \u201CRock\u201D, \u201CPaper\u201D or \u201CScissors\u201D to choose.</p> <form method="POST"${attr("action", `?/abortGame`)} class="sticky bottom-0 left-0 mt-8 w-full border-t border-gray-700 bg-black px-5 py-5 svelte-f8xamw"><input type="text" name="gh"${attr("value", store_get($$store_subs ??= {}, "$page", page).url.searchParams.get("gh"))} hidden class="svelte-f8xamw"> `;
      Button($$payload2, {
        type: "submit",
        class: "w-full rounded-full bg-blue-600 py-3 text-white",
        children: ($$payload3) => {
          $$payload3.out += `<!---->Abort game`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!----></form></div>`;
    }
    $$payload2.out += `<!--]-->`;
  }
  __name($$render_inner, "$$render_inner");
  do {
    $$settled = true;
    $$inner_payload = copy_payload($$payload);
    $$render_inner($$inner_payload);
  } while (!$$settled);
  assign_payload($$payload, $$inner_payload);
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
__name(Pwc4, "Pwc4");
function _page25($$payload) {
  Pwc4($$payload);
}
__name(_page25, "_page25");
var init_page_svelte25 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/rps/_typeOfPlay_/_page.svelte.js"() {
    init_index2();
    init_client();
    init_stores();
    init_button();
    init_utils3();
  }
});
var __exports29 = {};
__export(__exports29, {
  component: () => component29,
  fonts: () => fonts29,
  imports: () => imports29,
  index: () => index29,
  server: () => page_server_ts_exports10,
  server_id: () => server_id11,
  stylesheets: () => stylesheets29
});
var index29;
var component_cache29;
var component29;
var server_id11;
var imports29;
var stylesheets29;
var fonts29;
var init__29 = __esm({
  ".svelte-kit/output/server/nodes/28.js"() {
    init_page_server_ts10();
    index29 = 28;
    component29 = /* @__PURE__ */ __name(async () => component_cache29 ??= (await Promise.resolve().then(() => (init_page_svelte25(), page_svelte_exports25))).default, "component29");
    server_id11 = "src/routes/(app)/rps/[typeOfPlay]/+page.server.ts";
    imports29 = ["_app/immutable/nodes/28.BAGpiSGz.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/if.DLf01pqE.js", "_app/immutable/chunks/actions.DVNHJCdf.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js", "_app/immutable/chunks/class.waVxCJrB.js", "_app/immutable/chunks/transitions.D2VcR92X.js", "_app/immutable/chunks/props.CdXMhF7y.js", "_app/immutable/chunks/store.CDnLvhlJ.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/forms.CmnTScIw.js", "_app/immutable/chunks/entry.Zk5XMwWG.js", "_app/immutable/chunks/index-client.bJHR976g.js", "_app/immutable/chunks/index.bE0HzIKx.js", "_app/immutable/chunks/stores.DSH2_rmp.js", "_app/immutable/chunks/button.DQVOpKKk.js", "_app/immutable/chunks/slot.BDgc6-mN.js", "_app/immutable/chunks/lifecycle.BX15fcyy.js", "_app/immutable/chunks/misc.CXN-D0wo.js", "_app/immutable/chunks/create.OoZN6NjL.js", "_app/immutable/chunks/svelte-element.2QoIbCrV.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/this.CD6iIRB7.js", "_app/immutable/chunks/index.CplayyMK.js", "_app/immutable/chunks/index.Bi_aB5ul.js", "_app/immutable/chunks/bundle-mjs.BNYwEHuQ.js", "_app/immutable/chunks/utils.B8KE5qsB.js", "_app/immutable/chunks/index.CwHq6mbt.js"];
    stylesheets29 = ["_app/immutable/assets/28.Cf6dkqUH.css"];
    fonts29 = [];
  }
});
var page_svelte_exports26 = {};
__export(page_svelte_exports26, {
  default: () => _page26
});
function Filter($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const iconNode = [
    [
      "polygon",
      {
        "points": "22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"
      }
    ]
  ];
  Icon($$payload, spread_props([
    { name: "filter" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
}
__name(Filter, "Filter");
function addHighlight(element2) {
  element2.setAttribute("data-highlighted", "");
}
__name(addHighlight, "addHighlight");
function removeHighlight(element2) {
  element2.removeAttribute("data-highlighted");
}
__name(removeHighlight, "removeHighlight");
function debounce(fn, wait = 500) {
  let timeout = null;
  return function(...args) {
    const later = /* @__PURE__ */ __name(() => {
      timeout = null;
      fn(...args);
    }, "later");
    timeout && clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}
__name(debounce, "debounce");
function derivedVisible(obj) {
  const { open, forceVisible, activeTrigger } = obj;
  return derived([open, forceVisible, activeTrigger], ([$open, $forceVisible, $activeTrigger]) => ($open || $forceVisible) && $activeTrigger !== null);
}
__name(derivedVisible, "derivedVisible");
function handleRovingFocus(nextElement) {
  if (!isBrowser)
    return;
  sleep(1).then(() => {
    const currentFocusedElement = document.activeElement;
    if (!isHTMLElement(currentFocusedElement) || currentFocusedElement === nextElement)
      return;
    currentFocusedElement.tabIndex = -1;
    if (nextElement) {
      nextElement.tabIndex = 0;
      nextElement.focus();
    }
  });
}
__name(handleRovingFocus, "handleRovingFocus");
function getFocusableElements() {
  return Array.from(document.querySelectorAll('a[href]:not([tabindex="-1"]), button:not([disabled]):not([tabindex="-1"]), input:not([disabled]):not([tabindex="-1"]), select:not([disabled]):not([tabindex="-1"]), textarea:not([disabled]):not([tabindex="-1"]), [tabindex]:not([tabindex="-1"])'));
}
__name(getFocusableElements, "getFocusableElements");
function getNextFocusable(currentElement) {
  const focusableElements = getFocusableElements();
  const currentIndex = focusableElements.indexOf(currentElement);
  const nextIndex = currentIndex + 1;
  const nextElement = focusableElements[nextIndex];
  if (nextIndex < focusableElements.length && isHTMLElement(nextElement)) {
    return nextElement;
  }
  return null;
}
__name(getNextFocusable, "getNextFocusable");
function getPreviousFocusable(currentElement) {
  const focusableElements = getFocusableElements();
  const currentIndex = focusableElements.indexOf(currentElement);
  const previousIndex = currentIndex - 1;
  const prevElement = focusableElements[previousIndex];
  if (previousIndex >= 0 && isHTMLElement(prevElement)) {
    return prevElement;
  }
  return null;
}
__name(getPreviousFocusable, "getPreviousFocusable");
function createTypeaheadSearch(args = {}) {
  const withDefaults = { ...defaults$3, ...args };
  const typed = withGet(writable([]));
  const resetTyped = debounce(() => {
    typed.update(() => []);
  });
  const handleTypeaheadSearch = /* @__PURE__ */ __name((key2, items) => {
    if (ignoredKeys.has(key2))
      return;
    const currentItem = withDefaults.getCurrentItem();
    const $typed = get2(typed);
    if (!Array.isArray($typed)) {
      return;
    }
    $typed.push(key2.toLowerCase());
    typed.set($typed);
    const candidateItems = items.filter((item) => {
      if (item.getAttribute("disabled") === "true" || item.getAttribute("aria-disabled") === "true" || item.hasAttribute("data-disabled")) {
        return false;
      }
      return true;
    });
    const isRepeated = $typed.length > 1 && $typed.every((char) => char === $typed[0]);
    const normalizeSearch = isRepeated ? $typed[0] : $typed.join("");
    const currentItemIndex = isHTMLElement(currentItem) ? candidateItems.indexOf(currentItem) : -1;
    let wrappedItems = wrapArray(candidateItems, Math.max(currentItemIndex, 0));
    const excludeCurrentItem = normalizeSearch.length === 1;
    if (excludeCurrentItem) {
      wrappedItems = wrappedItems.filter((v2) => v2 !== currentItem);
    }
    const nextItem = wrappedItems.find((item) => item?.innerText && item.innerText.toLowerCase().startsWith(normalizeSearch.toLowerCase()));
    if (isHTMLElement(nextItem) && nextItem !== currentItem) {
      withDefaults.onMatch(nextItem);
    }
    resetTyped();
  }, "handleTypeaheadSearch");
  return {
    typed,
    resetTyped,
    handleTypeaheadSearch
  };
}
__name(createTypeaheadSearch, "createTypeaheadSearch");
function clamp(start, value, end) {
  return max(start, min(value, end));
}
__name(clamp, "clamp");
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
__name(evaluate, "evaluate");
function getSide(placement) {
  return placement.split("-")[0];
}
__name(getSide, "getSide");
function getAlignment(placement) {
  return placement.split("-")[1];
}
__name(getAlignment, "getAlignment");
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
__name(getOppositeAxis, "getOppositeAxis");
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
__name(getAxisLength, "getAxisLength");
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
__name(getSideAxis, "getSideAxis");
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
__name(getAlignmentAxis, "getAlignmentAxis");
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
__name(getAlignmentSides, "getAlignmentSides");
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
__name(getExpandedPlacements, "getExpandedPlacements");
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
__name(getOppositeAlignmentPlacement, "getOppositeAlignmentPlacement");
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
__name(getSideList, "getSideList");
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
__name(getOppositeAxisPlacements, "getOppositeAxisPlacements");
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
__name(getOppositePlacement, "getOppositePlacement");
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
__name(expandPaddingObject, "expandPaddingObject");
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
__name(getPaddingObject, "getPaddingObject");
function rectToClientRect(rect) {
  const {
    x: x2,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x2,
    right: x2 + width,
    bottom: y2 + height,
    x: x2,
    y: y2
  };
}
__name(rectToClientRect, "rectToClientRect");
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical2 = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical2 ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical2 ? -1 : 1);
      break;
  }
  return coords;
}
__name(computeCoordsFromPlacement, "computeCoordsFromPlacement");
async function detectOverflow(state, options2) {
  var _await$platform$isEle;
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options2, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element2 = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element2))) != null ? _await$platform$isEle : true) ? element2 : element2.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x2,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
__name(detectOverflow, "detectOverflow");
async function convertValueToCoords(state, options2) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical2 = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical2 ? -1 : 1;
  const rawValue = evaluate(options2, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical2 ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
__name(convertValueToCoords, "convertValueToCoords");
function hasWindow() {
  return typeof window !== "undefined";
}
__name(hasWindow, "hasWindow");
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
__name(getNodeName, "getNodeName");
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
__name(getWindow, "getWindow");
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
__name(getDocumentElement, "getDocumentElement");
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
__name(isNode, "isNode");
function isElement2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
__name(isElement2, "isElement2");
function isHTMLElement3(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
__name(isHTMLElement3, "isHTMLElement3");
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
__name(isShadowRoot, "isShadowRoot");
function isOverflowElement(element2) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element2);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
__name(isOverflowElement, "isOverflowElement");
function isTableElement(element2) {
  return ["table", "td", "th"].includes(getNodeName(element2));
}
__name(isTableElement, "isTableElement");
function isTopLayer(element2) {
  return [":popover-open", ":modal"].some((selector2) => {
    try {
      return element2.matches(selector2);
    } catch (e3) {
      return false;
    }
  });
}
__name(isTopLayer, "isTopLayer");
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement2(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
__name(isContainingBlock, "isContainingBlock");
function getContainingBlock(element2) {
  let currentNode = getParentNode(element2);
  while (isHTMLElement3(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
__name(getContainingBlock, "getContainingBlock");
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
__name(isWebKit, "isWebKit");
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
__name(isLastTraversableNode, "isLastTraversableNode");
function getComputedStyle2(element2) {
  return getWindow(element2).getComputedStyle(element2);
}
__name(getComputedStyle2, "getComputedStyle2");
function getNodeScroll(element2) {
  if (isElement2(element2)) {
    return {
      scrollLeft: element2.scrollLeft,
      scrollTop: element2.scrollTop
    };
  }
  return {
    scrollLeft: element2.scrollX,
    scrollTop: element2.scrollY
  };
}
__name(getNodeScroll, "getNodeScroll");
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
__name(getParentNode, "getParentNode");
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement3(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
__name(getNearestOverflowAncestor, "getNearestOverflowAncestor");
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
__name(getOverflowAncestors, "getOverflowAncestors");
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
__name(getFrameElement, "getFrameElement");
function getCssDimensions(element2) {
  const css = getComputedStyle2(element2);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement3(element2);
  const offsetWidth = hasOffset ? element2.offsetWidth : width;
  const offsetHeight = hasOffset ? element2.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
__name(getCssDimensions, "getCssDimensions");
function unwrapElement(element2) {
  return !isElement2(element2) ? element2.contextElement : element2;
}
__name(unwrapElement, "unwrapElement");
function getScale2(element2) {
  const domElement = unwrapElement(element2);
  if (!isHTMLElement3(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x2 = ($ ? round(rect.width) : rect.width) / width;
  let y2 = ($ ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
__name(getScale2, "getScale2");
function getVisualOffsets(element2) {
  const win = getWindow(element2);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
__name(getVisualOffsets, "getVisualOffsets");
function shouldAddVisualOffsets(element2, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element2)) {
    return false;
  }
  return isFixed;
}
__name(shouldAddVisualOffsets, "shouldAddVisualOffsets");
function getBoundingClientRect(element2, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element2.getBoundingClientRect();
  const domElement = unwrapElement(element2);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement2(offsetParent)) {
        scale = getScale2(offsetParent);
      }
    } else {
      scale = getScale2(element2);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement2(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale2(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y2 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
__name(getBoundingClientRect, "getBoundingClientRect");
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement3(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement3(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale2(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
__name(convertOffsetParentRelativeRectToViewportRelativeRect, "convertOffsetParentRelativeRectToViewportRelativeRect");
function getClientRects(element2) {
  return Array.from(element2.getClientRects());
}
__name(getClientRects, "getClientRects");
function getWindowScrollBarX(element2, rect) {
  const leftScroll = getNodeScroll(element2).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element2)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
__name(getWindowScrollBarX, "getWindowScrollBarX");
function getDocumentRect(element2) {
  const html = getDocumentElement(element2);
  const scroll = getNodeScroll(element2);
  const body2 = element2.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body2.scrollWidth, body2.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body2.scrollHeight, body2.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element2);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle2(body2).direction === "rtl") {
    x2 += max(html.clientWidth, body2.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
__name(getDocumentRect, "getDocumentRect");
function getViewportRect(element2, strategy) {
  const win = getWindow(element2);
  const html = getDocumentElement(element2);
  const visualViewport2 = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport2) {
    width = visualViewport2.width;
    height = visualViewport2.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport2.offsetLeft;
      y2 = visualViewport2.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
__name(getViewportRect, "getViewportRect");
function getInnerBoundingClientRect(element2, strategy) {
  const clientRect = getBoundingClientRect(element2, true, strategy === "fixed");
  const top = clientRect.top + element2.clientTop;
  const left = clientRect.left + element2.clientLeft;
  const scale = isHTMLElement3(element2) ? getScale2(element2) : createCoords(1);
  const width = element2.clientWidth * scale.x;
  const height = element2.clientHeight * scale.y;
  const x2 = left * scale.x;
  const y2 = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
__name(getInnerBoundingClientRect, "getInnerBoundingClientRect");
function getClientRectFromClippingAncestor(element2, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element2, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element2));
  } else if (isElement2(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element2);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
__name(getClientRectFromClippingAncestor, "getClientRectFromClippingAncestor");
function hasFixedPositionAncestor(element2, stopNode) {
  const parentNode = getParentNode(element2);
  if (parentNode === stopNode || !isElement2(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
__name(hasFixedPositionAncestor, "hasFixedPositionAncestor");
function getClippingElementAncestors(element2, cache2) {
  const cachedResult = cache2.get(element2);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element2, [], false).filter((el) => isElement2(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element2).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element2) : element2;
  while (isElement2(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element2, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache2.set(element2, result);
  return result;
}
__name(getClippingElementAncestors, "getClippingElementAncestors");
function getClippingRect(_ref) {
  let {
    element: element2,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element2) ? [] : getClippingElementAncestors(element2, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element2, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element2, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
__name(getClippingRect, "getClippingRect");
function getDimensions(element2) {
  const {
    width,
    height
  } = getCssDimensions(element2);
  return {
    width,
    height
  };
}
__name(getDimensions, "getDimensions");
function getRectRelativeToOffsetParent(element2, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement3(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element2, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  let htmlX = 0;
  let htmlY = 0;
  if (documentElement && !isOffsetParentAnElement && !isFixed) {
    const htmlRect = documentElement.getBoundingClientRect();
    htmlY = htmlRect.top + scroll.scrollTop;
    htmlX = htmlRect.left + scroll.scrollLeft - // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect);
  }
  const x2 = rect.left + scroll.scrollLeft - offsets.x - htmlX;
  const y2 = rect.top + scroll.scrollTop - offsets.y - htmlY;
  return {
    x: x2,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
__name(getRectRelativeToOffsetParent, "getRectRelativeToOffsetParent");
function isStaticPositioned(element2) {
  return getComputedStyle2(element2).position === "static";
}
__name(isStaticPositioned, "isStaticPositioned");
function getTrueOffsetParent(element2, polyfill) {
  if (!isHTMLElement3(element2) || getComputedStyle2(element2).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element2);
  }
  let rawOffsetParent = element2.offsetParent;
  if (getDocumentElement(element2) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
__name(getTrueOffsetParent, "getTrueOffsetParent");
function getOffsetParent(element2, polyfill) {
  const win = getWindow(element2);
  if (isTopLayer(element2)) {
    return win;
  }
  if (!isHTMLElement3(element2)) {
    let svgOffsetParent = getParentNode(element2);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement2(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element2, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element2) || win;
}
__name(getOffsetParent, "getOffsetParent");
function isRTL(element2) {
  return getComputedStyle2(element2).direction === "rtl";
}
__name(isRTL, "isRTL");
function observeMove(element2, onMove) {
  let io = null;
  let timeoutId;
  const root2 = getDocumentElement(element2);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  __name(cleanup, "cleanup");
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element2.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root2.clientWidth - (left + width));
    const insetBottom = floor(root2.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options2 = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    __name(handleObserve, "handleObserve");
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options2,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch (e3) {
      io = new IntersectionObserver(handleObserve, options2);
    }
    io.observe(element2);
  }
  __name(refresh, "refresh");
  refresh(true);
  return cleanup;
}
__name(observeMove, "observeMove");
function autoUpdate(reference, floating, update, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options2;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  __name(frameLoop, "frameLoop");
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
__name(autoUpdate, "autoUpdate");
function useFloating(reference, floating, opts = {}) {
  if (!floating || !reference || opts === null)
    return {
      destroy: noop2
    };
  const options2 = { ...defaultConfig$1, ...opts };
  const arrowEl = floating.querySelector("[data-arrow=true]");
  const middleware = [];
  if (options2.flip) {
    middleware.push(flip({
      boundary: options2.boundary,
      padding: options2.overflowPadding
    }));
  }
  const arrowOffset = isHTMLElement(arrowEl) ? arrowEl.offsetHeight / 2 : 0;
  if (options2.gutter || options2.offset) {
    const data = options2.gutter ? { mainAxis: options2.gutter } : options2.offset;
    if (data?.mainAxis != null) {
      data.mainAxis += arrowOffset;
    }
    middleware.push(offset(data));
  }
  middleware.push(shift({
    boundary: options2.boundary,
    crossAxis: options2.overlap,
    padding: options2.overflowPadding
  }));
  if (arrowEl) {
    middleware.push(arrow({ element: arrowEl, padding: 8 }));
  }
  middleware.push(size({
    padding: options2.overflowPadding,
    apply({ rects, availableHeight, availableWidth }) {
      if (options2.sameWidth) {
        Object.assign(floating.style, {
          width: `${Math.round(rects.reference.width)}px`,
          minWidth: "unset"
        });
      }
      if (options2.fitViewport) {
        Object.assign(floating.style, {
          maxWidth: `${availableWidth}px`,
          maxHeight: `${availableHeight}px`
        });
      }
    }
  }));
  function compute() {
    if (!reference || !floating)
      return;
    if (isHTMLElement(reference) && !reference.ownerDocument.documentElement.contains(reference))
      return;
    const { placement, strategy } = options2;
    computePosition(reference, floating, {
      placement,
      middleware,
      strategy
    }).then((data) => {
      const x2 = Math.round(data.x);
      const y2 = Math.round(data.y);
      const [side, align] = getSideAndAlignFromPlacement(data.placement);
      floating.setAttribute("data-side", side);
      floating.setAttribute("data-align", align);
      Object.assign(floating.style, {
        position: options2.strategy,
        top: `${y2}px`,
        left: `${x2}px`
      });
      if (isHTMLElement(arrowEl) && data.middlewareData.arrow) {
        const { x: x22, y: y22 } = data.middlewareData.arrow;
        const dir = data.placement.split("-")[0];
        arrowEl.setAttribute("data-side", dir);
        Object.assign(arrowEl.style, {
          position: "absolute",
          left: x22 != null ? `${x22}px` : "",
          top: y22 != null ? `${y22}px` : "",
          [dir]: `calc(100% - ${arrowOffset}px)`,
          transform: ARROW_TRANSFORM[dir],
          backgroundColor: "inherit",
          zIndex: "inherit"
        });
      }
      return data;
    });
  }
  __name(compute, "compute");
  Object.assign(floating.style, {
    position: options2.strategy
  });
  return {
    destroy: autoUpdate(reference, floating, compute)
  };
}
__name(useFloating, "useFloating");
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
__name(getSideAndAlignFromPlacement, "getSideAndAlignFromPlacement");
function createMenuBuilder(opts) {
  const { name: name3, selector: selector2 } = createElHelpers(opts.selector);
  const { preventScroll: preventScroll2, arrowSize, positioning, closeOnEscape, closeOnOutsideClick, portal, forceVisible, typeahead, loop, closeFocus, disableFocusFirstItem, closeOnItemClick, onOutsideClick } = opts.rootOptions;
  const rootOpen = opts.rootOpen;
  const rootActiveTrigger = opts.rootActiveTrigger;
  const nextFocusable = opts.nextFocusable;
  const prevFocusable = opts.prevFocusable;
  const isUsingKeyboard = withGet.writable(false);
  const lastPointerX = withGet(writable(0));
  const pointerGraceIntent = withGet(writable(null));
  const pointerDir = withGet(writable("right"));
  const currentFocusedItem = withGet(writable(null));
  const pointerMovingToSubmenu = withGet(derived([pointerDir, pointerGraceIntent], ([$pointerDir, $pointerGraceIntent]) => {
    return (e3) => {
      const isMovingTowards = $pointerDir === $pointerGraceIntent?.side;
      return isMovingTowards && isPointerInGraceArea(e3, $pointerGraceIntent?.area);
    };
  }));
  const { typed, handleTypeaheadSearch } = createTypeaheadSearch();
  const rootIds = toWritableStores({ ...generateIds(menuIdParts), ...opts.ids });
  const isVisible = derivedVisible({
    open: rootOpen,
    forceVisible,
    activeTrigger: rootActiveTrigger
  });
  const rootMenu = makeElement(name3(), {
    stores: [isVisible, portal, rootIds.menu, rootIds.trigger],
    returned: ([$isVisible, $portal, $rootMenuId, $rootTriggerId]) => {
      return {
        role: "menu",
        hidden: $isVisible ? void 0 : true,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        }),
        id: $rootMenuId,
        "aria-labelledby": $rootTriggerId,
        "data-state": $isVisible ? "open" : "closed",
        "data-portal": portalAttr($portal),
        tabindex: -1
      };
    },
    action: (node) => {
      let unsubPopper = noop2;
      const unsubDerived = effect2([isVisible, rootActiveTrigger, positioning, closeOnOutsideClick, portal, closeOnEscape], ([$isVisible, $rootActiveTrigger, $positioning, $closeOnOutsideClick, $portal, $closeOnEscape]) => {
        unsubPopper();
        if (!$isVisible || !$rootActiveTrigger)
          return;
        tick().then(() => {
          unsubPopper();
          setMeltMenuAttribute(node, selector2);
          unsubPopper = usePopper(node, {
            anchorElement: $rootActiveTrigger,
            open: rootOpen,
            options: {
              floating: $positioning,
              modal: {
                closeOnInteractOutside: $closeOnOutsideClick,
                shouldCloseOnInteractOutside: (e3) => {
                  onOutsideClick.get()?.(e3);
                  if (e3.defaultPrevented)
                    return false;
                  if (isHTMLElement($rootActiveTrigger) && $rootActiveTrigger.contains(e3.target)) {
                    return false;
                  }
                  return true;
                },
                onClose: () => {
                  rootOpen.set(false);
                  $rootActiveTrigger.focus();
                },
                open: $isVisible
              },
              portal: getPortalDestination(node, $portal),
              escapeKeydown: $closeOnEscape ? void 0 : null
            }
          }).destroy;
        });
      });
      const unsubEvents = executeCallbacks(addMeltEventListener(node, "keydown", (e3) => {
        const target = e3.target;
        const menuEl = e3.currentTarget;
        if (!isHTMLElement(target) || !isHTMLElement(menuEl))
          return;
        const isKeyDownInside = target.closest('[role="menu"]') === menuEl;
        if (!isKeyDownInside)
          return;
        if (FIRST_LAST_KEYS.includes(e3.key)) {
          handleMenuNavigation(e3, loop.get() ?? false);
        }
        if (e3.key === kbd.TAB) {
          e3.preventDefault();
          rootOpen.set(false);
          handleTabNavigation(e3, nextFocusable, prevFocusable);
          return;
        }
        const isCharacterKey = e3.key.length === 1;
        const isModifierKey = e3.ctrlKey || e3.altKey || e3.metaKey;
        if (!isModifierKey && isCharacterKey && typeahead.get() === true) {
          handleTypeaheadSearch(e3.key, getMenuItems(menuEl));
        }
      }));
      return {
        destroy() {
          unsubDerived();
          unsubEvents();
          unsubPopper();
        }
      };
    }
  });
  const rootTrigger = makeElement(name3("trigger"), {
    stores: [rootOpen, rootIds.menu, rootIds.trigger],
    returned: ([$rootOpen, $rootMenuId, $rootTriggerId]) => {
      return {
        "aria-controls": $rootMenuId,
        "aria-expanded": $rootOpen,
        "data-state": $rootOpen ? "open" : "closed",
        id: $rootTriggerId,
        tabindex: 0
      };
    },
    action: (node) => {
      applyAttrsIfDisabled(node);
      rootActiveTrigger.update((p2) => {
        if (p2)
          return p2;
        return node;
      });
      const unsub = executeCallbacks(addMeltEventListener(node, "click", (e3) => {
        const $rootOpen = rootOpen.get();
        const triggerEl = e3.currentTarget;
        if (!isHTMLElement(triggerEl))
          return;
        handleOpen(triggerEl);
        if (!$rootOpen)
          e3.preventDefault();
      }), addMeltEventListener(node, "keydown", (e3) => {
        const triggerEl = e3.currentTarget;
        if (!isHTMLElement(triggerEl))
          return;
        if (!(SELECTION_KEYS.includes(e3.key) || e3.key === kbd.ARROW_DOWN))
          return;
        e3.preventDefault();
        handleOpen(triggerEl);
        const menuId = triggerEl.getAttribute("aria-controls");
        if (!menuId)
          return;
        const menu = document.getElementById(menuId);
        if (!menu)
          return;
        const menuItems = getMenuItems(menu);
        if (!menuItems.length)
          return;
        handleRovingFocus(menuItems[0]);
      }));
      return {
        destroy: unsub
      };
    }
  });
  const rootArrow = makeElement(name3("arrow"), {
    stores: arrowSize,
    returned: ($arrowSize) => ({
      "data-arrow": true,
      style: styleToString({
        position: "absolute",
        width: `var(--arrow-size, ${$arrowSize}px)`,
        height: `var(--arrow-size, ${$arrowSize}px)`
      })
    })
  });
  const overlay = makeElement(name3("overlay"), {
    stores: [isVisible],
    returned: ([$isVisible]) => {
      return {
        hidden: $isVisible ? void 0 : true,
        tabindex: -1,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        }),
        "aria-hidden": "true",
        "data-state": stateAttr($isVisible)
      };
    },
    action: (node) => {
      let unsubEscapeKeydown = noop2;
      if (closeOnEscape.get()) {
        const escapeKeydown = useEscapeKeydown(node, {
          handler: () => {
            rootOpen.set(false);
            const $rootActiveTrigger = rootActiveTrigger.get();
            if ($rootActiveTrigger)
              $rootActiveTrigger.focus();
          }
        });
        if (escapeKeydown && escapeKeydown.destroy) {
          unsubEscapeKeydown = escapeKeydown.destroy;
        }
      }
      const unsubPortal = effect2([portal], ([$portal]) => {
        if ($portal === null)
          return noop2;
        const portalDestination = getPortalDestination(node, $portal);
        if (portalDestination === null)
          return noop2;
        return usePortal(node, portalDestination).destroy;
      });
      return {
        destroy() {
          unsubEscapeKeydown();
          unsubPortal();
        }
      };
    }
  });
  const item = makeElement(name3("item"), {
    returned: () => {
      return {
        role: "menuitem",
        tabindex: -1,
        "data-orientation": "vertical"
      };
    },
    action: (node) => {
      setMeltMenuAttribute(node, selector2);
      applyAttrsIfDisabled(node);
      const unsub = executeCallbacks(addMeltEventListener(node, "pointerdown", (e3) => {
        const itemEl = e3.currentTarget;
        if (!isHTMLElement(itemEl))
          return;
        if (isElementDisabled(itemEl)) {
          e3.preventDefault();
          return;
        }
      }), addMeltEventListener(node, "click", (e3) => {
        const itemEl = e3.currentTarget;
        if (!isHTMLElement(itemEl))
          return;
        if (isElementDisabled(itemEl)) {
          e3.preventDefault();
          return;
        }
        if (e3.defaultPrevented) {
          handleRovingFocus(itemEl);
          return;
        }
        if (closeOnItemClick.get()) {
          sleep(1).then(() => {
            rootOpen.set(false);
          });
        }
      }), addMeltEventListener(node, "keydown", (e3) => {
        onItemKeyDown(e3);
      }), addMeltEventListener(node, "pointermove", (e3) => {
        onMenuItemPointerMove(e3);
      }), addMeltEventListener(node, "pointerleave", (e3) => {
        onMenuItemPointerLeave(e3);
      }), addMeltEventListener(node, "focusin", (e3) => {
        onItemFocusIn(e3);
      }), addMeltEventListener(node, "focusout", (e3) => {
        onItemFocusOut(e3);
      }));
      return {
        destroy: unsub
      };
    }
  });
  const group = makeElement(name3("group"), {
    returned: () => {
      return (groupId) => ({
        role: "group",
        "aria-labelledby": groupId
      });
    }
  });
  const groupLabel = makeElement(name3("group-label"), {
    returned: () => {
      return (groupId) => ({
        id: groupId
      });
    }
  });
  const checkboxItemDefaults = {
    defaultChecked: false,
    disabled: false
  };
  const createCheckboxItem = /* @__PURE__ */ __name((props) => {
    const withDefaults = { ...checkboxItemDefaults, ...props };
    const checkedWritable = withDefaults.checked ?? writable(withDefaults.defaultChecked ?? null);
    const checked = overridable(checkedWritable, withDefaults.onCheckedChange);
    const disabled = writable(withDefaults.disabled);
    const checkboxItem = makeElement(name3("checkbox-item"), {
      stores: [checked, disabled],
      returned: ([$checked, $disabled]) => {
        return {
          role: "menuitemcheckbox",
          tabindex: -1,
          "data-orientation": "vertical",
          "aria-checked": isIndeterminate($checked) ? "mixed" : $checked ? "true" : "false",
          "data-disabled": disabledAttr($disabled),
          "data-state": getCheckedState($checked)
        };
      },
      action: (node) => {
        setMeltMenuAttribute(node, selector2);
        applyAttrsIfDisabled(node);
        const unsub = executeCallbacks(addMeltEventListener(node, "pointerdown", (e3) => {
          const itemEl = e3.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          if (isElementDisabled(itemEl)) {
            e3.preventDefault();
            return;
          }
        }), addMeltEventListener(node, "click", (e3) => {
          const itemEl = e3.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          if (isElementDisabled(itemEl)) {
            e3.preventDefault();
            return;
          }
          if (e3.defaultPrevented) {
            handleRovingFocus(itemEl);
            return;
          }
          checked.update((prev2) => {
            if (isIndeterminate(prev2))
              return true;
            return !prev2;
          });
          if (closeOnItemClick.get()) {
            tick().then(() => {
              rootOpen.set(false);
            });
          }
        }), addMeltEventListener(node, "keydown", (e3) => {
          onItemKeyDown(e3);
        }), addMeltEventListener(node, "pointermove", (e3) => {
          const itemEl = e3.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          if (isElementDisabled(itemEl)) {
            onItemLeave(e3);
            return;
          }
          onMenuItemPointerMove(e3, itemEl);
        }), addMeltEventListener(node, "pointerleave", (e3) => {
          onMenuItemPointerLeave(e3);
        }), addMeltEventListener(node, "focusin", (e3) => {
          onItemFocusIn(e3);
        }), addMeltEventListener(node, "focusout", (e3) => {
          onItemFocusOut(e3);
        }));
        return {
          destroy: unsub
        };
      }
    });
    const isChecked = derived(checked, ($checked) => $checked === true);
    const _isIndeterminate = derived(checked, ($checked) => $checked === "indeterminate");
    return {
      elements: {
        checkboxItem
      },
      states: {
        checked
      },
      helpers: {
        isChecked,
        isIndeterminate: _isIndeterminate
      },
      options: {
        disabled
      }
    };
  }, "createCheckboxItem");
  const createMenuRadioGroup = /* @__PURE__ */ __name((args = {}) => {
    const valueWritable = args.value ?? writable(args.defaultValue ?? null);
    const value = overridable(valueWritable, args.onValueChange);
    const radioGroup = makeElement(name3("radio-group"), {
      returned: () => ({
        role: "group"
      })
    });
    const radioItemDefaults = {
      disabled: false
    };
    const radioItem = makeElement(name3("radio-item"), {
      stores: [value],
      returned: ([$value]) => {
        return (itemProps) => {
          const { value: itemValue, disabled } = { ...radioItemDefaults, ...itemProps };
          const checked = $value === itemValue;
          return {
            disabled,
            role: "menuitemradio",
            "data-state": checked ? "checked" : "unchecked",
            "aria-checked": checked,
            "data-disabled": disabledAttr(disabled),
            "data-value": itemValue,
            "data-orientation": "vertical",
            tabindex: -1
          };
        };
      },
      action: (node) => {
        setMeltMenuAttribute(node, selector2);
        const unsub = executeCallbacks(addMeltEventListener(node, "pointerdown", (e3) => {
          const itemEl = e3.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          const itemValue = node.dataset.value;
          const disabled = node.dataset.disabled;
          if (disabled || itemValue === void 0) {
            e3.preventDefault();
            return;
          }
        }), addMeltEventListener(node, "click", (e3) => {
          const itemEl = e3.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          const itemValue = node.dataset.value;
          const disabled = node.dataset.disabled;
          if (disabled || itemValue === void 0) {
            e3.preventDefault();
            return;
          }
          if (e3.defaultPrevented) {
            if (!isHTMLElement(itemEl))
              return;
            handleRovingFocus(itemEl);
            return;
          }
          value.set(itemValue);
          if (closeOnItemClick.get()) {
            tick().then(() => {
              rootOpen.set(false);
            });
          }
        }), addMeltEventListener(node, "keydown", (e3) => {
          onItemKeyDown(e3);
        }), addMeltEventListener(node, "pointermove", (e3) => {
          const itemEl = e3.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          const itemValue = node.dataset.value;
          const disabled = node.dataset.disabled;
          if (disabled || itemValue === void 0) {
            onItemLeave(e3);
            return;
          }
          onMenuItemPointerMove(e3, itemEl);
        }), addMeltEventListener(node, "pointerleave", (e3) => {
          onMenuItemPointerLeave(e3);
        }), addMeltEventListener(node, "focusin", (e3) => {
          onItemFocusIn(e3);
        }), addMeltEventListener(node, "focusout", (e3) => {
          onItemFocusOut(e3);
        }));
        return {
          destroy: unsub
        };
      }
    });
    const isChecked = derived(value, ($value) => {
      return (itemValue) => {
        return $value === itemValue;
      };
    });
    return {
      elements: {
        radioGroup,
        radioItem
      },
      states: {
        value
      },
      helpers: {
        isChecked
      }
    };
  }, "createMenuRadioGroup");
  const { elements: { root: separator } } = createSeparator({
    orientation: "horizontal"
  });
  const subMenuDefaults = {
    ...defaults$2,
    disabled: false,
    positioning: {
      placement: "right-start",
      gutter: 8
    }
  };
  const createSubmenu = /* @__PURE__ */ __name((args) => {
    const withDefaults = { ...subMenuDefaults, ...args };
    const subOpenWritable = withDefaults.open ?? writable(false);
    const subOpen = overridable(subOpenWritable, withDefaults?.onOpenChange);
    const options2 = toWritableStores(omit(withDefaults, "ids"));
    const { positioning: positioning2, arrowSize: arrowSize2, disabled } = options2;
    const subActiveTrigger = withGet(writable(null));
    const subOpenTimer = withGet(writable(null));
    const pointerGraceTimer = withGet(writable(0));
    const subIds = toWritableStores({ ...generateIds(menuIdParts), ...withDefaults.ids });
    safeOnMount(() => {
      const subTrigger2 = document.getElementById(subIds.trigger.get());
      if (subTrigger2) {
        subActiveTrigger.set(subTrigger2);
      }
    });
    const subIsVisible = derivedVisible({
      open: subOpen,
      forceVisible,
      activeTrigger: subActiveTrigger
    });
    const subMenu = makeElement(name3("submenu"), {
      stores: [subIsVisible, subIds.menu, subIds.trigger],
      returned: ([$subIsVisible, $subMenuId, $subTriggerId]) => {
        return {
          role: "menu",
          hidden: $subIsVisible ? void 0 : true,
          style: styleToString({
            display: $subIsVisible ? void 0 : "none"
          }),
          id: $subMenuId,
          "aria-labelledby": $subTriggerId,
          "data-state": $subIsVisible ? "open" : "closed",
          // unit tests fail on `.closest` if the id starts with a number
          // so using a data attribute
          "data-id": $subMenuId,
          tabindex: -1
        };
      },
      action: (node) => {
        let unsubPopper = noop2;
        const unsubDerived = effect2([subIsVisible, positioning2], ([$subIsVisible, $positioning]) => {
          unsubPopper();
          if (!$subIsVisible)
            return;
          const activeTrigger = subActiveTrigger.get();
          if (!activeTrigger)
            return;
          tick().then(() => {
            unsubPopper();
            const parentMenuEl = getParentMenu(activeTrigger);
            unsubPopper = usePopper(node, {
              anchorElement: activeTrigger,
              open: subOpen,
              options: {
                floating: $positioning,
                portal: isHTMLElement(parentMenuEl) ? parentMenuEl : void 0,
                modal: null,
                focusTrap: null,
                escapeKeydown: null
              }
            }).destroy;
          });
        });
        const unsubEvents = executeCallbacks(addMeltEventListener(node, "keydown", (e3) => {
          if (e3.key === kbd.ESCAPE) {
            return;
          }
          const target = e3.target;
          const menuEl = e3.currentTarget;
          if (!isHTMLElement(target) || !isHTMLElement(menuEl))
            return;
          const isKeyDownInside = target.closest('[role="menu"]') === menuEl;
          if (!isKeyDownInside)
            return;
          if (FIRST_LAST_KEYS.includes(e3.key)) {
            e3.stopImmediatePropagation();
            handleMenuNavigation(e3, loop.get() ?? false);
            return;
          }
          const isCloseKey = SUB_CLOSE_KEYS["ltr"].includes(e3.key);
          const isModifierKey = e3.ctrlKey || e3.altKey || e3.metaKey;
          const isCharacterKey = e3.key.length === 1;
          if (isCloseKey) {
            const $subActiveTrigger = subActiveTrigger.get();
            e3.preventDefault();
            subOpen.update(() => {
              if ($subActiveTrigger) {
                handleRovingFocus($subActiveTrigger);
              }
              return false;
            });
            return;
          }
          if (e3.key === kbd.TAB) {
            e3.preventDefault();
            rootOpen.set(false);
            handleTabNavigation(e3, nextFocusable, prevFocusable);
            return;
          }
          if (!isModifierKey && isCharacterKey && typeahead.get() === true) {
            handleTypeaheadSearch(e3.key, getMenuItems(menuEl));
          }
        }), addMeltEventListener(node, "pointermove", (e3) => {
          onMenuPointerMove(e3);
        }), addMeltEventListener(node, "focusout", (e3) => {
          const $subActiveTrigger = subActiveTrigger.get();
          if (isUsingKeyboard.get()) {
            const target = e3.target;
            const submenuEl = document.getElementById(subIds.menu.get());
            if (!isHTMLElement(submenuEl) || !isHTMLElement(target))
              return;
            if (!submenuEl.contains(target) && target !== $subActiveTrigger) {
              subOpen.set(false);
            }
          } else {
            const menuEl = e3.currentTarget;
            const relatedTarget = e3.relatedTarget;
            if (!isHTMLElement(relatedTarget) || !isHTMLElement(menuEl))
              return;
            if (!menuEl.contains(relatedTarget) && relatedTarget !== $subActiveTrigger) {
              subOpen.set(false);
            }
          }
        }));
        return {
          destroy() {
            unsubDerived();
            unsubPopper();
            unsubEvents();
          }
        };
      }
    });
    const subTrigger = makeElement(name3("subtrigger"), {
      stores: [subOpen, disabled, subIds.menu, subIds.trigger],
      returned: ([$subOpen, $disabled, $subMenuId, $subTriggerId]) => {
        return {
          role: "menuitem",
          id: $subTriggerId,
          tabindex: -1,
          "aria-controls": $subMenuId,
          "aria-expanded": $subOpen,
          "data-state": $subOpen ? "open" : "closed",
          "data-disabled": disabledAttr($disabled),
          "aria-haspopop": "menu"
        };
      },
      action: (node) => {
        setMeltMenuAttribute(node, selector2);
        applyAttrsIfDisabled(node);
        subActiveTrigger.update((p2) => {
          if (p2)
            return p2;
          return node;
        });
        const unsubTimer = /* @__PURE__ */ __name(() => {
          clearTimerStore(subOpenTimer);
          window.clearTimeout(pointerGraceTimer.get());
          pointerGraceIntent.set(null);
        }, "unsubTimer");
        const unsubEvents = executeCallbacks(addMeltEventListener(node, "click", (e3) => {
          if (e3.defaultPrevented)
            return;
          const triggerEl = e3.currentTarget;
          if (!isHTMLElement(triggerEl) || isElementDisabled(triggerEl))
            return;
          handleRovingFocus(triggerEl);
          if (!subOpen.get()) {
            subOpen.update((prev2) => {
              const isAlreadyOpen = prev2;
              if (!isAlreadyOpen) {
                subActiveTrigger.set(triggerEl);
                return !prev2;
              }
              return prev2;
            });
          }
        }), addMeltEventListener(node, "keydown", (e3) => {
          const $typed = typed.get();
          const triggerEl = e3.currentTarget;
          if (!isHTMLElement(triggerEl) || isElementDisabled(triggerEl))
            return;
          const isTypingAhead = $typed.length > 0;
          if (isTypingAhead && e3.key === kbd.SPACE)
            return;
          if (SUB_OPEN_KEYS["ltr"].includes(e3.key)) {
            if (!subOpen.get()) {
              triggerEl.click();
              e3.preventDefault();
              return;
            }
            const menuId = triggerEl.getAttribute("aria-controls");
            if (!menuId)
              return;
            const menuEl = document.getElementById(menuId);
            if (!isHTMLElement(menuEl))
              return;
            const firstItem = getMenuItems(menuEl)[0];
            handleRovingFocus(firstItem);
          }
        }), addMeltEventListener(node, "pointermove", (e3) => {
          if (!isMouse(e3))
            return;
          onItemEnter(e3);
          if (e3.defaultPrevented)
            return;
          const triggerEl = e3.currentTarget;
          if (!isHTMLElement(triggerEl))
            return;
          if (!isFocusWithinSubmenu(subIds.menu.get())) {
            handleRovingFocus(triggerEl);
          }
          const openTimer = subOpenTimer.get();
          if (!subOpen.get() && !openTimer && !isElementDisabled(triggerEl)) {
            subOpenTimer.set(window.setTimeout(() => {
              subOpen.update(() => {
                subActiveTrigger.set(triggerEl);
                return true;
              });
              clearTimerStore(subOpenTimer);
            }, 100));
          }
        }), addMeltEventListener(node, "pointerleave", (e3) => {
          if (!isMouse(e3))
            return;
          clearTimerStore(subOpenTimer);
          const submenuEl = document.getElementById(subIds.menu.get());
          const contentRect = submenuEl?.getBoundingClientRect();
          if (contentRect) {
            const side = submenuEl?.dataset.side;
            const rightSide = side === "right";
            const bleed = rightSide ? -5 : 5;
            const contentNearEdge = contentRect[rightSide ? "left" : "right"];
            const contentFarEdge = contentRect[rightSide ? "right" : "left"];
            pointerGraceIntent.set({
              area: [
                // Apply a bleed on clientX to ensure that our exit point is
                // consistently within polygon bounds
                { x: e3.clientX + bleed, y: e3.clientY },
                { x: contentNearEdge, y: contentRect.top },
                { x: contentFarEdge, y: contentRect.top },
                { x: contentFarEdge, y: contentRect.bottom },
                { x: contentNearEdge, y: contentRect.bottom }
              ],
              side
            });
            window.clearTimeout(pointerGraceTimer.get());
            pointerGraceTimer.set(window.setTimeout(() => {
              pointerGraceIntent.set(null);
            }, 300));
          } else {
            onTriggerLeave(e3);
            if (e3.defaultPrevented)
              return;
            pointerGraceIntent.set(null);
          }
        }), addMeltEventListener(node, "focusout", (e3) => {
          const triggerEl = e3.currentTarget;
          if (!isHTMLElement(triggerEl))
            return;
          removeHighlight(triggerEl);
          const relatedTarget = e3.relatedTarget;
          if (!isHTMLElement(relatedTarget))
            return;
          const menuId = triggerEl.getAttribute("aria-controls");
          if (!menuId)
            return;
          const menu = document.getElementById(menuId);
          if (menu && !menu.contains(relatedTarget)) {
            subOpen.set(false);
          }
        }), addMeltEventListener(node, "focusin", (e3) => {
          onItemFocusIn(e3);
        }));
        return {
          destroy() {
            unsubTimer();
            unsubEvents();
          }
        };
      }
    });
    const subArrow = makeElement(name3("subarrow"), {
      stores: arrowSize2,
      returned: ($arrowSize) => ({
        "data-arrow": true,
        style: styleToString({
          position: "absolute",
          width: `var(--arrow-size, ${$arrowSize}px)`,
          height: `var(--arrow-size, ${$arrowSize}px)`
        })
      })
    });
    effect2([rootOpen], ([$rootOpen]) => {
      if (!$rootOpen) {
        subActiveTrigger.set(null);
        subOpen.set(false);
      }
    });
    effect2([pointerGraceIntent], ([$pointerGraceIntent]) => {
      if (!isBrowser || $pointerGraceIntent)
        return;
      window.clearTimeout(pointerGraceTimer.get());
    });
    effect2([subOpen], ([$subOpen]) => {
      if (!isBrowser)
        return;
      if ($subOpen && isUsingKeyboard.get()) {
        sleep(1).then(() => {
          const menuEl = document.getElementById(subIds.menu.get());
          if (!menuEl)
            return;
          const menuItems = getMenuItems(menuEl);
          if (!menuItems.length)
            return;
          handleRovingFocus(menuItems[0]);
        });
      }
      if (!$subOpen) {
        const focusedItem = currentFocusedItem.get();
        const subTriggerEl = document.getElementById(subIds.trigger.get());
        if (focusedItem) {
          sleep(1).then(() => {
            const menuEl = document.getElementById(subIds.menu.get());
            if (!menuEl)
              return;
            if (menuEl.contains(focusedItem)) {
              removeHighlight(focusedItem);
            }
          });
        }
        if (!subTriggerEl || document.activeElement === subTriggerEl)
          return;
        removeHighlight(subTriggerEl);
      }
    });
    return {
      ids: subIds,
      elements: {
        subTrigger,
        subMenu,
        subArrow
      },
      states: {
        subOpen
      },
      options: options2
    };
  }, "createSubmenu");
  safeOnMount(() => {
    const triggerEl = document.getElementById(rootIds.trigger.get());
    if (isHTMLElement(triggerEl) && rootOpen.get()) {
      rootActiveTrigger.set(triggerEl);
    }
    const unsubs = [];
    const handlePointer = /* @__PURE__ */ __name(() => isUsingKeyboard.set(false), "handlePointer");
    const handleKeyDown = /* @__PURE__ */ __name(() => {
      isUsingKeyboard.set(true);
      unsubs.push(executeCallbacks(addEventListener(document, "pointerdown", handlePointer, { capture: true, once: true }), addEventListener(document, "pointermove", handlePointer, { capture: true, once: true })));
    }, "handleKeyDown");
    const keydownListener = /* @__PURE__ */ __name((e3) => {
      if (e3.key === kbd.ESCAPE && closeOnEscape.get()) {
        rootOpen.set(false);
        return;
      }
    }, "keydownListener");
    unsubs.push(addEventListener(document, "keydown", handleKeyDown, { capture: true }));
    unsubs.push(addEventListener(document, "keydown", keydownListener));
    return () => {
      unsubs.forEach((unsub) => unsub());
    };
  });
  effect2([rootOpen, currentFocusedItem], ([$rootOpen, $currentFocusedItem]) => {
    if (!$rootOpen && $currentFocusedItem) {
      removeHighlight($currentFocusedItem);
    }
  });
  effect2([rootOpen], ([$rootOpen]) => {
    if (!isBrowser)
      return;
    if (!$rootOpen) {
      const $rootActiveTrigger = rootActiveTrigger.get();
      if (!$rootActiveTrigger)
        return;
      const $closeFocus = closeFocus.get();
      if (!$rootOpen && $rootActiveTrigger) {
        handleFocus({ prop: $closeFocus, defaultEl: $rootActiveTrigger });
      }
    }
  });
  effect2([rootOpen, preventScroll2], ([$rootOpen, $preventScroll]) => {
    if (!isBrowser)
      return;
    const unsubs = [];
    if ($rootOpen && $preventScroll) {
      unsubs.push(removeScroll());
    }
    sleep(1).then(() => {
      const menuEl = document.getElementById(rootIds.menu.get());
      if (menuEl && $rootOpen && isUsingKeyboard.get()) {
        if (disableFocusFirstItem.get()) {
          handleRovingFocus(menuEl);
          return;
        }
        const menuItems = getMenuItems(menuEl);
        if (!menuItems.length)
          return;
        handleRovingFocus(menuItems[0]);
      }
    });
    return () => {
      unsubs.forEach((unsub) => unsub());
    };
  });
  effect2(rootOpen, ($rootOpen) => {
    if (!isBrowser)
      return;
    const handlePointer = /* @__PURE__ */ __name(() => isUsingKeyboard.set(false), "handlePointer");
    const handleKeyDown = /* @__PURE__ */ __name((e3) => {
      isUsingKeyboard.set(true);
      if (e3.key === kbd.ESCAPE && $rootOpen && closeOnEscape.get()) {
        rootOpen.set(false);
        return;
      }
    }, "handleKeyDown");
    return executeCallbacks(addEventListener(document, "pointerdown", handlePointer, { capture: true, once: true }), addEventListener(document, "pointermove", handlePointer, { capture: true, once: true }), addEventListener(document, "keydown", handleKeyDown, { capture: true }));
  });
  function handleOpen(triggerEl) {
    rootOpen.update((prev2) => {
      const isOpen = !prev2;
      if (isOpen) {
        nextFocusable.set(getNextFocusable(triggerEl));
        prevFocusable.set(getPreviousFocusable(triggerEl));
        rootActiveTrigger.set(triggerEl);
      }
      return isOpen;
    });
  }
  __name(handleOpen, "handleOpen");
  function onItemFocusIn(e3) {
    const itemEl = e3.currentTarget;
    if (!isHTMLElement(itemEl))
      return;
    const $currentFocusedItem = currentFocusedItem.get();
    if ($currentFocusedItem) {
      removeHighlight($currentFocusedItem);
    }
    addHighlight(itemEl);
    currentFocusedItem.set(itemEl);
  }
  __name(onItemFocusIn, "onItemFocusIn");
  function onItemFocusOut(e3) {
    const itemEl = e3.currentTarget;
    if (!isHTMLElement(itemEl))
      return;
    removeHighlight(itemEl);
  }
  __name(onItemFocusOut, "onItemFocusOut");
  function onItemEnter(e3) {
    if (isPointerMovingToSubmenu(e3)) {
      e3.preventDefault();
    }
  }
  __name(onItemEnter, "onItemEnter");
  function onItemLeave(e3) {
    if (isPointerMovingToSubmenu(e3)) {
      return;
    }
    const target = e3.target;
    if (!isHTMLElement(target))
      return;
    const parentMenuEl = getParentMenu(target);
    if (!parentMenuEl)
      return;
    handleRovingFocus(parentMenuEl);
  }
  __name(onItemLeave, "onItemLeave");
  function onTriggerLeave(e3) {
    if (isPointerMovingToSubmenu(e3)) {
      e3.preventDefault();
    }
  }
  __name(onTriggerLeave, "onTriggerLeave");
  function onMenuPointerMove(e3) {
    if (!isMouse(e3))
      return;
    const target = e3.target;
    const currentTarget = e3.currentTarget;
    if (!isHTMLElement(currentTarget) || !isHTMLElement(target))
      return;
    const $lastPointerX = lastPointerX.get();
    const pointerXHasChanged = $lastPointerX !== e3.clientX;
    if (currentTarget.contains(target) && pointerXHasChanged) {
      const newDir = e3.clientX > $lastPointerX ? "right" : "left";
      pointerDir.set(newDir);
      lastPointerX.set(e3.clientX);
    }
  }
  __name(onMenuPointerMove, "onMenuPointerMove");
  function onMenuItemPointerMove(e3, currTarget = null) {
    if (!isMouse(e3))
      return;
    onItemEnter(e3);
    if (e3.defaultPrevented)
      return;
    if (currTarget) {
      handleRovingFocus(currTarget);
      return;
    }
    const currentTarget = e3.currentTarget;
    if (!isHTMLElement(currentTarget))
      return;
    handleRovingFocus(currentTarget);
  }
  __name(onMenuItemPointerMove, "onMenuItemPointerMove");
  function onMenuItemPointerLeave(e3) {
    if (!isMouse(e3))
      return;
    onItemLeave(e3);
  }
  __name(onMenuItemPointerLeave, "onMenuItemPointerLeave");
  function onItemKeyDown(e3) {
    const $typed = typed.get();
    const isTypingAhead = $typed.length > 0;
    if (isTypingAhead && e3.key === kbd.SPACE) {
      e3.preventDefault();
      return;
    }
    if (SELECTION_KEYS.includes(e3.key)) {
      e3.preventDefault();
      const itemEl = e3.currentTarget;
      if (!isHTMLElement(itemEl))
        return;
      itemEl.click();
    }
  }
  __name(onItemKeyDown, "onItemKeyDown");
  function isIndeterminate(checked) {
    return checked === "indeterminate";
  }
  __name(isIndeterminate, "isIndeterminate");
  function getCheckedState(checked) {
    return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
  }
  __name(getCheckedState, "getCheckedState");
  function isPointerMovingToSubmenu(e3) {
    return pointerMovingToSubmenu.get()(e3);
  }
  __name(isPointerMovingToSubmenu, "isPointerMovingToSubmenu");
  function getParentMenu(element2) {
    const parentMenuEl = element2.closest('[role="menu"]');
    if (!isHTMLElement(parentMenuEl))
      return null;
    return parentMenuEl;
  }
  __name(getParentMenu, "getParentMenu");
  return {
    elements: {
      trigger: rootTrigger,
      menu: rootMenu,
      overlay,
      item,
      group,
      groupLabel,
      arrow: rootArrow,
      separator
    },
    builders: {
      createCheckboxItem,
      createSubmenu,
      createMenuRadioGroup
    },
    states: {
      open: rootOpen
    },
    helpers: {
      handleTypeaheadSearch
    },
    ids: rootIds,
    options: opts.rootOptions
  };
}
__name(createMenuBuilder, "createMenuBuilder");
function handleTabNavigation(e3, nextFocusable, prevFocusable) {
  if (e3.shiftKey) {
    const $prevFocusable = prevFocusable.get();
    if ($prevFocusable) {
      e3.preventDefault();
      sleep(1).then(() => $prevFocusable.focus());
      prevFocusable.set(null);
    }
  } else {
    const $nextFocusable = nextFocusable.get();
    if ($nextFocusable) {
      e3.preventDefault();
      sleep(1).then(() => $nextFocusable.focus());
      nextFocusable.set(null);
    }
  }
}
__name(handleTabNavigation, "handleTabNavigation");
function getMenuItems(menuElement) {
  return Array.from(menuElement.querySelectorAll(`[data-melt-menu-id="${menuElement.id}"]`)).filter((item) => isHTMLElement(item));
}
__name(getMenuItems, "getMenuItems");
function applyAttrsIfDisabled(element2) {
  if (!element2 || !isElementDisabled(element2))
    return;
  element2.setAttribute("data-disabled", "");
  element2.setAttribute("aria-disabled", "true");
}
__name(applyAttrsIfDisabled, "applyAttrsIfDisabled");
function clearTimerStore(timerStore) {
  if (!isBrowser)
    return;
  const timer = timerStore.get();
  if (timer) {
    window.clearTimeout(timer);
    timerStore.set(null);
  }
}
__name(clearTimerStore, "clearTimerStore");
function isMouse(e3) {
  return e3.pointerType === "mouse";
}
__name(isMouse, "isMouse");
function setMeltMenuAttribute(element2, selector2) {
  if (!element2)
    return;
  const menuEl = element2.closest(`${selector2()}, ${selector2("submenu")}`);
  if (!isHTMLElement(menuEl))
    return;
  element2.setAttribute("data-melt-menu-id", menuEl.id);
}
__name(setMeltMenuAttribute, "setMeltMenuAttribute");
function handleMenuNavigation(e3, loop) {
  e3.preventDefault();
  const currentFocusedItem = document.activeElement;
  const currentTarget = e3.currentTarget;
  if (!isHTMLElement(currentFocusedItem) || !isHTMLElement(currentTarget))
    return;
  const menuItems = getMenuItems(currentTarget);
  if (!menuItems.length)
    return;
  const candidateNodes = menuItems.filter((item) => {
    if (item.hasAttribute("data-disabled") || item.getAttribute("disabled") === "true") {
      return false;
    }
    return true;
  });
  const currentIndex = candidateNodes.indexOf(currentFocusedItem);
  let nextIndex;
  switch (e3.key) {
    case kbd.ARROW_DOWN:
      if (loop) {
        nextIndex = currentIndex < candidateNodes.length - 1 ? currentIndex + 1 : 0;
      } else {
        nextIndex = currentIndex < candidateNodes.length - 1 ? currentIndex + 1 : currentIndex;
      }
      break;
    case kbd.ARROW_UP:
      if (loop) {
        nextIndex = currentIndex > 0 ? currentIndex - 1 : candidateNodes.length - 1;
      } else {
        nextIndex = currentIndex < 0 ? candidateNodes.length - 1 : currentIndex > 0 ? currentIndex - 1 : 0;
      }
      break;
    case kbd.HOME:
      nextIndex = 0;
      break;
    case kbd.END:
      nextIndex = candidateNodes.length - 1;
      break;
    default:
      return;
  }
  handleRovingFocus(candidateNodes[nextIndex]);
}
__name(handleMenuNavigation, "handleMenuNavigation");
function isPointerInGraceArea(e3, area) {
  if (!area)
    return false;
  const cursorPos = { x: e3.clientX, y: e3.clientY };
  return isPointInPolygon(cursorPos, area);
}
__name(isPointerInGraceArea, "isPointerInGraceArea");
function isPointInPolygon(point, polygon) {
  const { x: x2, y: y2 } = point;
  let inside = false;
  for (let i2 = 0, j2 = polygon.length - 1; i2 < polygon.length; j2 = i2++) {
    const xi = polygon[i2].x;
    const yi = polygon[i2].y;
    const xj = polygon[j2].x;
    const yj = polygon[j2].y;
    const intersect2 = yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
    if (intersect2)
      inside = !inside;
  }
  return inside;
}
__name(isPointInPolygon, "isPointInPolygon");
function isFocusWithinSubmenu(submenuId) {
  const activeEl = document.activeElement;
  if (!isHTMLElement(activeEl))
    return false;
  const submenuEl = activeEl.closest(`[data-id="${submenuId}"]`);
  return isHTMLElement(submenuEl);
}
__name(isFocusWithinSubmenu, "isFocusWithinSubmenu");
function stateAttr(open) {
  return open ? "open" : "closed";
}
__name(stateAttr, "stateAttr");
function createDropdownMenu(props) {
  const withDefaults = { ...defaults$1, ...props };
  const rootOptions = toWritableStores(omit(withDefaults, "ids"));
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const rootOpen = overridable(openWritable, withDefaults?.onOpenChange);
  const rootActiveTrigger = withGet(writable(null));
  const nextFocusable = withGet(writable(null));
  const prevFocusable = withGet(writable(null));
  const { elements, builders, ids, states, options: options2 } = createMenuBuilder({
    rootOptions,
    rootOpen,
    rootActiveTrigger: withGet(rootActiveTrigger),
    nextFocusable: withGet(nextFocusable),
    prevFocusable: withGet(prevFocusable),
    selector: "dropdown-menu",
    removeScroll: true,
    ids: withDefaults.ids
  });
  return {
    ids,
    elements,
    states,
    builders,
    options: options2
  };
}
__name(createDropdownMenu, "createDropdownMenu");
function generateId3() {
  return nanoid(10);
}
__name(generateId3, "generateId3");
function getPositioningUpdater(store) {
  return (props = {}) => {
    return updatePositioning$1(store, props);
  };
}
__name(getPositioningUpdater, "getPositioningUpdater");
function updatePositioning$1(store, props) {
  const defaultPositioningProps = {
    side: "bottom",
    align: "center",
    sideOffset: 0,
    alignOffset: 0,
    sameWidth: false,
    avoidCollisions: true,
    collisionPadding: 8,
    fitViewport: false,
    strategy: "absolute",
    overlap: false
  };
  const withDefaults = { ...defaultPositioningProps, ...props };
  store.update((prev2) => {
    return {
      ...prev2,
      placement: joinPlacement(withDefaults.side, withDefaults.align),
      offset: {
        ...prev2.offset,
        mainAxis: withDefaults.sideOffset,
        crossAxis: withDefaults.alignOffset
      },
      gutter: 0,
      sameWidth: withDefaults.sameWidth,
      flip: withDefaults.avoidCollisions,
      overflowPadding: withDefaults.collisionPadding,
      boundary: withDefaults.collisionBoundary,
      fitViewport: withDefaults.fitViewport,
      strategy: withDefaults.strategy,
      overlap: withDefaults.overlap
    };
  });
}
__name(updatePositioning$1, "updatePositioning$1");
function joinPlacement(side, align) {
  if (align === "center")
    return side;
  return `${side}-${align}`;
}
__name(joinPlacement, "joinPlacement");
function getMenuData() {
  const NAME = "menu";
  const SUB_NAME = "menu-submenu";
  const RADIO_GROUP_NAME = "menu-radiogroup";
  const CHECKBOX_ITEM_NAME = "menu-checkboxitem";
  const RADIO_ITEM_NAME = "menu-radioitem";
  const GROUP_NAME = "menu-group";
  const PARTS = [
    "arrow",
    "checkbox-indicator",
    "checkbox-item",
    "content",
    "group",
    "item",
    "label",
    "radio-group",
    "radio-item",
    "radio-indicator",
    "separator",
    "sub-content",
    "sub-trigger",
    "trigger"
  ];
  return {
    NAME,
    SUB_NAME,
    RADIO_GROUP_NAME,
    CHECKBOX_ITEM_NAME,
    RADIO_ITEM_NAME,
    GROUP_NAME,
    PARTS
  };
}
__name(getMenuData, "getMenuData");
function getCtx4() {
  const { NAME } = getMenuData();
  return getContext(NAME);
}
__name(getCtx4, "getCtx4");
function setCtx4(props) {
  const { NAME, PARTS } = getMenuData();
  const getAttrs2 = createBitAttrs("menu", PARTS);
  const dropdownMenu = {
    ...createDropdownMenu({ ...removeUndefined(props), forceVisible: true }),
    getAttrs: getAttrs2
  };
  setContext(NAME, dropdownMenu);
  return {
    ...dropdownMenu,
    updateOption: getOptionUpdater(dropdownMenu.options)
  };
}
__name(setCtx4, "setCtx4");
function setGroupCtx() {
  const { GROUP_NAME } = getMenuData();
  const { elements: { group }, getAttrs: getAttrs2 } = getCtx4();
  const id = generateId3();
  setContext(GROUP_NAME, id);
  return { group, id, getAttrs: getAttrs2 };
}
__name(setGroupCtx, "setGroupCtx");
function updatePositioning(props) {
  const defaultPlacement = {
    side: "bottom",
    align: "center"
  };
  const withDefaults = { ...defaultPlacement, ...props };
  const { options: { positioning } } = getCtx4();
  const updater = getPositioningUpdater(positioning);
  updater(withDefaults);
}
__name(updatePositioning, "updatePositioning");
function Menu_item($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["href", "asChild", "disabled", "el"]);
  push();
  var $$store_subs;
  let builder, attrs;
  let href = fallback($$props["href"], () => void 0, true);
  let asChild = fallback($$props["asChild"], false);
  let disabled = fallback($$props["disabled"], false);
  let el = fallback($$props["el"], () => void 0, true);
  const { elements: { item }, getAttrs: getAttrs2 } = getCtx4();
  builder = store_get($$store_subs ??= {}, "$item", item);
  attrs = {
    ...getAttrs2("item"),
    ...disabledAttrs(disabled)
  };
  Object.assign(builder, attrs);
  if (asChild) {
    $$payload.out += "<!--[-->";
    $$payload.out += `<!---->`;
    slot($$payload, $$props, "default", { builder }, null);
    $$payload.out += `<!---->`;
  } else {
    $$payload.out += "<!--[!-->";
    const $$tag = href ? "a" : "div";
    element(
      $$payload,
      $$tag,
      () => {
        $$payload.out += `${spread_attributes({ href, ...builder, ...$$restProps })}`;
      },
      () => {
        $$payload.out += `<!---->`;
        slot($$payload, $$props, "default", { builder }, null);
        $$payload.out += `<!---->`;
      }
    );
  }
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { href, asChild, disabled, el });
  pop();
}
__name(Menu_item, "Menu_item");
function Menu_group($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["asChild", "el"]);
  push();
  var $$store_subs;
  let builder;
  let asChild = fallback($$props["asChild"], false);
  let el = fallback($$props["el"], () => void 0, true);
  const { group, id, getAttrs: getAttrs2 } = setGroupCtx();
  const attrs = getAttrs2("group");
  builder = store_get($$store_subs ??= {}, "$group", group)(id);
  Object.assign(builder, attrs);
  if (asChild) {
    $$payload.out += "<!--[-->";
    $$payload.out += `<!---->`;
    slot($$payload, $$props, "default", { builder }, null);
    $$payload.out += `<!---->`;
  } else {
    $$payload.out += "<!--[!-->";
    $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!---->`;
    slot($$payload, $$props, "default", { builder }, null);
    $$payload.out += `<!----></div>`;
  }
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { asChild, el });
  pop();
}
__name(Menu_group, "Menu_group");
function Menu($$payload, $$props) {
  push();
  var $$store_subs;
  let closeOnOutsideClick = fallback($$props["closeOnOutsideClick"], () => void 0, true);
  let closeOnEscape = fallback($$props["closeOnEscape"], () => void 0, true);
  let portal = fallback($$props["portal"], () => void 0, true);
  let open = fallback($$props["open"], () => void 0, true);
  let onOpenChange = fallback($$props["onOpenChange"], () => void 0, true);
  let preventScroll2 = fallback($$props["preventScroll"], () => void 0, true);
  let loop = fallback($$props["loop"], () => void 0, true);
  let dir = fallback($$props["dir"], () => void 0, true);
  let typeahead = fallback($$props["typeahead"], () => void 0, true);
  let closeFocus = fallback($$props["closeFocus"], () => void 0, true);
  let disableFocusFirstItem = fallback($$props["disableFocusFirstItem"], () => void 0, true);
  let closeOnItemClick = fallback($$props["closeOnItemClick"], () => void 0, true);
  let onOutsideClick = fallback($$props["onOutsideClick"], () => void 0, true);
  const {
    states: { open: localOpen },
    updateOption,
    ids
  } = setCtx4({
    closeOnOutsideClick,
    closeOnEscape,
    portal,
    forceVisible: true,
    defaultOpen: open,
    preventScroll: preventScroll2,
    loop,
    dir,
    typeahead,
    closeFocus,
    disableFocusFirstItem,
    closeOnItemClick,
    onOutsideClick,
    onOpenChange: ({ next: next2 }) => {
      if (open !== next2) {
        onOpenChange?.(next2);
        open = next2;
      }
      return next2;
    }
  });
  const idValues = derived([ids.menu, ids.trigger], ([$menuId, $triggerId]) => ({ menu: $menuId, trigger: $triggerId }));
  open !== void 0 && localOpen.set(open);
  updateOption("closeOnOutsideClick", closeOnOutsideClick);
  updateOption("closeOnEscape", closeOnEscape);
  updateOption("portal", portal);
  updateOption("preventScroll", preventScroll2);
  updateOption("loop", loop);
  updateOption("dir", dir);
  updateOption("closeFocus", closeFocus);
  updateOption("disableFocusFirstItem", disableFocusFirstItem);
  updateOption("typeahead", typeahead);
  updateOption("closeOnItemClick", closeOnItemClick);
  updateOption("onOutsideClick", onOutsideClick);
  $$payload.out += `<!---->`;
  slot(
    $$payload,
    $$props,
    "default",
    {
      ids: store_get($$store_subs ??= {}, "$idValues", idValues)
    },
    null
  );
  $$payload.out += `<!---->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, {
    closeOnOutsideClick,
    closeOnEscape,
    portal,
    open,
    onOpenChange,
    preventScroll: preventScroll2,
    loop,
    dir,
    typeahead,
    closeFocus,
    disableFocusFirstItem,
    closeOnItemClick,
    onOutsideClick
  });
  pop();
}
__name(Menu, "Menu");
function Menu_content($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "id",
    "side",
    "align",
    "sideOffset",
    "alignOffset",
    "collisionPadding",
    "avoidCollisions",
    "collisionBoundary",
    "sameWidth",
    "fitViewport",
    "strategy",
    "overlap",
    "el"
  ]);
  push();
  var $$store_subs;
  let builder;
  let transition = fallback($$props["transition"], () => void 0, true);
  let transitionConfig = fallback($$props["transitionConfig"], () => void 0, true);
  let inTransition = fallback($$props["inTransition"], () => void 0, true);
  let inTransitionConfig = fallback($$props["inTransitionConfig"], () => void 0, true);
  let outTransition = fallback($$props["outTransition"], () => void 0, true);
  let outTransitionConfig = fallback($$props["outTransitionConfig"], () => void 0, true);
  let asChild = fallback($$props["asChild"], false);
  let id = fallback($$props["id"], () => void 0, true);
  let side = fallback($$props["side"], "bottom");
  let align = fallback($$props["align"], "center");
  let sideOffset = fallback($$props["sideOffset"], 0);
  let alignOffset = fallback($$props["alignOffset"], 0);
  let collisionPadding = fallback($$props["collisionPadding"], 8);
  let avoidCollisions = fallback($$props["avoidCollisions"], true);
  let collisionBoundary = fallback($$props["collisionBoundary"], () => void 0, true);
  let sameWidth = fallback($$props["sameWidth"], false);
  let fitViewport = fallback($$props["fitViewport"], false);
  let strategy = fallback($$props["strategy"], "absolute");
  let overlap = fallback($$props["overlap"], false);
  let el = fallback($$props["el"], () => void 0, true);
  const {
    elements: { menu },
    states: { open },
    ids,
    getAttrs: getAttrs2
  } = getCtx4();
  const attrs = getAttrs2("content");
  if (id) {
    ids.menu.set(id);
  }
  builder = store_get($$store_subs ??= {}, "$menu", menu);
  Object.assign(builder, attrs);
  if (store_get($$store_subs ??= {}, "$open", open)) {
    updatePositioning({
      side,
      align,
      sideOffset,
      alignOffset,
      collisionPadding,
      avoidCollisions,
      collisionBoundary,
      sameWidth,
      fitViewport,
      strategy,
      overlap
    });
  }
  if (asChild && store_get($$store_subs ??= {}, "$open", open)) {
    $$payload.out += "<!--[-->";
    $$payload.out += `<!---->`;
    slot($$payload, $$props, "default", { builder }, null);
    $$payload.out += `<!---->`;
  } else {
    $$payload.out += "<!--[!-->";
    if (transition && store_get($$store_subs ??= {}, "$open", open)) {
      $$payload.out += "<!--[-->";
      $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!---->`;
      slot($$payload, $$props, "default", { builder }, null);
      $$payload.out += `<!----></div>`;
    } else {
      $$payload.out += "<!--[!-->";
      if (inTransition && outTransition && store_get($$store_subs ??= {}, "$open", open)) {
        $$payload.out += "<!--[-->";
        $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!---->`;
        slot($$payload, $$props, "default", { builder }, null);
        $$payload.out += `<!----></div>`;
      } else {
        $$payload.out += "<!--[!-->";
        if (inTransition && store_get($$store_subs ??= {}, "$open", open)) {
          $$payload.out += "<!--[-->";
          $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!---->`;
          slot($$payload, $$props, "default", { builder }, null);
          $$payload.out += `<!----></div>`;
        } else {
          $$payload.out += "<!--[!-->";
          if (outTransition && store_get($$store_subs ??= {}, "$open", open)) {
            $$payload.out += "<!--[-->";
            $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!---->`;
            slot($$payload, $$props, "default", { builder }, null);
            $$payload.out += `<!----></div>`;
          } else {
            $$payload.out += "<!--[!-->";
            if (store_get($$store_subs ??= {}, "$open", open)) {
              $$payload.out += "<!--[-->";
              $$payload.out += `<div${spread_attributes({ ...builder, ...$$restProps })}><!---->`;
              slot($$payload, $$props, "default", { builder }, null);
              $$payload.out += `<!----></div>`;
            } else {
              $$payload.out += "<!--[!-->";
            }
            $$payload.out += `<!--]-->`;
          }
          $$payload.out += `<!--]-->`;
        }
        $$payload.out += `<!--]-->`;
      }
      $$payload.out += `<!--]-->`;
    }
    $$payload.out += `<!--]-->`;
  }
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, {
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    id,
    side,
    align,
    sideOffset,
    alignOffset,
    collisionPadding,
    avoidCollisions,
    collisionBoundary,
    sameWidth,
    fitViewport,
    strategy,
    overlap,
    el
  });
  pop();
}
__name(Menu_content, "Menu_content");
function Menu_trigger($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["asChild", "id", "el"]);
  push();
  var $$store_subs;
  let builder;
  let asChild = fallback($$props["asChild"], false);
  let id = fallback($$props["id"], () => void 0, true);
  let el = fallback($$props["el"], () => void 0, true);
  const { elements: { trigger }, ids, getAttrs: getAttrs2 } = getCtx4();
  const attrs = getAttrs2("trigger");
  if (id) {
    ids.trigger.set(id);
  }
  builder = store_get($$store_subs ??= {}, "$trigger", trigger);
  Object.assign(builder, attrs);
  if (asChild) {
    $$payload.out += "<!--[-->";
    $$payload.out += `<!---->`;
    slot($$payload, $$props, "default", { builder }, null);
    $$payload.out += `<!---->`;
  } else {
    $$payload.out += "<!--[!-->";
    $$payload.out += `<button${spread_attributes({ ...builder, type: "button", ...$$restProps })}><!---->`;
    slot($$payload, $$props, "default", { builder }, null);
    $$payload.out += `<!----></button>`;
  }
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  bind_props($$props, { asChild, id, el });
  pop();
}
__name(Menu_trigger, "Menu_trigger");
function Dropdown_menu_item($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "inset"]);
  push();
  let className = fallback($$props["class"], void 0);
  let inset = fallback($$props["inset"], void 0);
  Menu_item($$payload, spread_props([
    {
      class: cn("data-[highlighted]:bg-accent data-[highlighted]:text-accent-foreground relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50", inset && "pl-8", className)
    },
    $$restProps,
    {
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
  bind_props($$props, { class: className, inset });
  pop();
}
__name(Dropdown_menu_item, "Dropdown_menu_item");
function Dropdown_menu_content($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "class",
    "sideOffset",
    "transition",
    "transitionConfig"
  ]);
  push();
  let className = fallback($$props["class"], void 0);
  let sideOffset = fallback($$props["sideOffset"], 4);
  let transition = fallback($$props["transition"], flyAndScale);
  let transitionConfig = fallback($$props["transitionConfig"], void 0);
  Menu_content($$payload, spread_props([
    {
      transition,
      transitionConfig,
      sideOffset,
      class: cn("bg-popover text-popover-foreground z-50 min-w-[8rem] rounded-md border p-1 shadow-md focus:outline-none", className)
    },
    $$restProps,
    {
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
  bind_props($$props, {
    class: className,
    sideOffset,
    transition,
    transitionConfig
  });
  pop();
}
__name(Dropdown_menu_content, "Dropdown_menu_content");
function _page26($$payload, $$props) {
  let data = $$props["data"];
  const each_array = ensure_array_like({ length: 5 });
  $$payload.out += `<div class="flex items-center justify-between gap-5"><h1 class="text-2xl font-medium">Tournaments</h1> `;
  Root4($$payload, {
    children: ($$payload2) => {
      Trigger2($$payload2, {
        children: ($$payload3) => {
          Filter($$payload3, {});
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!----> `;
      Dropdown_menu_content($$payload2, {
        class: "bg-[#2E2E30] text-white ",
        children: ($$payload3) => {
          Group($$payload3, {
            children: ($$payload4) => {
              Dropdown_menu_item($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Created by me`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Dropdown_menu_item($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Number of players`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Dropdown_menu_item($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->By price`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Dropdown_menu_item($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->By location`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Dropdown_menu_item($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->By type`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!---->`;
            },
            $$slots: { default: true }
          });
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!---->`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!----></div> <div class="my-6 flex w-full items-center justify-between rounded-3xl bg-[#2E2E30] px-4 py-3 text-sm"><p class="h-fit w-fit rounded-2xl bg-blue-600 px-2 py-1 text-white">All</p> <p class="h-fit w-fit rounded-2xl px-2 py-1 text-white">Chess</p> <p class="h-fit w-fit rounded-2xl px-2 py-1 text-white">Uno</p> <p class="h-fit w-fit rounded-2xl px-2 py-1 text-white">Ludo</p> <p class="h-fit w-fit rounded-2xl px-2 py-1 text-white">Rps</p> <p class="h-fit w-fit rounded-2xl px-2 py-1 text-white">Checkers</p></div> <div class="space-y-4"><!--[-->`;
  for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
    each_array[$$index];
    $$payload.out += `<div class="rounded-md border border-[#AFAFAF] p-4"><div class="mb-2 flex justify-between text-sm font-medium"><p>Blitz</p> <p>(#)25,000</p></div> <p class="mb-2 flex items-center gap-5 text-xs text-[#AFAFAF]"><img src="/people.svg" alt=""> <span class="font-medium">2</span></p> <p class="mb-2 flex items-center gap-5 text-xs text-[#AFAFAF]"><img src="/clock.svg" alt=""> <span class="font-medium">5 hours</span></p> <div class="mb-2 flex items-center justify-between text-xs text-[#AFAFAF]"><p class="flex items-center gap-5"><img src="/lock.svg" alt=""> <span class="font-medium">Public</span></p> <p>% users joined</p></div></div>`;
  }
  $$payload.out += `<!--]--></div>`;
  bind_props($$props, { data });
}
__name(_page26, "_page26");
var ignoredKeys;
var defaults$3;
var min;
var max;
var round;
var floor;
var createCoords;
var oppositeSideMap;
var oppositeAlignmentMap;
var computePosition$1;
var arrow$1;
var flip$1;
var offset$1;
var shift$1;
var size$1;
var noOffsets;
var getElementRects;
var platform;
var offset;
var shift;
var flip;
var size;
var arrow;
var computePosition;
var defaultConfig$1;
var ARROW_TRANSFORM;
var defaultConfig;
var usePopper;
var SUB_OPEN_KEYS;
var SUB_CLOSE_KEYS;
var menuIdParts;
var defaults$2;
var defaults$1;
var defaults5;
var createSeparator;
var Root4;
var Trigger2;
var Group;
var init_page_svelte26 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/tournament/_page.svelte.js"() {
    init_index2();
    init_create();
    init_clsx();
    init_updater();
    init_index4();
    init_action();
    init_array2();
    init_index_server();
    init_utils3();
    init_Icon();
    ignoredKeys = /* @__PURE__ */ new Set(["Shift", "Control", "Alt", "Meta", "CapsLock", "NumLock"]);
    defaults$3 = {
      onMatch: handleRovingFocus,
      getCurrentItem: () => document.activeElement
    };
    min = Math.min;
    max = Math.max;
    round = Math.round;
    floor = Math.floor;
    createCoords = /* @__PURE__ */ __name((v2) => ({
      x: v2,
      y: v2
    }), "createCoords");
    oppositeSideMap = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    oppositeAlignmentMap = {
      start: "end",
      end: "start"
    };
    computePosition$1 = /* @__PURE__ */ __name(async (reference, floating, config) => {
      const {
        placement = "bottom",
        strategy = "absolute",
        middleware = [],
        platform: platform2
      } = config;
      const validMiddleware = middleware.filter(Boolean);
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
      let rects = await platform2.getElementRects({
        reference,
        floating,
        strategy
      });
      let {
        x: x2,
        y: y2
      } = computeCoordsFromPlacement(rects, placement, rtl);
      let statefulPlacement = placement;
      let middlewareData = {};
      let resetCount = 0;
      for (let i2 = 0; i2 < validMiddleware.length; i2++) {
        const {
          name: name3,
          fn
        } = validMiddleware[i2];
        const {
          x: nextX,
          y: nextY,
          data,
          reset: reset3
        } = await fn({
          x: x2,
          y: y2,
          initialPlacement: placement,
          placement: statefulPlacement,
          strategy,
          middlewareData,
          rects,
          platform: platform2,
          elements: {
            reference,
            floating
          }
        });
        x2 = nextX != null ? nextX : x2;
        y2 = nextY != null ? nextY : y2;
        middlewareData = {
          ...middlewareData,
          [name3]: {
            ...middlewareData[name3],
            ...data
          }
        };
        if (reset3 && resetCount <= 50) {
          resetCount++;
          if (typeof reset3 === "object") {
            if (reset3.placement) {
              statefulPlacement = reset3.placement;
            }
            if (reset3.rects) {
              rects = reset3.rects === true ? await platform2.getElementRects({
                reference,
                floating,
                strategy
              }) : reset3.rects;
            }
            ({
              x: x2,
              y: y2
            } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
          }
          i2 = -1;
        }
      }
      return {
        x: x2,
        y: y2,
        placement: statefulPlacement,
        strategy,
        middlewareData
      };
    }, "computePosition$1");
    arrow$1 = /* @__PURE__ */ __name((options2) => ({
      name: "arrow",
      options: options2,
      async fn(state) {
        const {
          x: x2,
          y: y2,
          placement,
          rects,
          platform: platform2,
          elements,
          middlewareData
        } = state;
        const {
          element: element2,
          padding = 0
        } = evaluate(options2, state) || {};
        if (element2 == null) {
          return {};
        }
        const paddingObject = getPaddingObject(padding);
        const coords = {
          x: x2,
          y: y2
        };
        const axis = getAlignmentAxis(placement);
        const length = getAxisLength(axis);
        const arrowDimensions = await platform2.getDimensions(element2);
        const isYAxis = axis === "y";
        const minProp = isYAxis ? "top" : "left";
        const maxProp = isYAxis ? "bottom" : "right";
        const clientProp = isYAxis ? "clientHeight" : "clientWidth";
        const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
        const startDiff = coords[axis] - rects.reference[axis];
        const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element2));
        let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
        if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
          clientSize = elements.floating[clientProp] || rects.floating[length];
        }
        const centerToReference = endDiff / 2 - startDiff / 2;
        const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
        const minPadding = min(paddingObject[minProp], largestPossiblePadding);
        const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
        const min$1 = minPadding;
        const max2 = clientSize - arrowDimensions[length] - maxPadding;
        const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
        const offset2 = clamp(min$1, center, max2);
        const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
        const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
        return {
          [axis]: coords[axis] + alignmentOffset,
          data: {
            [axis]: offset2,
            centerOffset: center - offset2 - alignmentOffset,
            ...shouldAddOffset && {
              alignmentOffset
            }
          },
          reset: shouldAddOffset
        };
      }
    }), "arrow$1");
    flip$1 = /* @__PURE__ */ __name(function(options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      return {
        name: "flip",
        options: options2,
        async fn(state) {
          var _middlewareData$arrow, _middlewareData$flip;
          const {
            placement,
            middlewareData,
            rects,
            initialPlacement,
            platform: platform2,
            elements
          } = state;
          const {
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = true,
            fallbackPlacements: specifiedFallbackPlacements,
            fallbackStrategy = "bestFit",
            fallbackAxisSideDirection = "none",
            flipAlignment = true,
            ...detectOverflowOptions
          } = evaluate(options2, state);
          if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
            return {};
          }
          const side = getSide(placement);
          const initialSideAxis = getSideAxis(initialPlacement);
          const isBasePlacement = getSide(initialPlacement) === initialPlacement;
          const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
          const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
          const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
          if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
            fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
          }
          const placements = [initialPlacement, ...fallbackPlacements];
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const overflows = [];
          let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
          if (checkMainAxis) {
            overflows.push(overflow[side]);
          }
          if (checkCrossAxis) {
            const sides = getAlignmentSides(placement, rects, rtl);
            overflows.push(overflow[sides[0]], overflow[sides[1]]);
          }
          overflowsData = [...overflowsData, {
            placement,
            overflows
          }];
          if (!overflows.every((side2) => side2 <= 0)) {
            var _middlewareData$flip2, _overflowsData$filter;
            const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
            const nextPlacement = placements[nextIndex];
            if (nextPlacement) {
              return {
                data: {
                  index: nextIndex,
                  overflows: overflowsData
                },
                reset: {
                  placement: nextPlacement
                }
              };
            }
            let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a2, b) => a2.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
            if (!resetPlacement) {
              switch (fallbackStrategy) {
                case "bestFit": {
                  var _overflowsData$filter2;
                  const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                    if (hasFallbackAxisSideDirection) {
                      const currentSideAxis = getSideAxis(d.placement);
                      return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                      // reading directions favoring greater width.
                      currentSideAxis === "y";
                    }
                    return true;
                  }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b) => a2[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                  if (placement2) {
                    resetPlacement = placement2;
                  }
                  break;
                }
                case "initialPlacement":
                  resetPlacement = initialPlacement;
                  break;
              }
            }
            if (placement !== resetPlacement) {
              return {
                reset: {
                  placement: resetPlacement
                }
              };
            }
          }
          return {};
        }
      };
    }, "flip$1");
    offset$1 = /* @__PURE__ */ __name(function(options2) {
      if (options2 === void 0) {
        options2 = 0;
      }
      return {
        name: "offset",
        options: options2,
        async fn(state) {
          var _middlewareData$offse, _middlewareData$arrow;
          const {
            x: x2,
            y: y2,
            placement,
            middlewareData
          } = state;
          const diffCoords = await convertValueToCoords(state, options2);
          if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
            return {};
          }
          return {
            x: x2 + diffCoords.x,
            y: y2 + diffCoords.y,
            data: {
              ...diffCoords,
              placement
            }
          };
        }
      };
    }, "offset$1");
    shift$1 = /* @__PURE__ */ __name(function(options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      return {
        name: "shift",
        options: options2,
        async fn(state) {
          const {
            x: x2,
            y: y2,
            placement
          } = state;
          const {
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = false,
            limiter = {
              fn: (_ref) => {
                let {
                  x: x22,
                  y: y22
                } = _ref;
                return {
                  x: x22,
                  y: y22
                };
              }
            },
            ...detectOverflowOptions
          } = evaluate(options2, state);
          const coords = {
            x: x2,
            y: y2
          };
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const crossAxis = getSideAxis(getSide(placement));
          const mainAxis = getOppositeAxis(crossAxis);
          let mainAxisCoord = coords[mainAxis];
          let crossAxisCoord = coords[crossAxis];
          if (checkMainAxis) {
            const minSide = mainAxis === "y" ? "top" : "left";
            const maxSide = mainAxis === "y" ? "bottom" : "right";
            const min2 = mainAxisCoord + overflow[minSide];
            const max2 = mainAxisCoord - overflow[maxSide];
            mainAxisCoord = clamp(min2, mainAxisCoord, max2);
          }
          if (checkCrossAxis) {
            const minSide = crossAxis === "y" ? "top" : "left";
            const maxSide = crossAxis === "y" ? "bottom" : "right";
            const min2 = crossAxisCoord + overflow[minSide];
            const max2 = crossAxisCoord - overflow[maxSide];
            crossAxisCoord = clamp(min2, crossAxisCoord, max2);
          }
          const limitedCoords = limiter.fn({
            ...state,
            [mainAxis]: mainAxisCoord,
            [crossAxis]: crossAxisCoord
          });
          return {
            ...limitedCoords,
            data: {
              x: limitedCoords.x - x2,
              y: limitedCoords.y - y2,
              enabled: {
                [mainAxis]: checkMainAxis,
                [crossAxis]: checkCrossAxis
              }
            }
          };
        }
      };
    }, "shift$1");
    size$1 = /* @__PURE__ */ __name(function(options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      return {
        name: "size",
        options: options2,
        async fn(state) {
          var _state$middlewareData, _state$middlewareData2;
          const {
            placement,
            rects,
            platform: platform2,
            elements
          } = state;
          const {
            apply = /* @__PURE__ */ __name(() => {
            }, "apply"),
            ...detectOverflowOptions
          } = evaluate(options2, state);
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const side = getSide(placement);
          const alignment = getAlignment(placement);
          const isYAxis = getSideAxis(placement) === "y";
          const {
            width,
            height
          } = rects.floating;
          let heightSide;
          let widthSide;
          if (side === "top" || side === "bottom") {
            heightSide = side;
            widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
          } else {
            widthSide = side;
            heightSide = alignment === "end" ? "top" : "bottom";
          }
          const maximumClippingHeight = height - overflow.top - overflow.bottom;
          const maximumClippingWidth = width - overflow.left - overflow.right;
          const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
          const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
          const noShift = !state.middlewareData.shift;
          let availableHeight = overflowAvailableHeight;
          let availableWidth = overflowAvailableWidth;
          if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
            availableWidth = maximumClippingWidth;
          }
          if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
            availableHeight = maximumClippingHeight;
          }
          if (noShift && !alignment) {
            const xMin = max(overflow.left, 0);
            const xMax = max(overflow.right, 0);
            const yMin = max(overflow.top, 0);
            const yMax = max(overflow.bottom, 0);
            if (isYAxis) {
              availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
            } else {
              availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
            }
          }
          await apply({
            ...state,
            availableWidth,
            availableHeight
          });
          const nextDimensions = await platform2.getDimensions(elements.floating);
          if (width !== nextDimensions.width || height !== nextDimensions.height) {
            return {
              reset: {
                rects: true
              }
            };
          }
          return {};
        }
      };
    }, "size$1");
    noOffsets = /* @__PURE__ */ createCoords(0);
    getElementRects = /* @__PURE__ */ __name(async function(data) {
      const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
      const getDimensionsFn = this.getDimensions;
      const floatingDimensions = await getDimensionsFn(data.floating);
      return {
        reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
        floating: {
          x: 0,
          y: 0,
          width: floatingDimensions.width,
          height: floatingDimensions.height
        }
      };
    }, "getElementRects");
    platform = {
      convertOffsetParentRelativeRectToViewportRelativeRect,
      getDocumentElement,
      getClippingRect,
      getOffsetParent,
      getElementRects,
      getClientRects,
      getDimensions,
      getScale: getScale2,
      isElement: isElement2,
      isRTL
    };
    offset = offset$1;
    shift = shift$1;
    flip = flip$1;
    size = size$1;
    arrow = arrow$1;
    computePosition = /* @__PURE__ */ __name((reference, floating, options2) => {
      const cache2 = /* @__PURE__ */ new Map();
      const mergedOptions = {
        platform,
        ...options2
      };
      const platformWithCache = {
        ...mergedOptions.platform,
        _c: cache2
      };
      return computePosition$1(reference, floating, {
        ...mergedOptions,
        platform: platformWithCache
      });
    }, "computePosition");
    defaultConfig$1 = {
      strategy: "absolute",
      placement: "top",
      gutter: 5,
      flip: true,
      sameWidth: false,
      overflowPadding: 8
    };
    ARROW_TRANSFORM = {
      bottom: "rotate(45deg)",
      left: "rotate(135deg)",
      top: "rotate(225deg)",
      right: "rotate(315deg)"
    };
    defaultConfig = {
      floating: {},
      focusTrap: {},
      modal: {},
      escapeKeydown: {},
      portal: "body"
    };
    usePopper = /* @__PURE__ */ __name((popperElement, args) => {
      popperElement.dataset.escapee = "";
      const { anchorElement, open, options: options2 } = args;
      if (!anchorElement || !open || !options2) {
        return { destroy: noop2 };
      }
      const opts = { ...defaultConfig, ...options2 };
      const callbacks = [];
      if (opts.portal !== null) {
        callbacks.push(usePortal(popperElement, opts.portal).destroy);
      }
      callbacks.push(useFloating(anchorElement, popperElement, opts.floating).destroy);
      if (opts.focusTrap !== null) {
        const { useFocusTrap } = createFocusTrap2({
          immediate: true,
          escapeDeactivates: false,
          allowOutsideClick: true,
          returnFocusOnDeactivate: false,
          fallbackFocus: popperElement,
          ...opts.focusTrap
        });
        callbacks.push(useFocusTrap(popperElement).destroy);
      }
      if (opts.modal !== null) {
        callbacks.push(useModal(popperElement, {
          onClose: () => {
            if (isHTMLElement(anchorElement)) {
              open.set(false);
              anchorElement.focus();
            }
          },
          shouldCloseOnInteractOutside: (e3) => {
            if (e3.defaultPrevented)
              return false;
            if (isHTMLElement(anchorElement) && anchorElement.contains(e3.target)) {
              return false;
            }
            return true;
          },
          ...opts.modal
        }).destroy);
      }
      if (opts.escapeKeydown !== null) {
        callbacks.push(useEscapeKeydown(popperElement, {
          enabled: open,
          handler: () => {
            open.set(false);
          },
          ...opts.escapeKeydown
        }).destroy);
      }
      const unsubscribe = executeCallbacks(...callbacks);
      return {
        destroy() {
          unsubscribe();
        }
      };
    }, "usePopper");
    SUB_OPEN_KEYS = {
      ltr: [...SELECTION_KEYS, kbd.ARROW_RIGHT],
      rtl: [...SELECTION_KEYS, kbd.ARROW_LEFT]
    };
    SUB_CLOSE_KEYS = {
      ltr: [kbd.ARROW_LEFT],
      rtl: [kbd.ARROW_RIGHT]
    };
    menuIdParts = ["menu", "trigger"];
    defaults$2 = {
      arrowSize: 8,
      positioning: {
        placement: "bottom"
      },
      preventScroll: true,
      closeOnEscape: true,
      closeOnOutsideClick: true,
      portal: void 0,
      loop: false,
      dir: "ltr",
      defaultOpen: false,
      typeahead: true,
      closeOnItemClick: true,
      onOutsideClick: void 0
    };
    defaults$1 = {
      arrowSize: 8,
      positioning: {
        placement: "bottom"
      },
      preventScroll: true,
      closeOnEscape: true,
      closeOnOutsideClick: true,
      portal: void 0,
      loop: false,
      dir: "ltr",
      defaultOpen: false,
      forceVisible: false,
      typeahead: true,
      closeFocus: void 0,
      disableFocusFirstItem: false,
      closeOnItemClick: true,
      onOutsideClick: void 0
    };
    defaults5 = {
      orientation: "horizontal",
      decorative: false
    };
    createSeparator = /* @__PURE__ */ __name((props) => {
      const withDefaults = { ...defaults5, ...props };
      const options2 = toWritableStores(withDefaults);
      const { orientation, decorative } = options2;
      const root2 = makeElement("separator", {
        stores: [orientation, decorative],
        returned: ([$orientation, $decorative]) => {
          const ariaOrientation = $orientation === "vertical" ? $orientation : void 0;
          return {
            role: $decorative ? "none" : "separator",
            "aria-orientation": ariaOrientation,
            "aria-hidden": $decorative,
            "data-orientation": $orientation
          };
        }
      });
      return {
        elements: {
          root: root2
        },
        options: options2
      };
    }, "createSeparator");
    Root4 = Menu;
    Trigger2 = Menu_trigger;
    Group = Menu_group;
  }
});
var __exports30 = {};
__export(__exports30, {
  component: () => component30,
  fonts: () => fonts30,
  imports: () => imports30,
  index: () => index30,
  stylesheets: () => stylesheets30
});
var index30;
var component_cache30;
var component30;
var imports30;
var stylesheets30;
var fonts30;
var init__30 = __esm({
  ".svelte-kit/output/server/nodes/29.js"() {
    index30 = 29;
    component30 = /* @__PURE__ */ __name(async () => component_cache30 ??= (await Promise.resolve().then(() => (init_page_svelte26(), page_svelte_exports26))).default, "component30");
    imports30 = ["_app/immutable/nodes/29.m9lBwdfV.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/props.CdXMhF7y.js", "_app/immutable/chunks/store.CDnLvhlJ.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/create.OoZN6NjL.js", "_app/immutable/chunks/index.bE0HzIKx.js", "_app/immutable/chunks/index-client.bJHR976g.js", "_app/immutable/chunks/if.DLf01pqE.js", "_app/immutable/chunks/slot.BDgc6-mN.js", "_app/immutable/chunks/actions.DVNHJCdf.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/this.CD6iIRB7.js", "_app/immutable/chunks/lifecycle.BX15fcyy.js", "_app/immutable/chunks/updater.MNDcgVG0.js", "_app/immutable/chunks/action._Er3-yw0.js", "_app/immutable/chunks/events.CdlZ0Ps4.js", "_app/immutable/chunks/misc.CXN-D0wo.js", "_app/immutable/chunks/transitions.D2VcR92X.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/utils.B8KE5qsB.js", "_app/immutable/chunks/bundle-mjs.BNYwEHuQ.js", "_app/immutable/chunks/Icon.DWW-WWR4.js", "_app/immutable/chunks/svelte-element.2QoIbCrV.js"];
    stylesheets30 = [];
    fonts30 = [];
  }
});
var page_svelte_exports27 = {};
__export(page_svelte_exports27, {
  default: () => _page27
});
function Trophy($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const iconNode = [
    [
      "path",
      { "d": "M6 9H4.5a2.5 2.5 0 0 1 0-5H6" }
    ],
    [
      "path",
      { "d": "M18 9h1.5a2.5 2.5 0 0 0 0-5H18" }
    ],
    ["path", { "d": "M4 22h16" }],
    [
      "path",
      {
        "d": "M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"
      }
    ],
    [
      "path",
      {
        "d": "M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"
      }
    ],
    [
      "path",
      { "d": "M18 2H6v7a6 6 0 0 0 12 0V2Z" }
    ]
  ];
  Icon($$payload, spread_props([
    { name: "trophy" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2) => {
        $$payload2.out += `<!---->`;
        slot($$payload2, $$props, "default", {}, null);
        $$payload2.out += `<!---->`;
      },
      $$slots: { default: true }
    }
  ]));
}
__name(Trophy, "Trophy");
function Badge($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "href", "variant"]);
  push();
  let className = fallback($$props["class"], void 0);
  let href = fallback($$props["href"], void 0);
  let variant = fallback($$props["variant"], "default");
  const $$tag = href ? "a" : "span";
  element(
    $$payload,
    $$tag,
    () => {
      $$payload.out += `${spread_attributes({
        href,
        class: cn(badgeVariants({ variant, className })),
        ...$$restProps
      })}`;
    },
    () => {
      $$payload.out += `<!---->`;
      slot($$payload, $$props, "default", {}, null);
      $$payload.out += `<!---->`;
    }
  );
  bind_props($$props, { class: className, href, variant });
  pop();
}
__name(Badge, "Badge");
function _page27($$payload, $$props) {
  push();
  let tournamentInfo = {
    gameMode: "15 + 10 Rapid",
    gameDuration: "10 hours",
    gameType: "Private",
    gameMembers: "25 players",
    timeLeft: "09:00:14"
  };
  let timeLeft = tournamentInfo.timeLeft;
  const each_array = ensure_array_like(Object.entries(tournamentInfo));
  $$payload.out += `<h1 class="mb-4 text-center text-2xl font-bold capitalize">Atomic Shield</h1> <div class="mx-auto h-full min-h-[110px] w-full max-w-[354px] rounded-xl bg-blue-500 py-5"><div class="mx-auto w-fit text-center">`;
  Trophy($$payload, { class: "mx-auto" });
  $$payload.out += `<!----> `;
  Badge($$payload, {
    class: "my-2",
    children: ($$payload2) => {
      $$payload2.out += `<!---->Badge`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!----> <h1 class="text-2xl font-bold">(#) 5000</h1></div></div> <div class="rounded-lg bg-black py-6 font-sans text-white"><h2 class="mb-6 font-medium">Tournament Info</h2> <div class="space-y-4"><!--[-->`;
  for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
    let [key2, value] = each_array[$$index];
    $$payload.out += `<div class="flex items-center justify-between"><span class="text-sm">${escape_html(key2.replace(/([A-Z])/g, " $1").replace(/^./, (str) => str.toUpperCase()))}</span> <span class="text-sm font-semibold">${escape_html(key2 === "timeLeft" ? timeLeft : value)}</span></div>`;
  }
  $$payload.out += `<!--]--></div></div> <h2 class="mb-4 mt-10 text-base font-medium">Current Leaderboard</h2> `;
  Table2($$payload, {
    children: ($$payload2) => {
      Table_header($$payload2, {
        children: ($$payload3) => {
          Table_row($$payload3, {
            class: "text-[#C6C6C6]",
            children: ($$payload4) => {
              Table_head($$payload4, {
                class: "w-[100px] text-[#C6C6C6]",
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Player`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Table_head($$payload4, {
                class: "text-[#C6C6C6]",
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Rating`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Table_head($$payload4, {
                class: "text-[#C6C6C6]",
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Win`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Table_head($$payload4, {
                class: "text-[#C6C6C6]",
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Draw`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Table_head($$payload4, {
                class: "text-[#C6C6C6]",
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Lost`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!---->`;
            },
            $$slots: { default: true }
          });
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!----> `;
      Table_body($$payload2, {
        children: ($$payload3) => {
          const each_array_1 = ensure_array_like({ length: 5 });
          $$payload3.out += `<!--[-->`;
          for (let $$index_1 = 0, $$length = each_array_1.length; $$index_1 < $$length; $$index_1++) {
            each_array_1[$$index_1];
            Table_row($$payload3, {
              children: ($$payload4) => {
                Table_cell($$payload4, {
                  class: "flex w-full  items-center gap-1 truncate font-medium",
                  children: ($$payload5) => {
                    $$payload5.out += `<img src="./avatar.png" class="size-10" alt=""> <p class="text-xs font-medium">@Grand_Maestro</p>`;
                  },
                  $$slots: { default: true }
                });
                $$payload4.out += `<!----> `;
                Table_cell($$payload4, {
                  class: "text-sm font-medium text-white",
                  children: ($$payload5) => {
                    $$payload5.out += `<!---->3000`;
                  },
                  $$slots: { default: true }
                });
                $$payload4.out += `<!----> `;
                Table_cell($$payload4, {
                  class: "text-sm font-medium text-green-500",
                  children: ($$payload5) => {
                    $$payload5.out += `<!---->2800`;
                  },
                  $$slots: { default: true }
                });
                $$payload4.out += `<!----> `;
                Table_cell($$payload4, {
                  class: "text-sm font-medium text-white",
                  children: ($$payload5) => {
                    $$payload5.out += `<!---->200`;
                  },
                  $$slots: { default: true }
                });
                $$payload4.out += `<!----> `;
                Table_cell($$payload4, {
                  class: "text-sm font-medium text-red-500",
                  children: ($$payload5) => {
                    $$payload5.out += `<!---->99`;
                  },
                  $$slots: { default: true }
                });
                $$payload4.out += `<!---->`;
              },
              $$slots: { default: true }
            });
          }
          $$payload3.out += `<!--]-->`;
        },
        $$slots: { default: true }
      });
      $$payload2.out += `<!---->`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!---->`;
  pop();
}
__name(_page27, "_page27");
var badgeVariants;
var init_page_svelte27 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/tournament/tournament-history/_page.svelte.js"() {
    init_index2();
    init_dist3();
    init_clsx();
    init_table_row();
    init_Icon();
    init_utils3();
    badgeVariants = ce({
      base: "focus:ring-ring inline-flex select-none items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2",
      variants: {
        variant: {
          default: "bg-primary text-primary-foreground hover:bg-primary/80 border-transparent",
          secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80 border-transparent",
          destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/80 border-transparent",
          outline: "text-foreground"
        }
      },
      defaultVariants: {
        variant: "default"
      }
    });
  }
});
var __exports31 = {};
__export(__exports31, {
  component: () => component31,
  fonts: () => fonts31,
  imports: () => imports31,
  index: () => index31,
  stylesheets: () => stylesheets31
});
var index31;
var component_cache31;
var component31;
var imports31;
var stylesheets31;
var fonts31;
var init__31 = __esm({
  ".svelte-kit/output/server/nodes/30.js"() {
    index31 = 30;
    component31 = /* @__PURE__ */ __name(async () => component_cache31 ??= (await Promise.resolve().then(() => (init_page_svelte27(), page_svelte_exports27))).default, "component31");
    imports31 = ["_app/immutable/nodes/30.Df3xnhGW.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/lifecycle.BX15fcyy.js", "_app/immutable/chunks/index.Bi_aB5ul.js", "_app/immutable/chunks/bundle-mjs.BNYwEHuQ.js", "_app/immutable/chunks/table-row.DtEc1Xxs.js", "_app/immutable/chunks/slot.BDgc6-mN.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js", "_app/immutable/chunks/props.CdXMhF7y.js", "_app/immutable/chunks/store.CDnLvhlJ.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/utils.B8KE5qsB.js", "_app/immutable/chunks/misc.CXN-D0wo.js", "_app/immutable/chunks/Icon.DWW-WWR4.js", "_app/immutable/chunks/svelte-element.2QoIbCrV.js"];
    stylesheets31 = [];
    fonts31 = [];
  }
});
var page_svelte_exports28 = {};
__export(page_svelte_exports28, {
  default: () => _page28
});
function AboutUno($$payload, $$props) {
  let { onclick } = $$props;
  $$payload.out += `<h1 class="mb-10 text-2xl font-medium">Uno</h1> <main class="relative h-screen space-y-6 overflow-auto"><div><h2 class="font-medium capitalize">About Uno</h2> <p class="text-xs">Uno Online\xA0is an exciting puzzle card game. You have to match the cards having the same color
			or number to clear all cards in your hand and block your opponents.</p></div> <div><h2 class="font-medium capitalize">Number Cards</h2> <p class="text-xs">There are a total of 108 cards in this deck. Seventy percent of the deck is made up of number
			cards from 0 to 9, with four colours including blue, green, red, and yellow. Each colour
			features 19 cards with one zero card and two of each other numbers in the deck. Action cards
			and wild cards make up the remaining 30% of the deck.</p></div> <div><h2 class="font-medium capitalize">Action cards</h2> <div class="text-xs">Uno is made more strategic with the addition of action cards. In an Uno deck, there are three
			different sorts of action cards. Each color has two copies of each action card. These are the
			following: <div class="pl-5"><ul class="list-inside list-disc"><li>Skip card - the next player in the sequence misses a turn.</li> <li>Reverse - reverses the direction of play.</li> <li>Draw two - the next player draws two cards and misses one turn.</li></ul></div></div></div> <div><h2 class="font-medium capitalize">Wild cards</h2> <div class="text-xs">There are two different sorts of wild cards, each containing four of them. They are as
			follows: <div class="pl-5"><ul class="list-inside list-disc"><li>Wild - lets the player choose what colour to play..</li> <li>Wild draw 4 - declare the next colour to match, and force the next player to draw four
						cards.</li> <li>Let's play and enjoy tricky Uno matches! Use your own strategies to become the first
						person clearing all cards and win!</li></ul></div></div></div> <div class="fixed bottom-0 left-0 mt-8 w-full border-t border-gray-700 bg-black px-5 py-5">`;
  Button($$payload, {
    onclick,
    class: "w-full rounded-full bg-blue-600 py-3 text-white",
    children: ($$payload2) => {
      $$payload2.out += `<!---->Send invite`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!----></div></main>`;
}
__name(AboutUno, "AboutUno");
function _page28($$payload) {
  let hideAboutUno = false;
  const playOptions = [
    {
      icon: "./circleComputer.svg",
      title: "Play with computer",
      subTitle: "Play against our ever smart AI bots now.",
      href: "play-with-computer"
    },
    {
      icon: "./playWithFriends.svg",
      title: "Play with Friend",
      subTitle: "Create and play your favorite game with a friend now.",
      href: "play-with-friend"
    },
    {
      icon: "./schedule.svg",
      title: "Schedule game",
      subTitle: "Schedule and play your favorite game at a later time.",
      href: "schedule-game"
    },
    {
      icon: "./circleTournament.svg",
      title: "Create tournament",
      subTitle: "Create and play your favourite game with a friend now.",
      href: "create-tournament"
    },
    {
      icon: "./instantPlay.svg",
      title: "Instant play",
      subTitle: "Create and play your favourite game at a later time.",
      href: "instant-play"
    }
  ];
  const each_array = ensure_array_like(playOptions);
  const each_array_1 = ensure_array_like({ length: 5 });
  $$payload.out += `<div${attr("hidden", hideAboutUno, true)} class="fixed left-0 right-0 top-0 z-50 mx-auto h-screen max-w-md overflow-auto bg-background px-2 pt-10">`;
  AboutUno($$payload, { onclick: () => hideAboutUno = true });
  $$payload.out += `<!----></div> <h1 class="mb-10 text-2xl font-medium">Uno</h1> <div class="grid grid-cols-2 gap-3 sm:gap-5"><!--[-->`;
  for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
    let { icon, subTitle, title, href } = each_array[$$index];
    $$payload.out += `<a${attr("href", `/uno/${stringify(href)}`)} class="w-full space-y-1 rounded-md border border-[#6D6D6E] px-3 py-[18px]"><img${attr("src", icon)} alt=""> <p class="text-sm font-semibold">${escape_html(title)}</p> <p class="mt-1 text-[10px] font-light">${escape_html(subTitle)}</p></a>`;
  }
  $$payload.out += `<!--]--></div> <div class="mt-10"><p class="mb-4">Quick pairing</p> <div class="space-y-4"><!--[-->`;
  for (let $$index_1 = 0, $$length = each_array_1.length; $$index_1 < $$length; $$index_1++) {
    each_array_1[$$index_1];
    $$payload.out += `<div class="rounded-md border border-[#AFAFAF] p-4"><div class="mb-2 flex justify-between text-sm font-medium"><p>Uno</p> <p>(#)Free</p></div> <p class="mb-2 flex items-center gap-5 text-xs text-[#AFAFAF]"><img src="/people.svg" alt=""> <span class="font-medium">2</span></p> <p class="mb-2 flex items-center gap-5 text-xs text-[#AFAFAF]"><img src="/clock.svg" alt=""> <span class="font-medium">5 hours</span></p> <div class="mb-2 flex items-center justify-between text-xs text-[#AFAFAF]"><p class="flex items-center gap-5"><img src="/lock.svg" alt=""> <span class="font-medium">Public</span></p> <p>2 users joined</p></div></div>`;
  }
  $$payload.out += `<!--]--></div></div>`;
}
__name(_page28, "_page28");
var init_page_svelte28 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/uno/_page.svelte.js"() {
    init_index2();
    init_index3();
    init_button();
  }
});
var __exports32 = {};
__export(__exports32, {
  component: () => component32,
  fonts: () => fonts32,
  imports: () => imports32,
  index: () => index32,
  stylesheets: () => stylesheets32
});
var index32;
var component_cache32;
var component32;
var imports32;
var stylesheets32;
var fonts32;
var init__32 = __esm({
  ".svelte-kit/output/server/nodes/31.js"() {
    index32 = 31;
    component32 = /* @__PURE__ */ __name(async () => component_cache32 ??= (await Promise.resolve().then(() => (init_page_svelte28(), page_svelte_exports28))).default, "component32");
    imports32 = ["_app/immutable/nodes/31.ChxK7yxZ.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js", "_app/immutable/chunks/index.CplayyMK.js", "_app/immutable/chunks/index.Bi_aB5ul.js", "_app/immutable/chunks/bundle-mjs.BNYwEHuQ.js", "_app/immutable/chunks/create.OoZN6NjL.js", "_app/immutable/chunks/index.bE0HzIKx.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/index-client.bJHR976g.js", "_app/immutable/chunks/button.DQVOpKKk.js", "_app/immutable/chunks/slot.BDgc6-mN.js", "_app/immutable/chunks/lifecycle.BX15fcyy.js", "_app/immutable/chunks/misc.CXN-D0wo.js", "_app/immutable/chunks/props.CdXMhF7y.js", "_app/immutable/chunks/store.CDnLvhlJ.js", "_app/immutable/chunks/if.DLf01pqE.js", "_app/immutable/chunks/svelte-element.2QoIbCrV.js", "_app/immutable/chunks/actions.DVNHJCdf.js", "_app/immutable/chunks/this.CD6iIRB7.js", "_app/immutable/chunks/utils.B8KE5qsB.js"];
    stylesheets32 = [];
    fonts32 = [];
  }
});
var page_svelte_exports29 = {};
__export(page_svelte_exports29, {
  default: () => _page29
});
function _page29($$payload) {
  let index39 = 1;
  head($$payload, ($$payload2) => {
    $$payload2.out += `<link rel="preload" as="image"${attr("href", `/howToPlay-1.svg`)}> <link rel="preload" as="image"${attr("href", `/howToPlay-2.svg`)}> <link rel="preload" as="image"${attr("href", `/howToPlay-3.svg`)}> <link rel="preload" as="image"${attr("href", `/howToPlay-4.svg`)}> <link rel="preload" as="image"${attr("href", `/howToPlay-5.svg`)}> <link rel="preload" as="image"${attr("href", `/howToPlay-6.svg`)}>`;
  });
  $$payload.out += `<div class="relative"><h1 class="mb-10 text-2xl font-medium">How To Play</h1> <!---->`;
  {
    $$payload.out += `<div><img${attr("src", `/howToPlay-${index39}.svg`)} class="w-full" alt=""></div>`;
  }
  $$payload.out += `<!----> <div class="fixed bottom-0 mx-auto mt-8 flex w-full max-w-md items-center gap-5 border-t border-gray-700 bg-black px-5 py-5">`;
  if (index39 === 6) {
    $$payload.out += "<!--[-->";
    Button($$payload, {
      class: "w-full rounded-full bg-blue-600 py-3 text-white",
      children: ($$payload2) => {
        $$payload2.out += `<!---->Start Uno`;
      },
      $$slots: { default: true }
    });
  } else {
    $$payload.out += "<!--[!-->";
    Button($$payload, {
      class: "w-full rounded-full bg-blue-600 py-3 text-white",
      children: ($$payload2) => {
        $$payload2.out += `<!---->Skip tutorial`;
      },
      $$slots: { default: true }
    });
    $$payload.out += `<!----> `;
    Button($$payload, {
      onclick: () => {
        if (index39 === 6)
          return;
        index39++;
      },
      class: "w-full rounded-full bg-background  py-3 text-white hover:bg-background",
      children: ($$payload2) => {
        $$payload2.out += `<!---->Next`;
      },
      $$slots: { default: true }
    });
    $$payload.out += `<!---->`;
  }
  $$payload.out += `<!--]--></div></div>`;
}
__name(_page29, "_page29");
var init_page_svelte29 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/uno/how-to-play/_page.svelte.js"() {
    init_index2();
    init_button();
  }
});
var __exports33 = {};
__export(__exports33, {
  component: () => component33,
  fonts: () => fonts33,
  imports: () => imports33,
  index: () => index33,
  stylesheets: () => stylesheets33
});
var index33;
var component_cache33;
var component33;
var imports33;
var stylesheets33;
var fonts33;
var init__33 = __esm({
  ".svelte-kit/output/server/nodes/32.js"() {
    index33 = 32;
    component33 = /* @__PURE__ */ __name(async () => component_cache33 ??= (await Promise.resolve().then(() => (init_page_svelte29(), page_svelte_exports29))).default, "component33");
    imports33 = ["_app/immutable/nodes/32.Jjnd2Y29.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/if.DLf01pqE.js", "_app/immutable/chunks/key.CCikwZWN.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js", "_app/immutable/chunks/transitions.D2VcR92X.js", "_app/immutable/chunks/button.DQVOpKKk.js", "_app/immutable/chunks/slot.BDgc6-mN.js", "_app/immutable/chunks/lifecycle.BX15fcyy.js", "_app/immutable/chunks/misc.CXN-D0wo.js", "_app/immutable/chunks/props.CdXMhF7y.js", "_app/immutable/chunks/store.CDnLvhlJ.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/create.OoZN6NjL.js", "_app/immutable/chunks/index.bE0HzIKx.js", "_app/immutable/chunks/index-client.bJHR976g.js", "_app/immutable/chunks/svelte-element.2QoIbCrV.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/actions.DVNHJCdf.js", "_app/immutable/chunks/this.CD6iIRB7.js", "_app/immutable/chunks/index.CplayyMK.js", "_app/immutable/chunks/index.Bi_aB5ul.js", "_app/immutable/chunks/bundle-mjs.BNYwEHuQ.js", "_app/immutable/chunks/utils.B8KE5qsB.js", "_app/immutable/chunks/index.CwHq6mbt.js"];
    stylesheets33 = [];
    fonts33 = [];
  }
});
var createTournamentSchema2;
var init_schema2 = __esm({
  ".svelte-kit/output/server/chunks/schema2.js"() {
    init_lib();
    createTournamentSchema2 = z.object({
      timeControl: z.string().min(1)
    });
  }
});
var page_server_ts_exports11 = {};
__export(page_server_ts_exports11, {
  load: () => load9
});
var load9;
var init_page_server_ts11 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/uno/_typeOfPlay_/_page.server.ts.js"() {
    init_client();
    init_zod();
    init_chunks();
    init_superValidate();
    init_schema2();
    load9 = /* @__PURE__ */ __name(async () => {
      const catForm = await superValidate(zod(createTournamentSchema2));
      return {
        catForm
      };
    }, "load9");
  }
});
var page_svelte_exports30 = {};
__export(page_svelte_exports30, {
  default: () => _page30
});
function Cat2($$payload, $$props) {
  push();
  var $$store_subs;
  let { catForm } = $$props;
  const form = superForm(catForm, {
    validators: zodClient(createTournamentSchema2)
  });
  const { enhance: enhance2, delayed, form: formData } = form;
  let $$settled = true;
  let $$inner_payload;
  function $$render_inner($$payload2) {
    $$payload2.out += `<h1 class="mb-10 text-2xl font-medium">Create a Tournament</h1> <form method="POST" class="relative w-full"><!---->`;
    Form_field($$payload2, {
      form,
      name: "timeControl",
      children: ($$payload3) => {
        $$payload3.out += `<!---->`;
        Control($$payload3, {
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload4, { attrs }) => {
              $$payload4.out += `<!---->`;
              Form_label($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Tournament name`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Input($$payload4, spread_props([
                attrs,
                {
                  get value() {
                    return store_get($$store_subs ??= {}, "$formData", formData).timeControl;
                  },
                  set value($$value) {
                    store_mutate($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).timeControl = $$value);
                    $$settled = false;
                  }
                }
              ]));
              $$payload4.out += `<!----> <!---->`;
              Form_description($$payload4, {
                class: "text-xs",
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Kindly pick a safe name for your tournament. An inappropriate name could get your account
				permanently closed.`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!---->`;
            }
          }
        });
        $$payload3.out += `<!----> <!---->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!---->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----> <!---->`;
    Form_field($$payload2, {
      form,
      name: "timeControl",
      children: ($$payload3) => {
        $$payload3.out += `<!---->`;
        Control($$payload3, {
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload4, { attrs }) => {
              $$payload4.out += `<!---->`;
              Form_label($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Tournament type`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Input($$payload4, spread_props([
                attrs,
                {
                  get value() {
                    return store_get($$store_subs ??= {}, "$formData", formData).timeControl;
                  },
                  set value($$value) {
                    store_mutate($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).timeControl = $$value);
                    $$settled = false;
                  }
                }
              ]));
              $$payload4.out += `<!---->`;
            }
          }
        });
        $$payload3.out += `<!----> <!---->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!---->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----> <!---->`;
    Form_field($$payload2, {
      form,
      name: "timeControl",
      children: ($$payload3) => {
        $$payload3.out += `<!---->`;
        Control($$payload3, {
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload4, { attrs }) => {
              $$payload4.out += `<!---->`;
              Form_label($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Tournament fees`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Input($$payload4, spread_props([
                attrs,
                {
                  get value() {
                    return store_get($$store_subs ??= {}, "$formData", formData).timeControl;
                  },
                  set value($$value) {
                    store_mutate($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).timeControl = $$value);
                    $$settled = false;
                  }
                }
              ]));
              $$payload4.out += `<!---->`;
            }
          }
        });
        $$payload3.out += `<!----> <!---->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!---->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----> <!---->`;
    Form_field($$payload2, {
      form,
      name: "timeControl",
      children: ($$payload3) => {
        $$payload3.out += `<!---->`;
        Control($$payload3, {
          children: invalid_default_snippet,
          $$slots: {
            default: ($$payload4, { attrs }) => {
              $$payload4.out += `<!---->`;
              Form_label($$payload4, {
                children: ($$payload5) => {
                  $$payload5.out += `<!---->Tournament fee`;
                },
                $$slots: { default: true }
              });
              $$payload4.out += `<!----> `;
              Input($$payload4, spread_props([
                attrs,
                {
                  get value() {
                    return store_get($$store_subs ??= {}, "$formData", formData).timeControl;
                  },
                  set value($$value) {
                    store_mutate($$store_subs ??= {}, "$formData", formData, store_get($$store_subs ??= {}, "$formData", formData).timeControl = $$value);
                    $$settled = false;
                  }
                }
              ]));
              $$payload4.out += `<!---->`;
            }
          }
        });
        $$payload3.out += `<!----> <!---->`;
        Form_description($$payload3, {
          children: ($$payload4) => {
            $$payload4.out += `<!---->Private tournaments are not free. A fee is compulsory.`;
          },
          $$slots: { default: true }
        });
        $$payload3.out += `<!----> <!---->`;
        Form_field_errors($$payload3, {});
        $$payload3.out += `<!---->`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----> `;
    FundWalletAlert($$payload2);
    $$payload2.out += `<!----> <div class="sticky bottom-0 left-0 mt-8 w-full border-t border-gray-700 bg-black px-5 py-5">`;
    Button($$payload2, {
      href: "play",
      class: "w-full rounded-full bg-blue-600 py-3 text-white",
      children: ($$payload3) => {
        $$payload3.out += `<!---->Create tournament`;
      },
      $$slots: { default: true }
    });
    $$payload2.out += `<!----></div> `;
    TournamentDrawer($$payload2);
    $$payload2.out += `<!----></form>`;
  }
  __name($$render_inner, "$$render_inner");
  do {
    $$settled = true;
    $$inner_payload = copy_payload($$payload);
    $$render_inner($$inner_payload);
  } while (!$$settled);
  assign_payload($$payload, $$inner_payload);
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
__name(Cat2, "Cat2");
function Pwc5($$payload) {
  const each_array = ensure_array_like({ length: 3 });
  $$payload.out += `<h1 class="mb-10 text-2xl font-medium">Select Players</h1> <p class="mb-4 font-medium capitalize">Select Number of Players</p> <div class="w-full space-y-4"><!--[-->`;
  for (let i2 = 0, $$length = each_array.length; i2 < $$length; i2++) {
    each_array[i2];
    $$payload.out += `<a href="how-to-play" class="flex w-full gap-5 rounded-lg border border-[#6D6D6E] px-6 py-5 text-left"><img${attr("src", `/number${stringify(i2 + 2)}.svg`)} alt=""> <div><h2 class="text-sm font-semibold">${escape_html(i2 + 2)} Players</h2> <p class="text-xs text-[#6D6D6E]">Lorem ipsum dolor sit amet consectetur.</p></div></a>`;
  }
  $$payload.out += `<!--]--></div>`;
}
__name(Pwc5, "Pwc5");
function createDeck() {
  const deck = [];
  const colors = ["Red", "Blue", "Green", "Yellow"];
  const values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "Skip", "Reverse", "DrawTwo"];
  for (const color of colors) {
    for (const value of values) {
      deck.push({ color, value });
      if (value !== 0) {
        deck.push({ color, value });
      }
    }
  }
  for (let i2 = 0; i2 < 4; i2++) {
    deck.push({ color: "Wild", value: "Wild" });
    deck.push({ color: "Wild", value: "WildDrawFour" });
  }
  return shuffleDeck(deck);
}
__name(createDeck, "createDeck");
function shuffleDeck(deck) {
  for (let i2 = deck.length - 1; i2 > 0; i2--) {
    const j2 = Math.floor(Math.random() * (i2 + 1));
    [deck[i2], deck[j2]] = [deck[j2], deck[i2]];
  }
  return deck;
}
__name(shuffleDeck, "shuffleDeck");
function Test($$payload, $$props) {
  push();
  ({
    deck: createDeck(),
    discardPile: [createDeck()[0]],
    // Set the discard pile with a non-empty array
    players: [
      {
        id: "player1",
        hand: [createDeck()[1]],
        // Set the player's hand with a non-empty array
        isComputer: false
      },
      {
        id: "player2",
        hand: [createDeck()[2]],
        // Set the player's hand with a non-empty array
        isComputer: true
      },
      {
        id: "player3",
        hand: [createDeck()[3]],
        // Set the player's hand with a non-empty array
        isComputer: true
      }
    ],
    currentPlayerIndex: 0,
    direction: 1,
    winner: "undefined"
    // Set the winner property to undefined
  });
  $$payload.out += `<main><h1>UNO Game</h1> `;
  {
    $$payload.out += "<!--[-->";
    $$payload.out += `<h2>${escape_html("Computer")} won!</h2> <button>New Game</button>`;
  }
  $$payload.out += `<!--]--></main>`;
  pop();
}
__name(Test, "Test");
function _page30($$payload, $$props) {
  push();
  var $$store_subs;
  let { data } = $$props;
  if (store_get($$store_subs ??= {}, "$page", page).params.typeOfPlay === "play-with-computer") {
    $$payload.out += "<!--[-->";
    Pwc5($$payload);
  } else {
    $$payload.out += "<!--[!-->";
    if (store_get($$store_subs ??= {}, "$page", page).params.typeOfPlay === "create-tournament") {
      $$payload.out += "<!--[-->";
      Cat2($$payload, { catForm: data.catForm });
    } else {
      $$payload.out += "<!--[!-->";
      if (store_get($$store_subs ??= {}, "$page", page).params.typeOfPlay === "test") {
        $$payload.out += "<!--[-->";
        Test($$payload);
      } else {
        $$payload.out += "<!--[!-->";
      }
      $$payload.out += `<!--]-->`;
    }
    $$payload.out += `<!--]-->`;
  }
  $$payload.out += `<!--]-->`;
  if ($$store_subs)
    unsubscribe_stores($$store_subs);
  pop();
}
__name(_page30, "_page30");
var init_page_svelte30 = __esm({
  ".svelte-kit/output/server/entries/pages/(app)/uno/_typeOfPlay_/_page.svelte.js"() {
    init_index2();
    init_stores();
    init_TournamentDrawer();
    init_client();
    init_zod();
    init_chunks();
    init_input();
    init_button();
    init_schema2();
  }
});
var __exports34 = {};
__export(__exports34, {
  component: () => component34,
  fonts: () => fonts34,
  imports: () => imports34,
  index: () => index34,
  server: () => page_server_ts_exports11,
  server_id: () => server_id12,
  stylesheets: () => stylesheets34
});
var index34;
var component_cache34;
var component34;
var server_id12;
var imports34;
var stylesheets34;
var fonts34;
var init__34 = __esm({
  ".svelte-kit/output/server/nodes/33.js"() {
    init_page_server_ts11();
    index34 = 33;
    component34 = /* @__PURE__ */ __name(async () => component_cache34 ??= (await Promise.resolve().then(() => (init_page_svelte30(), page_svelte_exports30))).default, "component34");
    server_id12 = "src/routes/(app)/uno/[typeOfPlay]/+page.server.ts";
    imports34 = ["_app/immutable/nodes/33.BgkL5UKI.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/if.DLf01pqE.js", "_app/immutable/chunks/store.CDnLvhlJ.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/stores.DSH2_rmp.js", "_app/immutable/chunks/entry.Zk5XMwWG.js", "_app/immutable/chunks/index-client.bJHR976g.js", "_app/immutable/chunks/index.bE0HzIKx.js", "_app/immutable/chunks/svelte-component.CXtuGKwm.js", "_app/immutable/chunks/actions.DVNHJCdf.js", "_app/immutable/chunks/props.CdXMhF7y.js", "_app/immutable/chunks/TournamentDrawer.lR2hNNEe.js", "_app/immutable/chunks/slot.BDgc6-mN.js", "_app/immutable/chunks/lifecycle.BX15fcyy.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/this.CD6iIRB7.js", "_app/immutable/chunks/utils.B8KE5qsB.js", "_app/immutable/chunks/bundle-mjs.BNYwEHuQ.js", "_app/immutable/chunks/misc.CXN-D0wo.js", "_app/immutable/chunks/create.OoZN6NjL.js", "_app/immutable/chunks/updater.MNDcgVG0.js", "_app/immutable/chunks/events.CdlZ0Ps4.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/class.waVxCJrB.js", "_app/immutable/chunks/action._Er3-yw0.js", "_app/immutable/chunks/index.CplayyMK.js", "_app/immutable/chunks/index.Bi_aB5ul.js", "_app/immutable/chunks/forms.CmnTScIw.js", "_app/immutable/chunks/_commonjsHelpers.CqkleIqs.js", "_app/immutable/chunks/index.AmeJI4DA.js", "_app/immutable/chunks/Icon.DWW-WWR4.js", "_app/immutable/chunks/svelte-element.2QoIbCrV.js", "_app/immutable/chunks/transitions.D2VcR92X.js", "_app/immutable/chunks/avatar-fallback.Dt2LaaM8.js", "_app/immutable/chunks/button.DQVOpKKk.js", "_app/immutable/chunks/input.BuFGoid3.js"];
    stylesheets34 = ["_app/immutable/assets/33.DAsTYMcu.css", "_app/immutable/assets/index.Dr-8sKQJ.css"];
    fonts34 = [];
  }
});
var page_server_ts_exports12 = {};
__export(page_server_ts_exports12, {
  load: () => load10
});
var load10;
var init_page_server_ts12 = __esm({
  ".svelte-kit/output/server/entries/pages/(auth)/login/_page.server.ts.js"() {
    load10 = /* @__PURE__ */ __name(async () => {
      return {};
    }, "load10");
  }
});
var page_svelte_exports31 = {};
__export(page_svelte_exports31, {
  default: () => _page31
});
function Logo($$payload) {
  $$payload.out += `<svg width="223" height="48" viewBox="0 0 223 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0 10.0538C0 7.53883 2.03883 5.5 4.55385 5.5H32.4462C34.9612 5.5 37 7.53883 37 10.0538V37.9462C37 40.4612 34.9612 42.5 32.4462 42.5H4.55385C2.03883 42.5 0 40.4612 0 37.9462V10.0538Z" fill="#204795"></path><path d="M11.9083 32.3392H2.27692V15.1769H11.396C12.7109 15.1769 13.7953 15.3306 14.6492 15.638C15.5201 15.9283 16.169 16.3894 16.5959 17.0212C17.0228 17.636 17.2363 18.4301 17.2363 19.4035C17.2363 20.4793 16.946 21.3332 16.3654 21.965C15.7848 22.5968 14.9053 22.964 13.727 23.0665V23.3995C15.1785 23.4507 16.2544 23.8691 16.9545 24.6546C17.6718 25.4402 18.0304 26.4135 18.0304 27.5748C18.0304 28.5652 17.8084 29.4191 17.3644 30.1363C16.9375 30.8535 16.2715 31.4 15.3664 31.7757C14.4613 32.1514 13.3086 32.3392 11.9083 32.3392ZM7.09262 25.4487V28.0102H11.729C12.1901 28.0102 12.5402 27.9419 12.7792 27.8053C13.0183 27.6687 13.1378 27.3186 13.1378 26.7551C13.1378 26.1745 13.0268 25.8158 12.8048 25.6792C12.5828 25.5255 12.2242 25.4487 11.729 25.4487H7.09262ZM7.09262 19.5059V21.7088H11.1398C11.6351 21.7088 11.9681 21.632 12.1388 21.4783C12.3267 21.3246 12.4206 21.0343 12.4206 20.6074C12.4206 20.1463 12.3096 19.8475 12.0876 19.7108C11.8827 19.5742 11.5326 19.5059 11.0374 19.5059H7.09262Z" fill="#030305"></path><path d="M24.1028 32.3392H19.2871V15.1769H27.9195C29.3711 15.1769 30.5664 15.3818 31.5057 15.7917C32.4449 16.1845 33.1451 16.7736 33.6061 17.5592C34.0672 18.3447 34.2978 19.3095 34.2978 20.4537C34.2978 21.3588 34.1697 22.1443 33.9135 22.8103C33.6574 23.4763 33.239 24.0142 32.6584 24.4241C32.0948 24.8168 31.3264 25.073 30.353 25.1925V25.4231C31.2239 25.6451 31.8728 26.0208 32.2998 26.5502C32.7438 27.0795 33.128 27.7114 33.4524 28.4457L35.2455 32.3392H29.6358L27.9451 28.7787C27.7061 28.2835 27.4841 27.8992 27.2791 27.626C27.0913 27.3357 26.8437 27.1393 26.5363 27.0368C26.246 26.9173 25.8276 26.8575 25.2811 26.8575H24.1028V32.3392ZM24.1028 19.5059V22.8615H27.7402C28.4233 22.8615 28.8844 22.742 29.1234 22.5029C29.3625 22.2638 29.4821 21.8028 29.4821 21.1197C29.4821 20.4878 29.3625 20.0609 29.1234 19.8389C28.8844 19.6169 28.4233 19.5059 27.7402 19.5059H24.1028Z" fill="#030305"></path><path d="M58.152 34H46.12V12.56H57.512C59.1547 12.56 60.5093 12.752 61.576 13.136C62.664 13.4987 63.4747 14.0747 64.008 14.864C64.5413 15.632 64.808 16.624 64.808 17.84C64.808 19.184 64.4453 20.2507 63.72 21.04C62.9947 21.8293 61.896 22.288 60.424 22.416V22.832C62.2373 22.896 63.5813 23.4187 64.456 24.4C65.352 25.3813 65.8 26.5973 65.8 28.048C65.8 29.2853 65.5227 30.352 64.968 31.248C64.4347 32.144 63.6027 32.8267 62.472 33.296C61.3413 33.7653 59.9013 34 58.152 34ZM52.136 25.392V28.592H57.928C58.504 28.592 58.9413 28.5067 59.24 28.336C59.5387 28.1653 59.688 27.728 59.688 27.024C59.688 26.2987 59.5493 25.8507 59.272 25.68C58.9947 25.488 58.5467 25.392 57.928 25.392H52.136ZM52.136 17.968V20.72H57.192C57.8107 20.72 58.2267 20.624 58.44 20.432C58.6747 20.24 58.792 19.8773 58.792 19.344C58.792 18.768 58.6533 18.3947 58.376 18.224C58.12 18.0533 57.6827 17.968 57.064 17.968H52.136ZM75.091 34.32C73.2777 34.32 71.731 33.9787 70.451 33.296C69.171 32.6133 68.1897 31.632 67.507 30.352C66.8457 29.072 66.515 27.5467 66.515 25.776C66.515 23.984 66.8457 22.4587 67.507 21.2C68.1897 19.92 69.171 18.9387 70.451 18.256C71.731 17.5733 73.2777 17.232 75.091 17.232C76.9043 17.232 78.451 17.5733 79.731 18.256C81.011 18.9387 81.9817 19.92 82.643 21.2C83.3257 22.4587 83.667 23.984 83.667 25.776C83.667 27.5467 83.3257 29.072 82.643 30.352C81.9817 31.632 81.011 32.6133 79.731 33.296C78.451 33.9787 76.9043 34.32 75.091 34.32ZM75.091 29.104C76.0937 29.104 76.7763 28.88 77.139 28.432C77.5017 27.9627 77.683 27.0773 77.683 25.776C77.683 24.4533 77.5017 23.568 77.139 23.12C76.7763 22.672 76.0937 22.448 75.091 22.448C74.0883 22.448 73.4057 22.672 73.043 23.12C72.6803 23.568 72.499 24.4533 72.499 25.776C72.499 27.0773 72.6803 27.9627 73.043 28.432C73.4057 28.88 74.0883 29.104 75.091 29.104ZM100.796 34H95.1635V31.504L95.0675 30.48V23.728C95.0675 23.216 94.9288 22.864 94.6515 22.672C94.3955 22.4587 93.8302 22.352 92.9555 22.352C92.0808 22.352 91.4942 22.448 91.1955 22.64C90.9182 22.832 90.7795 23.1733 90.7795 23.664V24.176H85.0515V23.792C85.0515 22.4267 85.3822 21.264 86.0435 20.304C86.7262 19.3227 87.6755 18.5653 88.8915 18.032C90.1075 17.4987 91.5368 17.232 93.1795 17.232C94.8862 17.232 96.2942 17.488 97.4035 18C98.5342 18.512 99.3768 19.28 99.9315 20.304C100.508 21.3067 100.796 22.5867 100.796 24.144V34ZM89.6595 34.32C88.2515 34.32 87.0675 33.9467 86.1075 33.2C85.1475 32.432 84.6675 31.3013 84.6675 29.808C84.6675 28.9547 84.8488 28.2187 85.2115 27.6C85.5955 26.96 86.1608 26.4373 86.9075 26.032C87.6755 25.6267 88.6462 25.328 89.8195 25.136L95.3875 24.24V27.76L91.0675 28.496C90.7475 28.5387 90.5128 28.624 90.3635 28.752C90.2355 28.8587 90.1715 29.0293 90.1715 29.264C90.1715 29.5413 90.2782 29.7333 90.4915 29.84C90.7048 29.9253 91.0888 29.968 91.6435 29.968C92.4755 29.968 93.1368 29.8933 93.6275 29.744C94.1395 29.5733 94.5022 29.3173 94.7155 28.976C94.9502 28.6133 95.0675 28.144 95.0675 27.568L95.5155 32.016H94.8755C94.6408 32.3573 94.3102 32.7093 93.8835 33.072C93.4568 33.4133 92.9022 33.712 92.2195 33.968C91.5368 34.2027 90.6835 34.32 89.6595 34.32ZM108.569 34H102.585V17.552H108.185V22.224L108.569 22.384V34ZM108.569 23.6H107.353V20.048H108.473C108.942 19.2373 109.561 18.5653 110.329 18.032C111.118 17.4987 112.057 17.232 113.145 17.232C114.212 17.232 115.054 17.4453 115.673 17.872C116.292 18.2987 116.74 18.9067 117.017 19.696C117.294 20.4853 117.433 21.424 117.433 22.512V25.488H111.417V23.856C111.417 23.2373 111.332 22.8213 111.161 22.608C110.99 22.3947 110.628 22.288 110.073 22.288C109.582 22.288 109.209 22.3627 108.953 22.512C108.697 22.64 108.569 23.0027 108.569 23.6ZM124.667 34.32C122.598 34.32 120.998 33.5413 119.867 31.984C118.737 30.4267 118.171 28.3573 118.171 25.776C118.171 23.1733 118.726 21.104 119.835 19.568C120.966 18.0107 122.619 17.232 124.795 17.232C125.99 17.232 126.982 17.4667 127.771 17.936C128.561 18.384 129.126 18.9813 129.467 19.728H130.683L130.363 25.168H129.755C129.755 24.4213 129.649 23.856 129.435 23.472C129.243 23.0667 128.945 22.8 128.539 22.672C128.134 22.5227 127.611 22.448 126.971 22.448C126.331 22.448 125.819 22.5227 125.435 22.672C125.073 22.8 124.795 23.0027 124.603 23.28C124.433 23.5573 124.315 23.9093 124.251 24.336C124.187 24.7413 124.155 25.2213 124.155 25.776C124.155 26.3307 124.187 26.8213 124.251 27.248C124.315 27.6533 124.443 27.9947 124.635 28.272C124.827 28.528 125.105 28.7307 125.467 28.88C125.851 29.008 126.353 29.072 126.971 29.072C127.611 29.072 128.134 29.008 128.539 28.88C128.945 28.7307 129.243 28.464 129.435 28.08C129.649 27.6747 129.755 27.0987 129.755 26.352H130.363L130.683 31.76H129.947C129.499 32.528 128.838 33.1467 127.963 33.616C127.089 34.0853 125.99 34.32 124.667 34.32ZM135.739 34H130.139V30.928L129.755 30.512V12.56H135.739V34ZM143.824 34H137.808V12.56H148.592C150.405 12.56 151.898 12.816 153.072 13.328C154.245 13.8187 155.12 14.5547 155.696 15.536C156.272 16.5173 156.56 17.7227 156.56 19.152C156.56 20.2827 156.4 21.264 156.08 22.096C155.76 22.928 155.237 23.6 154.512 24.112C153.808 24.6027 152.848 24.9227 151.632 25.072V25.36C152.72 25.6373 153.53 26.1067 154.064 26.768C154.618 27.4293 155.098 28.2187 155.503 29.136L157.744 34H150.736L148.624 29.552C148.325 28.9333 148.048 28.4533 147.792 28.112C147.557 27.7493 147.248 27.504 146.864 27.376C146.501 27.2267 145.978 27.152 145.296 27.152H143.824V34ZM143.824 17.968V22.16H148.368C149.221 22.16 149.797 22.0107 150.096 21.712C150.394 21.4133 150.544 20.8373 150.544 19.984C150.544 19.1947 150.394 18.6613 150.096 18.384C149.797 18.1067 149.221 17.968 148.368 17.968H143.824ZM166.06 34.32C164.246 34.32 162.7 33.9787 161.42 33.296C160.14 32.6133 159.158 31.632 158.476 30.352C157.814 29.072 157.484 27.5467 157.484 25.776C157.484 23.984 157.814 22.4587 158.476 21.2C159.158 19.92 160.14 18.9387 161.42 18.256C162.7 17.5733 164.246 17.232 166.06 17.232C167.873 17.232 169.42 17.5733 170.7 18.256C171.98 18.9387 172.95 19.92 173.612 21.2C174.294 22.4587 174.636 23.984 174.636 25.776C174.636 27.5467 174.294 29.072 173.612 30.352C172.95 31.632 171.98 32.6133 170.7 33.296C169.42 33.9787 167.873 34.32 166.06 34.32ZM166.06 29.104C167.062 29.104 167.745 28.88 168.108 28.432C168.47 27.9627 168.652 27.0773 168.652 25.776C168.652 24.4533 168.47 23.568 168.108 23.12C167.745 22.672 167.062 22.448 166.06 22.448C165.057 22.448 164.374 22.672 164.012 23.12C163.649 23.568 163.468 24.4533 163.468 25.776C163.468 27.0773 163.649 27.9627 164.012 28.432C164.374 28.88 165.057 29.104 166.06 29.104ZM184.497 34.32C182.684 34.32 181.137 33.9787 179.857 33.296C178.577 32.6133 177.596 31.632 176.913 30.352C176.252 29.072 175.921 27.5467 175.921 25.776C175.921 23.984 176.252 22.4587 176.913 21.2C177.596 19.92 178.577 18.9387 179.857 18.256C181.137 17.5733 182.684 17.232 184.497 17.232C186.311 17.232 187.857 17.5733 189.137 18.256C190.417 18.9387 191.388 19.92 192.049 21.2C192.732 22.4587 193.073 23.984 193.073 25.776C193.073 27.5467 192.732 29.072 192.049 30.352C191.388 31.632 190.417 32.6133 189.137 33.296C187.857 33.9787 186.311 34.32 184.497 34.32ZM184.497 29.104C185.5 29.104 186.183 28.88 186.545 28.432C186.908 27.9627 187.089 27.0773 187.089 25.776C187.089 24.4533 186.908 23.568 186.545 23.12C186.183 22.672 185.5 22.448 184.497 22.448C183.495 22.448 182.812 22.672 182.449 23.12C182.087 23.568 181.905 24.4533 181.905 25.776C181.905 27.0773 182.087 27.9627 182.449 28.432C182.812 28.88 183.495 29.104 184.497 29.104ZM222.045 34H216.029V24.72C216.029 23.8453 215.879 23.2373 215.581 22.896C215.303 22.5547 214.674 22.384 213.693 22.384C212.754 22.384 212.103 22.544 211.741 22.864C211.399 23.1627 211.229 23.7493 211.229 24.624L210.621 24.688L210.269 20.048H210.813C211.197 19.4293 211.645 18.9173 212.157 18.512C212.69 18.0853 213.298 17.7653 213.981 17.552C214.663 17.3387 215.399 17.232 216.189 17.232C217.618 17.232 218.759 17.52 219.613 18.096C220.466 18.6507 221.085 19.408 221.469 20.368C221.853 21.3067 222.045 22.3413 222.045 23.472V34ZM200.413 34H194.429V17.552H200.029V22.064L200.413 22.224V34ZM211.229 34H205.213V24.72C205.213 23.8453 205.063 23.2373 204.765 22.896C204.487 22.5547 203.858 22.384 202.877 22.384C201.938 22.384 201.287 22.544 200.925 22.864C200.583 23.1627 200.413 23.7493 200.413 24.624L199.805 24.688L199.453 20.048H200.317C200.615 19.4293 201.01 18.9173 201.501 18.512C202.013 18.0853 202.599 17.7653 203.261 17.552C203.922 17.3387 204.626 17.232 205.373 17.232C206.802 17.232 207.943 17.52 208.797 18.096C209.65 18.6507 210.269 19.408 210.653 20.368C211.037 21.3067 211.229 22.3413 211.229 23.472V34Z" fill="#3574F5"></path></svg>`;
}
__name(Logo, "Logo");
function _page31($$payload) {
  $$payload.out += `<div class="flex h-screen flex-col justify-between"><div class="mx-auto mb-[200px] mt-[100px] w-fit">`;
  Logo($$payload);
  $$payload.out += `<!----></div> <div class="mb-6 space-y-5"><a href="/api/google" class="relative inline-block w-full rounded-3xl bg-white py-3 text-center font-semibold capitalize text-black"><img src="./google.svg" class="absolute left-5 top-3" alt=""> Sign in with google</a> <button class="relative w-full rounded-3xl bg-[#1877F2] py-3 font-semibold capitalize text-white"><img src="./facebook.svg" class="absolute left-5 top-3" alt=""> Sign in with Facebook</button> <button class="relative w-full rounded-3xl border-2 border-white bg-transparent py-3 font-semibold capitalize text-white"><img src="./apple.svg" class="absolute left-5 top-3" alt=""> Sign in with Apple</button></div> <div class="mb-20 text-center"><p class="mb-10">By continuing, you agree to the Terms and Privacy Policy.</p> <p>Don\u2019t have an account? <span class="text-[#3574F5]">Sign up.</span></p></div></div>`;
}
__name(_page31, "_page31");
var init_page_svelte31 = __esm({
  ".svelte-kit/output/server/entries/pages/(auth)/login/_page.svelte.js"() {
    init_client();
  }
});
var __exports35 = {};
__export(__exports35, {
  component: () => component35,
  fonts: () => fonts35,
  imports: () => imports35,
  index: () => index35,
  server: () => page_server_ts_exports12,
  server_id: () => server_id13,
  stylesheets: () => stylesheets35
});
var index35;
var component_cache35;
var component35;
var server_id13;
var imports35;
var stylesheets35;
var fonts35;
var init__35 = __esm({
  ".svelte-kit/output/server/nodes/34.js"() {
    init_page_server_ts12();
    index35 = 34;
    component35 = /* @__PURE__ */ __name(async () => component_cache35 ??= (await Promise.resolve().then(() => (init_page_svelte31(), page_svelte_exports31))).default, "component35");
    server_id13 = "src/routes/(auth)/login/+page.server.ts";
    imports35 = ["_app/immutable/nodes/34.opC7oCrQ.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/entry.Zk5XMwWG.js", "_app/immutable/chunks/index-client.bJHR976g.js", "_app/immutable/chunks/index.bE0HzIKx.js", "_app/immutable/chunks/utils.DbbyPcj0.js"];
    stylesheets35 = [];
    fonts35 = [];
  }
});
var page_svelte_exports32 = {};
__export(page_svelte_exports32, {
  default: () => _page32
});
function initializeBoard() {
  const initialBoard = [
    [RED, EMPTY, RED, EMPTY, RED, EMPTY, RED, EMPTY],
    [EMPTY, RED, EMPTY, RED, EMPTY, RED, EMPTY, RED],
    [RED, EMPTY, RED, EMPTY, RED, EMPTY, RED, EMPTY],
    [EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY],
    [EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY],
    [EMPTY, BLACK, EMPTY, BLACK, EMPTY, BLACK, EMPTY, BLACK],
    [BLACK, EMPTY, BLACK, EMPTY, BLACK, EMPTY, BLACK, EMPTY],
    [EMPTY, BLACK, EMPTY, BLACK, EMPTY, BLACK, EMPTY, BLACK]
  ];
  const cells = [];
  const pieces = [];
  for (let i2 = 0; i2 < 8; i2++) {
    for (let j2 = 0; j2 < 8; j2++) {
      const state = initialBoard[i2][j2];
      cells.push({ row: i2, col: j2, state });
      if (state !== EMPTY) {
        pieces.push({ row: i2, col: j2, state });
      }
    }
  }
  return { cells, pieces, turn: RED };
}
__name(initializeBoard, "initializeBoard");
function getPieceCount(boardState) {
  return boardState.pieces.reduce(
    (count, piece) => {
      if (Math.abs(piece.state) === RED)
        count.red++;
      if (Math.abs(piece.state) === BLACK)
        count.black++;
      return count;
    },
    { red: 0, black: 0 }
  );
}
__name(getPieceCount, "getPieceCount");
function Board($$payload, $$props) {
  push();
  let board = $$props["board"];
  const each_array = ensure_array_like(board.cells);
  $$payload.out += `<div class="board svelte-wcdi2v"><!--[-->`;
  for (let $$index_1 = 0, $$length = each_array.length; $$index_1 < $$length; $$index_1++) {
    let cell = each_array[$$index_1];
    const each_array_1 = ensure_array_like(board.pieces);
    $$payload.out += `<div${attr("class", `cell svelte-wcdi2v ${stringify([(cell.row + cell.col) % 2 === 1 ? "dark" : ""].filter(Boolean).join(" "))}`)}><!--[-->`;
    for (let $$index = 0, $$length2 = each_array_1.length; $$index < $$length2; $$index++) {
      let piece = each_array_1[$$index];
      if (piece.row === cell.row && piece.col === cell.col) {
        $$payload.out += "<!--[-->";
        $$payload.out += `<div${attr("class", `piece svelte-wcdi2v ${stringify([
          piece.state > 0 ? "red" : "",
          piece.state < 0 ? "black" : "",
          Math.abs(piece.state) > 1 ? "king" : ""
        ].filter(Boolean).join(" "))}`)} draggable="true">${escape_html(Math.abs(piece.state) > 1 ? "K" : "")}</div>`;
      } else {
        $$payload.out += "<!--[!-->";
      }
      $$payload.out += `<!--]-->`;
    }
    $$payload.out += `<!--]--></div>`;
  }
  $$payload.out += `<!--]--></div>`;
  bind_props($$props, { board });
  pop();
}
__name(Board, "Board");
function ScoreBoard($$payload, $$props) {
  push();
  let pieceCount = $$props["pieceCount"];
  let gameOver = $$props["gameOver"];
  $$payload.out += `<div class="scoreboard svelte-1orf2za"><h2 class="svelte-1orf2za">Scoreboard</h2> <div class="scores svelte-1orf2za"><p>Red: ${escape_html(pieceCount.red)}</p> <p>Black: ${escape_html(pieceCount.black)}</p></div> `;
  if (gameOver) {
    $$payload.out += "<!--[-->";
    $$payload.out += `<div class="winner svelte-1orf2za">${escape_html(pieceCount.red > pieceCount.black ? "Red" : "Black")} Wins!</div>`;
  } else {
    $$payload.out += "<!--[!-->";
  }
  $$payload.out += `<!--]--></div>`;
  bind_props($$props, { pieceCount, gameOver });
  pop();
}
__name(ScoreBoard, "ScoreBoard");
function _page32($$payload, $$props) {
  push();
  let currentBoard = initializeBoard();
  let gameOver = false;
  $$payload.out += `<main><div class="game-container svelte-1u93ws7"><div class="controls svelte-1u93ws7"><button class="svelte-1u93ws7">Start New Game</button></div> <div class="game-area svelte-1u93ws7">`;
  Board($$payload, { board: currentBoard });
  $$payload.out += `<!----> `;
  ScoreBoard($$payload, {
    pieceCount: getPieceCount(currentBoard),
    gameOver
  });
  $$payload.out += `<!----></div></div></main>`;
  pop();
}
__name(_page32, "_page32");
var RED;
var BLACK;
var EMPTY;
var init_page_svelte32 = __esm({
  ".svelte-kit/output/server/entries/pages/checkers-text/_page.svelte.js"() {
    init_index2();
    RED = 1;
    BLACK = -1;
    EMPTY = 0;
  }
});
var __exports36 = {};
__export(__exports36, {
  component: () => component36,
  fonts: () => fonts36,
  imports: () => imports36,
  index: () => index36,
  stylesheets: () => stylesheets36
});
var index36;
var component_cache36;
var component36;
var imports36;
var stylesheets36;
var fonts36;
var init__36 = __esm({
  ".svelte-kit/output/server/nodes/35.js"() {
    index36 = 35;
    component36 = /* @__PURE__ */ __name(async () => component_cache36 ??= (await Promise.resolve().then(() => (init_page_svelte32(), page_svelte_exports32))).default, "component36");
    imports36 = ["_app/immutable/nodes/35.BZ5u9CK6.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/lifecycle.BX15fcyy.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/if.DLf01pqE.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/class.waVxCJrB.js", "_app/immutable/chunks/props.CdXMhF7y.js", "_app/immutable/chunks/store.CDnLvhlJ.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/index-client.bJHR976g.js"];
    stylesheets36 = ["_app/immutable/assets/35.CWMpL4vI.css"];
    fonts36 = [];
  }
});
var page_svelte_exports33 = {};
__export(page_svelte_exports33, {
  default: () => _page33
});
function _page33($$payload, $$props) {
  push();
  let currentPositions = {
    P1: [...BASE_POSITIONS.P1],
    P2: [...BASE_POSITIONS.P2]
  };
  let turn = 0;
  let state = STATE.DICE_NOT_ROLLED;
  function getPieceStyle(position) {
    const [x2, y2] = COORDINATES_MAP[position];
    return `top: ${y2 * STEP_LENGTH}%; left: ${x2 * STEP_LENGTH}%;`;
  }
  __name(getPieceStyle, "getPieceStyle");
  const each_array = ensure_array_like(PLAYERS);
  const each_array_2 = ensure_array_like(PLAYERS);
  $$payload.out += `<div class="ludo-container svelte-vltdjz"><div class="ludo svelte-vltdjz"><div class="player-pieces svelte-vltdjz"><!--[-->`;
  for (let $$index_1 = 0, $$length = each_array.length; $$index_1 < $$length; $$index_1++) {
    let player = each_array[$$index_1];
    const each_array_1 = ensure_array_like([0, 1, 2, 3]);
    $$payload.out += `<!--[-->`;
    for (let $$index = 0, $$length2 = each_array_1.length; $$index < $$length2; $$index++) {
      let piece = each_array_1[$$index];
      $$payload.out += `<div${attr("class", `player-piece svelte-vltdjz ${stringify([
        ""
      ].filter(Boolean).join(" "))}`)}${attr("style", getPieceStyle(currentPositions[player][piece]))}${attr("data-player-id", player)}${attr("data-piece", piece)}></div>`;
    }
    $$payload.out += `<!--]-->`;
  }
  $$payload.out += `<!--]--></div> <div class="player-bases svelte-vltdjz"><!--[-->`;
  for (let $$index_2 = 0, $$length = each_array_2.length; $$index_2 < $$length; $$index_2++) {
    let player = each_array_2[$$index_2];
    $$payload.out += `<div${attr("class", `player-base svelte-vltdjz ${stringify([player === PLAYERS[turn] ? "highlight" : ""].filter(Boolean).join(" "))}`)}${attr("data-player-id", player)}></div>`;
  }
  $$payload.out += `<!--]--></div></div> <div class="footer svelte-vltdjz"><div class="row svelte-vltdjz"><button class="btn btn-dice svelte-vltdjz"${attr("disabled", state !== STATE.DICE_NOT_ROLLED, true)}>Roll</button> <div class="dice-value svelte-vltdjz">${escape_html("")}</div> <button class="btn btn-reset svelte-vltdjz">Reset</button></div> <h2 class="active-player svelte-vltdjz">Active Player: <span class="svelte-vltdjz">${escape_html(PLAYERS[turn])}</span></h2></div></div>`;
  pop();
}
__name(_page33, "_page33");
var COORDINATES_MAP;
var STEP_LENGTH;
var PLAYERS;
var BASE_POSITIONS;
var STATE;
var init_page_svelte33 = __esm({
  ".svelte-kit/output/server/entries/pages/ludo-test/_page.svelte.js"() {
    init_index2();
    COORDINATES_MAP = {
      0: [6, 13],
      1: [6, 12],
      2: [6, 11],
      3: [6, 10],
      4: [6, 9],
      5: [5, 8],
      6: [4, 8],
      7: [3, 8],
      8: [2, 8],
      9: [1, 8],
      10: [0, 8],
      11: [0, 7],
      12: [0, 6],
      13: [1, 6],
      14: [2, 6],
      15: [3, 6],
      16: [4, 6],
      17: [5, 6],
      18: [6, 5],
      19: [6, 4],
      20: [6, 3],
      21: [6, 2],
      22: [6, 1],
      23: [6, 0],
      24: [7, 0],
      25: [8, 0],
      26: [8, 1],
      27: [8, 2],
      28: [8, 3],
      29: [8, 4],
      30: [8, 5],
      31: [9, 6],
      32: [10, 6],
      33: [11, 6],
      34: [12, 6],
      35: [13, 6],
      36: [14, 6],
      37: [14, 7],
      38: [14, 8],
      39: [13, 8],
      40: [12, 8],
      41: [11, 8],
      42: [10, 8],
      43: [9, 8],
      44: [8, 9],
      45: [8, 10],
      46: [8, 11],
      47: [8, 12],
      48: [8, 13],
      49: [8, 14],
      50: [7, 14],
      51: [6, 14],
      // HOME ENTRANCE
      // P1
      100: [7, 13],
      101: [7, 12],
      102: [7, 11],
      103: [7, 10],
      104: [7, 9],
      105: [7, 8],
      // P2
      200: [7, 1],
      201: [7, 2],
      202: [7, 3],
      203: [7, 4],
      204: [7, 5],
      205: [7, 6],
      // BASE POSITIONS
      // P1
      500: [1.5, 10.58],
      501: [3.57, 10.58],
      502: [1.5, 12.43],
      503: [3.57, 12.43],
      // P2
      600: [10.5, 1.58],
      601: [12.54, 1.58],
      602: [10.5, 3.45],
      603: [12.54, 3.45]
    };
    STEP_LENGTH = 6.66;
    PLAYERS = ["P1", "P2"];
    BASE_POSITIONS = {
      P1: [500, 501, 502, 503],
      P2: [600, 601, 602, 603]
    };
    STATE = {
      DICE_NOT_ROLLED: "DICE_NOT_ROLLED",
      DICE_ROLLED: "DICE_ROLLED"
    };
  }
});
var __exports37 = {};
__export(__exports37, {
  component: () => component37,
  fonts: () => fonts37,
  imports: () => imports37,
  index: () => index37,
  stylesheets: () => stylesheets37
});
var index37;
var component_cache37;
var component37;
var imports37;
var stylesheets37;
var fonts37;
var init__37 = __esm({
  ".svelte-kit/output/server/nodes/36.js"() {
    index37 = 36;
    component37 = /* @__PURE__ */ __name(async () => component_cache37 ??= (await Promise.resolve().then(() => (init_page_svelte33(), page_svelte_exports33))).default, "component37");
    imports37 = ["_app/immutable/nodes/36.C4qI7QKI.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js", "_app/immutable/chunks/class.waVxCJrB.js", "_app/immutable/chunks/lifecycle.BX15fcyy.js"];
    stylesheets37 = ["_app/immutable/assets/36.AKpP4IS-.css"];
    fonts37 = [];
  }
});
var page_svelte_exports34 = {};
__export(page_svelte_exports34, {
  default: () => _page34
});
function _page34($$payload, $$props) {
  push();
  let colors = ["red", "blue", "green", "yellow"];
  let values = [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "Skip",
    "Reverse",
    "Draw Two",
    "Wild",
    "Wild Draw Four"
  ];
  let deck = [];
  let playerHand = [];
  let computerHand = [];
  let currentCard = null;
  let currentPlayer = "player";
  let currentColor = null;
  let message = "";
  let showColorChooser = false;
  function createDeck2() {
    deck = [];
    for (let color of colors) {
      for (let value of values) {
        if (value === "Wild" || value === "Wild Draw Four") {
          deck.push({ color: "wild", value });
        } else {
          deck.push({ color, value });
        }
      }
    }
  }
  __name(createDeck2, "createDeck2");
  function shuffleDeck2() {
    for (let i2 = deck.length - 1; i2 > 0; i2--) {
      const j2 = Math.floor(Math.random() * (i2 + 1));
      [deck[i2], deck[j2]] = [deck[j2], deck[i2]];
    }
  }
  __name(shuffleDeck2, "shuffleDeck2");
  function dealInitialHands() {
    playerHand = [];
    computerHand = [];
    for (let i2 = 0; i2 < 7; i2++) {
      playerHand.push(deck.pop());
      computerHand.push(deck.pop());
    }
  }
  __name(dealInitialHands, "dealInitialHands");
  function getRandomNumber() {
    const numbers = [1e3, 2e3, 3e3];
    return numbers[Math.floor(Math.random() * numbers.length)];
  }
  __name(getRandomNumber, "getRandomNumber");
  function playCard(card) {
    if (currentPlayer !== "player")
      return;
    const randomNumber = getRandomNumber();
    if (card.color === "wild" || card.color === currentColor || card.value === currentCard?.value) {
      currentCard = card;
      currentColor = card.color === "wild" ? currentColor : card.color;
      playerHand = playerHand.filter((c2) => c2 !== card);
      if (card.color === "wild") {
        showColorChooser = true;
      } else {
        applyCardEffect(card);
        checkWinCondition("player");
        if (playerHand.length > 0 && currentPlayer === "computer") {
          setTimeout(computerTurn, randomNumber);
        }
      }
    } else {
      message = "Invalid move!";
    }
  }
  __name(playCard, "playCard");
  function chooseColor(color) {
    currentColor = color;
    showColorChooser = false;
    if (currentCard) {
      currentCard.color = currentColor;
      applyCardEffect(currentCard);
    }
    checkWinCondition("player");
    if (playerHand.length > 0 && currentPlayer === "computer") {
      setTimeout(computerTurn, 1e3);
    }
  }
  __name(chooseColor, "chooseColor");
  function applyCardEffect(card) {
    switch (card.value) {
      case "Skip":
      case "Reverse":
        break;
      case "Draw Two":
        if (currentPlayer === "player") {
          drawCards(computerHand, 2);
        } else {
          drawCards(playerHand, 2);
        }
        break;
      case "Wild Draw Four":
        if (currentPlayer === "player") {
          drawCards(computerHand, 4);
        } else {
          drawCards(playerHand, 4);
        }
        break;
      default:
        currentPlayer = currentPlayer === "player" ? "computer" : "player";
    }
  }
  __name(applyCardEffect, "applyCardEffect");
  function drawCards(hand, count) {
    for (let i2 = 0; i2 < count; i2++) {
      if (deck.length > 0) {
        hand.push(deck.pop());
      } else {
        reshuffleDeck();
        if (deck.length > 0) {
          hand.push(deck.pop());
        } else {
          message = "No more cards in the deck!";
          break;
        }
      }
    }
  }
  __name(drawCards, "drawCards");
  function reshuffleDeck() {
    let discardPile = deck.splice(0, deck.length);
    deck = discardPile.concat(deck);
    shuffleDeck2();
  }
  __name(reshuffleDeck, "reshuffleDeck");
  function drawCard() {
    if (currentPlayer !== "player")
      return;
    if (deck.length > 0) {
      const drawnCard = deck.pop();
      playerHand = [...playerHand, drawnCard];
      if (drawnCard.color === currentColor || drawnCard.value === currentCard?.value || drawnCard.color === "wild") {
        playCard(drawnCard);
      } else {
        currentPlayer = "computer";
        setTimeout(computerTurn, 1e3);
      }
    } else {
      reshuffleDeck();
      if (deck.length > 0) {
        drawCard();
      } else {
        message = "No more cards in the deck!";
      }
    }
  }
  __name(drawCard, "drawCard");
  function computerTurn() {
    let playableCards = computerHand.filter((card) => card.color === "wild" || card.color === currentColor || card.value === currentCard?.value);
    if (playableCards.length > 0) {
      let selectedCard = playableCards[Math.floor(Math.random() * playableCards.length)];
      if (selectedCard.color === currentColor) {
        selectedCard = playableCards.find((card) => card.color === currentColor);
      } else if (selectedCard.value === currentCard?.value) {
        selectedCard = playableCards.find((card) => card.value === currentCard?.value);
      }
      currentCard = selectedCard;
      currentColor = selectedCard.color === "wild" ? colors[Math.floor(Math.random() * colors.length)] : selectedCard.color;
      computerHand = computerHand.filter((c2) => c2 !== selectedCard);
      applyCardEffect(selectedCard);
      checkWinCondition("computer");
      if (currentPlayer === "computer") {
        setTimeout(computerTurn, 1e3);
      }
    } else {
      drawCards(computerHand, 1);
      currentPlayer = "player";
    }
  }
  __name(computerTurn, "computerTurn");
  function checkWinCondition(player) {
    if (player === "player" && playerHand.length === 0) {
      message = "Congratulations! You win!";
      setTimeout(initializeGame, 2e3);
    } else if (player === "computer" && computerHand.length === 0) {
      message = "Computer wins! Better luck next time.";
      setTimeout(initializeGame, 2e3);
    }
  }
  __name(checkWinCondition, "checkWinCondition");
  function initializeGame() {
    createDeck2();
    shuffleDeck2();
    dealInitialHands();
    currentCard = deck.pop();
    while (currentCard.color === "wild") {
      deck.push(currentCard);
      shuffleDeck2();
      currentCard = deck.pop();
    }
    currentColor = currentCard.color;
    currentPlayer = "player";
    message = "";
    showColorChooser = false;
  }
  __name(initializeGame, "initializeGame");
  const each_array = ensure_array_like(computerHand);
  const each_array_1 = ensure_array_like(playerHand);
  $$payload.out += `<main class="svelte-u3apel"><h1>UNO Game with Computer Opponent</h1> <div class="computer-hand svelte-u3apel"><!--[-->`;
  for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
    each_array[$$index];
    $$payload.out += `<div class="card computer-card svelte-u3apel">UNO</div>`;
  }
  $$payload.out += `<!--]--></div> <div class="current-card">`;
  if (currentCard) {
    $$payload.out += "<!--[-->";
    $$payload.out += `<div${attr("class", `card ${stringify(currentCard.color)} svelte-u3apel`)}>${escape_html(currentCard.value)}</div>`;
  } else {
    $$payload.out += "<!--[!-->";
  }
  $$payload.out += `<!--]--></div> <div class="player-hand svelte-u3apel"><!--[-->`;
  for (let $$index_1 = 0, $$length = each_array_1.length; $$index_1 < $$length; $$index_1++) {
    let card = each_array_1[$$index_1];
    $$payload.out += `<button${attr("class", `card ${stringify(card.color)} svelte-u3apel`)}>${escape_html(card.value)}</button>`;
  }
  $$payload.out += `<!--]--></div> `;
  Button($$payload, {
    onclick: drawCard,
    children: ($$payload2) => {
      $$payload2.out += `<!---->Draw Card`;
    },
    $$slots: { default: true }
  });
  $$payload.out += `<!----> `;
  if (showColorChooser) {
    $$payload.out += "<!--[-->";
    const each_array_2 = ensure_array_like(colors);
    $$payload.out += `<div class="color-chooser svelte-u3apel"><!--[-->`;
    for (let $$index_2 = 0, $$length = each_array_2.length; $$index_2 < $$length; $$index_2++) {
      let color = each_array_2[$$index_2];
      Button($$payload, {
        class: color,
        onclick: () => chooseColor(color),
        children: ($$payload2) => {
          $$payload2.out += `<!---->${escape_html(color)}`;
        },
        $$slots: { default: true }
      });
    }
    $$payload.out += `<!--]--></div>`;
  } else {
    $$payload.out += "<!--[!-->";
  }
  $$payload.out += `<!--]--> `;
  if (message) {
    $$payload.out += "<!--[-->";
    $$payload.out += `<p class="message text-red-500 svelte-u3apel">${escape_html(message)}</p>`;
  } else {
    $$payload.out += "<!--[!-->";
  }
  $$payload.out += `<!--]--></main>`;
  pop();
}
__name(_page34, "_page34");
var init_page_svelte34 = __esm({
  ".svelte-kit/output/server/entries/pages/uno-test/_page.svelte.js"() {
    init_index2();
    init_button();
  }
});
var __exports38 = {};
__export(__exports38, {
  component: () => component38,
  fonts: () => fonts38,
  imports: () => imports38,
  index: () => index38,
  stylesheets: () => stylesheets38
});
var index38;
var component_cache38;
var component38;
var imports38;
var stylesheets38;
var fonts38;
var init__38 = __esm({
  ".svelte-kit/output/server/nodes/37.js"() {
    index38 = 37;
    component38 = /* @__PURE__ */ __name(async () => component_cache38 ??= (await Promise.resolve().then(() => (init_page_svelte34(), page_svelte_exports34))).default, "component38");
    imports38 = ["_app/immutable/nodes/37.B3HtMJiD.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/if.DLf01pqE.js", "_app/immutable/chunks/each.BsZK1HXx.js", "_app/immutable/chunks/class.waVxCJrB.js", "_app/immutable/chunks/props.CdXMhF7y.js", "_app/immutable/chunks/store.CDnLvhlJ.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/index-client.bJHR976g.js", "_app/immutable/chunks/button.DQVOpKKk.js", "_app/immutable/chunks/slot.BDgc6-mN.js", "_app/immutable/chunks/lifecycle.BX15fcyy.js", "_app/immutable/chunks/misc.CXN-D0wo.js", "_app/immutable/chunks/create.OoZN6NjL.js", "_app/immutable/chunks/index.bE0HzIKx.js", "_app/immutable/chunks/svelte-element.2QoIbCrV.js", "_app/immutable/chunks/actions.DVNHJCdf.js", "_app/immutable/chunks/attributes.Bw0m-Wyd.js", "_app/immutable/chunks/this.CD6iIRB7.js", "_app/immutable/chunks/index.CplayyMK.js", "_app/immutable/chunks/index.Bi_aB5ul.js", "_app/immutable/chunks/bundle-mjs.BNYwEHuQ.js", "_app/immutable/chunks/utils.B8KE5qsB.js"];
    stylesheets38 = ["_app/immutable/assets/37.D3UwVf7R.css"];
    fonts38 = [];
  }
});
var server_ts_exports = {};
var init_server_ts = __esm({
  ".svelte-kit/output/server/entries/endpoints/api/create-game/_server.ts.js"() {
  }
});
var init_hex2 = __esm({
  "node_modules/.pnpm/@oslojs+encoding@0.4.1/node_modules/@oslojs/encoding/dist/hex.js"() {
  }
});
var EncodingPadding3;
var DecodingPadding3;
var init_base322 = __esm({
  "node_modules/.pnpm/@oslojs+encoding@0.4.1/node_modules/@oslojs/encoding/dist/base32.js"() {
    (function(EncodingPadding5) {
      EncodingPadding5[EncodingPadding5["Include"] = 0] = "Include";
      EncodingPadding5[EncodingPadding5["None"] = 1] = "None";
    })(EncodingPadding3 || (EncodingPadding3 = {}));
    (function(DecodingPadding5) {
      DecodingPadding5[DecodingPadding5["Required"] = 0] = "Required";
      DecodingPadding5[DecodingPadding5["Ignore"] = 1] = "Ignore";
    })(DecodingPadding3 || (DecodingPadding3 = {}));
  }
});
function encodeBase64urlNoPadding2(bytes) {
  return encodeBase64_internal(bytes, base64urlAlphabet, EncodingPadding4.None);
}
__name(encodeBase64urlNoPadding2, "encodeBase64urlNoPadding2");
function encodeBase64_internal(bytes, alphabet, padding) {
  let result = "";
  for (let i2 = 0; i2 < bytes.byteLength; i2 += 3) {
    let buffer = 0;
    let bufferBitSize = 0;
    for (let j2 = 0; j2 < 3 && i2 + j2 < bytes.byteLength; j2++) {
      buffer = buffer << 8 | bytes[i2 + j2];
      bufferBitSize += 8;
    }
    for (let j2 = 0; j2 < 4; j2++) {
      if (bufferBitSize >= 6) {
        result += alphabet[buffer >> bufferBitSize - 6 & 63];
        bufferBitSize -= 6;
      } else if (bufferBitSize > 0) {
        result += alphabet[buffer << 6 - bufferBitSize & 63];
        bufferBitSize = 0;
      } else if (padding === EncodingPadding4.Include) {
        result += "=";
      }
    }
  }
  return result;
}
__name(encodeBase64_internal, "encodeBase64_internal");
function decodeBase64urlIgnorePadding2(encoded) {
  return decodeBase64_internal(encoded, base64urlDecodeMap, DecodingPadding4.Ignore);
}
__name(decodeBase64urlIgnorePadding2, "decodeBase64urlIgnorePadding2");
function decodeBase64_internal(encoded, decodeMap, padding) {
  const result = new Uint8Array(Math.ceil(encoded.length / 4) * 3);
  let totalBytes = 0;
  for (let i2 = 0; i2 < encoded.length; i2 += 4) {
    let chunk = 0;
    let bitsRead = 0;
    for (let j2 = 0; j2 < 4; j2++) {
      if (padding === DecodingPadding4.Required && encoded[i2 + j2] === "=") {
        continue;
      }
      if (padding === DecodingPadding4.Ignore && (i2 + j2 >= encoded.length || encoded[i2 + j2] === "=")) {
        continue;
      }
      if (j2 > 0 && encoded[i2 + j2 - 1] === "=") {
        throw new Error("Invalid padding");
      }
      if (!(encoded[i2 + j2] in decodeMap)) {
        throw new Error("Invalid character");
      }
      chunk |= decodeMap[encoded[i2 + j2]] << (3 - j2) * 6;
      bitsRead += 6;
    }
    if (bitsRead < 24) {
      let unused;
      if (bitsRead === 12) {
        unused = chunk & 65535;
      } else if (bitsRead === 18) {
        unused = chunk & 255;
      } else {
        throw new Error("Invalid padding");
      }
      if (unused !== 0) {
        throw new Error("Invalid padding");
      }
    }
    const byteLength = Math.floor(bitsRead / 8);
    for (let i3 = 0; i3 < byteLength; i3++) {
      result[totalBytes] = chunk >> 16 - i3 * 8 & 255;
      totalBytes++;
    }
  }
  return result.slice(0, totalBytes);
}
__name(decodeBase64_internal, "decodeBase64_internal");
var base64urlAlphabet;
var EncodingPadding4;
var DecodingPadding4;
var base64urlDecodeMap;
var init_base642 = __esm({
  "node_modules/.pnpm/@oslojs+encoding@0.4.1/node_modules/@oslojs/encoding/dist/base64.js"() {
    base64urlAlphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
    (function(EncodingPadding5) {
      EncodingPadding5[EncodingPadding5["Include"] = 0] = "Include";
      EncodingPadding5[EncodingPadding5["None"] = 1] = "None";
    })(EncodingPadding4 || (EncodingPadding4 = {}));
    (function(DecodingPadding5) {
      DecodingPadding5[DecodingPadding5["Required"] = 0] = "Required";
      DecodingPadding5[DecodingPadding5["Ignore"] = 1] = "Ignore";
    })(DecodingPadding4 || (DecodingPadding4 = {}));
    base64urlDecodeMap = {
      "0": 52,
      "1": 53,
      "2": 54,
      "3": 55,
      "4": 56,
      "5": 57,
      "6": 58,
      "7": 59,
      "8": 60,
      "9": 61,
      A: 0,
      B: 1,
      C: 2,
      D: 3,
      E: 4,
      F: 5,
      G: 6,
      H: 7,
      I: 8,
      J: 9,
      K: 10,
      L: 11,
      M: 12,
      N: 13,
      O: 14,
      P: 15,
      Q: 16,
      R: 17,
      S: 18,
      T: 19,
      U: 20,
      V: 21,
      W: 22,
      X: 23,
      Y: 24,
      Z: 25,
      a: 26,
      b: 27,
      c: 28,
      d: 29,
      e: 30,
      f: 31,
      g: 32,
      h: 33,
      i: 34,
      j: 35,
      k: 36,
      l: 37,
      m: 38,
      n: 39,
      o: 40,
      p: 41,
      q: 42,
      r: 43,
      s: 44,
      t: 45,
      u: 46,
      v: 47,
      w: 48,
      x: 49,
      y: 50,
      z: 51,
      "-": 62,
      _: 63
    };
  }
});
var init_dist4 = __esm({
  "node_modules/.pnpm/@oslojs+encoding@0.4.1/node_modules/@oslojs/encoding/dist/index.js"() {
    init_hex2();
    init_base322();
    init_base642();
  }
});
var BigEndian2;
var LittleEndian2;
var bigEndian2;
var littleEndian2;
var init_uint2 = __esm({
  "node_modules/.pnpm/@oslojs+binary@0.2.3/node_modules/@oslojs/binary/dist/uint.js"() {
    BigEndian2 = /* @__PURE__ */ __name(class {
      uint8(data) {
        if (data.byteLength === 0) {
          throw new TypeError("Empty byte array");
        }
        return data[data.length - 1];
      }
      uint16(data) {
        if (data.byteLength === 0) {
          throw new TypeError("Empty byte array");
        }
        if (data.byteLength > 1) {
          return data[data.byteLength - 2] << 8 | data[data.byteLength - 1];
        }
        return data[data.byteLength - 1];
      }
      uint32(data) {
        if (data.byteLength === 0) {
          throw new TypeError("Empty byte array");
        }
        let result = 0;
        for (let i2 = 0; i2 < 4; i2++) {
          let byte = 0;
          if (data.byteLength - i2 - 1 >= 0) {
            byte = data[data.byteLength - i2 - 1];
          }
          result |= byte << i2 * 8;
        }
        return result;
      }
      uint64(data) {
        if (data.byteLength === 0) {
          throw new TypeError("Empty byte array");
        }
        let result = 0n;
        for (let i2 = 0; i2 < 8; i2++) {
          let byte = 0n;
          if (data.byteLength - i2 - 1 >= 0) {
            byte = BigInt(data[data.byteLength - i2 - 1]);
          }
          result |= byte << BigInt(i2 * 8);
        }
        return result;
      }
      putUint8(target, value, offset2) {
        if (target.length < 1 + offset2) {
          throw new TypeError("Not enough space");
        }
        target[offset2] = value;
      }
      putUint16(target, value, offset2) {
        if (target.length < 2 + offset2) {
          throw new TypeError("Not enough space");
        }
        target[offset2] = value >> 8;
        target[offset2 + 1] = value & 255;
      }
      putUint32(target, value, offset2) {
        if (target.length < 4 + offset2) {
          throw new TypeError("Not enough space");
        }
        for (let i2 = 0; i2 < 4; i2++) {
          target[offset2 + i2] = value >> (3 - i2) * 8 & 255;
        }
      }
      putUint64(target, value, offset2) {
        if (target.length < 8 + offset2) {
          throw new TypeError("Not enough space");
        }
        for (let i2 = 0; i2 < 8; i2++) {
          target[offset2 + i2] = Number(value >> BigInt((7 - i2) * 8) & 0xffn);
        }
      }
    }, "BigEndian2");
    LittleEndian2 = /* @__PURE__ */ __name(class {
      uint8(data) {
        if (data.byteLength === 0) {
          throw new TypeError("Empty byte array");
        }
        return data[0];
      }
      uint16(data) {
        if (data.byteLength === 0) {
          throw new TypeError("Empty byte array");
        }
        return data[0] | (data[1] ?? 0) << 8;
      }
      uint32(data) {
        if (data.byteLength === 0) {
          throw new TypeError("Empty byte array");
        }
        let result = 0;
        for (let i2 = 0; i2 < 4; i2++) {
          result |= (data[i2] ?? 0) << i2 * 8;
        }
        return result;
      }
      uint64(data) {
        if (data.byteLength === 0) {
          throw new TypeError("Empty byte array");
        }
        let result = 0n;
        for (let i2 = 0; i2 < 8; i2++) {
          const byte = BigInt(data[i2] ?? 0);
          result |= byte << BigInt(i2 * 8);
        }
        return result;
      }
      putUint8(target, value, offset2) {
        if (target.length < 1 + offset2) {
          throw new TypeError("Not enough space");
        }
        target[offset2] = value;
      }
      putUint16(target, value, offset2) {
        if (target.length < 2 + offset2) {
          throw new TypeError("Not enough space");
        }
        target[offset2 + 1] = value >> 8;
        target[offset2] = value & 255;
      }
      putUint32(target, value, offset2) {
        if (target.length < 4 + offset2) {
          throw new TypeError("Not enough space");
        }
        for (let i2 = 0; i2 < 4; i2++) {
          target[offset2 + i2] = value >> i2 * 8 & 255;
        }
      }
      putUint64(target, value, offset2) {
        if (target.length < 8 + offset2) {
          throw new TypeError("Not enough space");
        }
        for (let i2 = 0; i2 < 8; i2++) {
          target[offset2 + i2] = Number(value >> BigInt(i2 * 8) & 0xffn);
        }
      }
    }, "LittleEndian2");
    bigEndian2 = new BigEndian2();
    littleEndian2 = new LittleEndian2();
  }
});
var init_bytes2 = __esm({
  "node_modules/.pnpm/@oslojs+binary@0.2.3/node_modules/@oslojs/binary/dist/bytes.js"() {
  }
});
function rotr322(x2, n2) {
  return (x2 << 32 - n2 | x2 >>> n2) >>> 0;
}
__name(rotr322, "rotr322");
var init_operation = __esm({
  "node_modules/.pnpm/@oslojs+binary@0.2.3/node_modules/@oslojs/binary/dist/operation.js"() {
  }
});
var init_big2 = __esm({
  "node_modules/.pnpm/@oslojs+binary@0.2.3/node_modules/@oslojs/binary/dist/big.js"() {
  }
});
var init_dist5 = __esm({
  "node_modules/.pnpm/@oslojs+binary@0.2.3/node_modules/@oslojs/binary/dist/index.js"() {
    init_uint2();
    init_bytes2();
    init_operation();
    init_big2();
  }
});
var K4;
var init_sha2242 = __esm({
  "node_modules/.pnpm/@oslojs+crypto@0.6.0/node_modules/@oslojs/crypto/dist/sha2/sha224.js"() {
    init_dist5();
    init_dist5();
    K4 = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
  }
});
function sha2563(data) {
  const hash2 = new SHA2562();
  hash2.update(data);
  return hash2.digest();
}
__name(sha2563, "sha2563");
var SHA2562;
var K5;
var init_sha2562 = __esm({
  "node_modules/.pnpm/@oslojs+crypto@0.6.0/node_modules/@oslojs/crypto/dist/sha2/sha256.js"() {
    init_dist5();
    init_dist5();
    SHA2562 = /* @__PURE__ */ __name(class {
      blockSize = 64;
      size = 32;
      blocks = new Uint8Array(64);
      currentBlockSize = 0;
      H = new Uint32Array([
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ]);
      l = 0n;
      w = new Uint32Array(64);
      update(data) {
        this.l += BigInt(data.byteLength) * 8n;
        if (this.currentBlockSize + data.byteLength < 64) {
          this.blocks.set(data, this.currentBlockSize);
          this.currentBlockSize += data.byteLength;
          return;
        }
        let processed = 0;
        if (this.currentBlockSize > 0) {
          const next2 = data.slice(0, 64 - this.currentBlockSize);
          this.blocks.set(next2, this.currentBlockSize);
          this.process();
          processed += next2.byteLength;
          this.currentBlockSize = 0;
        }
        while (processed + 64 <= data.byteLength) {
          const next2 = data.slice(processed, processed + 64);
          this.blocks.set(next2);
          this.process();
          processed += 64;
        }
        if (data.byteLength - processed > 0) {
          const remaining = data.slice(processed);
          this.blocks.set(remaining);
          this.currentBlockSize = remaining.byteLength;
        }
      }
      digest() {
        this.blocks[this.currentBlockSize] = 128;
        this.currentBlockSize += 1;
        if (64 - this.currentBlockSize < 8) {
          this.blocks.fill(0, this.currentBlockSize);
          this.process();
          this.currentBlockSize = 0;
        }
        this.blocks.fill(0, this.currentBlockSize);
        bigEndian2.putUint64(this.blocks, this.l, this.blockSize - 8);
        this.process();
        const result = new Uint8Array(32);
        for (let i2 = 0; i2 < 8; i2++) {
          bigEndian2.putUint32(result, this.H[i2], i2 * 4);
        }
        return result;
      }
      process() {
        for (let t2 = 0; t2 < 16; t2++) {
          this.w[t2] = (this.blocks[t2 * 4] << 24 | this.blocks[t2 * 4 + 1] << 16 | this.blocks[t2 * 4 + 2] << 8 | this.blocks[t2 * 4 + 3]) >>> 0;
        }
        for (let t2 = 16; t2 < 64; t2++) {
          const sigma1 = (rotr322(this.w[t2 - 2], 17) ^ rotr322(this.w[t2 - 2], 19) ^ this.w[t2 - 2] >>> 10) >>> 0;
          const sigma0 = (rotr322(this.w[t2 - 15], 7) ^ rotr322(this.w[t2 - 15], 18) ^ this.w[t2 - 15] >>> 3) >>> 0;
          this.w[t2] = sigma1 + this.w[t2 - 7] + sigma0 + this.w[t2 - 16] | 0;
        }
        let a2 = this.H[0];
        let b = this.H[1];
        let c2 = this.H[2];
        let d = this.H[3];
        let e3 = this.H[4];
        let f = this.H[5];
        let g2 = this.H[6];
        let h = this.H[7];
        for (let t2 = 0; t2 < 64; t2++) {
          const sigma1 = (rotr322(e3, 6) ^ rotr322(e3, 11) ^ rotr322(e3, 25)) >>> 0;
          const ch = (e3 & f ^ ~e3 & g2) >>> 0;
          const t1 = h + sigma1 + ch + K5[t2] + this.w[t2] | 0;
          const sigma0 = (rotr322(a2, 2) ^ rotr322(a2, 13) ^ rotr322(a2, 22)) >>> 0;
          const maj = (a2 & b ^ a2 & c2 ^ b & c2) >>> 0;
          const t22 = sigma0 + maj | 0;
          h = g2;
          g2 = f;
          f = e3;
          e3 = d + t1 | 0;
          d = c2;
          c2 = b;
          b = a2;
          a2 = t1 + t22 | 0;
        }
        this.H[0] = a2 + this.H[0] | 0;
        this.H[1] = b + this.H[1] | 0;
        this.H[2] = c2 + this.H[2] | 0;
        this.H[3] = d + this.H[3] | 0;
        this.H[4] = e3 + this.H[4] | 0;
        this.H[5] = f + this.H[5] | 0;
        this.H[6] = g2 + this.H[6] | 0;
        this.H[7] = h + this.H[7] | 0;
      }
    }, "SHA2562");
    K5 = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
  }
});
var K6;
var init_sha5122 = __esm({
  "node_modules/.pnpm/@oslojs+crypto@0.6.0/node_modules/@oslojs/crypto/dist/sha2/sha512.js"() {
    init_dist5();
    init_dist5();
    K6 = new BigUint64Array([
      0x428a2f98d728ae22n,
      0x7137449123ef65cdn,
      0xb5c0fbcfec4d3b2fn,
      0xe9b5dba58189dbbcn,
      0x3956c25bf348b538n,
      0x59f111f1b605d019n,
      0x923f82a4af194f9bn,
      0xab1c5ed5da6d8118n,
      0xd807aa98a3030242n,
      0x12835b0145706fben,
      0x243185be4ee4b28cn,
      0x550c7dc3d5ffb4e2n,
      0x72be5d74f27b896fn,
      0x80deb1fe3b1696b1n,
      0x9bdc06a725c71235n,
      0xc19bf174cf692694n,
      0xe49b69c19ef14ad2n,
      0xefbe4786384f25e3n,
      0x0fc19dc68b8cd5b5n,
      0x240ca1cc77ac9c65n,
      0x2de92c6f592b0275n,
      0x4a7484aa6ea6e483n,
      0x5cb0a9dcbd41fbd4n,
      0x76f988da831153b5n,
      0x983e5152ee66dfabn,
      0xa831c66d2db43210n,
      0xb00327c898fb213fn,
      0xbf597fc7beef0ee4n,
      0xc6e00bf33da88fc2n,
      0xd5a79147930aa725n,
      0x06ca6351e003826fn,
      0x142929670a0e6e70n,
      0x27b70a8546d22ffcn,
      0x2e1b21385c26c926n,
      0x4d2c6dfc5ac42aedn,
      0x53380d139d95b3dfn,
      0x650a73548baf63den,
      0x766a0abb3c77b2a8n,
      0x81c2c92e47edaee6n,
      0x92722c851482353bn,
      0xa2bfe8a14cf10364n,
      0xa81a664bbc423001n,
      0xc24b8b70d0f89791n,
      0xc76c51a30654be30n,
      0xd192e819d6ef5218n,
      0xd69906245565a910n,
      0xf40e35855771202an,
      0x106aa07032bbd1b8n,
      0x19a4c116b8d2d0c8n,
      0x1e376c085141ab53n,
      0x2748774cdf8eeb99n,
      0x34b0bcb5e19b48a8n,
      0x391c0cb3c5c95a63n,
      0x4ed8aa4ae3418acbn,
      0x5b9cca4f7763e373n,
      0x682e6ff3d6b2b8a3n,
      0x748f82ee5defb2fcn,
      0x78a5636f43172f60n,
      0x84c87814a1f0ab72n,
      0x8cc702081a6439ecn,
      0x90befffa23631e28n,
      0xa4506cebde82bde9n,
      0xbef9a3f7b2c67915n,
      0xc67178f2e372532bn,
      0xca273eceea26619cn,
      0xd186b8c721c0c207n,
      0xeada7dd6cde0eb1en,
      0xf57d4f7fee6ed178n,
      0x06f067aa72176fban,
      0x0a637dc5a2c898a6n,
      0x113f9804bef90daen,
      0x1b710b35131c471bn,
      0x28db77f523047d84n,
      0x32caab7b40c72493n,
      0x3c9ebe0a15c9bebcn,
      0x431d67c49c100d4cn,
      0x4cc5d4becb3e42b6n,
      0x597f299cfc657e2an,
      0x5fcb6fab3ad6faecn,
      0x6c44198c4a475817n
    ]);
  }
});
var init_sha3842 = __esm({
  "node_modules/.pnpm/@oslojs+crypto@0.6.0/node_modules/@oslojs/crypto/dist/sha2/sha384.js"() {
    init_sha5122();
  }
});
var init_sha512_2242 = __esm({
  "node_modules/.pnpm/@oslojs+crypto@0.6.0/node_modules/@oslojs/crypto/dist/sha2/sha512_224.js"() {
    init_sha5122();
  }
});
var init_sha512_2562 = __esm({
  "node_modules/.pnpm/@oslojs+crypto@0.6.0/node_modules/@oslojs/crypto/dist/sha2/sha512_256.js"() {
    init_sha5122();
  }
});
var init_sha22 = __esm({
  "node_modules/.pnpm/@oslojs+crypto@0.6.0/node_modules/@oslojs/crypto/dist/sha2/index.js"() {
    init_sha2242();
    init_sha2562();
    init_sha3842();
    init_sha5122();
    init_sha512_2242();
    init_sha512_2562();
  }
});
function createS256CodeChallenge(codeVerifier) {
  const codeChallengeBytes = sha2563(new TextEncoder().encode(codeVerifier));
  return encodeBase64urlNoPadding2(codeChallengeBytes);
}
__name(createS256CodeChallenge, "createS256CodeChallenge");
function generateCodeVerifier() {
  const randomValues = new Uint8Array(32);
  crypto.getRandomValues(randomValues);
  return encodeBase64urlNoPadding2(randomValues);
}
__name(generateCodeVerifier, "generateCodeVerifier");
function generateState() {
  const randomValues = new Uint8Array(32);
  crypto.getRandomValues(randomValues);
  return encodeBase64urlNoPadding2(randomValues);
}
__name(generateState, "generateState");
var OAuth2Tokens;
var init_oauth2 = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/oauth2.js"() {
    init_dist4();
    init_sha22();
    OAuth2Tokens = /* @__PURE__ */ __name(class {
      data;
      constructor(data) {
        this.data = data;
      }
      tokenType() {
        if ("token_type" in this.data && typeof this.data.token_type === "string") {
          return this.data.token_type;
        }
        throw new Error("Missing or invalid 'token_type' field");
      }
      accessToken() {
        if ("access_token" in this.data && typeof this.data.access_token === "string") {
          return this.data.access_token;
        }
        throw new Error("Missing or invalid 'access_token' field");
      }
      accessTokenExpiresInSeconds() {
        if ("expires_in" in this.data && typeof this.data.expires_in === "number") {
          return this.data.expires_in;
        }
        throw new Error("Missing or invalid 'expires_in' field");
      }
      accessTokenExpiresAt() {
        return new Date(Date.now() + this.accessTokenExpiresInSeconds() * 1e3);
      }
      hasRefreshToken() {
        return "refresh_token" in this.data && typeof this.data.refresh_token === "string";
      }
      refreshToken() {
        if ("refresh_token" in this.data && typeof this.data.refresh_token === "string") {
          return this.data.refresh_token;
        }
        throw new Error("Missing or invalid 'refresh_token' field");
      }
      hasScopes() {
        return "scope" in this.data && typeof this.data.scope === "string";
      }
      scopes() {
        if ("scope" in this.data && typeof this.data.scope === "string") {
          return this.data.scope.split(" ");
        }
        throw new Error("Missing or invalid 'scope' field");
      }
      idToken() {
        if ("id_token" in this.data && typeof this.data.id_token === "string") {
          return this.data.id_token;
        }
        throw new Error("Missing or invalid field 'id_token'");
      }
    }, "OAuth2Tokens");
  }
});
function createOAuth2Request(endpoint, body2) {
  const request = new Request(endpoint, {
    method: "POST",
    body: body2
  });
  request.headers.set("Content-Type", "application/x-www-form-urlencoded");
  request.headers.set("Accept", "application/json");
  request.headers.set("User-Agent", "arctic");
  return request;
}
__name(createOAuth2Request, "createOAuth2Request");
async function sendTokenRequest(request) {
  let response;
  try {
    response = await fetch(request);
  } catch (e3) {
    throw new ArcticFetchError(e3);
  }
  let data;
  try {
    data = await response.json();
  } catch {
    throw new Error("Failed to parse response body");
  }
  if (typeof data !== "object" || data === null) {
    throw new Error("Unexpected response body data");
  }
  if ("error" in data && typeof data.error === "string") {
    const error2 = createOAuth2RequestError(data);
    throw error2;
  }
  return new OAuth2Tokens(data);
}
__name(sendTokenRequest, "sendTokenRequest");
async function sendTokenRevocationRequest(request) {
  let response;
  try {
    response = await fetch(request);
  } catch (e3) {
    throw new ArcticFetchError(e3);
  }
  if (response.ok && response.body === null) {
    return;
  }
  let data;
  try {
    data = await response.json();
  } catch {
    throw new Error("Failed to parse response body");
  }
  if (typeof data !== "object" || data === null) {
    throw new Error("Unexpected response body data");
  }
  if ("error" in data && typeof data.error === "string") {
    const error2 = createOAuth2RequestError(data);
    throw error2;
  }
}
__name(sendTokenRevocationRequest, "sendTokenRevocationRequest");
function createOAuth2RequestError(result) {
  let code;
  if ("error" in result && typeof result.error === "string") {
    code = result.error;
  } else {
    throw new Error("Invalid error response");
  }
  let description = null;
  let uri = null;
  let state = null;
  if ("error_description" in result && typeof result.error_description === "string") {
    description = result.error_description;
  }
  if ("error_uri" in result && typeof result.error_uri === "string") {
    uri = result.error_uri;
  }
  if ("state" in result && typeof result.state === "string") {
    state = result.state;
  }
  return new OAuth2RequestError(code, description, uri, state);
}
__name(createOAuth2RequestError, "createOAuth2RequestError");
var ArcticFetchError;
var OAuth2RequestError;
var init_request = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/request.js"() {
    init_dist4();
    init_oauth2();
    ArcticFetchError = /* @__PURE__ */ __name(class extends Error {
      constructor(cause) {
        super("Failed to send request", {
          cause
        });
      }
    }, "ArcticFetchError");
    OAuth2RequestError = /* @__PURE__ */ __name(class extends Error {
      code;
      description;
      uri;
      state;
      constructor(code, description, uri, state) {
        super(`OAuth request error: ${code}`);
        this.code = code;
        this.description = description;
        this.uri = uri;
        this.state = state;
      }
    }, "OAuth2RequestError");
  }
});
var init_amazon_cognito = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/amazon-cognito.js"() {
    init_oauth2();
    init_request();
  }
});
var init_anilist = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/anilist.js"() {
    init_request();
  }
});
function parseJWT(jwt) {
  const parts = jwt.split(".");
  if (parts.length !== 3) {
    throw new Error("Invalid JWT");
  }
  let jsonHeader;
  let jsonPayload;
  let signature;
  try {
    jsonHeader = new TextDecoder().decode(decodeBase64urlIgnorePadding2(parts[0]));
    jsonPayload = new TextDecoder().decode(decodeBase64urlIgnorePadding2(parts[1]));
    signature = decodeBase64urlIgnorePadding2(parts[2]);
  } catch {
    throw new Error("Invalid JWT: Invalid base64url encoding");
  }
  let header;
  let payload;
  try {
    header = JSON.parse(jsonHeader);
    payload = JSON.parse(jsonPayload);
  } catch {
    throw new Error("Invalid JWT: Invalid JSON encoding");
  }
  if (typeof header !== "object" || header === null) {
    throw new Error("Invalid JWT: Invalid header");
  }
  if (typeof payload !== "object" || payload === null) {
    throw new Error("Invalid JWT: Invalid payload");
  }
  return [header, payload, signature];
}
__name(parseJWT, "parseJWT");
var init_dist6 = __esm({
  "node_modules/.pnpm/@oslojs+jwt@0.1.0/node_modules/@oslojs/jwt/dist/index.js"() {
    init_dist4();
  }
});
var init_apple = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/apple.js"() {
    init_request();
    init_dist6();
  }
});
var init_atlassian = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/atlassian.js"() {
    init_request();
  }
});
var init_auth0 = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/auth0.js"() {
    init_request();
  }
});
var init_authentik = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/authentik.js"() {
    init_oauth2();
    init_request();
  }
});
var init_bitbucket = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/bitbucket.js"() {
    init_request();
  }
});
var init_box = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/box.js"() {
    init_request();
  }
});
var init_bungie = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/bungie.js"() {
    init_request();
  }
});
var init_coinbase = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/coinbase.js"() {
    init_request();
  }
});
var init_discord = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/discord.js"() {
    init_request();
  }
});
var init_dribbble = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/dribbble.js"() {
    init_request();
  }
});
var init_dropbox = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/dropbox.js"() {
    init_request();
  }
});
var init_facebook = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/facebook.js"() {
    init_request();
  }
});
var init_figma = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/figma.js"() {
    init_request();
  }
});
var init_intuit = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/intuit.js"() {
    init_request();
  }
});
var init_github = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/github.js"() {
    init_request();
  }
});
var init_gitlab = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/gitlab.js"() {
    init_request();
  }
});
var authorizationEndpoint;
var tokenEndpoint;
var tokenRevocationEndpoint;
var Google;
var init_google = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/google.js"() {
    init_oauth2();
    init_request();
    authorizationEndpoint = "https://accounts.google.com/o/oauth2/v2/auth";
    tokenEndpoint = "https://oauth2.googleapis.com/token";
    tokenRevocationEndpoint = "https://oauth2.googleapis.com/revoke";
    Google = /* @__PURE__ */ __name(class {
      clientId;
      clientSecret;
      redirectURI;
      constructor(clientId, clientSecret, redirectURI) {
        this.clientId = clientId;
        this.clientSecret = clientSecret;
        this.redirectURI = redirectURI;
      }
      createAuthorizationURL(state, codeVerifier, scopes) {
        const url = new URL(authorizationEndpoint);
        url.searchParams.set("response_type", "code");
        url.searchParams.set("client_id", this.clientId);
        url.searchParams.set("state", state);
        url.searchParams.set("scope", scopes.join(" "));
        url.searchParams.set("redirect_uri", this.redirectURI);
        const codeChallenge = createS256CodeChallenge(codeVerifier);
        url.searchParams.set("code_challenge_method", "S256");
        url.searchParams.set("code_challenge", codeChallenge);
        return url;
      }
      async validateAuthorizationCode(code, codeVerifier) {
        const body2 = new URLSearchParams();
        body2.set("grant_type", "authorization_code");
        body2.set("code", code);
        body2.set("code_verifier", codeVerifier);
        body2.set("redirect_uri", this.redirectURI);
        body2.set("client_id", this.clientId);
        body2.set("client_secret", this.clientSecret);
        const request = createOAuth2Request(tokenEndpoint, body2);
        const tokens = await sendTokenRequest(request);
        return tokens;
      }
      async refreshAccessToken(refreshToken) {
        const body2 = new URLSearchParams();
        body2.set("grant_type", "refresh_token");
        body2.set("refresh_token", refreshToken);
        body2.set("client_id", this.clientId);
        body2.set("client_secret", this.clientSecret);
        const request = createOAuth2Request(tokenEndpoint, body2);
        const tokens = await sendTokenRequest(request);
        return tokens;
      }
      async revokeToken(token) {
        const body2 = new URLSearchParams();
        body2.set("token", token);
        body2.set("client_id", this.clientId);
        body2.set("client_secret", this.clientSecret);
        const request = createOAuth2Request(tokenRevocationEndpoint, body2);
        await sendTokenRevocationRequest(request);
      }
    }, "Google");
  }
});
var init_kakao = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/kakao.js"() {
    init_request();
  }
});
var init_keycloak = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/keycloak.js"() {
    init_oauth2();
    init_request();
  }
});
var init_lichess = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/lichess.js"() {
    init_oauth2();
    init_request();
  }
});
var init_line = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/line.js"() {
    init_oauth2();
    init_request();
  }
});
var init_linear = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/linear.js"() {
    init_request();
  }
});
var init_linkedin = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/linkedin.js"() {
    init_request();
  }
});
var init_microsoft_entra_id = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/microsoft-entra-id.js"() {
    init_oauth2();
    init_request();
  }
});
var init_myanimelist = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/myanimelist.js"() {
    init_request();
  }
});
var init_notion = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/notion.js"() {
    init_request();
  }
});
var init_okta = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/okta.js"() {
    init_oauth2();
    init_request();
  }
});
var init_osu = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/osu.js"() {
    init_request();
  }
});
var init_patreon = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/patreon.js"() {
    init_request();
  }
});
var init_polar = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/polar.js"() {
    init_request();
    init_oauth2();
  }
});
var init_reddit = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/reddit.js"() {
    init_request();
  }
});
var init_roblox = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/roblox.js"() {
    init_oauth2();
    init_request();
  }
});
var init_salesforce = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/salesforce.js"() {
    init_oauth2();
    init_request();
  }
});
var init_shikimori = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/shikimori.js"() {
    init_request();
  }
});
var init_slack = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/slack.js"() {
    init_request();
  }
});
var init_spotify = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/spotify.js"() {
    init_request();
  }
});
var init_startgg = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/startgg.js"() {
    init_request();
  }
});
var init_strava = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/strava.js"() {
    init_request();
  }
});
var init_tiltify = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/tiltify.js"() {
    init_request();
  }
});
var init_tumblr = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/tumblr.js"() {
    init_request();
  }
});
var init_twitch = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/twitch.js"() {
    init_request();
  }
});
var init_twitter = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/twitter.js"() {
    init_oauth2();
    init_request();
  }
});
var init_vk = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/vk.js"() {
    init_request();
  }
});
var init_workos = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/workos.js"() {
    init_request();
  }
});
var init_yahoo = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/yahoo.js"() {
    init_request();
  }
});
var init_yandex = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/yandex.js"() {
    init_request();
  }
});
var init_zoom = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/zoom.js"() {
    init_oauth2();
    init_request();
  }
});
var init__39 = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/providers/42.js"() {
    init_request();
  }
});
function decodeIdToken(idToken) {
  try {
    const [_header, payload, _signature] = parseJWT(idToken);
    return payload;
  } catch (e3) {
    throw new Error("Invalid ID token", {
      cause: e3
    });
  }
}
__name(decodeIdToken, "decodeIdToken");
var init_oidc = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/oidc.js"() {
    init_dist6();
  }
});
var init_dist7 = __esm({
  "node_modules/.pnpm/arctic@2.0.0-next.9/node_modules/arctic/dist/index.js"() {
    init_amazon_cognito();
    init_anilist();
    init_apple();
    init_atlassian();
    init_auth0();
    init_authentik();
    init_bitbucket();
    init_box();
    init_bungie();
    init_coinbase();
    init_discord();
    init_dribbble();
    init_dropbox();
    init_facebook();
    init_figma();
    init_intuit();
    init_github();
    init_gitlab();
    init_google();
    init_kakao();
    init_keycloak();
    init_lichess();
    init_line();
    init_linear();
    init_linkedin();
    init_microsoft_entra_id();
    init_myanimelist();
    init_notion();
    init_okta();
    init_osu();
    init_patreon();
    init_polar();
    init_reddit();
    init_roblox();
    init_salesforce();
    init_shikimori();
    init_slack();
    init_spotify();
    init_startgg();
    init_strava();
    init_tiltify();
    init_tumblr();
    init_twitch();
    init_twitter();
    init_vk();
    init_workos();
    init_yahoo();
    init_yandex();
    init_zoom();
    init__39();
    init_oauth2();
    init_request();
    init_oidc();
  }
});
var GOOGLE_CLIENT_ID;
var GOOGLE_CLIENT_SECRET;
var GOOGLE_CALLBACK_URL;
var google;
var init_oauth = __esm({
  ".svelte-kit/output/server/chunks/oauth.js"() {
    init_dist7();
    GOOGLE_CLIENT_ID = "32919470601-9f5ue1oa8q8qttptmh0ehjp0prhs1938.apps.googleusercontent.com";
    GOOGLE_CLIENT_SECRET = "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";
    GOOGLE_CALLBACK_URL = "http://localhost:5173/api/google/callback";
    google = new Google(GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, GOOGLE_CALLBACK_URL);
  }
});
var server_ts_exports2 = {};
__export(server_ts_exports2, {
  GET: () => GET
});
async function GET(event) {
  const state = generateState();
  const codeVerifier = generateCodeVerifier();
  const url = await google.createAuthorizationURL(state, codeVerifier, [
    "openid",
    "email",
    "profile"
  ]);
  event.cookies.set("google_oauth_state", state, {
    httpOnly: true,
    maxAge: 60 * 10,
    secure: true,
    path: "/",
    sameSite: "lax"
  });
  event.cookies.set("google_code_verifier", codeVerifier, {
    httpOnly: true,
    maxAge: 60 * 10,
    secure: true,
    path: "/",
    sameSite: "lax"
  });
  return new Response(null, {
    status: 302,
    headers: {
      Location: url.toString()
    }
  });
}
__name(GET, "GET");
var init_server_ts2 = __esm({
  ".svelte-kit/output/server/entries/endpoints/api/google/_server.ts.js"() {
    init_oauth();
    init_dist7();
  }
});
var server_ts_exports3 = {};
__export(server_ts_exports3, {
  GET: () => GET2
});
async function createUser(googleId, email, name3, picture, db) {
  const user = await db.insert(usersTable).values({
    googleId,
    email,
    name: name3,
    picture
  }).returning().get();
  if (user.id === null) {
    throw new Error("Unexpected error");
  }
  return user;
}
__name(createUser, "createUser");
async function getUserFromGoogleId(googleId, db) {
  const user = await db.query.usersTable.findFirst({
    where: eq(usersTable.googleId, googleId)
  });
  if (!user) {
    return null;
  }
  return user;
}
__name(getUserFromGoogleId, "getUserFromGoogleId");
async function GET2(event) {
  const { db } = event.locals;
  const code = event.url.searchParams.get("code");
  const state = event.url.searchParams.get("state");
  const storedState = event.cookies.get("google_oauth_state") ?? null;
  const codeVerifier = event.cookies.get("google_code_verifier") ?? null;
  if (code === null || state === null || storedState === null || codeVerifier === null) {
    return new Response(null, {
      status: 400
    });
  }
  if (state !== storedState) {
    return new Response(null, {
      status: 400
    });
  }
  let tokens;
  try {
    tokens = await google.validateAuthorizationCode(code, codeVerifier);
  } catch {
    return new Response(null, {
      status: 400
    });
  }
  const claims = decodeIdToken(tokens.idToken());
  const googleUserId = claims.sub;
  const username = claims.name;
  const email = claims.email;
  const picture = claims.picture;
  const existingUser = await getUserFromGoogleId(googleUserId, db);
  if (existingUser !== null) {
    const sessionToken2 = generateSessionToken();
    const session2 = await createSession(sessionToken2, existingUser.id, db);
    setSessionTokenCookie(event, sessionToken2, session2.expiresAt);
    return new Response(null, {
      status: 302,
      headers: {
        Location: "/"
      }
    });
  }
  const user = await createUser(googleUserId, email, username, picture, db);
  const sessionToken = generateSessionToken();
  const session = await createSession(sessionToken, user.id, db);
  setSessionTokenCookie(event, sessionToken, session.expiresAt);
  return new Response(null, {
    status: 302,
    headers: {
      Location: "/"
    }
  });
}
__name(GET2, "GET2");
var init_server_ts3 = __esm({
  ".svelte-kit/output/server/entries/endpoints/api/google/callback/_server.ts.js"() {
    init_session2();
    init_oauth();
    init_dist7();
    init_drizzle_orm();
    init_schema();
  }
});
var server_ts_exports4 = {};
var init_server_ts4 = __esm({
  ".svelte-kit/output/server/entries/endpoints/api/move/_server.ts.js"() {
  }
});
var server_ts_exports5 = {};
__export(server_ts_exports5, {
  POST: () => POST
});
var POST;
var init_server_ts5 = __esm({
  ".svelte-kit/output/server/entries/endpoints/api/rps/plw/_server.ts.js"() {
    init_schema();
    init_chunks();
    init_drizzle_orm();
    POST = /* @__PURE__ */ __name(async ({ locals: { db, user }, request }) => {
      const { gameHistoryId, winner, draw } = await request.json();
      if (!gameHistoryId)
        error(400, "Invalid gameHistoryId");
      if (!user)
        error(401, "Unauthorized");
      try {
        const game = await db.query.gameHistoryTable.findFirst({
          where: and(eq(gameHistoryTable.id, gameHistoryId), eq(gameHistoryTable.status, "IN_PROGRESS"))
        });
        if (!game) {
          error(400, "Game not found or already finished");
        }
        if (game.playerOneId !== user.id && game.playerTwoId !== user.id) {
          error(400, "User not part of this game");
        }
        await db.update(gameHistoryTable).set({
          status: "COMPLETED",
          winner: winner ? user.id : null
        }).where(eq(gameHistoryTable.id, game.id));
        const lostIncrement = winner ? 0 : 1;
        const wonIncrement = winner ? 1 : 0;
        const drawIncrement = draw ? 1 : 0;
        const rankingChange = winner ? 10 : draw ? 0 : -10;
        const res = await db.insert(statsTable).values({
          gameId: 4,
          globalRanking: 1e3,
          userId: user.id,
          gamesPlayed: 1,
          gamesLost: lostIncrement,
          gamesWon: wonIncrement,
          gamesDrawn: drawIncrement
        }).onConflictDoUpdate({
          target: [statsTable.userId, statsTable.gameId],
          set: {
            gamesPlayed: sql`games_played + 1`,
            gamesLost: sql`games_lost + ${lostIncrement}`,
            gamesWon: sql`games_won + ${wonIncrement}`,
            gamesDrawn: sql`games_drawn + ${drawIncrement}`,
            globalRanking: sql`global_ranking + ${rankingChange}`
          }
        }).returning().get();
        console.log("\u{1F680} ~ POST ~ res:", res);
      } catch (err) {
        console.log("\u{1F680} ~ abortGame: ~ error:", err);
        error(500, "something went wrong");
      }
      return new Response(JSON.stringify({ success: true }), {
        headers: { "Content-Type": "application/json" }
      });
    }, "POST");
  }
});
init_index2();
init_index2();
init_environment();
var base = "";
var assets = base;
var initial = { base, assets };
function override(paths) {
  base = paths.base;
  assets = paths.assets;
}
__name(override, "override");
function reset() {
  base = initial.base;
  assets = initial.assets;
}
__name(reset, "reset");
var public_env = {};
var safe_public_env = {};
function set_private_env(environment) {
}
__name(set_private_env, "set_private_env");
function set_public_env(environment) {
  public_env = environment;
}
__name(set_public_env, "set_public_env");
function set_safe_public_env(environment) {
  safe_public_env = environment;
}
__name(set_safe_public_env, "set_safe_public_env");
function hydration_mismatch(location2) {
  {
    console.warn("hydration_mismatch");
  }
}
__name(hydration_mismatch, "hydration_mismatch");
var hydrating = false;
function set_hydrating(value) {
  hydrating = value;
}
__name(set_hydrating, "set_hydrating");
var hydrate_node;
function set_hydrate_node(node) {
  if (node === null) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  return hydrate_node = node;
}
__name(set_hydrate_node, "set_hydrate_node");
function hydrate_next() {
  return set_hydrate_node(
    /** @type {TemplateNode} */
    get_next_sibling(hydrate_node)
  );
}
__name(hydrate_next, "hydrate_next");
var all_registered_events = /* @__PURE__ */ new Set();
var root_event_handles = /* @__PURE__ */ new Set();
function handle_event_propagation(event) {
  var handler_element = this;
  var owner_document = (
    /** @type {Node} */
    handler_element.ownerDocument
  );
  var event_name = event.type;
  var path = event.composedPath?.() || [];
  var current_target = (
    /** @type {null | Element} */
    path[0] || event.target
  );
  var path_idx = 0;
  var handled_at = event.__root;
  if (handled_at) {
    var at_idx = path.indexOf(handled_at);
    if (at_idx !== -1 && (handler_element === document || handler_element === /** @type {any} */
    window)) {
      event.__root = handler_element;
      return;
    }
    var handler_idx = path.indexOf(handler_element);
    if (handler_idx === -1) {
      return;
    }
    if (at_idx <= handler_idx) {
      path_idx = at_idx;
    }
  }
  current_target = /** @type {Element} */
  path[path_idx] || event.target;
  if (current_target === handler_element)
    return;
  define_property(event, "currentTarget", {
    configurable: true,
    get() {
      return current_target || owner_document;
    }
  });
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    var throw_error;
    var other_errors = [];
    while (current_target !== null) {
      var parent_element = current_target.assignedSlot || current_target.parentNode || /** @type {any} */
      current_target.host || null;
      try {
        var delegated = current_target["__" + event_name];
        if (delegated !== void 0 && !/** @type {any} */
        current_target.disabled) {
          if (is_array(delegated)) {
            var [fn, ...data] = delegated;
            fn.apply(current_target, [event, ...data]);
          } else {
            delegated.call(current_target, event);
          }
        }
      } catch (error2) {
        if (throw_error) {
          other_errors.push(error2);
        } else {
          throw_error = error2;
        }
      }
      if (event.cancelBubble || parent_element === handler_element || parent_element === null) {
        break;
      }
      current_target = parent_element;
    }
    if (throw_error) {
      for (let error2 of other_errors) {
        queueMicrotask(() => {
          throw error2;
        });
      }
      throw throw_error;
    }
  } finally {
    event.__root = handler_element;
    delete event.currentTarget;
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}
__name(handle_event_propagation, "handle_event_propagation");
function assign_nodes(start, end) {
  var effect4 = (
    /** @type {Effect} */
    active_effect
  );
  if (effect4.nodes_start === null) {
    effect4.nodes_start = start;
    effect4.nodes_end = end;
  }
}
__name(assign_nodes, "assign_nodes");
function mount(component39, options2) {
  return _mount(component39, options2);
}
__name(mount, "mount");
function hydrate(component39, options2) {
  init_operations();
  options2.intro = options2.intro ?? false;
  const target = options2.target;
  const was_hydrating = hydrating;
  const previous_hydrate_node = hydrate_node;
  try {
    var anchor = (
      /** @type {TemplateNode} */
      get_first_child(target)
    );
    while (anchor && (anchor.nodeType !== 8 || /** @type {Comment} */
    anchor.data !== HYDRATION_START)) {
      anchor = /** @type {TemplateNode} */
      get_next_sibling(anchor);
    }
    if (!anchor) {
      throw HYDRATION_ERROR;
    }
    set_hydrating(true);
    set_hydrate_node(
      /** @type {Comment} */
      anchor
    );
    hydrate_next();
    const instance = _mount(component39, { ...options2, anchor });
    if (hydrate_node === null || hydrate_node.nodeType !== 8 || /** @type {Comment} */
    hydrate_node.data !== HYDRATION_END) {
      hydration_mismatch();
      throw HYDRATION_ERROR;
    }
    set_hydrating(false);
    return (
      /**  @type {Exports} */
      instance
    );
  } catch (error2) {
    if (error2 === HYDRATION_ERROR) {
      if (options2.recover === false) {
        hydration_failed();
      }
      init_operations();
      clear_text_content(target);
      set_hydrating(false);
      return mount(component39, options2);
    }
    throw error2;
  } finally {
    set_hydrating(was_hydrating);
    set_hydrate_node(previous_hydrate_node);
  }
}
__name(hydrate, "hydrate");
var document_listeners = /* @__PURE__ */ new Map();
function _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {
  init_operations();
  var registered_events = /* @__PURE__ */ new Set();
  var event_handle = /* @__PURE__ */ __name((events2) => {
    for (var i2 = 0; i2 < events2.length; i2++) {
      var event_name = events2[i2];
      if (registered_events.has(event_name))
        continue;
      registered_events.add(event_name);
      var passive = is_passive_event(event_name);
      target.addEventListener(event_name, handle_event_propagation, { passive });
      var n2 = document_listeners.get(event_name);
      if (n2 === void 0) {
        document.addEventListener(event_name, handle_event_propagation, { passive });
        document_listeners.set(event_name, 1);
      } else {
        document_listeners.set(event_name, n2 + 1);
      }
    }
  }, "event_handle");
  event_handle(array_from(all_registered_events));
  root_event_handles.add(event_handle);
  var component39 = void 0;
  var unmount2 = effect_root(() => {
    var anchor_node = anchor ?? target.appendChild(create_text());
    branch(() => {
      if (context) {
        push$1({});
        var ctx = (
          /** @type {ComponentContext} */
          component_context
        );
        ctx.c = context;
      }
      if (events) {
        props.$$events = events;
      }
      if (hydrating) {
        assign_nodes(
          /** @type {TemplateNode} */
          anchor_node,
          null
        );
      }
      component39 = Component(anchor_node, props) || {};
      if (hydrating) {
        active_effect.nodes_end = hydrate_node;
      }
      if (context) {
        pop$1();
      }
    });
    return () => {
      for (var event_name of registered_events) {
        target.removeEventListener(event_name, handle_event_propagation);
        var n2 = (
          /** @type {number} */
          document_listeners.get(event_name)
        );
        if (--n2 === 0) {
          document.removeEventListener(event_name, handle_event_propagation);
          document_listeners.delete(event_name);
        } else {
          document_listeners.set(event_name, n2);
        }
      }
      root_event_handles.delete(event_handle);
      mounted_components.delete(component39);
      if (anchor_node !== anchor) {
        anchor_node.parentNode?.removeChild(anchor_node);
      }
    };
  });
  mounted_components.set(component39, unmount2);
  return component39;
}
__name(_mount, "_mount");
var mounted_components = /* @__PURE__ */ new WeakMap();
function unmount(component39) {
  const fn = mounted_components.get(component39);
  if (fn) {
    fn();
  }
}
__name(unmount, "unmount");
function asClassComponent$1(component39) {
  return class extends Svelte4Component {
    /** @param {any} options */
    constructor(options2) {
      super({
        component: component39,
        ...options2
      });
    }
  };
}
__name(asClassComponent$1, "asClassComponent$1");
var Svelte4Component = /* @__PURE__ */ __name(class {
  /** @type {any} */
  #events;
  /** @type {Record<string, any>} */
  #instance;
  /**
   * @param {ComponentConstructorOptions & {
   *  component: any;
   * }} options
   */
  constructor(options2) {
    var sources = /* @__PURE__ */ new Map();
    var add_source = /* @__PURE__ */ __name((key2, value) => {
      var s3 = mutable_source(value);
      sources.set(key2, s3);
      return s3;
    }, "add_source");
    const props = new Proxy(
      { ...options2.props || {}, $$events: {} },
      {
        get(target, prop) {
          return get(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));
        },
        has(target, prop) {
          get(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));
          return Reflect.has(target, prop);
        },
        set(target, prop, value) {
          set(sources.get(prop) ?? add_source(prop, value), value);
          return Reflect.set(target, prop, value);
        }
      }
    );
    this.#instance = (options2.hydrate ? hydrate : mount)(options2.component, {
      target: options2.target,
      props,
      context: options2.context,
      intro: options2.intro ?? false,
      recover: options2.recover
    });
    if (!options2?.props?.$$host || options2.sync === false) {
      flush_sync();
    }
    this.#events = props.$$events;
    for (const key2 of Object.keys(this.#instance)) {
      if (key2 === "$set" || key2 === "$destroy" || key2 === "$on")
        continue;
      define_property(this, key2, {
        get() {
          return this.#instance[key2];
        },
        /** @param {any} value */
        set(value) {
          this.#instance[key2] = value;
        },
        enumerable: true
      });
    }
    this.#instance.$set = /** @param {Record<string, any>} next */
    (next2) => {
      Object.assign(props, next2);
    };
    this.#instance.$destroy = () => {
      unmount(this.#instance);
    };
  }
  /** @param {Record<string, any>} props */
  $set(props) {
    this.#instance.$set(props);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(event, callback) {
    this.#events[event] = this.#events[event] || [];
    const cb = /* @__PURE__ */ __name((...args) => callback.call(this, ...args), "cb");
    this.#events[event].push(cb);
    return () => {
      this.#events[event] = this.#events[event].filter(
        /** @param {any} fn */
        (fn) => fn !== cb
      );
    };
  }
  $destroy() {
    this.#instance.$destroy();
  }
}, "Svelte4Component");
var read_implementation = null;
function set_read_implementation(fn) {
  read_implementation = fn;
}
__name(set_read_implementation, "set_read_implementation");
function asClassComponent(component39) {
  const component_constructor = asClassComponent$1(component39);
  const _render = /* @__PURE__ */ __name((props, { context } = {}) => {
    const result = render(component39, { props, context });
    return {
      css: { code: "", map: null },
      head: result.head,
      html: result.body
    };
  }, "_render");
  component_constructor.render = _render;
  return component_constructor;
}
__name(asClassComponent, "asClassComponent");
function Root($$payload, $$props) {
  push();
  let {
    stores,
    page: page3,
    constructors,
    components = [],
    form,
    data_0 = null,
    data_1 = null,
    data_2 = null
  } = $$props;
  {
    setContext("__svelte__", stores);
  }
  {
    stores.page.set(page3);
  }
  const Pyramid_2 = constructors[2];
  if (constructors[1]) {
    $$payload.out += "<!--[-->";
    const Pyramid_0 = constructors[0];
    $$payload.out += `<!---->`;
    Pyramid_0($$payload, {
      data: data_0,
      form,
      children: ($$payload2) => {
        if (constructors[2]) {
          $$payload2.out += "<!--[-->";
          const Pyramid_1 = constructors[1];
          $$payload2.out += `<!---->`;
          Pyramid_1($$payload2, {
            data: data_1,
            form,
            children: ($$payload3) => {
              $$payload3.out += `<!---->`;
              Pyramid_2($$payload3, { data: data_2, form });
              $$payload3.out += `<!---->`;
            },
            $$slots: { default: true }
          });
          $$payload2.out += `<!---->`;
        } else {
          $$payload2.out += "<!--[!-->";
          const Pyramid_1 = constructors[1];
          $$payload2.out += `<!---->`;
          Pyramid_1($$payload2, { data: data_1, form });
          $$payload2.out += `<!---->`;
        }
        $$payload2.out += `<!--]-->`;
      },
      $$slots: { default: true }
    });
    $$payload.out += `<!---->`;
  } else {
    $$payload.out += "<!--[!-->";
    const Pyramid_0 = constructors[0];
    $$payload.out += `<!---->`;
    Pyramid_0($$payload, { data: data_0, form });
    $$payload.out += `<!---->`;
  }
  $$payload.out += `<!--]--> `;
  {
    $$payload.out += "<!--[!-->";
  }
  $$payload.out += `<!--]-->`;
  pop();
}
__name(Root, "Root");
var root = asClassComponent(Root);
var options = {
  app_dir: "_app",
  app_template_contains_nonce: false,
  csp: { "mode": "auto", "directives": { "upgrade-insecure-requests": false, "block-all-mixed-content": false }, "reportOnly": { "upgrade-insecure-requests": false, "block-all-mixed-content": false } },
  csrf_check_origin: true,
  embedded: false,
  env_public_prefix: "PUBLIC_",
  env_private_prefix: "",
  hooks: null,
  // added lazily, via `get_hooks`
  preload_strategy: "modulepreload",
  root,
  service_worker: false,
  templates: {
    app: ({ head: head2, body: body2, assets: assets2, nonce, env }) => '<!doctype html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<link rel="icon" href="' + assets2 + '/favicon.png" />\n		<meta name="viewport" content="width=device-width, initial-scale=1" />\n		' + head2 + '\n	</head>\n	<body data-sveltekit-preload-data="hover">\n		<div style="display: contents">' + body2 + "</div>\n	</body>\n</html>\n",
    error: ({ status, message }) => '<!doctype html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<title>' + message + `</title>

		<style>
			body {
				--bg: white;
				--fg: #222;
				--divider: #ccc;
				background: var(--bg);
				color: var(--fg);
				font-family:
					system-ui,
					-apple-system,
					BlinkMacSystemFont,
					'Segoe UI',
					Roboto,
					Oxygen,
					Ubuntu,
					Cantarell,
					'Open Sans',
					'Helvetica Neue',
					sans-serif;
				display: flex;
				align-items: center;
				justify-content: center;
				height: 100vh;
				margin: 0;
			}

			.error {
				display: flex;
				align-items: center;
				max-width: 32rem;
				margin: 0 1rem;
			}

			.status {
				font-weight: 200;
				font-size: 3rem;
				line-height: 1;
				position: relative;
				top: -0.05rem;
			}

			.message {
				border-left: 1px solid var(--divider);
				padding: 0 0 0 1rem;
				margin: 0 0 0 1rem;
				min-height: 2.5rem;
				display: flex;
				align-items: center;
			}

			.message h1 {
				font-weight: 400;
				font-size: 1em;
				margin: 0;
			}

			@media (prefers-color-scheme: dark) {
				body {
					--bg: #222;
					--fg: #ddd;
					--divider: #666;
				}
			}
		</style>
	</head>
	<body>
		<div class="error">
			<span class="status">` + status + '</span>\n			<div class="message">\n				<h1>' + message + "</h1>\n			</div>\n		</div>\n	</body>\n</html>\n"
  },
  version_hash: "1x117rr"
};
async function get_hooks() {
  return {
    ...await Promise.resolve().then(() => (init_hooks_server(), hooks_server_exports))
  };
}
__name(get_hooks, "get_hooks");
init_chunks();
init_exports();
init_stringify();
init_index4();
init_environment();
var SVELTE_KIT_ASSETS = "/_svelte_kit_assets";
var ENDPOINT_METHODS = ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS", "HEAD"];
var PAGE_METHODS = ["GET", "POST", "HEAD"];
function negotiate(accept, types) {
  const parts = [];
  accept.split(",").forEach((str, i2) => {
    const match = /([^/ \t]+)\/([^; \t]+)[ \t]*(?:;[ \t]*q=([0-9.]+))?/.exec(str);
    if (match) {
      const [, type, subtype, q2 = "1"] = match;
      parts.push({ type, subtype, q: +q2, i: i2 });
    }
  });
  parts.sort((a2, b) => {
    if (a2.q !== b.q) {
      return b.q - a2.q;
    }
    if (a2.subtype === "*" !== (b.subtype === "*")) {
      return a2.subtype === "*" ? 1 : -1;
    }
    if (a2.type === "*" !== (b.type === "*")) {
      return a2.type === "*" ? 1 : -1;
    }
    return a2.i - b.i;
  });
  let accepted;
  let min_priority = Infinity;
  for (const mimetype of types) {
    const [type, subtype] = mimetype.split("/");
    const priority = parts.findIndex(
      (part) => (part.type === type || part.type === "*") && (part.subtype === subtype || part.subtype === "*")
    );
    if (priority !== -1 && priority < min_priority) {
      accepted = mimetype;
      min_priority = priority;
    }
  }
  return accepted;
}
__name(negotiate, "negotiate");
function is_content_type(request, ...types) {
  const type = request.headers.get("content-type")?.split(";", 1)[0].trim() ?? "";
  return types.includes(type.toLowerCase());
}
__name(is_content_type, "is_content_type");
function is_form_content_type(request) {
  return is_content_type(
    request,
    "application/x-www-form-urlencoded",
    "multipart/form-data",
    "text/plain"
  );
}
__name(is_form_content_type, "is_form_content_type");
function coalesce_to_error(err) {
  return err instanceof Error || err && /** @type {any} */
  err.name && /** @type {any} */
  err.message ? (
    /** @type {Error} */
    err
  ) : new Error(JSON.stringify(err));
}
__name(coalesce_to_error, "coalesce_to_error");
function normalize_error(error2) {
  return (
    /** @type {import('../runtime/control.js').Redirect | HttpError | SvelteKitError | Error} */
    error2
  );
}
__name(normalize_error, "normalize_error");
function get_status(error2) {
  return error2 instanceof HttpError || error2 instanceof SvelteKitError ? error2.status : 500;
}
__name(get_status, "get_status");
function get_message(error2) {
  return error2 instanceof SvelteKitError ? error2.text : "Internal Error";
}
__name(get_message, "get_message");
function method_not_allowed(mod, method) {
  return text2(`${method} method not allowed`, {
    status: 405,
    headers: {
      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
      // "The server must generate an Allow header field in a 405 status code response"
      allow: allowed_methods(mod).join(", ")
    }
  });
}
__name(method_not_allowed, "method_not_allowed");
function allowed_methods(mod) {
  const allowed = ENDPOINT_METHODS.filter((method) => method in mod);
  if ("GET" in mod || "HEAD" in mod)
    allowed.push("HEAD");
  return allowed;
}
__name(allowed_methods, "allowed_methods");
function static_error_page(options2, status, message) {
  let page3 = options2.templates.error({ status, message });
  return text2(page3, {
    headers: { "content-type": "text/html; charset=utf-8" },
    status
  });
}
__name(static_error_page, "static_error_page");
async function handle_fatal_error(event, options2, error2) {
  error2 = error2 instanceof HttpError ? error2 : coalesce_to_error(error2);
  const status = get_status(error2);
  const body2 = await handle_error_and_jsonify(event, options2, error2);
  const type = negotiate(event.request.headers.get("accept") || "text/html", [
    "application/json",
    "text/html"
  ]);
  if (event.isDataRequest || type === "application/json") {
    return json(body2, {
      status
    });
  }
  return static_error_page(options2, status, body2.message);
}
__name(handle_fatal_error, "handle_fatal_error");
async function handle_error_and_jsonify(event, options2, error2) {
  if (error2 instanceof HttpError) {
    return error2.body;
  }
  const status = get_status(error2);
  const message = get_message(error2);
  return await options2.hooks.handleError({ error: error2, event, status, message }) ?? { message };
}
__name(handle_error_and_jsonify, "handle_error_and_jsonify");
function redirect_response(status, location2) {
  const response = new Response(void 0, {
    status,
    headers: { location: location2 }
  });
  return response;
}
__name(redirect_response, "redirect_response");
function clarify_devalue_error(event, error2) {
  if (error2.path) {
    return `Data returned from \`load\` while rendering ${event.route.id} is not serializable: ${error2.message} (data${error2.path})`;
  }
  if (error2.path === "") {
    return `Data returned from \`load\` while rendering ${event.route.id} is not a plain object`;
  }
  return error2.message;
}
__name(clarify_devalue_error, "clarify_devalue_error");
function stringify_uses(node) {
  const uses = [];
  if (node.uses && node.uses.dependencies.size > 0) {
    uses.push(`"dependencies":${JSON.stringify(Array.from(node.uses.dependencies))}`);
  }
  if (node.uses && node.uses.search_params.size > 0) {
    uses.push(`"search_params":${JSON.stringify(Array.from(node.uses.search_params))}`);
  }
  if (node.uses && node.uses.params.size > 0) {
    uses.push(`"params":${JSON.stringify(Array.from(node.uses.params))}`);
  }
  if (node.uses?.parent)
    uses.push('"parent":1');
  if (node.uses?.route)
    uses.push('"route":1');
  if (node.uses?.url)
    uses.push('"url":1');
  return `"uses":{${uses.join(",")}}`;
}
__name(stringify_uses, "stringify_uses");
async function render_endpoint(event, mod, state) {
  const method = (
    /** @type {import('types').HttpMethod} */
    event.request.method
  );
  let handler = mod[method] || mod.fallback;
  if (method === "HEAD" && mod.GET && !mod.HEAD) {
    handler = mod.GET;
  }
  if (!handler) {
    return method_not_allowed(mod, method);
  }
  const prerender = mod.prerender ?? state.prerender_default;
  if (prerender && (mod.POST || mod.PATCH || mod.PUT || mod.DELETE)) {
    throw new Error("Cannot prerender endpoints that have mutative methods");
  }
  if (state.prerendering && !prerender) {
    if (state.depth > 0) {
      throw new Error(`${event.route.id} is not prerenderable`);
    } else {
      return new Response(void 0, { status: 204 });
    }
  }
  try {
    let response = await handler(
      /** @type {import('@sveltejs/kit').RequestEvent<Record<string, any>>} */
      event
    );
    if (!(response instanceof Response)) {
      throw new Error(
        `Invalid response from route ${event.url.pathname}: handler should return a Response object`
      );
    }
    if (state.prerendering) {
      response = new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers: new Headers(response.headers)
      });
      response.headers.set("x-sveltekit-prerender", String(prerender));
    }
    return response;
  } catch (e3) {
    if (e3 instanceof Redirect) {
      return new Response(void 0, {
        status: e3.status,
        headers: { location: e3.location }
      });
    }
    throw e3;
  }
}
__name(render_endpoint, "render_endpoint");
function is_endpoint_request(event) {
  const { method, headers: headers2 } = event.request;
  if (ENDPOINT_METHODS.includes(method) && !PAGE_METHODS.includes(method)) {
    return true;
  }
  if (method === "POST" && headers2.get("x-sveltekit-action") === "true")
    return false;
  const accept = event.request.headers.get("accept") ?? "*/*";
  return negotiate(accept, ["*", "text/html"]) !== "text/html";
}
__name(is_endpoint_request, "is_endpoint_request");
function compact(arr) {
  return arr.filter(
    /** @returns {val is NonNullable<T>} */
    (val) => val != null
  );
}
__name(compact, "compact");
var chars$1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
var unsafe_chars = /[<\b\f\n\r\t\0\u2028\u2029]/g;
var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
function uneval(value, replacer) {
  const counts = /* @__PURE__ */ new Map();
  const keys = [];
  const custom2 = /* @__PURE__ */ new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new DevalueError(`Cannot stringify a function`, keys);
    }
    if (!is_primitive(thing)) {
      if (counts.has(thing)) {
        counts.set(thing, counts.get(thing) + 1);
        return;
      }
      counts.set(thing, 1);
      if (replacer) {
        const str2 = replacer(thing);
        if (typeof str2 === "string") {
          custom2.set(thing, str2);
          return;
        }
      }
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "BigInt":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach((value2, i2) => {
            keys.push(`[${i2}]`);
            walk(value2);
            keys.pop();
          });
          break;
        case "Set":
          Array.from(thing).forEach(walk);
          break;
        case "Map":
          for (const [key2, value2] of thing) {
            keys.push(
              `.get(${is_primitive(key2) ? stringify_primitive2(key2) : "..."})`
            );
            walk(value2);
            keys.pop();
          }
          break;
        case "Int8Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Int16Array":
        case "Uint16Array":
        case "Int32Array":
        case "Uint32Array":
        case "Float32Array":
        case "Float64Array":
        case "BigInt64Array":
        case "BigUint64Array":
          return;
        case "ArrayBuffer":
          return;
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys
            );
          }
          if (enumerable_symbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys
            );
          }
          for (const key2 in thing) {
            keys.push(stringify_key(key2));
            walk(thing[key2]);
            keys.pop();
          }
      }
    }
  }
  __name(walk, "walk");
  walk(value);
  const names = /* @__PURE__ */ new Map();
  Array.from(counts).filter((entry) => entry[1] > 1).sort((a2, b) => b[1] - a2[1]).forEach((entry, i2) => {
    names.set(entry[0], get_name(i2));
  });
  function stringify22(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (is_primitive(thing)) {
      return stringify_primitive2(thing);
    }
    if (custom2.has(thing)) {
      return custom2.get(thing);
    }
    const type = get_type(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return `Object(${stringify22(thing.valueOf())})`;
      case "RegExp":
        return `new RegExp(${stringify_string(thing.source)}, "${thing.flags}")`;
      case "Date":
        return `new Date(${thing.getTime()})`;
      case "Array":
        const members = (
          /** @type {any[]} */
          thing.map(
            (v2, i2) => i2 in thing ? stringify22(v2) : ""
          )
        );
        const tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return `[${members.join(",")}${tail}]`;
      case "Set":
      case "Map":
        return `new ${type}([${Array.from(thing).map(stringify22).join(",")}])`;
      case "Int8Array":
      case "Uint8Array":
      case "Uint8ClampedArray":
      case "Int16Array":
      case "Uint16Array":
      case "Int32Array":
      case "Uint32Array":
      case "Float32Array":
      case "Float64Array":
      case "BigInt64Array":
      case "BigUint64Array": {
        const typedArray = thing;
        return `new ${type}([${typedArray.toString()}])`;
      }
      case "ArrayBuffer": {
        const ui8 = new Uint8Array(thing);
        return `new Uint8Array([${ui8.toString()}]).buffer`;
      }
      default:
        const obj = `{${Object.keys(thing).map((key2) => `${safe_key(key2)}:${stringify22(thing[key2])}`).join(",")}}`;
        const proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? `Object.assign(Object.create(null),${obj})` : `Object.create(null)`;
        }
        return obj;
    }
  }
  __name(stringify22, "stringify22");
  const str = stringify22(value);
  if (names.size) {
    const params = [];
    const statements = [];
    const values = [];
    names.forEach((name3, thing) => {
      params.push(name3);
      if (custom2.has(thing)) {
        values.push(
          /** @type {string} */
          custom2.get(thing)
        );
        return;
      }
      if (is_primitive(thing)) {
        values.push(stringify_primitive2(thing));
        return;
      }
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values.push(`Object(${stringify22(thing.valueOf())})`);
          break;
        case "RegExp":
          values.push(thing.toString());
          break;
        case "Date":
          values.push(`new Date(${thing.getTime()})`);
          break;
        case "Array":
          values.push(`Array(${thing.length})`);
          thing.forEach((v2, i2) => {
            statements.push(`${name3}[${i2}]=${stringify22(v2)}`);
          });
          break;
        case "Set":
          values.push(`new Set`);
          statements.push(
            `${name3}.${Array.from(thing).map((v2) => `add(${stringify22(v2)})`).join(".")}`
          );
          break;
        case "Map":
          values.push(`new Map`);
          statements.push(
            `${name3}.${Array.from(thing).map(([k, v2]) => `set(${stringify22(k)}, ${stringify22(v2)})`).join(".")}`
          );
          break;
        default:
          values.push(
            Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}"
          );
          Object.keys(thing).forEach((key2) => {
            statements.push(
              `${name3}${safe_prop(key2)}=${stringify22(thing[key2])}`
            );
          });
      }
    });
    statements.push(`return ${str}`);
    return `(function(${params.join(",")}){${statements.join(
      ";"
    )}}(${values.join(",")}))`;
  } else {
    return str;
  }
}
__name(uneval, "uneval");
function get_name(num) {
  let name3 = "";
  do {
    name3 = chars$1[num % chars$1.length] + name3;
    num = ~~(num / chars$1.length) - 1;
  } while (num >= 0);
  return reserved.test(name3) ? `${name3}0` : name3;
}
__name(get_name, "get_name");
function escape_unsafe_char(c2) {
  return escaped[c2] || c2;
}
__name(escape_unsafe_char, "escape_unsafe_char");
function escape_unsafe_chars(str) {
  return str.replace(unsafe_chars, escape_unsafe_char);
}
__name(escape_unsafe_chars, "escape_unsafe_chars");
function safe_key(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? key2 : escape_unsafe_chars(JSON.stringify(key2));
}
__name(safe_key, "safe_key");
function safe_prop(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? `.${key2}` : `[${escape_unsafe_chars(JSON.stringify(key2))}]`;
}
__name(safe_prop, "safe_prop");
function stringify_primitive2(thing) {
  if (typeof thing === "string")
    return stringify_string(thing);
  if (thing === void 0)
    return "void 0";
  if (thing === 0 && 1 / thing < 0)
    return "-0";
  const str = String(thing);
  if (typeof thing === "number")
    return str.replace(/^(-)?0\./, "$1.");
  if (typeof thing === "bigint")
    return thing + "n";
  return str;
}
__name(stringify_primitive2, "stringify_primitive2");
function is_action_json_request(event) {
  const accept = negotiate(event.request.headers.get("accept") ?? "*/*", [
    "application/json",
    "text/html"
  ]);
  return accept === "application/json" && event.request.method === "POST";
}
__name(is_action_json_request, "is_action_json_request");
async function handle_action_json_request(event, options2, server2) {
  const actions4 = server2?.actions;
  if (!actions4) {
    const no_actions_error = new SvelteKitError(
      405,
      "Method Not Allowed",
      "POST method not allowed. No actions exist for this page"
    );
    return action_json(
      {
        type: "error",
        error: await handle_error_and_jsonify(event, options2, no_actions_error)
      },
      {
        status: no_actions_error.status,
        headers: {
          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
          // "The server must generate an Allow header field in a 405 status code response"
          allow: "GET"
        }
      }
    );
  }
  check_named_default_separate(actions4);
  try {
    const data = await call_action(event, actions4);
    if (false)
      ;
    if (data instanceof ActionFailure) {
      return action_json({
        type: "failure",
        status: data.status,
        // @ts-expect-error we assign a string to what is supposed to be an object. That's ok
        // because we don't use the object outside, and this way we have better code navigation
        // through knowing where the related interface is used.
        data: stringify_action_response(
          data.data,
          /** @type {string} */
          event.route.id
        )
      });
    } else {
      return action_json({
        type: "success",
        status: data ? 200 : 204,
        // @ts-expect-error see comment above
        data: stringify_action_response(
          data,
          /** @type {string} */
          event.route.id
        )
      });
    }
  } catch (e3) {
    const err = normalize_error(e3);
    if (err instanceof Redirect) {
      return action_json_redirect(err);
    }
    return action_json(
      {
        type: "error",
        error: await handle_error_and_jsonify(event, options2, check_incorrect_fail_use(err))
      },
      {
        status: get_status(err)
      }
    );
  }
}
__name(handle_action_json_request, "handle_action_json_request");
function check_incorrect_fail_use(error2) {
  return error2 instanceof ActionFailure ? new Error('Cannot "throw fail()". Use "return fail()"') : error2;
}
__name(check_incorrect_fail_use, "check_incorrect_fail_use");
function action_json_redirect(redirect2) {
  return action_json({
    type: "redirect",
    status: redirect2.status,
    location: redirect2.location
  });
}
__name(action_json_redirect, "action_json_redirect");
function action_json(data, init2) {
  return json(data, init2);
}
__name(action_json, "action_json");
function is_action_request(event) {
  return event.request.method === "POST";
}
__name(is_action_request, "is_action_request");
async function handle_action_request(event, server2) {
  const actions4 = server2?.actions;
  if (!actions4) {
    event.setHeaders({
      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
      // "The server must generate an Allow header field in a 405 status code response"
      allow: "GET"
    });
    return {
      type: "error",
      error: new SvelteKitError(
        405,
        "Method Not Allowed",
        "POST method not allowed. No actions exist for this page"
      )
    };
  }
  check_named_default_separate(actions4);
  try {
    const data = await call_action(event, actions4);
    if (false)
      ;
    if (data instanceof ActionFailure) {
      return {
        type: "failure",
        status: data.status,
        data: data.data
      };
    } else {
      return {
        type: "success",
        status: 200,
        // @ts-expect-error this will be removed upon serialization, so `undefined` is the same as omission
        data
      };
    }
  } catch (e3) {
    const err = normalize_error(e3);
    if (err instanceof Redirect) {
      return {
        type: "redirect",
        status: err.status,
        location: err.location
      };
    }
    return {
      type: "error",
      error: check_incorrect_fail_use(err)
    };
  }
}
__name(handle_action_request, "handle_action_request");
function check_named_default_separate(actions4) {
  if (actions4.default && Object.keys(actions4).length > 1) {
    throw new Error(
      "When using named actions, the default action cannot be used. See the docs for more info: https://svelte.dev/docs/kit/form-actions#named-actions"
    );
  }
}
__name(check_named_default_separate, "check_named_default_separate");
async function call_action(event, actions4) {
  const url = new URL(event.request.url);
  let name3 = "default";
  for (const param of url.searchParams) {
    if (param[0].startsWith("/")) {
      name3 = param[0].slice(1);
      if (name3 === "default") {
        throw new Error('Cannot use reserved action name "default"');
      }
      break;
    }
  }
  const action = actions4[name3];
  if (!action) {
    throw new SvelteKitError(404, "Not Found", `No action with name '${name3}' found`);
  }
  if (!is_form_content_type(event.request)) {
    throw new SvelteKitError(
      415,
      "Unsupported Media Type",
      `Form actions expect form-encoded data \u2014 received ${event.request.headers.get(
        "content-type"
      )}`
    );
  }
  return action(event);
}
__name(call_action, "call_action");
function uneval_action_response(data, route_id) {
  return try_deserialize(data, uneval, route_id);
}
__name(uneval_action_response, "uneval_action_response");
function stringify_action_response(data, route_id) {
  return try_deserialize(data, stringify2, route_id);
}
__name(stringify_action_response, "stringify_action_response");
function try_deserialize(data, fn, route_id) {
  try {
    return fn(data);
  } catch (e3) {
    const error2 = (
      /** @type {any} */
      e3
    );
    if (data instanceof Response) {
      throw new Error(
        `Data returned from action inside ${route_id} is not serializable. Form actions need to return plain objects or fail(). E.g. return { success: true } or return fail(400, { message: "invalid" });`
      );
    }
    if ("path" in error2) {
      let message = `Data returned from action inside ${route_id} is not serializable: ${error2.message}`;
      if (error2.path !== "")
        message += ` (data.${error2.path})`;
      throw new Error(message);
    }
    throw error2;
  }
}
__name(try_deserialize, "try_deserialize");
var INVALIDATED_PARAM = "x-sveltekit-invalidated";
var TRAILING_SLASH_PARAM = "x-sveltekit-trailing-slash";
function b64_encode(buffer) {
  if (globalThis.Buffer) {
    return Buffer.from(buffer).toString("base64");
  }
  const little_endian = new Uint8Array(new Uint16Array([1]).buffer)[0] > 0;
  return btoa(
    new TextDecoder(little_endian ? "utf-16le" : "utf-16be").decode(
      new Uint16Array(new Uint8Array(buffer))
    )
  );
}
__name(b64_encode, "b64_encode");
async function load_server_data({ event, state, node, parent }) {
  if (!node?.server)
    return null;
  let is_tracking = true;
  const uses = {
    dependencies: /* @__PURE__ */ new Set(),
    params: /* @__PURE__ */ new Set(),
    parent: false,
    route: false,
    url: false,
    search_params: /* @__PURE__ */ new Set()
  };
  const url = make_trackable(
    event.url,
    () => {
      if (is_tracking) {
        uses.url = true;
      }
    },
    (param) => {
      if (is_tracking) {
        uses.search_params.add(param);
      }
    }
  );
  if (state.prerendering) {
    disable_search(url);
  }
  const result = await node.server.load?.call(null, {
    ...event,
    fetch: (info, init2) => {
      new URL(info instanceof Request ? info.url : info, event.url);
      return event.fetch(info, init2);
    },
    /** @param {string[]} deps */
    depends: (...deps) => {
      for (const dep of deps) {
        const { href } = new URL(dep, event.url);
        uses.dependencies.add(href);
      }
    },
    params: new Proxy(event.params, {
      get: (target, key2) => {
        if (is_tracking) {
          uses.params.add(key2);
        }
        return target[
          /** @type {string} */
          key2
        ];
      }
    }),
    parent: async () => {
      if (is_tracking) {
        uses.parent = true;
      }
      return parent();
    },
    route: new Proxy(event.route, {
      get: (target, key2) => {
        if (is_tracking) {
          uses.route = true;
        }
        return target[
          /** @type {'id'} */
          key2
        ];
      }
    }),
    url,
    untrack(fn) {
      is_tracking = false;
      try {
        return fn();
      } finally {
        is_tracking = true;
      }
    }
  });
  return {
    type: "data",
    data: result ?? null,
    uses,
    slash: node.server.trailingSlash
  };
}
__name(load_server_data, "load_server_data");
async function load_data({
  event,
  fetched,
  node,
  parent,
  server_data_promise,
  state,
  resolve_opts,
  csr
}) {
  const server_data_node = await server_data_promise;
  if (!node?.universal?.load) {
    return server_data_node?.data ?? null;
  }
  const result = await node.universal.load.call(null, {
    url: event.url,
    params: event.params,
    data: server_data_node?.data ?? null,
    route: event.route,
    fetch: create_universal_fetch(event, state, fetched, csr, resolve_opts),
    setHeaders: event.setHeaders,
    depends: () => {
    },
    parent,
    untrack: (fn) => fn()
  });
  return result ?? null;
}
__name(load_data, "load_data");
function create_universal_fetch(event, state, fetched, csr, resolve_opts) {
  const universal_fetch = /* @__PURE__ */ __name(async (input, init2) => {
    const cloned_body = input instanceof Request && input.body ? input.clone().body : null;
    const cloned_headers = input instanceof Request && [...input.headers].length ? new Headers(input.headers) : init2?.headers;
    let response = await event.fetch(input, init2);
    const url = new URL(input instanceof Request ? input.url : input, event.url);
    const same_origin = url.origin === event.url.origin;
    let dependency;
    if (same_origin) {
      if (state.prerendering) {
        dependency = { response, body: null };
        state.prerendering.dependencies.set(url.pathname, dependency);
      }
    } else {
      const mode = input instanceof Request ? input.mode : init2?.mode ?? "cors";
      if (mode === "no-cors") {
        response = new Response("", {
          status: response.status,
          statusText: response.statusText,
          headers: response.headers
        });
      } else {
        const acao = response.headers.get("access-control-allow-origin");
        if (!acao || acao !== event.url.origin && acao !== "*") {
          throw new Error(
            `CORS error: ${acao ? "Incorrect" : "No"} 'Access-Control-Allow-Origin' header is present on the requested resource`
          );
        }
      }
    }
    const proxy = new Proxy(response, {
      get(response2, key2, _receiver) {
        async function push_fetched(body2, is_b64) {
          const status_number = Number(response2.status);
          if (isNaN(status_number)) {
            throw new Error(
              `response.status is not a number. value: "${response2.status}" type: ${typeof response2.status}`
            );
          }
          fetched.push({
            url: same_origin ? url.href.slice(event.url.origin.length) : url.href,
            method: event.request.method,
            request_body: (
              /** @type {string | ArrayBufferView | undefined} */
              input instanceof Request && cloned_body ? await stream_to_string(cloned_body) : init2?.body
            ),
            request_headers: cloned_headers,
            response_body: body2,
            response: response2,
            is_b64
          });
        }
        __name(push_fetched, "push_fetched");
        if (key2 === "arrayBuffer") {
          return async () => {
            const buffer = await response2.arrayBuffer();
            if (dependency) {
              dependency.body = new Uint8Array(buffer);
            }
            if (buffer instanceof ArrayBuffer) {
              await push_fetched(b64_encode(buffer), true);
            }
            return buffer;
          };
        }
        async function text22() {
          const body2 = await response2.text();
          if (!body2 || typeof body2 === "string") {
            await push_fetched(body2, false);
          }
          if (dependency) {
            dependency.body = body2;
          }
          return body2;
        }
        __name(text22, "text22");
        if (key2 === "text") {
          return text22;
        }
        if (key2 === "json") {
          return async () => {
            return JSON.parse(await text22());
          };
        }
        return Reflect.get(response2, key2, response2);
      }
    });
    if (csr) {
      const get4 = response.headers.get;
      response.headers.get = (key2) => {
        const lower = key2.toLowerCase();
        const value = get4.call(response.headers, lower);
        if (value && !lower.startsWith("x-sveltekit-")) {
          const included = resolve_opts.filterSerializedResponseHeaders(lower, value);
          if (!included) {
            throw new Error(
              `Failed to get response header "${lower}" \u2014 it must be included by the \`filterSerializedResponseHeaders\` option: https://svelte.dev/docs/kit/hooks#Server-hooks-handle (at ${event.route.id})`
            );
          }
        }
        return value;
      };
    }
    return proxy;
  }, "universal_fetch");
  return (input, init2) => {
    const response = universal_fetch(input, init2);
    response.catch(() => {
    });
    return response;
  };
}
__name(create_universal_fetch, "create_universal_fetch");
async function stream_to_string(stream) {
  let result = "";
  const reader = stream.getReader();
  const decoder = new TextDecoder();
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      break;
    }
    result += decoder.decode(value);
  }
  return result;
}
__name(stream_to_string, "stream_to_string");
function hash(...values) {
  let hash2 = 5381;
  for (const value of values) {
    if (typeof value === "string") {
      let i2 = value.length;
      while (i2)
        hash2 = hash2 * 33 ^ value.charCodeAt(--i2);
    } else if (ArrayBuffer.isView(value)) {
      const buffer = new Uint8Array(value.buffer, value.byteOffset, value.byteLength);
      let i2 = buffer.length;
      while (i2)
        hash2 = hash2 * 33 ^ buffer[--i2];
    } else {
      throw new TypeError("value must be a string or TypedArray");
    }
  }
  return (hash2 >>> 0).toString(36);
}
__name(hash, "hash");
var escape_html_attr_dict = {
  "&": "&amp;",
  '"': "&quot;"
};
var escape_html_attr_regex = new RegExp(
  // special characters
  `[${Object.keys(escape_html_attr_dict).join("")}]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\udc00-\\udfff]`,
  "g"
);
function escape_html_attr(str) {
  const escaped_str = str.replace(escape_html_attr_regex, (match) => {
    if (match.length === 2) {
      return match;
    }
    return escape_html_attr_dict[match] ?? `&#${match.charCodeAt(0)};`;
  });
  return `"${escaped_str}"`;
}
__name(escape_html_attr, "escape_html_attr");
var replacements2 = {
  "<": "\\u003C",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var pattern = new RegExp(`[${Object.keys(replacements2).join("")}]`, "g");
function serialize_data(fetched, filter, prerendering2 = false) {
  const headers2 = {};
  let cache_control = null;
  let age = null;
  let varyAny = false;
  for (const [key2, value] of fetched.response.headers) {
    if (filter(key2, value)) {
      headers2[key2] = value;
    }
    if (key2 === "cache-control")
      cache_control = value;
    else if (key2 === "age")
      age = value;
    else if (key2 === "vary" && value.trim() === "*")
      varyAny = true;
  }
  const payload = {
    status: fetched.response.status,
    statusText: fetched.response.statusText,
    headers: headers2,
    body: fetched.response_body
  };
  const safe_payload = JSON.stringify(payload).replace(pattern, (match) => replacements2[match]);
  const attrs = [
    'type="application/json"',
    "data-sveltekit-fetched",
    `data-url=${escape_html_attr(fetched.url)}`
  ];
  if (fetched.is_b64) {
    attrs.push("data-b64");
  }
  if (fetched.request_headers || fetched.request_body) {
    const values = [];
    if (fetched.request_headers) {
      values.push([...new Headers(fetched.request_headers)].join(","));
    }
    if (fetched.request_body) {
      values.push(fetched.request_body);
    }
    attrs.push(`data-hash="${hash(...values)}"`);
  }
  if (!prerendering2 && fetched.method === "GET" && cache_control && !varyAny) {
    const match = /s-maxage=(\d+)/g.exec(cache_control) ?? /max-age=(\d+)/g.exec(cache_control);
    if (match) {
      const ttl = +match[1] - +(age ?? "0");
      attrs.push(`data-ttl="${ttl}"`);
    }
  }
  return `<script ${attrs.join(" ")}>${safe_payload}<\/script>`;
}
__name(serialize_data, "serialize_data");
var s = JSON.stringify;
var encoder$2 = new TextEncoder();
function sha2562(data) {
  if (!key[0])
    precompute();
  const out = init.slice(0);
  const array22 = encode$1(data);
  for (let i2 = 0; i2 < array22.length; i2 += 16) {
    const w = array22.subarray(i2, i2 + 16);
    let tmp;
    let a2;
    let b;
    let out0 = out[0];
    let out1 = out[1];
    let out2 = out[2];
    let out3 = out[3];
    let out4 = out[4];
    let out5 = out[5];
    let out6 = out[6];
    let out7 = out[7];
    for (let i22 = 0; i22 < 64; i22++) {
      if (i22 < 16) {
        tmp = w[i22];
      } else {
        a2 = w[i22 + 1 & 15];
        b = w[i22 + 14 & 15];
        tmp = w[i22 & 15] = (a2 >>> 7 ^ a2 >>> 18 ^ a2 >>> 3 ^ a2 << 25 ^ a2 << 14) + (b >>> 17 ^ b >>> 19 ^ b >>> 10 ^ b << 15 ^ b << 13) + w[i22 & 15] + w[i22 + 9 & 15] | 0;
      }
      tmp = tmp + out7 + (out4 >>> 6 ^ out4 >>> 11 ^ out4 >>> 25 ^ out4 << 26 ^ out4 << 21 ^ out4 << 7) + (out6 ^ out4 & (out5 ^ out6)) + key[i22];
      out7 = out6;
      out6 = out5;
      out5 = out4;
      out4 = out3 + tmp | 0;
      out3 = out2;
      out2 = out1;
      out1 = out0;
      out0 = tmp + (out1 & out2 ^ out3 & (out1 ^ out2)) + (out1 >>> 2 ^ out1 >>> 13 ^ out1 >>> 22 ^ out1 << 30 ^ out1 << 19 ^ out1 << 10) | 0;
    }
    out[0] = out[0] + out0 | 0;
    out[1] = out[1] + out1 | 0;
    out[2] = out[2] + out2 | 0;
    out[3] = out[3] + out3 | 0;
    out[4] = out[4] + out4 | 0;
    out[5] = out[5] + out5 | 0;
    out[6] = out[6] + out6 | 0;
    out[7] = out[7] + out7 | 0;
  }
  const bytes = new Uint8Array(out.buffer);
  reverse_endianness(bytes);
  return base64(bytes);
}
__name(sha2562, "sha2562");
var init = new Uint32Array(8);
var key = new Uint32Array(64);
function precompute() {
  function frac(x2) {
    return (x2 - Math.floor(x2)) * 4294967296;
  }
  __name(frac, "frac");
  let prime = 2;
  for (let i2 = 0; i2 < 64; prime++) {
    let is_prime = true;
    for (let factor = 2; factor * factor <= prime; factor++) {
      if (prime % factor === 0) {
        is_prime = false;
        break;
      }
    }
    if (is_prime) {
      if (i2 < 8) {
        init[i2] = frac(prime ** (1 / 2));
      }
      key[i2] = frac(prime ** (1 / 3));
      i2++;
    }
  }
}
__name(precompute, "precompute");
function reverse_endianness(bytes) {
  for (let i2 = 0; i2 < bytes.length; i2 += 4) {
    const a2 = bytes[i2 + 0];
    const b = bytes[i2 + 1];
    const c2 = bytes[i2 + 2];
    const d = bytes[i2 + 3];
    bytes[i2 + 0] = d;
    bytes[i2 + 1] = c2;
    bytes[i2 + 2] = b;
    bytes[i2 + 3] = a2;
  }
}
__name(reverse_endianness, "reverse_endianness");
function encode$1(str) {
  const encoded = encoder$2.encode(str);
  const length = encoded.length * 8;
  const size2 = 512 * Math.ceil((length + 65) / 512);
  const bytes = new Uint8Array(size2 / 8);
  bytes.set(encoded);
  bytes[encoded.length] = 128;
  reverse_endianness(bytes);
  const words = new Uint32Array(bytes.buffer);
  words[words.length - 2] = Math.floor(length / 4294967296);
  words[words.length - 1] = length;
  return words;
}
__name(encode$1, "encode$1");
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
function base64(bytes) {
  const l2 = bytes.length;
  let result = "";
  let i2;
  for (i2 = 2; i2 < l2; i2 += 3) {
    result += chars[bytes[i2 - 2] >> 2];
    result += chars[(bytes[i2 - 2] & 3) << 4 | bytes[i2 - 1] >> 4];
    result += chars[(bytes[i2 - 1] & 15) << 2 | bytes[i2] >> 6];
    result += chars[bytes[i2] & 63];
  }
  if (i2 === l2 + 1) {
    result += chars[bytes[i2 - 2] >> 2];
    result += chars[(bytes[i2 - 2] & 3) << 4];
    result += "==";
  }
  if (i2 === l2) {
    result += chars[bytes[i2 - 2] >> 2];
    result += chars[(bytes[i2 - 2] & 3) << 4 | bytes[i2 - 1] >> 4];
    result += chars[(bytes[i2 - 1] & 15) << 2];
    result += "=";
  }
  return result;
}
__name(base64, "base64");
var array2 = new Uint8Array(16);
function generate_nonce() {
  crypto.getRandomValues(array2);
  return base64(array2);
}
__name(generate_nonce, "generate_nonce");
var quoted = /* @__PURE__ */ new Set([
  "self",
  "unsafe-eval",
  "unsafe-hashes",
  "unsafe-inline",
  "none",
  "strict-dynamic",
  "report-sample",
  "wasm-unsafe-eval",
  "script"
]);
var crypto_pattern = /^(nonce|sha\d\d\d)-/;
var BaseProvider = /* @__PURE__ */ __name(class {
  /** @type {boolean} */
  #use_hashes;
  /** @type {boolean} */
  #script_needs_csp;
  /** @type {boolean} */
  #style_needs_csp;
  /** @type {import('types').CspDirectives} */
  #directives;
  /** @type {import('types').Csp.Source[]} */
  #script_src;
  /** @type {import('types').Csp.Source[]} */
  #script_src_elem;
  /** @type {import('types').Csp.Source[]} */
  #style_src;
  /** @type {import('types').Csp.Source[]} */
  #style_src_attr;
  /** @type {import('types').Csp.Source[]} */
  #style_src_elem;
  /** @type {string} */
  #nonce;
  /**
   * @param {boolean} use_hashes
   * @param {import('types').CspDirectives} directives
   * @param {string} nonce
   */
  constructor(use_hashes, directives, nonce) {
    this.#use_hashes = use_hashes;
    this.#directives = directives;
    const d = this.#directives;
    this.#script_src = [];
    this.#script_src_elem = [];
    this.#style_src = [];
    this.#style_src_attr = [];
    this.#style_src_elem = [];
    const effective_script_src = d["script-src"] || d["default-src"];
    const script_src_elem = d["script-src-elem"];
    const effective_style_src = d["style-src"] || d["default-src"];
    const style_src_attr = d["style-src-attr"];
    const style_src_elem = d["style-src-elem"];
    this.#script_needs_csp = !!effective_script_src && effective_script_src.filter((value) => value !== "unsafe-inline").length > 0 || !!script_src_elem && script_src_elem.filter((value) => value !== "unsafe-inline").length > 0;
    this.#style_needs_csp = !!effective_style_src && effective_style_src.filter((value) => value !== "unsafe-inline").length > 0 || !!style_src_attr && style_src_attr.filter((value) => value !== "unsafe-inline").length > 0 || !!style_src_elem && style_src_elem.filter((value) => value !== "unsafe-inline").length > 0;
    this.script_needs_nonce = this.#script_needs_csp && !this.#use_hashes;
    this.style_needs_nonce = this.#style_needs_csp && !this.#use_hashes;
    this.#nonce = nonce;
  }
  /** @param {string} content */
  add_script(content) {
    if (this.#script_needs_csp) {
      const d = this.#directives;
      if (this.#use_hashes) {
        const hash2 = sha2562(content);
        this.#script_src.push(`sha256-${hash2}`);
        if (d["script-src-elem"]?.length) {
          this.#script_src_elem.push(`sha256-${hash2}`);
        }
      } else {
        if (this.#script_src.length === 0) {
          this.#script_src.push(`nonce-${this.#nonce}`);
        }
        if (d["script-src-elem"]?.length) {
          this.#script_src_elem.push(`nonce-${this.#nonce}`);
        }
      }
    }
  }
  /** @param {string} content */
  add_style(content) {
    if (this.#style_needs_csp) {
      const empty_comment_hash = "9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=";
      const d = this.#directives;
      if (this.#use_hashes) {
        const hash2 = sha2562(content);
        this.#style_src.push(`sha256-${hash2}`);
        if (d["style-src-attr"]?.length) {
          this.#style_src_attr.push(`sha256-${hash2}`);
        }
        if (d["style-src-elem"]?.length) {
          if (hash2 !== empty_comment_hash && !d["style-src-elem"].includes(`sha256-${empty_comment_hash}`)) {
            this.#style_src_elem.push(`sha256-${empty_comment_hash}`);
          }
          this.#style_src_elem.push(`sha256-${hash2}`);
        }
      } else {
        if (this.#style_src.length === 0 && !d["style-src"]?.includes("unsafe-inline")) {
          this.#style_src.push(`nonce-${this.#nonce}`);
        }
        if (d["style-src-attr"]?.length) {
          this.#style_src_attr.push(`nonce-${this.#nonce}`);
        }
        if (d["style-src-elem"]?.length) {
          if (!d["style-src-elem"].includes(`sha256-${empty_comment_hash}`)) {
            this.#style_src_elem.push(`sha256-${empty_comment_hash}`);
          }
          this.#style_src_elem.push(`nonce-${this.#nonce}`);
        }
      }
    }
  }
  /**
   * @param {boolean} [is_meta]
   */
  get_header(is_meta = false) {
    const header = [];
    const directives = { ...this.#directives };
    if (this.#style_src.length > 0) {
      directives["style-src"] = [
        ...directives["style-src"] || directives["default-src"] || [],
        ...this.#style_src
      ];
    }
    if (this.#style_src_attr.length > 0) {
      directives["style-src-attr"] = [
        ...directives["style-src-attr"] || [],
        ...this.#style_src_attr
      ];
    }
    if (this.#style_src_elem.length > 0) {
      directives["style-src-elem"] = [
        ...directives["style-src-elem"] || [],
        ...this.#style_src_elem
      ];
    }
    if (this.#script_src.length > 0) {
      directives["script-src"] = [
        ...directives["script-src"] || directives["default-src"] || [],
        ...this.#script_src
      ];
    }
    if (this.#script_src_elem.length > 0) {
      directives["script-src-elem"] = [
        ...directives["script-src-elem"] || [],
        ...this.#script_src_elem
      ];
    }
    for (const key2 in directives) {
      if (is_meta && (key2 === "frame-ancestors" || key2 === "report-uri" || key2 === "sandbox")) {
        continue;
      }
      const value = (
        /** @type {string[] | true} */
        directives[key2]
      );
      if (!value)
        continue;
      const directive = [key2];
      if (Array.isArray(value)) {
        value.forEach((value2) => {
          if (quoted.has(value2) || crypto_pattern.test(value2)) {
            directive.push(`'${value2}'`);
          } else {
            directive.push(value2);
          }
        });
      }
      header.push(directive.join(" "));
    }
    return header.join("; ");
  }
}, "BaseProvider");
var CspProvider = /* @__PURE__ */ __name(class extends BaseProvider {
  get_meta() {
    const content = this.get_header(true);
    if (!content) {
      return;
    }
    return `<meta http-equiv="content-security-policy" content=${escape_html_attr(content)}>`;
  }
}, "CspProvider");
var CspReportOnlyProvider = /* @__PURE__ */ __name(class extends BaseProvider {
  /**
   * @param {boolean} use_hashes
   * @param {import('types').CspDirectives} directives
   * @param {string} nonce
   */
  constructor(use_hashes, directives, nonce) {
    super(use_hashes, directives, nonce);
    if (Object.values(directives).filter((v2) => !!v2).length > 0) {
      const has_report_to = directives["report-to"]?.length ?? 0 > 0;
      const has_report_uri = directives["report-uri"]?.length ?? 0 > 0;
      if (!has_report_to && !has_report_uri) {
        throw Error(
          "`content-security-policy-report-only` must be specified with either the `report-to` or `report-uri` directives, or both"
        );
      }
    }
  }
}, "CspReportOnlyProvider");
var Csp = /* @__PURE__ */ __name(class {
  /** @readonly */
  nonce = generate_nonce();
  /** @type {CspProvider} */
  csp_provider;
  /** @type {CspReportOnlyProvider} */
  report_only_provider;
  /**
   * @param {import('./types.js').CspConfig} config
   * @param {import('./types.js').CspOpts} opts
   */
  constructor({ mode, directives, reportOnly }, { prerender }) {
    const use_hashes = mode === "hash" || mode === "auto" && prerender;
    this.csp_provider = new CspProvider(use_hashes, directives, this.nonce);
    this.report_only_provider = new CspReportOnlyProvider(use_hashes, reportOnly, this.nonce);
  }
  get script_needs_nonce() {
    return this.csp_provider.script_needs_nonce || this.report_only_provider.script_needs_nonce;
  }
  get style_needs_nonce() {
    return this.csp_provider.style_needs_nonce || this.report_only_provider.style_needs_nonce;
  }
  /** @param {string} content */
  add_script(content) {
    this.csp_provider.add_script(content);
    this.report_only_provider.add_script(content);
  }
  /** @param {string} content */
  add_style(content) {
    this.csp_provider.add_style(content);
    this.report_only_provider.add_style(content);
  }
}, "Csp");
function defer() {
  let fulfil;
  let reject;
  const promise = new Promise((f, r3) => {
    fulfil = f;
    reject = r3;
  });
  return { promise, fulfil, reject };
}
__name(defer, "defer");
function create_async_iterator() {
  const deferred = [defer()];
  return {
    iterator: {
      [Symbol.asyncIterator]() {
        return {
          next: async () => {
            const next2 = await deferred[0].promise;
            if (!next2.done)
              deferred.shift();
            return next2;
          }
        };
      }
    },
    push: (value) => {
      deferred[deferred.length - 1].fulfil({
        value,
        done: false
      });
      deferred.push(defer());
    },
    done: () => {
      deferred[deferred.length - 1].fulfil({ done: true });
    }
  };
}
__name(create_async_iterator, "create_async_iterator");
var updated = {
  ...readable(false),
  check: () => false
};
var encoder$1 = new TextEncoder();
async function render_response({
  branch: branch2,
  fetched,
  options: options2,
  manifest: manifest2,
  state,
  page_config,
  status,
  error: error2 = null,
  event,
  resolve_opts,
  action_result
}) {
  if (state.prerendering) {
    if (options2.csp.mode === "nonce") {
      throw new Error('Cannot use prerendering if config.kit.csp.mode === "nonce"');
    }
    if (options2.app_template_contains_nonce) {
      throw new Error("Cannot use prerendering if page template contains %sveltekit.nonce%");
    }
  }
  const { client } = manifest2._;
  const modulepreloads = new Set(client.imports);
  const stylesheets39 = new Set(client.stylesheets);
  const fonts39 = new Set(client.fonts);
  const link_header_preloads = /* @__PURE__ */ new Set();
  const inline_styles = /* @__PURE__ */ new Map();
  let rendered;
  const form_value = action_result?.type === "success" || action_result?.type === "failure" ? action_result.data ?? null : null;
  let base$1 = base;
  let assets$1 = assets;
  let base_expression = s(base);
  if (!state.prerendering?.fallback) {
    const segments = event.url.pathname.slice(base.length).split("/").slice(2);
    base$1 = segments.map(() => "..").join("/") || ".";
    base_expression = `new URL(${s(base$1)}, location).pathname.slice(0, -1)`;
    if (!assets || assets[0] === "/" && assets !== SVELTE_KIT_ASSETS) {
      assets$1 = base$1;
    }
  }
  if (page_config.ssr) {
    const props = {
      stores: {
        page: writable(null),
        navigating: writable(null),
        updated
      },
      constructors: await Promise.all(branch2.map(({ node }) => node.component())),
      form: form_value
    };
    let data2 = {};
    for (let i2 = 0; i2 < branch2.length; i2 += 1) {
      data2 = { ...data2, ...branch2[i2].data };
      props[`data_${i2}`] = data2;
    }
    props.page = {
      error: error2,
      params: (
        /** @type {Record<string, any>} */
        event.params
      ),
      route: event.route,
      status,
      url: event.url,
      data: data2,
      form: form_value,
      state: {}
    };
    override({ base: base$1, assets: assets$1 });
    {
      try {
        rendered = options2.root.render(props);
      } finally {
        reset();
      }
    }
    for (const { node } of branch2) {
      for (const url of node.imports)
        modulepreloads.add(url);
      for (const url of node.stylesheets)
        stylesheets39.add(url);
      for (const url of node.fonts)
        fonts39.add(url);
      if (node.inline_styles) {
        Object.entries(await node.inline_styles()).forEach(([k, v2]) => inline_styles.set(k, v2));
      }
    }
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  let head2 = "";
  let body2 = rendered.html;
  const csp = new Csp(options2.csp, {
    prerender: !!state.prerendering
  });
  const prefixed = /* @__PURE__ */ __name((path) => {
    if (path.startsWith("/")) {
      return base + path;
    }
    return `${assets$1}/${path}`;
  }, "prefixed");
  if (inline_styles.size > 0) {
    const content = Array.from(inline_styles.values()).join("\n");
    const attributes = [];
    if (csp.style_needs_nonce)
      attributes.push(` nonce="${csp.nonce}"`);
    csp.add_style(content);
    head2 += `
	<style${attributes.join("")}>${content}</style>`;
  }
  for (const dep of stylesheets39) {
    const path = prefixed(dep);
    const attributes = ['rel="stylesheet"'];
    if (inline_styles.has(dep)) {
      attributes.push("disabled", 'media="(max-width: 0)"');
    } else {
      if (resolve_opts.preload({ type: "css", path })) {
        const preload_atts = ['rel="preload"', 'as="style"'];
        link_header_preloads.add(`<${encodeURI(path)}>; ${preload_atts.join(";")}; nopush`);
      }
    }
    head2 += `
		<link href="${path}" ${attributes.join(" ")}>`;
  }
  for (const dep of fonts39) {
    const path = prefixed(dep);
    if (resolve_opts.preload({ type: "font", path })) {
      const ext = dep.slice(dep.lastIndexOf(".") + 1);
      const attributes = [
        'rel="preload"',
        'as="font"',
        `type="font/${ext}"`,
        `href="${path}"`,
        "crossorigin"
      ];
      head2 += `
		<link ${attributes.join(" ")}>`;
    }
  }
  const global = `__sveltekit_${options2.version_hash}`;
  const { data, chunks } = get_data(
    event,
    options2,
    branch2.map((b) => b.server_data),
    csp,
    global
  );
  if (page_config.ssr && page_config.csr) {
    body2 += `
			${fetched.map(
      (item) => serialize_data(item, resolve_opts.filterSerializedResponseHeaders, !!state.prerendering)
    ).join("\n			")}`;
  }
  if (page_config.csr) {
    if (client.uses_env_dynamic_public && state.prerendering) {
      modulepreloads.add(`${options2.app_dir}/env.js`);
    }
    const included_modulepreloads = Array.from(modulepreloads, (dep) => prefixed(dep)).filter(
      (path) => resolve_opts.preload({ type: "js", path })
    );
    for (const path of included_modulepreloads) {
      link_header_preloads.add(`<${encodeURI(path)}>; rel="modulepreload"; nopush`);
      if (options2.preload_strategy !== "modulepreload") {
        head2 += `
		<link rel="preload" as="script" crossorigin="anonymous" href="${path}">`;
      } else if (state.prerendering) {
        head2 += `
		<link rel="modulepreload" href="${path}">`;
      }
    }
    const blocks = [];
    const load_env_eagerly = client.uses_env_dynamic_public && state.prerendering;
    const properties = [`base: ${base_expression}`];
    if (assets) {
      properties.push(`assets: ${s(assets)}`);
    }
    if (client.uses_env_dynamic_public) {
      properties.push(`env: ${load_env_eagerly ? "null" : s(public_env)}`);
    }
    if (chunks) {
      blocks.push("const deferred = new Map();");
      properties.push(`defer: (id) => new Promise((fulfil, reject) => {
							deferred.set(id, { fulfil, reject });
						})`);
      properties.push(`resolve: ({ id, data, error }) => {
							const { fulfil, reject } = deferred.get(id);
							deferred.delete(id);

							if (error) reject(error);
							else fulfil(data);
						}`);
    }
    blocks.push(`${global} = {
						${properties.join(",\n						")}
					};`);
    const args = ["app", "element"];
    blocks.push("const element = document.currentScript.parentElement;");
    if (page_config.ssr) {
      const serialized = { form: "null", error: "null" };
      blocks.push(`const data = ${data};`);
      if (form_value) {
        serialized.form = uneval_action_response(
          form_value,
          /** @type {string} */
          event.route.id
        );
      }
      if (error2) {
        serialized.error = uneval(error2);
      }
      const hydrate2 = [
        `node_ids: [${branch2.map(({ node }) => node.index).join(", ")}]`,
        "data",
        `form: ${serialized.form}`,
        `error: ${serialized.error}`
      ];
      if (status !== 200) {
        hydrate2.push(`status: ${status}`);
      }
      if (options2.embedded) {
        hydrate2.push(`params: ${uneval(event.params)}`, `route: ${s(event.route)}`);
      }
      const indent = "	".repeat(load_env_eagerly ? 7 : 6);
      args.push(`{
${indent}	${hydrate2.join(`,
${indent}	`)}
${indent}}`);
    }
    if (load_env_eagerly) {
      blocks.push(`import(${s(`${base$1}/${options2.app_dir}/env.js`)}).then(({ env }) => {
						${global}.env = env;

						Promise.all([
							import(${s(prefixed(client.start))}),
							import(${s(prefixed(client.app))})
						]).then(([kit, app]) => {
							kit.start(${args.join(", ")});
						});
					});`);
    } else {
      blocks.push(`Promise.all([
						import(${s(prefixed(client.start))}),
						import(${s(prefixed(client.app))})
					]).then(([kit, app]) => {
						kit.start(${args.join(", ")});
					});`);
    }
    if (options2.service_worker) {
      const opts = "";
      blocks.push(`if ('serviceWorker' in navigator) {
						addEventListener('load', function () {
							navigator.serviceWorker.register('${prefixed("service-worker.js")}'${opts});
						});
					}`);
    }
    const init_app = `
				{
					${blocks.join("\n\n					")}
				}
			`;
    csp.add_script(init_app);
    body2 += `
			<script${csp.script_needs_nonce ? ` nonce="${csp.nonce}"` : ""}>${init_app}<\/script>
		`;
  }
  const headers2 = new Headers({
    "x-sveltekit-page": "true",
    "content-type": "text/html"
  });
  if (state.prerendering) {
    const http_equiv = [];
    const csp_headers = csp.csp_provider.get_meta();
    if (csp_headers) {
      http_equiv.push(csp_headers);
    }
    if (state.prerendering.cache) {
      http_equiv.push(`<meta http-equiv="cache-control" content="${state.prerendering.cache}">`);
    }
    if (http_equiv.length > 0) {
      head2 = http_equiv.join("\n") + head2;
    }
  } else {
    const csp_header = csp.csp_provider.get_header();
    if (csp_header) {
      headers2.set("content-security-policy", csp_header);
    }
    const report_only_header = csp.report_only_provider.get_header();
    if (report_only_header) {
      headers2.set("content-security-policy-report-only", report_only_header);
    }
    if (link_header_preloads.size) {
      headers2.set("link", Array.from(link_header_preloads).join(", "));
    }
  }
  head2 += rendered.head;
  const html = options2.templates.app({
    head: head2,
    body: body2,
    assets: assets$1,
    nonce: (
      /** @type {string} */
      csp.nonce
    ),
    env: safe_public_env
  });
  const transformed = await resolve_opts.transformPageChunk({
    html,
    done: true
  }) || "";
  if (!chunks) {
    headers2.set("etag", `"${hash(transformed)}"`);
  }
  return !chunks ? text2(transformed, {
    status,
    headers: headers2
  }) : new Response(
    new ReadableStream({
      async start(controller) {
        controller.enqueue(encoder$1.encode(transformed + "\n"));
        for await (const chunk of chunks) {
          controller.enqueue(encoder$1.encode(chunk));
        }
        controller.close();
      },
      type: "bytes"
    }),
    {
      headers: headers2
    }
  );
}
__name(render_response, "render_response");
function get_data(event, options2, nodes, csp, global) {
  let promise_id = 1;
  let count = 0;
  const { iterator, push: push2, done } = create_async_iterator();
  function replacer(thing) {
    if (typeof thing?.then === "function") {
      const id = promise_id++;
      count += 1;
      thing.then(
        /** @param {any} data */
        (data) => ({ data })
      ).catch(
        /** @param {any} error */
        async (error2) => ({
          error: await handle_error_and_jsonify(event, options2, error2)
        })
      ).then(
        /**
         * @param {{data: any; error: any}} result
         */
        async ({ data, error: error2 }) => {
          count -= 1;
          let str;
          try {
            str = uneval({ id, data, error: error2 }, replacer);
          } catch {
            error2 = await handle_error_and_jsonify(
              event,
              options2,
              new Error(`Failed to serialize promise while rendering ${event.route.id}`)
            );
            data = void 0;
            str = uneval({ id, data, error: error2 }, replacer);
          }
          const nonce = csp.script_needs_nonce ? ` nonce="${csp.nonce}"` : "";
          push2(`<script${nonce}>${global}.resolve(${str})<\/script>
`);
          if (count === 0)
            done();
        }
      );
      return `${global}.defer(${id})`;
    }
  }
  __name(replacer, "replacer");
  try {
    const strings = nodes.map((node) => {
      if (!node)
        return "null";
      return `{"type":"data","data":${uneval(node.data, replacer)},${stringify_uses(node)}${node.slash ? `,"slash":${JSON.stringify(node.slash)}` : ""}}`;
    });
    return {
      data: `[${strings.join(",")}]`,
      chunks: count > 0 ? iterator : null
    };
  } catch (e3) {
    throw new Error(clarify_devalue_error(
      event,
      /** @type {any} */
      e3
    ));
  }
}
__name(get_data, "get_data");
function get_option(nodes, option) {
  return nodes.reduce(
    (value, node) => {
      return (
        /** @type {Value} TypeScript's too dumb to understand this */
        node?.universal?.[option] ?? node?.server?.[option] ?? value
      );
    },
    /** @type {Value | undefined} */
    void 0
  );
}
__name(get_option, "get_option");
async function respond_with_error({
  event,
  options: options2,
  manifest: manifest2,
  state,
  status,
  error: error2,
  resolve_opts
}) {
  if (event.request.headers.get("x-sveltekit-error")) {
    return static_error_page(
      options2,
      status,
      /** @type {Error} */
      error2.message
    );
  }
  const fetched = [];
  try {
    const branch2 = [];
    const default_layout = await manifest2._.nodes[0]();
    const ssr = get_option([default_layout], "ssr") ?? true;
    const csr = get_option([default_layout], "csr") ?? true;
    if (ssr) {
      state.error = true;
      const server_data_promise = load_server_data({
        event,
        state,
        node: default_layout,
        // eslint-disable-next-line @typescript-eslint/require-await
        parent: async () => ({})
      });
      const server_data = await server_data_promise;
      const data = await load_data({
        event,
        fetched,
        node: default_layout,
        // eslint-disable-next-line @typescript-eslint/require-await
        parent: async () => ({}),
        resolve_opts,
        server_data_promise,
        state,
        csr
      });
      branch2.push(
        {
          node: default_layout,
          server_data,
          data
        },
        {
          node: await manifest2._.nodes[1](),
          // 1 is always the root error
          data: null,
          server_data: null
        }
      );
    }
    return await render_response({
      options: options2,
      manifest: manifest2,
      state,
      page_config: {
        ssr,
        csr
      },
      status,
      error: await handle_error_and_jsonify(event, options2, error2),
      branch: branch2,
      fetched,
      event,
      resolve_opts
    });
  } catch (e3) {
    if (e3 instanceof Redirect) {
      return redirect_response(e3.status, e3.location);
    }
    return static_error_page(
      options2,
      get_status(e3),
      (await handle_error_and_jsonify(event, options2, e3)).message
    );
  }
}
__name(respond_with_error, "respond_with_error");
function once(fn) {
  let done = false;
  let result;
  return () => {
    if (done)
      return result;
    done = true;
    return result = fn();
  };
}
__name(once, "once");
var encoder2 = new TextEncoder();
async function render_data(event, route, options2, manifest2, state, invalidated_data_nodes, trailing_slash) {
  if (!route.page) {
    return new Response(void 0, {
      status: 404
    });
  }
  try {
    const node_ids = [...route.page.layouts, route.page.leaf];
    const invalidated = invalidated_data_nodes ?? node_ids.map(() => true);
    let aborted = false;
    const url = new URL(event.url);
    url.pathname = normalize_path(url.pathname, trailing_slash);
    const new_event = { ...event, url };
    const functions = node_ids.map((n2, i2) => {
      return once(async () => {
        try {
          if (aborted) {
            return (
              /** @type {import('types').ServerDataSkippedNode} */
              {
                type: "skip"
              }
            );
          }
          const node = n2 == void 0 ? n2 : await manifest2._.nodes[n2]();
          return load_server_data({
            event: new_event,
            state,
            node,
            parent: async () => {
              const data2 = {};
              for (let j2 = 0; j2 < i2; j2 += 1) {
                const parent = (
                  /** @type {import('types').ServerDataNode | null} */
                  await functions[j2]()
                );
                if (parent) {
                  Object.assign(data2, parent.data);
                }
              }
              return data2;
            }
          });
        } catch (e3) {
          aborted = true;
          throw e3;
        }
      });
    });
    const promises = functions.map(async (fn, i2) => {
      if (!invalidated[i2]) {
        return (
          /** @type {import('types').ServerDataSkippedNode} */
          {
            type: "skip"
          }
        );
      }
      return fn();
    });
    let length = promises.length;
    const nodes = await Promise.all(
      promises.map(
        (p2, i2) => p2.catch(async (error2) => {
          if (error2 instanceof Redirect) {
            throw error2;
          }
          length = Math.min(length, i2 + 1);
          return (
            /** @type {import('types').ServerErrorNode} */
            {
              type: "error",
              error: await handle_error_and_jsonify(event, options2, error2),
              status: error2 instanceof HttpError || error2 instanceof SvelteKitError ? error2.status : void 0
            }
          );
        })
      )
    );
    const { data, chunks } = get_data_json(event, options2, nodes);
    if (!chunks) {
      return json_response(data);
    }
    return new Response(
      new ReadableStream({
        async start(controller) {
          controller.enqueue(encoder2.encode(data));
          for await (const chunk of chunks) {
            controller.enqueue(encoder2.encode(chunk));
          }
          controller.close();
        },
        type: "bytes"
      }),
      {
        headers: {
          // we use a proprietary content type to prevent buffering.
          // the `text` prefix makes it inspectable
          "content-type": "text/sveltekit-data",
          "cache-control": "private, no-store"
        }
      }
    );
  } catch (e3) {
    const error2 = normalize_error(e3);
    if (error2 instanceof Redirect) {
      return redirect_json_response(error2);
    } else {
      return json_response(await handle_error_and_jsonify(event, options2, error2), 500);
    }
  }
}
__name(render_data, "render_data");
function json_response(json2, status = 200) {
  return text2(typeof json2 === "string" ? json2 : JSON.stringify(json2), {
    status,
    headers: {
      "content-type": "application/json",
      "cache-control": "private, no-store"
    }
  });
}
__name(json_response, "json_response");
function redirect_json_response(redirect2) {
  return json_response({
    type: "redirect",
    location: redirect2.location
  });
}
__name(redirect_json_response, "redirect_json_response");
function get_data_json(event, options2, nodes) {
  let promise_id = 1;
  let count = 0;
  const { iterator, push: push2, done } = create_async_iterator();
  const reducers = {
    /** @param {any} thing */
    Promise: (thing) => {
      if (typeof thing?.then === "function") {
        const id = promise_id++;
        count += 1;
        let key2 = "data";
        thing.catch(
          /** @param {any} e */
          async (e3) => {
            key2 = "error";
            return handle_error_and_jsonify(
              event,
              options2,
              /** @type {any} */
              e3
            );
          }
        ).then(
          /** @param {any} value */
          async (value) => {
            let str;
            try {
              str = stringify2(value, reducers);
            } catch {
              const error2 = await handle_error_and_jsonify(
                event,
                options2,
                new Error(`Failed to serialize promise while rendering ${event.route.id}`)
              );
              key2 = "error";
              str = stringify2(error2, reducers);
            }
            count -= 1;
            push2(`{"type":"chunk","id":${id},"${key2}":${str}}
`);
            if (count === 0)
              done();
          }
        );
        return id;
      }
    }
  };
  try {
    const strings = nodes.map((node) => {
      if (!node)
        return "null";
      if (node.type === "error" || node.type === "skip") {
        return JSON.stringify(node);
      }
      return `{"type":"data","data":${stringify2(node.data, reducers)},${stringify_uses(
        node
      )}${node.slash ? `,"slash":${JSON.stringify(node.slash)}` : ""}}`;
    });
    return {
      data: `{"type":"data","nodes":[${strings.join(",")}]}
`,
      chunks: count > 0 ? iterator : null
    };
  } catch (e3) {
    throw new Error(clarify_devalue_error(
      event,
      /** @type {any} */
      e3
    ));
  }
}
__name(get_data_json, "get_data_json");
function load_page_nodes(page3, manifest2) {
  return Promise.all([
    // we use == here rather than === because [undefined] serializes as "[null]"
    ...page3.layouts.map((n2) => n2 == void 0 ? n2 : manifest2._.nodes[n2]()),
    manifest2._.nodes[page3.leaf]()
  ]);
}
__name(load_page_nodes, "load_page_nodes");
var MAX_DEPTH = 10;
async function render_page(event, page3, options2, manifest2, state, resolve_opts) {
  if (state.depth > MAX_DEPTH) {
    return text2(`Not found: ${event.url.pathname}`, {
      status: 404
      // TODO in some cases this should be 500. not sure how to differentiate
    });
  }
  if (is_action_json_request(event)) {
    const node = await manifest2._.nodes[page3.leaf]();
    return handle_action_json_request(event, options2, node?.server);
  }
  try {
    const nodes = await load_page_nodes(page3, manifest2);
    const leaf_node = (
      /** @type {import('types').SSRNode} */
      nodes.at(-1)
    );
    let status = 200;
    let action_result = void 0;
    if (is_action_request(event)) {
      action_result = await handle_action_request(event, leaf_node.server);
      if (action_result?.type === "redirect") {
        return redirect_response(action_result.status, action_result.location);
      }
      if (action_result?.type === "error") {
        status = get_status(action_result.error);
      }
      if (action_result?.type === "failure") {
        status = action_result.status;
      }
    }
    const should_prerender_data = nodes.some((node) => node?.server?.load);
    const data_pathname = add_data_suffix(event.url.pathname);
    const should_prerender = get_option(nodes, "prerender") ?? false;
    if (should_prerender) {
      const mod = leaf_node.server;
      if (mod?.actions) {
        throw new Error("Cannot prerender pages with actions");
      }
    } else if (state.prerendering) {
      return new Response(void 0, {
        status: 204
      });
    }
    state.prerender_default = should_prerender;
    const fetched = [];
    if (get_option(nodes, "ssr") === false && !(state.prerendering && should_prerender_data)) {
      if (DEV && action_result && !event.request.headers.has("x-sveltekit-action"))
        ;
      return await render_response({
        branch: [],
        fetched,
        page_config: {
          ssr: false,
          csr: get_option(nodes, "csr") ?? true
        },
        status,
        error: null,
        event,
        options: options2,
        manifest: manifest2,
        state,
        resolve_opts
      });
    }
    const branch2 = [];
    let load_error = null;
    const server_promises = nodes.map((node, i2) => {
      if (load_error) {
        throw load_error;
      }
      return Promise.resolve().then(async () => {
        try {
          if (node === leaf_node && action_result?.type === "error") {
            throw action_result.error;
          }
          return await load_server_data({
            event,
            state,
            node,
            parent: async () => {
              const data = {};
              for (let j2 = 0; j2 < i2; j2 += 1) {
                const parent = await server_promises[j2];
                if (parent)
                  Object.assign(data, parent.data);
              }
              return data;
            }
          });
        } catch (e3) {
          load_error = /** @type {Error} */
          e3;
          throw load_error;
        }
      });
    });
    const csr = get_option(nodes, "csr") ?? true;
    const load_promises = nodes.map((node, i2) => {
      if (load_error)
        throw load_error;
      return Promise.resolve().then(async () => {
        try {
          return await load_data({
            event,
            fetched,
            node,
            parent: async () => {
              const data = {};
              for (let j2 = 0; j2 < i2; j2 += 1) {
                Object.assign(data, await load_promises[j2]);
              }
              return data;
            },
            resolve_opts,
            server_data_promise: server_promises[i2],
            state,
            csr
          });
        } catch (e3) {
          load_error = /** @type {Error} */
          e3;
          throw load_error;
        }
      });
    });
    for (const p2 of server_promises)
      p2.catch(() => {
      });
    for (const p2 of load_promises)
      p2.catch(() => {
      });
    for (let i2 = 0; i2 < nodes.length; i2 += 1) {
      const node = nodes[i2];
      if (node) {
        try {
          const server_data = await server_promises[i2];
          const data = await load_promises[i2];
          branch2.push({ node, server_data, data });
        } catch (e3) {
          const err = normalize_error(e3);
          if (err instanceof Redirect) {
            if (state.prerendering && should_prerender_data) {
              const body2 = JSON.stringify({
                type: "redirect",
                location: err.location
              });
              state.prerendering.dependencies.set(data_pathname, {
                response: text2(body2),
                body: body2
              });
            }
            return redirect_response(err.status, err.location);
          }
          const status2 = get_status(err);
          const error2 = await handle_error_and_jsonify(event, options2, err);
          while (i2--) {
            if (page3.errors[i2]) {
              const index39 = (
                /** @type {number} */
                page3.errors[i2]
              );
              const node2 = await manifest2._.nodes[index39]();
              let j2 = i2;
              while (!branch2[j2])
                j2 -= 1;
              return await render_response({
                event,
                options: options2,
                manifest: manifest2,
                state,
                resolve_opts,
                page_config: { ssr: true, csr: true },
                status: status2,
                error: error2,
                branch: compact(branch2.slice(0, j2 + 1)).concat({
                  node: node2,
                  data: null,
                  server_data: null
                }),
                fetched
              });
            }
          }
          return static_error_page(options2, status2, error2.message);
        }
      } else {
        branch2.push(null);
      }
    }
    if (state.prerendering && should_prerender_data) {
      let { data, chunks } = get_data_json(
        event,
        options2,
        branch2.map((node) => node?.server_data)
      );
      if (chunks) {
        for await (const chunk of chunks) {
          data += chunk;
        }
      }
      state.prerendering.dependencies.set(data_pathname, {
        response: text2(data),
        body: data
      });
    }
    const ssr = get_option(nodes, "ssr") ?? true;
    return await render_response({
      event,
      options: options2,
      manifest: manifest2,
      state,
      resolve_opts,
      page_config: {
        csr: get_option(nodes, "csr") ?? true,
        ssr
      },
      status,
      error: null,
      branch: ssr === false ? [] : compact(branch2),
      action_result,
      fetched
    });
  } catch (e3) {
    return await respond_with_error({
      event,
      options: options2,
      manifest: manifest2,
      state,
      status: 500,
      error: e3,
      resolve_opts
    });
  }
}
__name(render_page, "render_page");
function exec(match, params, matchers) {
  const result = {};
  const values = match.slice(1);
  const values_needing_match = values.filter((value) => value !== void 0);
  let buffered = 0;
  for (let i2 = 0; i2 < params.length; i2 += 1) {
    const param = params[i2];
    let value = values[i2 - buffered];
    if (param.chained && param.rest && buffered) {
      value = values.slice(i2 - buffered, i2 + 1).filter((s22) => s22).join("/");
      buffered = 0;
    }
    if (value === void 0) {
      if (param.rest)
        result[param.name] = "";
      continue;
    }
    if (!param.matcher || matchers[param.matcher](value)) {
      result[param.name] = value;
      const next_param = params[i2 + 1];
      const next_value = values[i2 + 1];
      if (next_param && !next_param.rest && next_param.optional && next_value && param.chained) {
        buffered = 0;
      }
      if (!next_param && !next_value && Object.keys(result).length === values_needing_match.length) {
        buffered = 0;
      }
      continue;
    }
    if (param.optional && param.chained) {
      buffered++;
      continue;
    }
    return;
  }
  if (buffered)
    return;
  return result;
}
__name(exec, "exec");
var parse_1 = parse$1;
var serialize_1 = serialize;
var __toString = Object.prototype.toString;
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
function parse$1(str, options2) {
  if (typeof str !== "string") {
    throw new TypeError("argument str must be a string");
  }
  var obj = {};
  var opt = options2 || {};
  var dec = opt.decode || decode;
  var index39 = 0;
  while (index39 < str.length) {
    var eqIdx = str.indexOf("=", index39);
    if (eqIdx === -1) {
      break;
    }
    var endIdx = str.indexOf(";", index39);
    if (endIdx === -1) {
      endIdx = str.length;
    } else if (endIdx < eqIdx) {
      index39 = str.lastIndexOf(";", eqIdx - 1) + 1;
      continue;
    }
    var key2 = str.slice(index39, eqIdx).trim();
    if (void 0 === obj[key2]) {
      var val = str.slice(eqIdx + 1, endIdx).trim();
      if (val.charCodeAt(0) === 34) {
        val = val.slice(1, -1);
      }
      obj[key2] = tryDecode(val, dec);
    }
    index39 = endIdx + 1;
  }
  return obj;
}
__name(parse$1, "parse$1");
function serialize(name3, val, options2) {
  var opt = options2 || {};
  var enc = opt.encode || encode;
  if (typeof enc !== "function") {
    throw new TypeError("option encode is invalid");
  }
  if (!fieldContentRegExp.test(name3)) {
    throw new TypeError("argument name is invalid");
  }
  var value = enc(val);
  if (value && !fieldContentRegExp.test(value)) {
    throw new TypeError("argument val is invalid");
  }
  var str = name3 + "=" + value;
  if (null != opt.maxAge) {
    var maxAge = opt.maxAge - 0;
    if (isNaN(maxAge) || !isFinite(maxAge)) {
      throw new TypeError("option maxAge is invalid");
    }
    str += "; Max-Age=" + Math.floor(maxAge);
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += "; Path=" + opt.path;
  }
  if (opt.expires) {
    var expires = opt.expires;
    if (!isDate(expires) || isNaN(expires.valueOf())) {
      throw new TypeError("option expires is invalid");
    }
    str += "; Expires=" + expires.toUTCString();
  }
  if (opt.httpOnly) {
    str += "; HttpOnly";
  }
  if (opt.secure) {
    str += "; Secure";
  }
  if (opt.partitioned) {
    str += "; Partitioned";
  }
  if (opt.priority) {
    var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
    switch (priority) {
      case "low":
        str += "; Priority=Low";
        break;
      case "medium":
        str += "; Priority=Medium";
        break;
      case "high":
        str += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
}
__name(serialize, "serialize");
function decode(str) {
  return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
}
__name(decode, "decode");
function encode(val) {
  return encodeURIComponent(val);
}
__name(encode, "encode");
function isDate(val) {
  return __toString.call(val) === "[object Date]" || val instanceof Date;
}
__name(isDate, "isDate");
function tryDecode(str, decode2) {
  try {
    return decode2(str);
  } catch (e3) {
    return str;
  }
}
__name(tryDecode, "tryDecode");
function validate_options(options2) {
  if (options2?.path === void 0) {
    throw new Error("You must specify a `path` when setting, deleting or serializing cookies");
  }
}
__name(validate_options, "validate_options");
function get_cookies(request, url, trailing_slash) {
  const header = request.headers.get("cookie") ?? "";
  const initial_cookies = parse_1(header, { decode: (value) => value });
  const normalized_url = normalize_path(url.pathname, trailing_slash);
  const new_cookies = {};
  const defaults6 = {
    httpOnly: true,
    sameSite: "lax",
    secure: url.hostname === "localhost" && url.protocol === "http:" ? false : true
  };
  const cookies = {
    // The JSDoc param annotations appearing below for get, set and delete
    // are necessary to expose the `cookie` library types to
    // typescript users. `@type {import('@sveltejs/kit').Cookies}` above is not
    // sufficient to do so.
    /**
     * @param {string} name
     * @param {import('cookie').CookieParseOptions} opts
     */
    get(name3, opts) {
      const c2 = new_cookies[name3];
      if (c2 && domain_matches(url.hostname, c2.options.domain) && path_matches(url.pathname, c2.options.path)) {
        return c2.value;
      }
      const decoder = opts?.decode || decodeURIComponent;
      const req_cookies = parse_1(header, { decode: decoder });
      const cookie = req_cookies[name3];
      return cookie;
    },
    /**
     * @param {import('cookie').CookieParseOptions} opts
     */
    getAll(opts) {
      const decoder = opts?.decode || decodeURIComponent;
      const cookies2 = parse_1(header, { decode: decoder });
      for (const c2 of Object.values(new_cookies)) {
        if (domain_matches(url.hostname, c2.options.domain) && path_matches(url.pathname, c2.options.path)) {
          cookies2[c2.name] = c2.value;
        }
      }
      return Object.entries(cookies2).map(([name3, value]) => ({ name: name3, value }));
    },
    /**
     * @param {string} name
     * @param {string} value
     * @param {import('./page/types.js').Cookie['options']} options
     */
    set(name3, value, options2) {
      validate_options(options2);
      set_internal(name3, value, { ...defaults6, ...options2 });
    },
    /**
     * @param {string} name
     *  @param {import('./page/types.js').Cookie['options']} options
     */
    delete(name3, options2) {
      validate_options(options2);
      cookies.set(name3, "", { ...options2, maxAge: 0 });
    },
    /**
     * @param {string} name
     * @param {string} value
     *  @param {import('./page/types.js').Cookie['options']} options
     */
    serialize(name3, value, options2) {
      validate_options(options2);
      let path = options2.path;
      if (!options2.domain || options2.domain === url.hostname) {
        path = resolve(normalized_url, path);
      }
      return serialize_1(name3, value, { ...defaults6, ...options2, path });
    }
  };
  function get_cookie_header(destination, header2) {
    const combined_cookies = {
      // cookies sent by the user agent have lowest precedence
      ...initial_cookies
    };
    for (const key2 in new_cookies) {
      const cookie = new_cookies[key2];
      if (!domain_matches(destination.hostname, cookie.options.domain))
        continue;
      if (!path_matches(destination.pathname, cookie.options.path))
        continue;
      const encoder22 = cookie.options.encode || encodeURIComponent;
      combined_cookies[cookie.name] = encoder22(cookie.value);
    }
    if (header2) {
      const parsed = parse_1(header2, { decode: (value) => value });
      for (const name3 in parsed) {
        combined_cookies[name3] = parsed[name3];
      }
    }
    return Object.entries(combined_cookies).map(([name3, value]) => `${name3}=${value}`).join("; ");
  }
  __name(get_cookie_header, "get_cookie_header");
  function set_internal(name3, value, options2) {
    let path = options2.path;
    if (!options2.domain || options2.domain === url.hostname) {
      path = resolve(normalized_url, path);
    }
    new_cookies[name3] = { name: name3, value, options: { ...options2, path } };
  }
  __name(set_internal, "set_internal");
  return { cookies, new_cookies, get_cookie_header, set_internal };
}
__name(get_cookies, "get_cookies");
function domain_matches(hostname, constraint2) {
  if (!constraint2)
    return true;
  const normalized = constraint2[0] === "." ? constraint2.slice(1) : constraint2;
  if (hostname === normalized)
    return true;
  return hostname.endsWith("." + normalized);
}
__name(domain_matches, "domain_matches");
function path_matches(path, constraint2) {
  if (!constraint2)
    return true;
  const normalized = constraint2.endsWith("/") ? constraint2.slice(0, -1) : constraint2;
  if (path === normalized)
    return true;
  return path.startsWith(normalized + "/");
}
__name(path_matches, "path_matches");
function add_cookies_to_headers(headers2, cookies) {
  for (const new_cookie of cookies) {
    const { name: name3, value, options: options2 } = new_cookie;
    headers2.append("set-cookie", serialize_1(name3, value, options2));
    if (options2.path.endsWith(".html")) {
      const path = add_data_suffix(options2.path);
      headers2.append("set-cookie", serialize_1(name3, value, { ...options2, path }));
    }
  }
}
__name(add_cookies_to_headers, "add_cookies_to_headers");
var setCookie = { exports: {} };
var defaultParseOptions = {
  decodeValues: true,
  map: false,
  silent: false
};
function isNonEmptyString(str) {
  return typeof str === "string" && !!str.trim();
}
__name(isNonEmptyString, "isNonEmptyString");
function parseString(setCookieValue, options2) {
  var parts = setCookieValue.split(";").filter(isNonEmptyString);
  var nameValuePairStr = parts.shift();
  var parsed = parseNameValuePair(nameValuePairStr);
  var name3 = parsed.name;
  var value = parsed.value;
  options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions;
  try {
    value = options2.decodeValues ? decodeURIComponent(value) : value;
  } catch (e3) {
    console.error(
      "set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.",
      e3
    );
  }
  var cookie = {
    name: name3,
    value
  };
  parts.forEach(function(part) {
    var sides = part.split("=");
    var key2 = sides.shift().trimLeft().toLowerCase();
    var value2 = sides.join("=");
    if (key2 === "expires") {
      cookie.expires = new Date(value2);
    } else if (key2 === "max-age") {
      cookie.maxAge = parseInt(value2, 10);
    } else if (key2 === "secure") {
      cookie.secure = true;
    } else if (key2 === "httponly") {
      cookie.httpOnly = true;
    } else if (key2 === "samesite") {
      cookie.sameSite = value2;
    } else if (key2 === "partitioned") {
      cookie.partitioned = true;
    } else {
      cookie[key2] = value2;
    }
  });
  return cookie;
}
__name(parseString, "parseString");
function parseNameValuePair(nameValuePairStr) {
  var name3 = "";
  var value = "";
  var nameValueArr = nameValuePairStr.split("=");
  if (nameValueArr.length > 1) {
    name3 = nameValueArr.shift();
    value = nameValueArr.join("=");
  } else {
    value = nameValuePairStr;
  }
  return { name: name3, value };
}
__name(parseNameValuePair, "parseNameValuePair");
function parse(input, options2) {
  options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions;
  if (!input) {
    if (!options2.map) {
      return [];
    } else {
      return {};
    }
  }
  if (input.headers) {
    if (typeof input.headers.getSetCookie === "function") {
      input = input.headers.getSetCookie();
    } else if (input.headers["set-cookie"]) {
      input = input.headers["set-cookie"];
    } else {
      var sch = input.headers[Object.keys(input.headers).find(function(key2) {
        return key2.toLowerCase() === "set-cookie";
      })];
      if (!sch && input.headers.cookie && !options2.silent) {
        console.warn(
          "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
        );
      }
      input = sch;
    }
  }
  if (!Array.isArray(input)) {
    input = [input];
  }
  if (!options2.map) {
    return input.filter(isNonEmptyString).map(function(str) {
      return parseString(str, options2);
    });
  } else {
    var cookies = {};
    return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
      var cookie = parseString(str, options2);
      cookies2[cookie.name] = cookie;
      return cookies2;
    }, cookies);
  }
}
__name(parse, "parse");
function splitCookiesString(cookiesString) {
  if (Array.isArray(cookiesString)) {
    return cookiesString;
  }
  if (typeof cookiesString !== "string") {
    return [];
  }
  var cookiesStrings = [];
  var pos = 0;
  var start;
  var ch;
  var lastComma;
  var nextStart;
  var cookiesSeparatorFound;
  function skipWhitespace() {
    while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
      pos += 1;
    }
    return pos < cookiesString.length;
  }
  __name(skipWhitespace, "skipWhitespace");
  function notSpecialChar() {
    ch = cookiesString.charAt(pos);
    return ch !== "=" && ch !== ";" && ch !== ",";
  }
  __name(notSpecialChar, "notSpecialChar");
  while (pos < cookiesString.length) {
    start = pos;
    cookiesSeparatorFound = false;
    while (skipWhitespace()) {
      ch = cookiesString.charAt(pos);
      if (ch === ",") {
        lastComma = pos;
        pos += 1;
        skipWhitespace();
        nextStart = pos;
        while (pos < cookiesString.length && notSpecialChar()) {
          pos += 1;
        }
        if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
          cookiesSeparatorFound = true;
          pos = nextStart;
          cookiesStrings.push(cookiesString.substring(start, lastComma));
          start = pos;
        } else {
          pos = lastComma + 1;
        }
      } else {
        pos += 1;
      }
    }
    if (!cookiesSeparatorFound || pos >= cookiesString.length) {
      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
    }
  }
  return cookiesStrings;
}
__name(splitCookiesString, "splitCookiesString");
setCookie.exports = parse;
setCookie.exports.parse = parse;
var parseString_1 = setCookie.exports.parseString = parseString;
var splitCookiesString_1 = setCookie.exports.splitCookiesString = splitCookiesString;
function create_fetch({ event, options: options2, manifest: manifest2, state, get_cookie_header, set_internal }) {
  const server_fetch = /* @__PURE__ */ __name(async (info, init2) => {
    const original_request = normalize_fetch_input(info, init2, event.url);
    let mode = (info instanceof Request ? info.mode : init2?.mode) ?? "cors";
    let credentials = (info instanceof Request ? info.credentials : init2?.credentials) ?? "same-origin";
    return options2.hooks.handleFetch({
      event,
      request: original_request,
      fetch: async (info2, init3) => {
        const request = normalize_fetch_input(info2, init3, event.url);
        const url = new URL(request.url);
        if (!request.headers.has("origin")) {
          request.headers.set("origin", event.url.origin);
        }
        if (info2 !== original_request) {
          mode = (info2 instanceof Request ? info2.mode : init3?.mode) ?? "cors";
          credentials = (info2 instanceof Request ? info2.credentials : init3?.credentials) ?? "same-origin";
        }
        if ((request.method === "GET" || request.method === "HEAD") && (mode === "no-cors" && url.origin !== event.url.origin || url.origin === event.url.origin)) {
          request.headers.delete("origin");
        }
        if (url.origin !== event.url.origin) {
          if (`.${url.hostname}`.endsWith(`.${event.url.hostname}`) && credentials !== "omit") {
            const cookie = get_cookie_header(url, request.headers.get("cookie"));
            if (cookie)
              request.headers.set("cookie", cookie);
          }
          return fetch(request);
        }
        const prefix = assets || base;
        const decoded = decodeURIComponent(url.pathname);
        const filename = (decoded.startsWith(prefix) ? decoded.slice(prefix.length) : decoded).slice(1);
        const filename_html = `${filename}/index.html`;
        const is_asset = manifest2.assets.has(filename) || filename in manifest2._.server_assets;
        const is_asset_html = manifest2.assets.has(filename_html) || filename_html in manifest2._.server_assets;
        if (is_asset || is_asset_html) {
          const file = is_asset ? filename : filename_html;
          if (state.read) {
            const type = is_asset ? manifest2.mimeTypes[filename.slice(filename.lastIndexOf("."))] : "text/html";
            return new Response(state.read(file), {
              headers: type ? { "content-type": type } : {}
            });
          } else if (read_implementation && file in manifest2._.server_assets) {
            const length = manifest2._.server_assets[file];
            const type = manifest2.mimeTypes[file.slice(file.lastIndexOf("."))];
            return new Response(read_implementation(file), {
              headers: {
                "Content-Length": "" + length,
                "Content-Type": type
              }
            });
          }
          return await fetch(request);
        }
        if (credentials !== "omit") {
          const cookie = get_cookie_header(url, request.headers.get("cookie"));
          if (cookie) {
            request.headers.set("cookie", cookie);
          }
          const authorization = event.request.headers.get("authorization");
          if (authorization && !request.headers.has("authorization")) {
            request.headers.set("authorization", authorization);
          }
        }
        if (!request.headers.has("accept")) {
          request.headers.set("accept", "*/*");
        }
        if (!request.headers.has("accept-language")) {
          request.headers.set(
            "accept-language",
            /** @type {string} */
            event.request.headers.get("accept-language")
          );
        }
        const response = await respond(request, options2, manifest2, {
          ...state,
          depth: state.depth + 1
        });
        const set_cookie = response.headers.get("set-cookie");
        if (set_cookie) {
          for (const str of splitCookiesString_1(set_cookie)) {
            const { name: name3, value, ...options3 } = parseString_1(str, {
              decodeValues: false
            });
            const path = options3.path ?? (url.pathname.split("/").slice(0, -1).join("/") || "/");
            set_internal(name3, value, {
              path,
              encode: (value2) => value2,
              .../** @type {import('cookie').CookieSerializeOptions} */
              options3
            });
          }
        }
        return response;
      }
    });
  }, "server_fetch");
  return (input, init2) => {
    const response = server_fetch(input, init2);
    response.catch(() => {
    });
    return response;
  };
}
__name(create_fetch, "create_fetch");
function normalize_fetch_input(info, init2, url) {
  if (info instanceof Request) {
    return info;
  }
  return new Request(typeof info === "string" ? new URL(info, url) : info, init2);
}
__name(normalize_fetch_input, "normalize_fetch_input");
var body;
var etag;
var headers;
function get_public_env(request) {
  body ??= `export const env=${JSON.stringify(public_env)}`;
  etag ??= `W/${Date.now()}`;
  headers ??= new Headers({
    "content-type": "application/javascript; charset=utf-8",
    etag
  });
  if (request.headers.get("if-none-match") === etag) {
    return new Response(void 0, { status: 304, headers });
  }
  return new Response(body, { headers });
}
__name(get_public_env, "get_public_env");
function get_page_config(nodes) {
  let current = {};
  for (const node of nodes) {
    if (!node?.universal?.config && !node?.server?.config)
      continue;
    current = {
      ...current,
      ...node?.universal?.config,
      ...node?.server?.config
    };
  }
  return Object.keys(current).length ? current : void 0;
}
__name(get_page_config, "get_page_config");
var default_transform = /* @__PURE__ */ __name(({ html }) => html, "default_transform");
var default_filter = /* @__PURE__ */ __name(() => false, "default_filter");
var default_preload = /* @__PURE__ */ __name(({ type }) => type === "js" || type === "css", "default_preload");
var page_methods = /* @__PURE__ */ new Set(["GET", "HEAD", "POST"]);
var allowed_page_methods = /* @__PURE__ */ new Set(["GET", "HEAD", "OPTIONS"]);
async function respond(request, options2, manifest2, state) {
  const url = new URL(request.url);
  if (options2.csrf_check_origin) {
    const forbidden = is_form_content_type(request) && (request.method === "POST" || request.method === "PUT" || request.method === "PATCH" || request.method === "DELETE") && request.headers.get("origin") !== url.origin;
    if (forbidden) {
      const csrf_error = new HttpError(
        403,
        `Cross-site ${request.method} form submissions are forbidden`
      );
      if (request.headers.get("accept") === "application/json") {
        return json(csrf_error.body, { status: csrf_error.status });
      }
      return text2(csrf_error.body.message, { status: csrf_error.status });
    }
  }
  let rerouted_path;
  try {
    rerouted_path = options2.hooks.reroute({ url: new URL(url) }) ?? url.pathname;
  } catch {
    return text2("Internal Server Error", {
      status: 500
    });
  }
  let decoded;
  try {
    decoded = decode_pathname(rerouted_path);
  } catch {
    return text2("Malformed URI", { status: 400 });
  }
  let route = null;
  let params = {};
  if (base && !state.prerendering?.fallback) {
    if (!decoded.startsWith(base)) {
      return text2("Not found", { status: 404 });
    }
    decoded = decoded.slice(base.length) || "/";
  }
  if (decoded === `/${options2.app_dir}/env.js`) {
    return get_public_env(request);
  }
  if (decoded.startsWith(`/${options2.app_dir}`)) {
    const headers22 = new Headers();
    headers22.set("cache-control", "public, max-age=0, must-revalidate");
    return text2("Not found", { status: 404, headers: headers22 });
  }
  const is_data_request = has_data_suffix(decoded);
  let invalidated_data_nodes;
  if (is_data_request) {
    decoded = strip_data_suffix(decoded) || "/";
    url.pathname = strip_data_suffix(url.pathname) + (url.searchParams.get(TRAILING_SLASH_PARAM) === "1" ? "/" : "") || "/";
    url.searchParams.delete(TRAILING_SLASH_PARAM);
    invalidated_data_nodes = url.searchParams.get(INVALIDATED_PARAM)?.split("").map((node) => node === "1");
    url.searchParams.delete(INVALIDATED_PARAM);
  }
  if (!state.prerendering?.fallback) {
    const matchers = await manifest2._.matchers();
    for (const candidate of manifest2._.routes) {
      const match = candidate.pattern.exec(decoded);
      if (!match)
        continue;
      const matched = exec(match, candidate.params, matchers);
      if (matched) {
        route = candidate;
        params = decode_params(matched);
        break;
      }
    }
  }
  let trailing_slash = void 0;
  const headers2 = {};
  let cookies_to_add = {};
  const event = {
    // @ts-expect-error `cookies` and `fetch` need to be created after the `event` itself
    cookies: null,
    // @ts-expect-error
    fetch: null,
    getClientAddress: state.getClientAddress || (() => {
      throw new Error(
        `${"@sveltejs/adapter-cloudflare"} does not specify getClientAddress. Please raise an issue`
      );
    }),
    locals: {},
    params,
    platform: state.platform,
    request,
    route: { id: route?.id ?? null },
    setHeaders: (new_headers) => {
      for (const key2 in new_headers) {
        const lower = key2.toLowerCase();
        const value = new_headers[key2];
        if (lower === "set-cookie") {
          throw new Error(
            "Use `event.cookies.set(name, value, options)` instead of `event.setHeaders` to set cookies"
          );
        } else if (lower in headers2) {
          throw new Error(`"${key2}" header is already set`);
        } else {
          headers2[lower] = value;
          if (state.prerendering && lower === "cache-control") {
            state.prerendering.cache = /** @type {string} */
            value;
          }
        }
      }
    },
    url,
    isDataRequest: is_data_request,
    isSubRequest: state.depth > 0
  };
  let resolve_opts = {
    transformPageChunk: default_transform,
    filterSerializedResponseHeaders: default_filter,
    preload: default_preload
  };
  try {
    if (route) {
      if (url.pathname === base || url.pathname === base + "/") {
        trailing_slash = "always";
      } else if (route.page) {
        const nodes = await load_page_nodes(route.page, manifest2);
        if (DEV)
          ;
        trailing_slash = get_option(nodes, "trailingSlash");
      } else if (route.endpoint) {
        const node = await route.endpoint();
        trailing_slash = node.trailingSlash;
        if (DEV)
          ;
      }
      if (!is_data_request) {
        const normalized = normalize_path(url.pathname, trailing_slash ?? "never");
        if (normalized !== url.pathname && !state.prerendering?.fallback) {
          return new Response(void 0, {
            status: 308,
            headers: {
              "x-sveltekit-normalize": "1",
              location: (
                // ensure paths starting with '//' are not treated as protocol-relative
                (normalized.startsWith("//") ? url.origin + normalized : normalized) + (url.search === "?" ? "" : url.search)
              )
            }
          });
        }
      }
      if (state.before_handle || state.emulator?.platform) {
        let config = {};
        let prerender = false;
        if (route.endpoint) {
          const node = await route.endpoint();
          config = node.config ?? config;
          prerender = node.prerender ?? prerender;
        } else if (route.page) {
          const nodes = await load_page_nodes(route.page, manifest2);
          config = get_page_config(nodes) ?? config;
          prerender = get_option(nodes, "prerender") ?? false;
        }
        if (state.before_handle) {
          state.before_handle(event, config, prerender);
        }
        if (state.emulator?.platform) {
          event.platform = await state.emulator.platform({ config, prerender });
        }
      }
    } else if (state.emulator?.platform) {
      event.platform = await state.emulator.platform({
        config: {},
        prerender: !!state.prerendering?.fallback
      });
    }
    const { cookies, new_cookies, get_cookie_header, set_internal } = get_cookies(
      request,
      url,
      trailing_slash ?? "never"
    );
    cookies_to_add = new_cookies;
    event.cookies = cookies;
    event.fetch = create_fetch({
      event,
      options: options2,
      manifest: manifest2,
      state,
      get_cookie_header,
      set_internal
    });
    if (state.prerendering && !state.prerendering.fallback)
      disable_search(url);
    const response = await options2.hooks.handle({
      event,
      resolve: (event2, opts) => resolve2(event2, opts).then((response2) => {
        for (const key2 in headers2) {
          const value = headers2[key2];
          response2.headers.set(
            key2,
            /** @type {string} */
            value
          );
        }
        add_cookies_to_headers(response2.headers, Object.values(cookies_to_add));
        if (state.prerendering && event2.route.id !== null) {
          response2.headers.set("x-sveltekit-routeid", encodeURI(event2.route.id));
        }
        return response2;
      })
    });
    if (response.status === 200 && response.headers.has("etag")) {
      let if_none_match_value = request.headers.get("if-none-match");
      if (if_none_match_value?.startsWith('W/"')) {
        if_none_match_value = if_none_match_value.substring(2);
      }
      const etag2 = (
        /** @type {string} */
        response.headers.get("etag")
      );
      if (if_none_match_value === etag2) {
        const headers22 = new Headers({ etag: etag2 });
        for (const key2 of [
          "cache-control",
          "content-location",
          "date",
          "expires",
          "vary",
          "set-cookie"
        ]) {
          const value = response.headers.get(key2);
          if (value)
            headers22.set(key2, value);
        }
        return new Response(void 0, {
          status: 304,
          headers: headers22
        });
      }
    }
    if (is_data_request && response.status >= 300 && response.status <= 308) {
      const location2 = response.headers.get("location");
      if (location2) {
        return redirect_json_response(new Redirect(
          /** @type {any} */
          response.status,
          location2
        ));
      }
    }
    return response;
  } catch (e3) {
    if (e3 instanceof Redirect) {
      const response = is_data_request ? redirect_json_response(e3) : route?.page && is_action_json_request(event) ? action_json_redirect(e3) : redirect_response(e3.status, e3.location);
      add_cookies_to_headers(response.headers, Object.values(cookies_to_add));
      return response;
    }
    return await handle_fatal_error(event, options2, e3);
  }
  async function resolve2(event2, opts) {
    try {
      if (opts) {
        resolve_opts = {
          transformPageChunk: opts.transformPageChunk || default_transform,
          filterSerializedResponseHeaders: opts.filterSerializedResponseHeaders || default_filter,
          preload: opts.preload || default_preload
        };
      }
      if (state.prerendering?.fallback) {
        return await render_response({
          event: event2,
          options: options2,
          manifest: manifest2,
          state,
          page_config: { ssr: false, csr: true },
          status: 200,
          error: null,
          branch: [],
          fetched: [],
          resolve_opts
        });
      }
      if (route) {
        const method = (
          /** @type {import('types').HttpMethod} */
          event2.request.method
        );
        let response;
        if (is_data_request) {
          response = await render_data(
            event2,
            route,
            options2,
            manifest2,
            state,
            invalidated_data_nodes,
            trailing_slash ?? "never"
          );
        } else if (route.endpoint && (!route.page || is_endpoint_request(event2))) {
          response = await render_endpoint(event2, await route.endpoint(), state);
        } else if (route.page) {
          if (page_methods.has(method)) {
            response = await render_page(event2, route.page, options2, manifest2, state, resolve_opts);
          } else {
            const allowed_methods2 = new Set(allowed_page_methods);
            const node = await manifest2._.nodes[route.page.leaf]();
            if (node?.server?.actions) {
              allowed_methods2.add("POST");
            }
            if (method === "OPTIONS") {
              response = new Response(null, {
                status: 204,
                headers: {
                  allow: Array.from(allowed_methods2.values()).join(", ")
                }
              });
            } else {
              const mod = [...allowed_methods2].reduce(
                (acc, curr) => {
                  acc[curr] = true;
                  return acc;
                },
                /** @type {Record<string, any>} */
                {}
              );
              response = method_not_allowed(mod, method);
            }
          }
        } else {
          throw new Error("This should never happen");
        }
        if (request.method === "GET" && route.page && route.endpoint) {
          const vary = response.headers.get("vary")?.split(",")?.map((v2) => v2.trim().toLowerCase());
          if (!(vary?.includes("accept") || vary?.includes("*"))) {
            response = new Response(response.body, {
              status: response.status,
              statusText: response.statusText,
              headers: new Headers(response.headers)
            });
            response.headers.append("Vary", "Accept");
          }
        }
        return response;
      }
      if (state.error && event2.isSubRequest) {
        return await fetch(request, {
          headers: {
            "x-sveltekit-error": "true"
          }
        });
      }
      if (state.error) {
        return text2("Internal Server Error", {
          status: 500
        });
      }
      if (state.depth === 0) {
        return await respond_with_error({
          event: event2,
          options: options2,
          manifest: manifest2,
          state,
          status: 404,
          error: new SvelteKitError(404, "Not Found", `Not found: ${event2.url.pathname}`),
          resolve_opts
        });
      }
      if (state.prerendering) {
        return text2("not found", { status: 404 });
      }
      return await fetch(request);
    } catch (e3) {
      return await handle_fatal_error(event2, options2, e3);
    } finally {
      event2.cookies.set = () => {
        throw new Error("Cannot use `cookies.set(...)` after the response has been generated");
      };
      event2.setHeaders = () => {
        throw new Error("Cannot use `setHeaders(...)` after the response has been generated");
      };
    }
  }
  __name(resolve2, "resolve2");
}
__name(respond, "respond");
function filter_private_env(env, { public_prefix, private_prefix }) {
  return Object.fromEntries(
    Object.entries(env).filter(
      ([k]) => k.startsWith(private_prefix) && (public_prefix === "" || !k.startsWith(public_prefix))
    )
  );
}
__name(filter_private_env, "filter_private_env");
function filter_public_env(env, { public_prefix, private_prefix }) {
  return Object.fromEntries(
    Object.entries(env).filter(
      ([k]) => k.startsWith(public_prefix) && (private_prefix === "" || !k.startsWith(private_prefix))
    )
  );
}
__name(filter_public_env, "filter_public_env");
var prerender_env_handler = {
  get({ type }, prop) {
    throw new Error(
      `Cannot read values from $env/dynamic/${type} while prerendering (attempted to read env.${prop.toString()}). Use $env/static/${type} instead`
    );
  }
};
var Server = /* @__PURE__ */ __name(class {
  /** @type {import('types').SSROptions} */
  #options;
  /** @type {import('@sveltejs/kit').SSRManifest} */
  #manifest;
  /** @param {import('@sveltejs/kit').SSRManifest} manifest */
  constructor(manifest2) {
    this.#options = options;
    this.#manifest = manifest2;
  }
  /**
   * @param {{
   *   env: Record<string, string>;
   *   read?: (file: string) => ReadableStream;
   * }} opts
   */
  async init({ env, read }) {
    const prefixes = {
      public_prefix: this.#options.env_public_prefix,
      private_prefix: this.#options.env_private_prefix
    };
    const private_env = filter_private_env(env, prefixes);
    const public_env2 = filter_public_env(env, prefixes);
    set_private_env(
      prerendering ? new Proxy({ type: "private" }, prerender_env_handler) : private_env
    );
    set_public_env(
      prerendering ? new Proxy({ type: "public" }, prerender_env_handler) : public_env2
    );
    set_safe_public_env(public_env2);
    if (read) {
      set_read_implementation(read);
    }
    if (!this.#options.hooks) {
      try {
        const module = await get_hooks();
        this.#options.hooks = {
          handle: module.handle || (({ event, resolve: resolve2 }) => resolve2(event)),
          handleError: module.handleError || (({ error: error2 }) => console.error(error2)),
          handleFetch: module.handleFetch || (({ request, fetch: fetch2 }) => fetch2(request)),
          reroute: module.reroute || (() => {
          })
        };
      } catch (error2) {
        {
          throw error2;
        }
      }
    }
  }
  /**
   * @param {Request} request
   * @param {import('types').RequestOptions} options
   */
  async respond(request, options2) {
    return respond(request, this.#options, this.#manifest, {
      ...options2,
      error: false,
      depth: 0
    });
  }
}, "Server");
var manifest = (() => {
  function __memo(fn) {
    let value;
    return () => value ??= value = fn();
  }
  __name(__memo, "__memo");
  return {
    appDir: "_app",
    appPath: "_app",
    assets: /* @__PURE__ */ new Set([".assetsignore", "apple.svg", "avatar-big.svg", "avatar.png", "backBtn.svg", "checkerCard/checkerBoard.png", "checkerCard/checkerHead.png", "checkers.svg", "chessCard/chessboard.svg", "chessCard/chessHeader.svg", "chessPlayWithComputer.svg", "chessStatic.svg", "circleComputer.svg", "circleTournament.svg", "clock.svg", "deck.svg", "dialyChallenge.svg", "explore.svg", "facebook.svg", "favicon.png", "google.svg", "home.svg", "howToPlay-1.svg", "howToPlay-2.svg", "howToPlay-3.svg", "howToPlay-4.svg", "howToPlay-5.svg", "howToPlay-6.svg", "instantPlay.svg", "lock.svg", "ludo-bg.jpg", "ludoCard/ludoBoard.png", "ludoCard/ludoHead.png", "menu.svg", "notification.svg", "number2.svg", "number3.svg", "number4.svg", "paper.svg", "people.svg", "playWithFriends.svg", "robot.svg", "rock.svg", "rockLg.svg", "rpsCard/rpsBoard.png", "rpsCard/rpsHead.png", "schedule.svg", "scissors.svg", "scissorsLg.svg", "stockfish.js", "tournament.svg", "uno.svg", "unoCard/unoBoard.png", "unoCard/unoHead.png", "verified.svg", "vs.svg"]),
    mimeTypes: { ".svg": "image/svg+xml", ".png": "image/png", ".jpg": "image/jpeg", ".js": "text/javascript" },
    _: {
      client: { "start": "_app/immutable/entry/start.C0xyxR0-.js", "app": "_app/immutable/entry/app.BJxAeIEI.js", "imports": ["_app/immutable/entry/start.C0xyxR0-.js", "_app/immutable/chunks/entry.Zk5XMwWG.js", "_app/immutable/chunks/index-client.bJHR976g.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/index.bE0HzIKx.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/entry/app.BJxAeIEI.js", "_app/immutable/chunks/runtime.Cj5CxX35.js", "_app/immutable/chunks/render.RIqL4_R6.js", "_app/immutable/chunks/utils.M4KGanEH.js", "_app/immutable/chunks/template.DAPeAxUe.js", "_app/immutable/chunks/disclose-version.Bg9kRutz.js", "_app/immutable/chunks/if.DLf01pqE.js", "_app/immutable/chunks/svelte-component.CXtuGKwm.js", "_app/immutable/chunks/props.CdXMhF7y.js", "_app/immutable/chunks/store.CDnLvhlJ.js", "_app/immutable/chunks/utils.DbbyPcj0.js", "_app/immutable/chunks/this.CD6iIRB7.js", "_app/immutable/chunks/index-client.bJHR976g.js"], "stylesheets": [], "fonts": [], "uses_env_dynamic_public": false },
      nodes: [
        __memo(() => Promise.resolve().then(() => (init__(), __exports))),
        __memo(() => Promise.resolve().then(() => (init__2(), __exports2))),
        __memo(() => Promise.resolve().then(() => (init__3(), __exports3))),
        __memo(() => Promise.resolve().then(() => (init__4(), __exports4))),
        __memo(() => Promise.resolve().then(() => (init__5(), __exports5))),
        __memo(() => Promise.resolve().then(() => (init__6(), __exports6))),
        __memo(() => Promise.resolve().then(() => (init__7(), __exports7))),
        __memo(() => Promise.resolve().then(() => (init__8(), __exports8))),
        __memo(() => Promise.resolve().then(() => (init__9(), __exports9))),
        __memo(() => Promise.resolve().then(() => (init__10(), __exports10))),
        __memo(() => Promise.resolve().then(() => (init__11(), __exports11))),
        __memo(() => Promise.resolve().then(() => (init__12(), __exports12))),
        __memo(() => Promise.resolve().then(() => (init__13(), __exports13))),
        __memo(() => Promise.resolve().then(() => (init__14(), __exports14))),
        __memo(() => Promise.resolve().then(() => (init__15(), __exports15))),
        __memo(() => Promise.resolve().then(() => (init__16(), __exports16))),
        __memo(() => Promise.resolve().then(() => (init__17(), __exports17))),
        __memo(() => Promise.resolve().then(() => (init__18(), __exports18))),
        __memo(() => Promise.resolve().then(() => (init__19(), __exports19))),
        __memo(() => Promise.resolve().then(() => (init__20(), __exports20))),
        __memo(() => Promise.resolve().then(() => (init__21(), __exports21))),
        __memo(() => Promise.resolve().then(() => (init__22(), __exports22))),
        __memo(() => Promise.resolve().then(() => (init__23(), __exports23))),
        __memo(() => Promise.resolve().then(() => (init__24(), __exports24))),
        __memo(() => Promise.resolve().then(() => (init__25(), __exports25))),
        __memo(() => Promise.resolve().then(() => (init__26(), __exports26))),
        __memo(() => Promise.resolve().then(() => (init__27(), __exports27))),
        __memo(() => Promise.resolve().then(() => (init__28(), __exports28))),
        __memo(() => Promise.resolve().then(() => (init__29(), __exports29))),
        __memo(() => Promise.resolve().then(() => (init__30(), __exports30))),
        __memo(() => Promise.resolve().then(() => (init__31(), __exports31))),
        __memo(() => Promise.resolve().then(() => (init__32(), __exports32))),
        __memo(() => Promise.resolve().then(() => (init__33(), __exports33))),
        __memo(() => Promise.resolve().then(() => (init__34(), __exports34))),
        __memo(() => Promise.resolve().then(() => (init__35(), __exports35))),
        __memo(() => Promise.resolve().then(() => (init__36(), __exports36))),
        __memo(() => Promise.resolve().then(() => (init__37(), __exports37))),
        __memo(() => Promise.resolve().then(() => (init__38(), __exports38)))
      ],
      routes: [
        {
          id: "/(app)",
          pattern: /^\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 4 },
          endpoint: null
        },
        {
          id: "/api/create-game",
          pattern: /^\/api\/create-game\/?$/,
          params: [],
          page: null,
          endpoint: __memo(() => Promise.resolve().then(() => (init_server_ts(), server_ts_exports)))
        },
        {
          id: "/api/google",
          pattern: /^\/api\/google\/?$/,
          params: [],
          page: null,
          endpoint: __memo(() => Promise.resolve().then(() => (init_server_ts2(), server_ts_exports2)))
        },
        {
          id: "/api/google/callback",
          pattern: /^\/api\/google\/callback\/?$/,
          params: [],
          page: null,
          endpoint: __memo(() => Promise.resolve().then(() => (init_server_ts3(), server_ts_exports3)))
        },
        {
          id: "/api/move",
          pattern: /^\/api\/move\/?$/,
          params: [],
          page: null,
          endpoint: __memo(() => Promise.resolve().then(() => (init_server_ts4(), server_ts_exports4)))
        },
        {
          id: "/api/rps/plw",
          pattern: /^\/api\/rps\/plw\/?$/,
          params: [],
          page: null,
          endpoint: __memo(() => Promise.resolve().then(() => (init_server_ts5(), server_ts_exports5)))
        },
        {
          id: "/checkers-text",
          pattern: /^\/checkers-text\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 35 },
          endpoint: null
        },
        {
          id: "/(app)/checkers",
          pattern: /^\/checkers\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 5 },
          endpoint: null
        },
        {
          id: "/(app)/checkers/how-to-play",
          pattern: /^\/checkers\/how-to-play\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 6 },
          endpoint: null
        },
        {
          id: "/(app)/checkers/[typeOfPlay]",
          pattern: /^\/checkers\/([^/]+?)\/?$/,
          params: [{ "name": "typeOfPlay", "optional": false, "rest": false, "chained": false }],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 7 },
          endpoint: null
        },
        {
          id: "/(app)/chess",
          pattern: /^\/chess\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 8 },
          endpoint: null
        },
        {
          id: "/(app)/chess/play",
          pattern: /^\/chess\/play\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 9 },
          endpoint: null
        },
        {
          id: "/(app)/chess/[typeOfPlay]",
          pattern: /^\/chess\/([^/]+?)\/?$/,
          params: [{ "name": "typeOfPlay", "optional": false, "rest": false, "chained": false }],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 10 },
          endpoint: null
        },
        {
          id: "/(app)/explore",
          pattern: /^\/explore\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 11 },
          endpoint: null
        },
        {
          id: "/(auth)/login",
          pattern: /^\/login\/?$/,
          params: [],
          page: { layouts: [0, 3], errors: [1, ,], leaf: 34 },
          endpoint: null
        },
        {
          id: "/ludo-test",
          pattern: /^\/ludo-test\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 36 },
          endpoint: null
        },
        {
          id: "/(app)/ludo",
          pattern: /^\/ludo\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 12 },
          endpoint: null
        },
        {
          id: "/(app)/ludo/[typeOfPlay]",
          pattern: /^\/ludo\/([^/]+?)\/?$/,
          params: [{ "name": "typeOfPlay", "optional": false, "rest": false, "chained": false }],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 13 },
          endpoint: null
        },
        {
          id: "/(app)/more",
          pattern: /^\/more\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 14 },
          endpoint: null
        },
        {
          id: "/(app)/more/faq",
          pattern: /^\/more\/faq\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 15 },
          endpoint: null
        },
        {
          id: "/(app)/more/game-history",
          pattern: /^\/more\/game-history\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 16 },
          endpoint: null
        },
        {
          id: "/(app)/more/reviews",
          pattern: /^\/more\/reviews\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 17 },
          endpoint: null
        },
        {
          id: "/(app)/more/settings",
          pattern: /^\/more\/settings\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 18 },
          endpoint: null
        },
        {
          id: "/(app)/more/settings/manage-profile",
          pattern: /^\/more\/settings\/manage-profile\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 19 },
          endpoint: null
        },
        {
          id: "/(app)/more/settings/notification",
          pattern: /^\/more\/settings\/notification\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 20 },
          endpoint: null
        },
        {
          id: "/(app)/more/support",
          pattern: /^\/more\/support\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 21 },
          endpoint: null
        },
        {
          id: "/(app)/more/wallet",
          pattern: /^\/more\/wallet\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 22 },
          endpoint: null
        },
        {
          id: "/(app)/notification",
          pattern: /^\/notification\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 23 },
          endpoint: null
        },
        {
          id: "/(app)/play",
          pattern: /^\/play\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 24 },
          endpoint: null
        },
        {
          id: "/(app)/realtime",
          pattern: /^\/realtime\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 25 },
          endpoint: null
        },
        {
          id: "/(app)/rps",
          pattern: /^\/rps\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 26 },
          endpoint: null
        },
        {
          id: "/(app)/rps/how-to-play",
          pattern: /^\/rps\/how-to-play\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 27 },
          endpoint: null
        },
        {
          id: "/(app)/rps/[typeOfPlay]",
          pattern: /^\/rps\/([^/]+?)\/?$/,
          params: [{ "name": "typeOfPlay", "optional": false, "rest": false, "chained": false }],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 28 },
          endpoint: null
        },
        {
          id: "/(app)/tournament",
          pattern: /^\/tournament\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 29 },
          endpoint: null
        },
        {
          id: "/(app)/tournament/tournament-history",
          pattern: /^\/tournament\/tournament-history\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 30 },
          endpoint: null
        },
        {
          id: "/uno-test",
          pattern: /^\/uno-test\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 37 },
          endpoint: null
        },
        {
          id: "/(app)/uno",
          pattern: /^\/uno\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 31 },
          endpoint: null
        },
        {
          id: "/(app)/uno/how-to-play",
          pattern: /^\/uno\/how-to-play\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 32 },
          endpoint: null
        },
        {
          id: "/(app)/uno/[typeOfPlay]",
          pattern: /^\/uno\/([^/]+?)\/?$/,
          params: [{ "name": "typeOfPlay", "optional": false, "rest": false, "chained": false }],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 33 },
          endpoint: null
        }
      ],
      matchers: async () => {
        return {};
      },
      server_assets: {}
    }
  };
})();
var prerendered = /* @__PURE__ */ new Set([]);
var base_path = "";
async function e(e3, t2) {
  let n2 = "string" != typeof t2 && "HEAD" === t2.method;
  n2 && (t2 = new Request(t2, { method: "GET" }));
  let r3 = await e3.match(t2);
  return n2 && r3 && (r3 = new Response(null, r3)), r3;
}
__name(e, "e");
function t(e3, t2, n2, o2) {
  return ("string" == typeof t2 || "GET" === t2.method) && r2(n2) && (n2.headers.has("Set-Cookie") && (n2 = new Response(n2.body, n2)).headers.append("Cache-Control", "private=Set-Cookie"), o2.waitUntil(e3.put(t2, n2.clone()))), n2;
}
__name(t, "t");
var n = /* @__PURE__ */ new Set([200, 203, 204, 300, 301, 404, 405, 410, 414, 501]);
function r2(e3) {
  if (!n.has(e3.status))
    return false;
  if (~(e3.headers.get("Vary") || "").indexOf("*"))
    return false;
  let t2 = e3.headers.get("Cache-Control") || "";
  return !/(private|no-cache|no-store)/i.test(t2);
}
__name(r2, "r2");
function o(n2) {
  return async function(r3, o2) {
    let a2 = await e(n2, r3);
    if (a2)
      return a2;
    o2.defer((e3) => {
      t(n2, r3, e3, o2);
    });
  };
}
__name(o, "o");
var s2 = caches.default;
var c = t.bind(0, s2);
var r22 = e.bind(0, s2);
var e2 = o.bind(0, s2);
var server = new Server(manifest);
var app_path = `/${manifest.appPath}`;
var immutable = `${app_path}/immutable/`;
var version_file = `${app_path}/version.json`;
var worker = {
  async fetch(req, env, context) {
    await server.init({ env });
    let pragma = req.headers.get("cache-control") || "";
    let res = !pragma.includes("no-cache") && await r22(req);
    if (res)
      return res;
    let { pathname, search } = new URL(req.url);
    try {
      pathname = decodeURIComponent(pathname);
    } catch {
    }
    const stripped_pathname = pathname.replace(/\/$/, "");
    let is_static_asset = false;
    const filename = stripped_pathname.slice(base_path.length + 1);
    if (filename) {
      is_static_asset = manifest.assets.has(filename) || manifest.assets.has(filename + "/index.html") || filename in manifest._.server_assets || filename + "/index.html" in manifest._.server_assets;
    }
    let location2 = pathname.at(-1) === "/" ? stripped_pathname : pathname + "/";
    if (is_static_asset || prerendered.has(pathname) || pathname === version_file || pathname.startsWith(immutable)) {
      res = await env.ASSETS.fetch(req);
    } else if (location2 && prerendered.has(location2)) {
      if (search)
        location2 += search;
      res = new Response("", {
        status: 308,
        headers: {
          location: location2
        }
      });
    } else {
      res = await server.respond(req, {
        // @ts-ignore
        platform: { env, context, caches, cf: req.cf },
        getClientAddress() {
          return req.headers.get("cf-connecting-ip");
        }
      });
    }
    pragma = res.headers.get("cache-control") || "";
    return pragma && res.status < 400 ? c(req, res, context) : res;
  }
};
var worker_default = worker;
export {
  worker_default as default
};
/**
 * @license lucide-svelte v0.399.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
/*!
* focus-trap 7.6.0
* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
*/
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! Bundled license information:

chess.js/dist/esm/chess.js:
  (**
   * @license
   * Copyright (c) 2023, Jeff Hlywa (jhlywa@gmail.com)
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   *    this list of conditions and the following disclaimer.
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   *    this list of conditions and the following disclaimer in the documentation
   *    and/or other materials provided with the distribution.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   *)

pusher-js/dist/web/pusher.js:
  (*!
   * Pusher JavaScript Library v8.4.0-rc2
   * https://pusher.com/
   *
   * Copyright 2020, Pusher
   * Released under the MIT licence.
   *)
*/
//# sourceMappingURL=_worker.js.map
